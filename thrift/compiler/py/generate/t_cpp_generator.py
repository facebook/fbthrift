#!/usr/local/bin/python2.6 -tt
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from cStringIO import StringIO
from itertools import chain, ifilter
from collections import namedtuple
import errno
import os
import re
import sys

from thrift.compiler import frontend
# Easy access to the enum of t_base_type::t_base
from thrift.compiler.frontend import t_base
# Easy access to the enum of t_field::e_req
from thrift.compiler.frontend import e_req
# Easy access to the enum of t_const_value::t_const_value_type
from thrift.compiler.frontend import e_const_value_type as e_cv_type

from thrift.compiler.generate import t_generator

from thrift.compiler.generate.t_cpp_context import *
from thrift.compiler.generate.t_output_aggregator import get_global_scope
from thrift.compiler.generate.t_output import IndentedOutput

# TODO move from here
class OrderedDict(dict):
    def __init__(self, *a, **b):
        dict.__init__(self, *a, **b)
        self._order = []

    def __setitem__(self, index, item):
        dict.__setitem__(self, index, item)
        self._order.append(index)

    def iteritems(self):
        return ((key, self[key]) for key in self._order)

# Same as map.get, but works for almost-dictionary-like types
# (like the ones generated by boost.python)
def _map_get(map, key, default=None):
    return map[key] if key in map else default

# ---------------------------------------------------------------
# Generator
# ---------------------------------------------------------------

class CompilerError(RuntimeError):
    pass

SerializedFieldOptions = namedtuple('SerializedFieldOptions',
        ['has_serialized_fields', 'keep_unknown_fields'])

class CppGenerator(t_generator.Generator):
    '''
    Plain ol' c++ generator
    Note: this is NOT legitimacy incarnate
    '''

    # Protocols to generate client/server code for.
    protocols = [("binary", "BinaryProtocol", "T_BINARY_PROTOCOL"),
                 ("compact", "CompactProtocol", "T_COMPACT_PROTOCOL")]
    short_name = 'cpp2'
    long_name = 'C++ version 2'
    supported_flags = {
        'include_prefix': 'Use full include paths in generated files.',
        'cob_style': '',
        'no_client_completion': '',
        'bootstrap': '',
        'compatibility': 'Use thrift1 structs instead of generating new ones',
        'terse_writes': 'Avoid emitting unspec fields whose values are default',
        'stack_arguments': 'Pass arguments on stack instead of heap',
        'future': 'enable wangle futures',
        'process_in_event_base': 'Process request in event base thread',
    }
    _out_dir_base = 'gen-cpp2'
    _compatibility_dir_base = 'gen-cpp'

    _base_to_cpp_typename = {
        t_base.void: 'void',
        t_base.string: 'std::string',
        t_base.bool: 'bool',
        t_base.byte: 'int8_t',
        t_base.i16: 'int16_t',
        t_base.i32: 'int32_t',
        t_base.i64: 'int64_t',
        t_base.double: 'double',
        t_base.float: 'float',
    }

    _serialized_fields_name = '__serialized'
    _serialized_fields_type = 'apache::thrift::CloneableIOBuf'
    _serialized_fields_protocol_name = '__serialized_protocol'

    def __init__(self, *args, **kwargs):
        # super constructor
        t_generator.Generator.__init__(self, *args, **kwargs)
        prefix = self._flags.get('include_prefix')
        if isinstance(prefix, basestring):
            self.program.include_prefix = prefix
        terse_writes = self._flags.get('terse_writes')
        self.safe_terse_writes = (terse_writes == 'safe')

    def _base_type_name(self, tbase):
        if tbase in self._base_to_cpp_typename:
            return self._base_to_cpp_typename[tbase]
        raise CompilerError('no C++ base type name for base type ' + tbase)

    def _cpp_annotation(self, type, key, default=None):
        t = _map_get(type.annotations, 'cpp2.' + key)
        if t:
            if self.flag_compatibility:
                raise CompilerError(
                    'cpp2.{0} annotation not allowed in compatibility mode: '
                    '{1}'.format(key, type))
            return t
        t = _map_get(type.annotations, 'cpp.' + key)
        if t:
            return t
        return default

    def _has_cpp_annotation(self, type, key):
        return self._cpp_annotation(type, key) is not None

    def _cpp_type_name(self, type, default=None):
        return self._cpp_annotation(type, 'type', default)

    def _type_name(self, ttype, in_typedef=False,
                   arg=False, scope=None, unique=False):
        unique = unique and not self.flag_stack_arguments
        if ttype.is_base_type:
            # cast it
            btype = ttype.as_base_type
            bname = self._base_type_name(btype.base)
            if arg and ttype.is_string:
                return self._reference_name(bname, unique)
            return self._cpp_type_name(ttype, bname)
        # Check for a custom overloaded C++ name
        if ttype.is_container:
            tcontainer = ttype.as_container
            inner_types = None
            template = self._cpp_annotation(tcontainer, 'template')
            cname = self._cpp_type_name(tcontainer)
            if cname:
                pass
            elif ttype.is_map:
                tmap = ttype.as_map
                if template:
                    cname = template
                elif tmap.is_unordered:
                    cname = 'std::unordered_map'
                else:
                    cname = 'std::map'
                inner_types = [self._type_name(tmap.key_type, in_typedef,
                                               scope=scope),
                               self._type_name(tmap.value_type, in_typedef,
                                               scope=scope)]
                cname = cname + '<{0}, {1}>'
            elif ttype.is_set:
                cname = 'std::set'
                if template:
                    cname = template
                tset = ttype.as_set
                inner_types = [self._type_name(tset.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            elif ttype.is_list:
                cname = 'std::vector'
                if template:
                    cname = template
                tlist = ttype.as_list
                inner_types = [self._type_name(tlist.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            if inner_types:
                cname = cname.format(*inner_types)
            if arg:
                return self._reference_name(cname, unique)
            else:
                return cname

        if ttype.is_stream:
            raise TypeError('CANNOT DETERMINE C++ TYPE FOR stream TYPE')

        if in_typedef and (ttype.is_struct or ttype.is_xception) and \
                ttype.program == self._program:
            if self.flag_compatibility:
                scope('typedef ' + self._namespace_prefix(
                        self._program.get_namespace('cpp')) + ttype.name + \
                          ' ' + ttype.name + ';')
            else:
                scope('class ' + ttype.name + ';')

        # Check if it needs to be namespaced
        program = ttype.program
        if program is not None:
            pname = self._namespace_prefix(self._get_namespace(program)) + \
                    ttype.name
        else:
            pname = ttype.name

        if arg and self._is_complex_type(ttype):
            return self._reference_name(pname, unique)
        else:
            return pname

    def _is_orderable_type(self, ttype):
        if ttype.is_base_type:
            return True
        elif ttype.is_enum:
            return True
        elif ttype.is_struct or ttype.is_xception:
            for m in ttype.as_struct.members:
                if m.req == e_req.optional \
                  or self._has_cpp_annotation(m.type, 'template') \
                  or not self._is_orderable_type(m.type):
                    return False
            return True
        elif ttype.is_map and not ttype.as_map.is_unordered:
            return self._is_orderable_type(ttype.as_map.key_type)
        elif ttype.is_set:
            return self._is_orderable_type(ttype.as_set.elem_type)
        elif ttype.is_list:
            return self._is_orderable_type(ttype.as_list.elem_type)
        else:
            return False

    # noncopyable is a hack to support gcc < 4.8, where declaring a constructor
    # as defaulted tries to generate it, even though it should be deleted.
    def _is_copyable_struct(self, ttype):
        assert ttype.is_struct or ttype.is_xception
        return not self._has_cpp_annotation(ttype, "noncopyable")

    def _is_noex_move_ctor_struct(self, ttype):
        return ttype.is_struct and \
            self._has_cpp_annotation(ttype, "noexcept_move_ctor")

    def _reference_name(self, name, unique):
        if unique:
            return "std::unique_ptr<{0}>".format(name)
        else:
            return "const {0}&".format(name)

    def _get_namespace(self, program=None):
        if program == None:
            program = self._program
        ns = program.get_namespace('cpp2')
        if ns == '':
            if len(program.get_namespace('cpp')) > 0:
                ns = program.get_namespace('cpp') + '.cpp2'
            else:
                ns = 'cpp2'
        return ns

    def _namespace_prefix(self, ns):
        'Return the absolute c++ prefix for the .-separated namespace param'
        prefix = ' ::' + '::'.join(ns.split('.'))
        if len(ns) > 0:
            prefix += '::'
        return prefix

    def _is_complex_type(self, ttype):
        ttype = self._get_true_type(ttype)
        return ttype.is_container or \
               ttype.is_struct or \
               ttype.is_xception or \
               ttype.is_base_type and \
                    ttype.as_base_type.base == frontend.t_base.string

    def _get_true_type(self, ttype):
        'Get the true type behind a series of typedefs'
        while ttype.is_typedef:
            ttype = ttype.as_typedef.type
        return ttype

    def _type_access_suffix(self, ttype):
        if not ttype.is_typedef:
            return ''
        return self._cpp_annotation(ttype.as_typedef.type, 'indirection', '')

    def _generate_enum_constant_list(self, enum, constants, quote_names,
                                      include_values):
        if include_values:
            name_format = '{0.name}'
            value_format = ' = {0.value}'
        else:
            value_format = ''
            name_format = quote_names and '"{0.name}"' or enum + "::{0.name}"
        return ',\n'.join((name_format + value_format).format(const) \
                          for const in constants)

    def _generate_enum(self, tenum):
        '''
        Generates code for an enumerated type. In C++, this is essentially the
        same as the thrift defn itself, using the enum keyword in C++.

        @param  tenum    The enumeration
        '''
        constants = tenum.constants
        # get the scope inside the namespace definitions
        s = self._types_scope
        if self.flag_compatibility:
            s('typedef {0} {1};'.format(self._namespace_prefix(
                        self._program.get_namespace('cpp')) + tenum.name,
                                        tenum.name))
            return
        primitive = s.defn('enum class {0.name}'.format(tenum), in_header=True)
        # what follows after the closing brace
        primitive.epilogue = ';\n\n'
        with primitive as s1:
            txt = self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=False, include_values=True)
            s1(txt)
        # Generate a character array of enum values for debugging purposes.
        with s.impl('{0} _k{0}Values[] ='.format(tenum.name)) as s1:
            txt = self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=False, include_values=False)
            s1(txt)
        with s.impl('const char* _k{0}Names[] ='.format(tenum.name)) as t:
            txt = self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=True, include_values=False)
            t(txt)
        s.extern('const std::map<{0}, const char*> _{0}_VALUES_TO_NAMES'.format(
            tenum.name), value=('(apache::thrift::TEnumIterator<{0}>({1}, '
                '_k{0}Values, _k{0}Names), apache::thrift::TEnumIterator<{0}>('
                '-1, nullptr, nullptr));\n').format(tenum.name, len(constants)))
        s.extern('const std::map<const char*, {0}, apache::thrift::ltstr> '
                '_{0}_NAMES_TO_VALUES'.format(tenum.name),
                 value=('(apache::thrift::TEnumInverseIterator<{0}>({1}, '
                        '_k{0}Values, _k{0}Names), '
                        'apache::thrift::TEnumInverseIterator<{0}>'
                        '(-1, nullptr, nullptr));\n').format(
                                tenum.name, len(constants)))
        s()
        s.impl('\n')

        # specialize TEnumTraitsBase
        # TODO: generate TEnumTraits<T>::min(), max()
        s.release()

        ns = self._namespace_prefix(self._get_namespace())
        fullName = ns + tenum.name
        s = self._types_global.namespace('apache.thrift').scope
        s.acquire()

        with s.defn('template <> const char* TEnumTraitsBase<{fullName}>::'
                'findName({fullName} value)'.format(**locals()),
                name='findName') as f:
            f('return findName({ns}_{tenum.name}_VALUES_TO_NAMES, '
                    'value);'.format(**locals()))
        with s.defn('template <> bool TEnumTraitsBase<{fullName}>::'
                'findValue(const char* name, {fullName}* outValue)'.
                format(**locals()), name='findName') as f:
            f('return findValue({ns}_{tenum.name}_NAMES_TO_VALUES, '
                    'name, outValue);'.format(**locals()))
        s.release()
        s = self._types_scope = \
                s.namespace(self._get_namespace()).scope
        s.acquire()

    def _generate_typedef(self, ttypedef):
        the_type = self._type_name(ttypedef.type, in_typedef=True,
                                   scope=self._types_scope)
        txt = 'typedef {0} {1};\n\n'.format(the_type, ttypedef.symbolic)
        # write it to the types scope
        self._types_scope(txt)

    def _declare_field(self, field, pointer=False, constant=False,
                        reference=False):
        # I removed the 'init' argument, as all inits happen in default
        # constructor
        result = ''
        if constant:
            result += 'const '
        result += self._type_name(field.type)
        if pointer:
            result += '*'
        if reference:
            result += '&'
        result += ' ' + field.name
        if not reference:
            result += ';'
        return result

    def _type_to_enum(self, ttype):
        'Converts the parse type to a C++ enum string for a given type.'
        t = self._get_true_type(ttype)
        suffix = None
        if t.is_base_type:
            base = t.as_base_type.base
            if base == t_base.void:
                raise ValueError('NO T_VOID CONSTRUCT')
            switch = {
                t_base.string: 'T_STRING',
                t_base.bool: 'T_BOOL',
                t_base.byte: 'T_BYTE',
                t_base.i16: 'T_I16',
                t_base.i32: 'T_I32',
                t_base.i64: 'T_I64',
                t_base.double: 'T_DOUBLE',
                t_base.float: 'T_FLOAT',
            }
            suffix = switch[base]
        elif t.is_enum:
            suffix = 'T_I32'
        elif t.is_struct or t.is_xception:
            suffix = 'T_STRUCT'
        elif t.is_map:
            suffix = 'T_MAP'
        elif t.is_set:
            suffix = 'T_SET'
        elif t.is_list:
            suffix = 'T_LIST'
        elif t.is_stream:
            suffix = 'T_STREAM'
        if suffix is None:
            raise TypeError('INVALID TYPE IN type_to_enum: ' + t.name)
        return 'apache::thrift::protocol::' + suffix

    # =====================================================================
    # SERVICE INTERFACE
    # =====================================================================

    def _generate_service(self, service):
        # open files and instantiate outputs
        context = self._make_context(service.name, True)
        self._out_tcc = context.tcc
        s = self._service_global = get_global_scope(CppPrimitiveFactory,
                                                    context)
        # Enter the scope (prints guard)
        s.acquire()
        s('#include "thrift/lib/cpp/Thrift.h"')
        if not self.flag_bootstrap:
            s('#include "thrift/lib/cpp/TApplicationException.h"')
        s('#include "thrift/lib/cpp/protocol/TProtocolTypes.h"')
        s('#include "thrift/lib/cpp/transport/THeader.h"')
        s('#include "thrift/lib/cpp2/protocol/Protocol.h"')
        s('#include "thrift/lib/cpp2/protocol/StreamSerializers.h"')
        s('#include "thrift/lib/cpp2/async/AsyncProcessor.h"')
        s('#include "thrift/lib/cpp2/async/RequestChannel.h"')
        if self.flag_future:
            s('#include "thrift/lib/cpp2/async/FutureRequest.h"')
            s('#include "common/wangle/Future.h"')
        s('#include "folly/MoveWrapper.h"')
        s('#include <thread>')
        s('#include "thrift/lib/cpp2/async/Stream.h"')
        s('#include "thrift/lib/cpp2/async/HeaderClientChannel.h"')
        s('#include "thrift/lib/cpp/async/TEventBaseManager.h"')
        s('#include "thrift/lib/cpp2/server/Cpp2ConnContext.h"')
        s('#include "folly/ScopeGuard.h"')
        s('#include "thrift/lib/cpp/TProcessor.h"')
        s('#include "folly/io/IOBuf.h"')
        s('#include "folly/io/IOBufQueue.h"')
        s('#include <unordered_map>')
        s('#include <unordered_set>')
        s('#include "{0}"'.format(self._with_include_prefix(self._program,
                                                             self._program.name
                                                             + '_types.h')))
        for shortprot, protname, prottype in self.protocols:
            s('#include <thrift/lib/cpp2/protocol/{0}.h>'.format(protname))
        s()
        if self.flag_compatibility:
            # Transform the cpp2 include prefix path into a cpp prefix path.
            s('#include "{0}.h"'
              .format(self._with_compatibility_include_prefix(self._program,
                                                    service.name)))
        # Include other Thrift includes
        for inc in self._program.includes:
            s('#include "{0}_types.h"' \
              .format(self._with_include_prefix(inc, inc.name)))
            print >>self._out_tcc, '#include "{0}_types.tcc"'.format(
                self._with_include_prefix(inc, inc.name))
        s()
        # Include custom headers
        for inc in self._program.cpp_includes:
            if inc.startswith('<'):
                s('#include {0}'.format(inc))
            else:
                s('#include "{0}"'.format(inc))

        if service.extends:
            s('#include "{0}.h"'.format(
                    self._with_include_prefix(service.extends.program,
                                              service.extends.name)))
        s()

        # Open namespace
        s = s.namespace(self._get_namespace()).scope
        s.acquire()

        self._generate_service_server_interface_async(service, s)
        s('class ' + service.name + 'AsyncProcessor;')
        self._generate_service_server_interface(service, s)
        self._generate_processor(service, s)
        self._generate_service_client(service, s)
        self._generate_service_helpers(service, s)

        if self._service_uses_streams(service):
            self._generate_service_stream_serializer(service, s)

        # make sure that the main types namespace is closed
        s.release()

        self._generate_service_helpers_serializers(service, s)

        # Include the types.tcc file from the types header file,
        # so clients don't have to explicitly include the tcc file.
        s = self._service_global
        s()
        s('#include "{0}.tcc"'.format(
                self._with_include_prefix(self._program, service.name)))
        self._service_global.release()

    def _generate_service_helpers_serializers(self, service, s):
        s = s.namespace('apache.thrift').scope
        s.acquire()
        for function in service.functions:
            arglist = function.arglist
            arglist.name = "{0}_{1}_args".format(service.name, function.name)
            self._generate_cpp2ops(True, arglist, s)
            arglist.name = "{0}_{1}_pargs".format(service.name, function.name)
            self._generate_cpp2ops(True, arglist, s)

            if not function.oneway:
                result = self._get_presult_object(service, function)
                self._generate_cpp2ops(True, result, s)
                result.name = "{0}_{1}_result".format(
                    service.name, function.name)
                self._generate_cpp2ops(True, result, s)
        s.release()

    def _get_presult_object(self, service, function):
        result = frontend.t_struct(
            self.program,
            "{0}_{1}_presult".format(service.name, function.name))
        success = frontend.t_field(function.returntype, "success", 0)
        if not function.returntype.is_void:
            result.append(success)
        xs = function.xceptions
        for field in xs.members:
            result.append(field)
        return result



    def _generate_service_helpers(self, service, s):
        for function in service.functions:
            arglist = function.arglist
            name_orig = arglist.name
            arglist.name = "{0}_{1}_args".format(service.name, function.name)
            self._generate_struct_complete(s, arglist,
                                           is_exception=False,
                                           pointers=False,
                                           read=True,
                                           write=True,
                                           swap=False,
                                           result=False)
            arglist.name = "{0}_{1}_pargs".format(service.name, function.name)
            self._generate_struct_complete(s, arglist,
                                           is_exception=False,
                                           pointers=True,
                                           read=True,
                                           write=True,
                                           swap=False,
                                           result=False,
                                           has_isset=False)
            arglist.name = name_orig

            if not function.oneway:
                # WTF Using _get_presult_object causes a segmentation fault?
                result = frontend.t_struct(
                    self.program,
                    "{0}_{1}_presult".format(service.name, function.name))
                success = frontend.t_field(function.returntype, "success", 0)
                if not function.returntype.is_void:
                    result.append(success)
                xs = function.xceptions
                for field in xs.members:
                    result.append(field)
                self._generate_struct_complete(s, result,
                                               is_exception=False,
                                               pointers=True,
                                               read=True,
                                               write=True,
                                               swap=False,
                                               result=True)

                # Also generate _result version for exceptions
                result.name = "{0}_{1}_result".format(
                    service.name, function.name)

                self._generate_struct_complete(s, result,
                                               is_exception=False,
                                               pointers=False,
                                               read=True,
                                               write=True,
                                               swap=False,
                                               result=True)

    def _service_uses_streams(self, service):
        for function in service.functions:
            if self._function_uses_streams(function):
                return True
        return False

    def _generate_service_stream_serializer(self, service, s):
        class_signature = 'class {0}StreamSerializer'.format(service.name)
        with s.cls(class_signature) as c:
            c.label('public:')

            generated_stream_types = set()
            for function in service.functions:
                for arg_type in [arg.type for arg in function.arglist.members]:
                    if arg_type.is_stream:
                        type = self._get_true_type(arg_type)
                        type = type.as_stream.elem_type
                        true_type = self._get_true_type(type)
                        type_name = self._type_name(true_type)
                        if type_name not in generated_stream_types:
                            self._generate_stream_type_serializer(c, type)
                            self._generate_stream_type_deserializer(c, type)
                            generated_stream_types.add(type_name)
                            c()

                if self._function_uses_streams(function):
                    return_type = function.returntype
                    if not return_type.is_void:
                        type = return_type
                        if type.is_stream:
                            type = self._get_true_type(type)
                            type = type.as_stream.elem_type
                        true_type = self._get_true_type(type)
                        type_name = self._type_name(true_type)
                        if type_name not in generated_stream_types:
                            self._generate_stream_type_serializer(c, type)
                            self._generate_stream_type_deserializer(c, type)
                            generated_stream_types.add(type_name)
                            c()

                    self._generate_function_exception_serializer(c, function)
                    self._generate_function_exception_deserializer(c, function)
                    c()

    def _generate_stream_type_serializer(self, c, type):
        type_name = self._type_name(type)
        with c.defn('template<typename Writer>\n'
                    'uint32_t {name}(Writer& writer, const ' + type_name +
                    '& value)',
                    name='serialize',
                    modifiers='static',
                    output=self._out_tcc) as f:
            f('Writer * prot_ = &writer;')
            f('uint32_t xfer = 0;')
            ttype = self._get_true_type(type)
            self._generate_serialize_type(f, ttype, 'value')
            f('return xfer;')

    def _generate_stream_type_deserializer(self, c, type):
        type_name = self._type_name(type)
        with c.defn('template<typename Reader>\n'
                    'uint32_t {name}(Reader& reader, ' + type_name + '& value)',
                    name='deserialize',
                    modifiers='static',
                    output=self._out_tcc) as f:
            f('Reader * iprot = &reader;')
            f('uint32_t xfer = 0;')
            ttype = self._get_true_type(type)
            self._generate_deserialize_type(f, ttype, 'value')
            f('return xfer;')

    def _generate_function_exception_serializer(self, c, function):
        with c.defn('void {name}(apache::thrift::StreamWriter& writer, '
                    'const std::exception_ptr& exception)',
                    name=function.name + 'ExceptionSerializer',
                    modifiers='static') as f:

            with f('try') as t:
                t('std::rethrow_exception(exception);')

                for exception_field in function.xceptions.members:
                    exception_type = self._type_name(exception_field.type)

                    with t.catch('const ' + exception_type + '& e') as h:
                        h('writer.writeExceptionItem({exception_id}, e);'
                          .format(exception_id=exception_field.key))

                with t.catch('...') as h:
                    h('throw;')

    def _generate_function_exception_deserializer(self, c, function):
        with c.defn('std::exception_ptr {name}('
                    'apache::thrift::StreamReader& reader)',
                    name=function.name + 'ExceptionDeserializer',
                    modifiers='static') as f:

            f('int16_t exceptionId = reader.readExceptionId();')

            with f('switch(exceptionId)') as s:
                for exception_field in function.xceptions.members:
                    exception_type = self._type_name(exception_field.type)
                    with s.case(str(exception_field.key), nobreak=True) as a:
                        a('return reader.readExceptionItem<{exception_type}>();'
                                .format(exception_type=exception_type))

                with s.case('default', nobreak=True) as a:
                    a('reader.skipException();')
                    a('return std::make_exception_ptr(apache::thrift::'
                      'TApplicationException("Unknown exception received."));')

    def _generate_service_client(self, service, s):
        classname = service.name + "AsyncClient"
        if not service.extends:
            class_signature = 'class ' + classname + \
                ' : public apache::thrift::TClientBase'
        else:
            class_signature = 'class ' + classname + \
                ' : public ' + self._type_name(service.extends) +\
                'AsyncClient'
        with s.cls(class_signature) as c:
            c.label('public:')

            with c.defn('std::string {name}()', name='getServiceName',
                        modifiers='virtual') as gsn:
                gsn("return \"{0}\";".format(service.name))

            c("typedef std::unique_ptr<apache::thrift::RequestChannel"
              ", apache::thrift::async::TDelayedDestruction::Destructor>"
              " channel_ptr;")
            init = OrderedDict()
            if service.extends:
                init[self._type_name(service.extends) + 'AsyncClient'] = \
                    'std::move(channel)'
            if not service.extends:
                init["channel_"] = "std::move(channel)"
            # TODO: make it possible to create a connection context from a
            # thrift channel
            c.defn('~{name}()', name=classname,
                   modifiers='virtual', in_header=True).scope.empty()

            with c.defn('{name}(channel_ptr channel)', name=classname,
                        init_dict=init,
                        in_header=True) as cons:
                cons('connectionContext_ = '
                  'std::unique_ptr<TClientBase::ConnContext>('
                  'new TClientBase::ConnContext(channel_->getHeader(),'
                     'nullptr));')

            if not service.extends:
                with c.defn('apache::thrift::RequestChannel* '
                            ' {name}()', name='getChannel',
                            in_header=True) as getchannel:
                    getchannel("return this->channel_.get();")

            # Write out all the functions
            for function in service.functions:
                self._generate_client_async_function(c, service, function)
                self._generate_client_async_function(c, service, function,
                                                     name_prefix="callback_")

                self._generate_client_async_function(c, service, function,
                                                     uses_rpc_options=True)

                self._generate_client_sync_function(c, service, function)
                self._generate_client_sync_function(c, service, function,
                                                    uses_rpc_options=True)

                if not self._function_uses_streams(function):
                    self._generate_client_std_function(c, function)
                    self._generate_client_std_function(c, function,
                                                       name_prefix="functor_")

                if self.flag_future:
                    if not self._function_uses_streams(function):
                        self._generate_client_future_gate_function(c, function)

                    self._generate_client_future_function(c, service, function)
                    self._generate_client_future_function(c, service, function,
                                                          uses_rpc_options=True)
                if not function.oneway:
                    self._generate_recv_function(c, function)

                self._generate_templated_client_function(c, service, function)

                if not function.oneway:
                    self._generate_templated_recv_function(c, service, function)

            if not service.extends:
                c.label('protected:')
                c("std::unique_ptr<apache::thrift::server::TConnectionContext>"
                  "connectionContext_;")
                c("channel_ptr channel_;")

    def _get_async_func_name(self, function):
        if self._is_processed_in_eb(function):
            return 'async_eb_' + function.name
        else:
            return 'async_tm_' + function.name



    def _generate_service_server_interface_async(self, service, s):
        classname = service.name + "SvAsyncIf"
        class_signature = "class " + classname
        with s.cls(class_signature) as c:
            c.label('public:')
            c.defn('~{0}()'.format(classname), name=classname,
                   modifiers='virtual',
                   in_header=True).scope.empty()
            for function in service.functions:
                c.defn(self._get_process_function_signature_async(service,
                                                                  function),
                       name=self._get_async_func_name(function),
                       modifiers='virtual',
                       pure_virtual=True)

                # TODO: Remove this once everything has migrated to async_eb or
                # async_tm
                c.defn(self._get_process_function_signature_async(service,
                                                                  function),
                       name="async_" + function.name,
                       modifiers='virtual',
                       delete=True)
                if self.flag_future and not self._function_uses_streams(
                    function
                ):
                    c.defn(self._get_process_function_signature_future(
                            service, function),
                           name="future_" + function.name,
                           modifiers='virtual',
                           pure_virtual=True)

    def _generate_service_server_interface(self, service, s):
        classname = service.name + "SvIf"
        if not service.extends:
            class_signature = "class " + classname + " : public " + \
                service.name + \
                "SvAsyncIf, public apache::thrift::ServerInterface"
        else:
            class_signature = "class " + classname + " : public " + \
                service.name + "SvAsyncIf, virtual public " + \
                self._type_name(service.extends) + "SvIf"
        with s.cls(class_signature) as c:
            c.label('public:')
            c('typedef ' + service.name + 'AsyncProcessor ProcessorType;')
            c.defn('~{0}()'.format(classname), name=classname,
                   modifiers='virtual',
                   in_header=True).scope.empty()
            with c.defn('std::unique_ptr<apache::thrift::AsyncProcessor>' +
                        ' {name}()',
                        name='getProcessor',
                        modifiers='virtual') as p:
                        p('return std::unique_ptr<' +
                          'apache::thrift::AsyncProcessor>(' +
                          'new {0}AsyncProcessor(({0}SvIf*)this));'.format(
                                  service.name))
            for function in service.functions:
                if not self._function_uses_streams(function):
                    with c.defn(self._get_prio_function_signature(service,
                                                                  function),
                                name="getprio_" + function.name) as d:
                        if function.annotations is not None and \
                                'priority' in function.annotations.annotations:
                            prio = function.annotations.annotations['priority']
                        elif 'priority' in service.annotations:
                            prio = service.annotations['priority']
                        else:
                            prio = 'NORMAL'
                        PTM = 'apache::thrift::concurrency'
                        priovar = self.tmp('prio')
                        d('{0}::PRIORITY {1} = reqCtx->getHeader()->'
                          'getCallPriority();'.format(PTM, priovar))
                        with d('if ({0} != {1}::N_PRIORITIES)'.format(
                               priovar, PTM)) as e:
                            e('return {0};'.format(priovar))
                        d('return {0}::{1};'.format(PTM, prio))
                if self._function_uses_streams(function) or \
                  (not self.flag_future and
                   not self._is_processed_in_eb(function)):
                    with c.defn(self._get_process_function_signature(service,
                                                                     function),
                                name=function.name,
                                modifiers='virtual') as d:
                        d('throw apache::thrift::TApplicationException('
                          '"Function {0} is unimplemented");'
                          .format(function.name))
                        if not function.oneway and \
                          not function.returntype.is_void and \
                          not self._function_uses_streams(function) and \
                          not self._is_complex_type(function.returntype):
                            d('return ' +
                              self._default_value(function.returntype) + ';')
                else:
                    # TODO: Remove this once everything is moved over to
                    # async_tm and async_eb. This is to ensure that if we
                    # switch to async_eb with a flag, we do not accidentally
                    # unimplement a sync function.
                    c.defn(self._get_process_function_signature(service,
                                                                function),
                           name=function.name,
                           modifiers='virtual',
                           delete=True)
                if self._function_uses_streams(function):
                    self._generate_server_async_stream_function(c, service,
                                                                function)
                else:
                    if self.flag_future:
                        self._generate_server_future_function(c, service,
                                                              function)
                    self._generate_server_async_non_stream_function(c, service,
                                                                    function)

    def _generate_server_future_function(self, c, service, function):
        with c.defn(self._get_process_function_signature_future(service,
                                                               function),
                    name="future_" + function.name) as f:
            rettype = self._type_name(function.returntype)
            if self._is_complex_type(function.returntype):
                rettype = "std::unique_ptr<{0}>".format(
                    self._type_name(function.returntype))
            promise_name = self.tmp("promise")
            f("facebook::wangle::Promise<{type}> {promise};"
              .format(type=rettype, promise=promise_name))
            future_name = self.tmp("future")
            f(("auto {future} = {promise}.getFuture();")
              .format(future=future_name, promise=promise_name))
            f('apache::thrift::TApplicationException ex("Function {0} is '
              'unimplemented");'.format(function.name))
            f("{promise}.setException(ex);"
              .format(promise=promise_name))
            f("return {future};".format(future=future_name))

    def _generate_server_async_non_stream_function(self, c, service, function):
        with c.defn(self._get_process_function_signature_async(service,
                                                               function),
                    name=self._get_async_func_name(function),
                    modifiers='virtual') as f:
            args = []
            for member in function.arglist.members:
                if self._is_complex_type(member.type) \
                  and not self.flag_stack_arguments:
                    args.append("std::move({0})".format(member.name))
                else:
                    args.append(member.name)

            if self._is_processed_in_eb(function):
                if (self.flag_future):
                    f('auto callbackp = callback.release();')
                    f('setConnectionContext(callbackp->getConnectionContext()'
                      ');')
                    f('setThreadManager(callbackp->getThreadManager());')
                    f('setEventBase(callbackp->getEventBase());')
                    future_name = self.tmp('future')
                    rettype = "facebook::wangle::Try<{0}>".format(
                        self._type_name(function.returntype))
                    if self._is_complex_type(function.returntype):
                        rettype = "facebook::wangle::Try<std::unique_ptr" \
                          "<{0}>>".format(self._type_name(function.returntype))
                    with f("try") as t:
                        if not function.oneway and \
                          not function.returntype.is_void:
                            t("auto {2} = future_{0}({1});".format(
                                function.name, ", ".join(args), future_name))
                            with t("{0}.then([=]({1}&& _return)".format(
                                   future_name, rettype)) as w:
                                with w("try") as g:
                                    g("callbackp->resultInThread("
                                      "std::move(_return.value()));")
                                    with g.catch("...") as fin:
                                        fin("callbackp->exceptionInThread("
                                            "std::current_exception());")
                            t(");")
                        else:
                            t("auto {1} = future_{0}(".format(
                              function.name, future_name)
                              + ", ".join(args) + ");")
                            if not function.oneway:
                                t(("{0}.then([=](facebook::wangle" +
                                   "::Try<void>&& t){{").format(future_name))
                                t("  callbackp->doneInThread();")
                                t("});")
                            else:
                                t("delete callbackp;")
                        with t.catch("const std::exception& ex") as cth:
                            if not function.oneway:
                                cth("callbackp->exceptionInThread(std::"
                                    "current_exception());")
                            else:
                                cth("delete callbackp;")
                else:
                    f('apache::thrift::TApplicationException ex("Function {0} '
                      'is unimplemented");'.format(function.name))
                    f('callback->exception(std::make_exception_ptr(ex));')
            else:
                f('auto callbackp = callback.release();')
                # Oneway request won't be canceled if expired. see D1006482 for
                # further details. TODO: fix this
                if not function.oneway:
                    with f('if (!callbackp->isRequestActive())') as g:
                        g('callbackp->deleteInThread();')
                        g('return;')
                f('setConnectionContext(callbackp->getConnectionContext());')
                if not function.oneway and self._is_complex_type(
                    function.returntype
                ):
                    if self.flag_stack_arguments:
                        args.insert(0, "_return")
                    else:
                        args.insert(0, "*_return")
                with f("try") as t:
                    if not function.oneway and not function.returntype.is_void:
                        if self._is_complex_type(function.returntype) \
                          and not self.flag_stack_arguments:
                            t("std::unique_ptr<{0}> _return(new {0});"
                              .format(self._type_name(function.returntype)))

                            t("{0}({1});".format(function.name,
                                                 ", ".join(args)))
                            t("callbackp->resultInThread(std::move(_return));")
                        elif self._is_complex_type(function.returntype):
                            t("{0} _return;".format(self._type_name(
                                function.returntype)))
                            t("{0}({1});".format(function.name,
                                                 ", ".join(args)))
                            t("callbackp->resultInThread(_return);")
                        else:
                            t("callbackp->resultInThread({0}({1}));"
                              .format(function.name, ", ".join(args)))
                    else:
                        t("{0}(".format(function.name) + ", ".join(args) + ");")
                        if not function.oneway:
                            t("callbackp->doneInThread();")
                        else:
                            t("callbackp->deleteInThread();")
                    with t.catch("const std::exception& ex") as cth:
                        if not function.oneway:
                            cth("callbackp->exceptionInThread(std::"
                                "current_exception());")
                        else:
                            cth("callbackp->deleteInThread();")
                f('setConnectionContext(nullptr);')

    def _generate_server_async_stream_function(self, c, service, function):
        serializer = "{service}StreamSerializer".format(service=service.name)

        with c.defn(self._get_process_function_signature_async(service,
                                                               function),
                    name=self._get_async_func_name(function),
                    modifiers='virtual') as f:

            args = []
            for member in function.arglist.members:
                if not member.type.is_stream and \
                   self._is_complex_type(member.type) and \
                   not self.flag_stack_arguments:
                    args.append("std::move({0})".format(member.name))
                else:
                    args.append(member.name)

            if not function.returntype.is_void:
                template = ("apache::thrift::AsyncOutputStream<{type}> "
                            "_return;")
                f(self._format_stream_declaration(template,
                                                  function.returntype))
                args.insert(0, "_return")

            for arg in function.arglist.members:
                if arg.type.is_stream:
                    template = ("apache::thrift::AsyncInputStream<{type}> "
                                "{name};")
                    f(self._format_stream_declaration(template,
                                                      arg.type,
                                                      arg.name))
            with f("try") as t:
                t("{name}({args});"
                  .format(name=function.name, args=", ".join(args)))
                t()

                t("apache::thrift::StreamSource::StreamMap sourceMap;")
                for arg in function.arglist.members:
                    if arg.type.is_stream:
                        type_enum = self._stream_type_to_enum(arg.type)
                        handler = "_{arg}Handler".format(arg=arg.name)

                        f("auto {handler} = {arg}.makeHandler<{ser}>();"
                          .format(handler=handler,
                                  arg=arg.name,
                                  ser=serializer))
                        with f("if ({0})".format(handler)) as i:
                            i("{handler}->setType({enum});"
                              .format(handler=handler, enum=type_enum))
                            i("sourceMap[{key}] = std::move({handler});"
                              .format(key=arg.key, handler=handler))
                t()

                t("apache::thrift::StreamSink::StreamMap sinkMap;")
                if not function.returntype.is_void:
                    type_enum = self._stream_type_to_enum(
                            function.returntype)

                    f("auto _returnHandler = _return.makeHandler<{ser}>();"
                      .format(ser=serializer))
                    with f("if (_returnHandler)") as i:
                        i("_returnHandler->setType({enum});"
                          .format(enum=type_enum))
                        i("sinkMap[0] = std::move(_returnHandler);")
                t()

                prefix = ("{service}StreamSerializer::{func}Exception"
                         .format(service=service.name, func=function.name))
                t("apache::thrift::StreamManager * stream = ")
                t("     new apache::thrift::StreamManager(")
                t("         callback->getEventBase(),")
                t("         std::move(sourceMap),")
                t("         {prefix}Deserializer,".format(prefix=prefix))
                t("         std::move(sinkMap),")
                t("         {prefix}Serializer);".format(prefix=prefix))
                t()

                t("callback->result(stream);")

                with t.catch("...") as h:
                    h("callback->exception("
                      "std::current_exception());")


    def _get_process_function_signature_async(self, service, function):
        sig = 'void {name}('
        if function.oneway:
            sig += 'std::unique_ptr<apache::thrift::HandlerCallbackBase>' + \
                ' callback'
        else:
            if self._function_uses_streams(function):
                rettype = 'apache::thrift::StreamManager *'
            elif self._is_complex_type(function.returntype) and \
                 not self.flag_stack_arguments:
                rettype = self._type_name(function.returntype)
                rettype = 'std::unique_ptr<' + rettype + '>'
            else:
                rettype = self._type_name(function.returntype)

            sig += ('std::unique_ptr<apache::thrift::HandlerCallback<{0}>>' + \
                        ' callback').format(rettype)

        sig += self._argument_list(function.arglist, True, unique=True)
        sig += ')'
        return sig

    def _get_process_function_signature_future(self, service, function):
        rettype = self._type_name(function.returntype)
        if self._is_complex_type(function.returntype) and \
                not self.flag_stack_arguments:
            rettype = 'std::unique_ptr<' + rettype + '>'
        sig = 'facebook::wangle::Future<' + \
            rettype + '> {name}('

        sig += self._argument_list(function.arglist, False, unique=True)
        sig += ')'
        return sig

    def _get_process_function_signature(self, service, function):
        stream_type = "apache::thrift::AsyncInputStream<{type}>&"
        addcomma = False
        if not function.oneway:
            if self._function_uses_streams(function) and \
                    not function.returntype.is_void:
                template = "apache::thrift::AsyncOutputStream<{type}>& _return"
                ret_arg = self._format_stream_declaration(template,
                                                          function.returntype)
                sig = ('void {name}(' + ret_arg)
                addcomma = True

            elif self._is_complex_type(function.returntype):
                sig = 'void {name}' + '({0}& _return'.format(
                    self._type_name(function.returntype))
                addcomma = True
            else:
                sig = self._type_name(function.returntype)
                sig += ' {name}('
        else:
            sig = 'void {name}('
        sig += self._argument_list(function.arglist, addcomma, unique=True,
                                   stream_type=stream_type)
        sig += ')'
        return sig

    def _get_prio_function_signature(self, service, function):
        sig = 'apache::thrift::concurrency::PriorityThreadManager::PRIORITY ' \
              '{name}(apache::thrift::Cpp2RequestContext* reqCtx)'
        return sig

    def _generate_app_ex(self, service, errorstr, functionname, seqid, is_in_eb,
                         s, static=True, err_code=None, err_header=True):
        with s('if (req)') as se:
            se('LOG(ERROR) << {0} << " in function {1}";'.format(
                    errorstr, functionname))
            code = '' if err_code is None else \
                    'apache::thrift::TApplicationException::' \
                    'TApplicationExceptionType::' + err_code + ', '
            se('apache::thrift::TApplicationException x({0}{1});'.
                format(code, errorstr))
            if static:
                ctx = 'ctx.get()'
                if err_header:
                    se('ctx->userException(' +
                       'folly::demangle(typeid(e)).toStdString());')
            else:
                ctx = 'nullptr'
            if is_in_eb:
                se('auto queue = serializeException("{0}", &prot, {1}, {2}, '
                   'x);'.format(functionname, seqid, ctx))
                se('req->sendReply(queue.move());')
            else:
                se('auto queue_mw = makeMoveWrapper(serializeException("{0}", '
                   '&prot, {1}, {2}, x));'.format(functionname, seqid, ctx))
                se('auto req_mw = makeMoveWrapper(std::move(req));')
                with se('eb->runInEventBaseThread([=]() mutable') as seeb:
                    seeb('(*req_mw)->sendReply(queue_mw->move());')
                se(');')
            se('return;')
        with s('else') as y:
            y('LOG(ERROR) << {0} << " in oneway function {1}";'.format(
                    errorstr, functionname))

    def _generate_processor(self, service, s):
        if not service.extends:
            class_signature = 'class {0} : '.format(
                service.name + 'AsyncProcessor') + \
                'public ::apache::thrift::GeneratedAsyncProcessor'
        else:
            class_signature = 'class {0} : '.format(
                service.name + 'AsyncProcessor') + \
                'public ' + self._type_name(service.extends) + \
                'AsyncProcessor'
        with s.cls(class_signature) as p:
            p.label('public:')
            with p.defn('std::string {name}()', name='getServiceName',
                        modifiers='virtual') as gsn:
                gsn("return \"{0}\";".format(service.name))

            p.label('protected:')

            p('{0}SvIf* iface_;'.format(service.name))
            with p.defn('void {name}(std::unique_ptr<' +
                        'apache::thrift::ResponseChannel::Request> req, ' +
                        'std::unique_ptr<folly::IOBuf> buf, ' +
                        'apache::thrift::protocol::PROTOCOL_TYPES protType,' +
                        'apache::thrift::Cpp2RequestContext* context,' +
                        'apache::thrift::async::TEventBase* eb, ' +
                        'apache::thrift::concurrency::ThreadManager* tm)',
                        name='process',
                        modifiers='virtual') as d:
                d('std::string fname;')
                d('apache::thrift::MessageType mtype;')
                d('int32_t protoSeqId = 0;')
                switch = d('switch(protType)').scope
                for shortprot, protname, prottype in self.protocols:
                    with switch.case('apache::thrift::protocol::' +
                                     prottype, nobreak=True) as b:
                        b(('std::unique_ptr<apache::thrift::' +
                           '{0}Reader> ' +
                           'iprot(new apache::thrift::' +
                           '{0}Reader());').format(protname))
                        b('iprot->setInput(buf.get());')
                        with b('try') as t:
                            t('iprot->readMessageBegin(fname, mtype,' + \
                                  ' protoSeqId);')
                            with t.catch("const TException& ex") as x:
                                x('LOG(ERROR) << "received invalid message' +
                                  ' from client: " << ex.what();')
                                b('apache::thrift::{0}Writer prot;'
                                  .format(protname))
                                self._generate_app_ex(
                                    service, '"invalid message from client"',
                                    "process", "protoSeqId", False, x, False)
                                x('return;')
                        with b('if (mtype != apache::thrift::T_CALL && ' +
                               'mtype != apache::thrift::T_ONEWAY)') as x:
                            x('LOG(ERROR) << "received invalid message of ' +
                              'type " << mtype;')
                            b('apache::thrift::{0}Writer prot;'
                              .format(protname))
                            self._generate_app_ex(
                                service, '"invalid message arguments"',
                                "process", "protoSeqId", False, x, False)
                        b('auto pfn = {0}ProcessMap_.find(fname);'.format(
                                shortprot))
                        with b('if (pfn == {0}ProcessMap_.end())'.format(
                                shortprot)) as i:
                            if not service.extends:
                                x('const std::string exMsg = ' +
                                  'folly::stringPrintf(' +
                                  ' "Method name %s not found",' +
                                  ' fname.c_str());')
                                b('apache::thrift::{0}Writer prot;'
                                  .format(protname))
                                self._generate_app_ex(
                                    service, 'exMsg',
                                    "process", "protoSeqId", False, x, False)
                            else:
                                i(self._type_name(service.extends) +
                                  'AsyncProcessor::process(std::move(req), ' +
                                  'std::move(buf), protType, context, eb, tm);')
                            i('return;')
                        b('(this->*(pfn->second))(std::move(req), ' +
                          'std::move(buf), std::move(iprot), context, eb, tm);')
                        b('return;')
                with switch.case('default') as d:
                    d('LOG(ERROR) << "invalid protType: " << protType;')
                    d('return;')
                switch.release()

            with p.defn('bool {name}(const folly::IOBuf* buf, ' +
                    'const apache::thrift::transport::THeader* header)',
                        name='isOnewayMethod',
                        modifiers='virtual') as d:
                d('std::string fname;')
                d('apache::thrift::MessageType mtype;')
                d('int32_t protoSeqId = 0;')
                d('apache::thrift::protocol::PROTOCOL_TYPES protType = ' +
                  'static_cast<apache::thrift::protocol::PROTOCOL_TYPES>' +
                  '(header->getProtocolId());')
                switch = d('switch(protType)').scope
                for shortprot, protname, prottype in self.protocols:
                    with switch.case('apache::thrift::protocol::' +
                                     prottype, nobreak=True) as b:
                        b(('apache::thrift::{0}Reader iprot;')
                                .format(protname))
                        b('iprot.setInput(buf);')
                        with b('try') as t:
                            t('iprot.readMessageBegin(fname, mtype,' +
                                  ' protoSeqId);')
                            t('auto it = onewayMethods.find(fname);')
                            t('return it != onewayMethods.end();')
                            with t.catch("const TException& ex") as x:
                                x('LOG(ERROR) << "received invalid message' +
                                  ' from client: " << ex.what();')
                                x('return false;')
                with switch.case('default') as d:
                    d('LOG(ERROR) << "invalid protType: " << protType;')
                switch.release()
                d('return false;')

            p.label('private:')
            p('std::unordered_set<std::string> onewayMethods;')
            for shortprot, protname, prottype in self.protocols:
                p(('typedef void ({0}::*{1}ProcessFunction)(std::unique_ptr' +
                   '<apache::thrift::ResponseChannel::Request> req, ').format(
                           service.name + "AsyncProcessor", shortprot) +
                  'std::unique_ptr<folly::IOBuf> buf, ' +
                  'std::unique_ptr<apache::thrift::{0}Reader> iprot, '.format(
                          protname) +
                  'apache::thrift::Cpp2RequestContext* context, ' +
                  'apache::thrift::async::TEventBase* eb, ' +
                  'apache::thrift::concurrency::ThreadManager* tm' + ');')
                p('typedef std::unordered_map<std::string, ' +
                  '{0}ProcessFunction>'.format(shortprot) +
                  ' {0}ProcessMap;'.format(shortprot))
                p('{0}ProcessMap {0}ProcessMap_;'.format(shortprot))
            for function in service.functions:
                loadname = '"{0}.{1}"'.format(service.name, function.name)
                if not self._is_processed_in_eb(function):
                    with p.defn('template <typename ProtocolIn_, '
                                'typename ProtocolOut_>\n'
                                'void {name}(std::unique_ptr<'
                                'apache::thrift::ResponseChannel::Request> req,'
                                ' std::unique_ptr<folly::IOBuf> buf, '
                                'std::unique_ptr<ProtocolIn_> iprot, '
                                'apache::thrift::Cpp2RequestContext* ctx, '
                                'apache::thrift::async::TEventBase* eb, '
                                'apache::thrift::concurrency::ThreadManager* tm'
                                ')',
                                name="_processInThread_{0}"
                                .format(function.name),
                                output=self._out_tcc) as f:
                                    f('using folly::makeMoveWrapper;')
                                    if function.oneway:
                                        # Old clients may not send the special
                                        # oneway id, so we need to send a fake
                                        # response to them while in event base.
                                        with f('if (!req->isOneway())') as g:
                                            g('req->sendReply(std::unique_ptr<'
                                              'folly::IOBuf>());')
                                    f('auto preq = req.get();')
                                    f('auto piprot = iprot.get();')
                                    f('auto buf_mw = makeMoveWrapper('
                                      'std::move(buf));')
                                    f()
                                    with f('try') as t:

                                        with t(
                                            'tm->add(std::make_shared<'
                                            'apache::thrift::PriorityEventTask>'
                                            '(iface_->getprio_{0}(ctx), '
                                            '[=]() mutable'
                                            .format(function.name)
                                        ) as g:
                                            g('auto req_mw = makeMoveWrapper('
                                              'std::unique_ptr'
                                              '<apache::thrift::ResponseChannel'
                                              '::Request>(preq));')
                                            g('auto iprot_holder = '
                                              'std::unique_ptr<ProtocolIn_>('
                                              'piprot);')
                                            if not function.oneway:
                                                # Oneway request won't be
                                                # canceled if expired. see
                                                # D1006482 for furhter details.
                                                # TODO: fix this
                                                with g('if (!(*req_mw)->'
                                                       'isActive())') as h:
                                                    with h(
                                                        'eb->runInEventBase'
                                                        'Thread([=]() mutable'
                                                    ) as i:
                                                        i('delete req_mw->'
                                                          'release();')
                                                    h(');')
                                                    h('return;')
                                            g('this->process_{0}'
                                              '<ProtocolIn_, ProtocolOut_>('
                                              'std::move(*req_mw), '
                                              'std::move(*buf_mw), '
                                              'std::move(iprot_holder), ctx, '
                                              'eb, tm);'.format(function.name))
                                        t('));')
                                        t('req.release();')
                                        t('iprot.release();')
                                        with t.catch('std::exception& e') as x:
                                            if not function.oneway:
                                                x('apache::thrift::TApplication'
                                                  'Exception ex("Failed to add '
                                                  'task to queue, too full");')
                                                x('req->sendError(std::make_'
                                                  'exception_ptr(ex),'
                                                  'kOverloadedErrorCode);')

                with p.defn('template <typename ProtocolIn_, ' +
                            'typename ProtocolOut_>\n' +
                            'void {name}(std::unique_ptr<' +
                            'apache::thrift::ResponseChannel::Request> req, ' +
                            'std::unique_ptr<folly::IOBuf> buf, ' +
                            'std::unique_ptr<ProtocolIn_> iprot,' +
                            'apache::thrift::Cpp2RequestContext* ctx,' +
                            'apache::thrift::async::TEventBase* eb, ' +
                            'apache::thrift::concurrency::ThreadManager* tm)',
                            name="process_{0}".format(function.name),
                            output=self._out_tcc) as f:
                                if function.oneway:
                                    if self._is_processed_in_eb(function):
                                        # Old clients may not send the special
                                        # oneway id, so we need to send a fake
                                        # response to them while in event base.
                                        with c('if (!req->isOneway())') as cb:
                                            cb('req->sendReply('
                                               'std::unique_ptr<folly::IOBuf>()'
                                               ');')
                                f("// make sure getConnectionContext is null")
                                f("// so async calls don't accidentally use it")
                                f('iface_->setConnectionContext(nullptr);')
                                aprefix = 'uarg_'
                                if self.flag_stack_arguments:
                                    f('{0}_{1}_args args;'.format(
                                            service.name, function.name))
                                else:
                                    f('{0}_{1}_pargs args;'.format(
                                            service.name, function.name))
                                for field in function.arglist.members:
                                    val = ""
                                    t = self._get_true_type(field.type)
                                    if t.is_base_type or t.is_enum:
                                        val = self._member_default_value(field)

                                    if self.flag_stack_arguments:
                                        pass
                                    elif t.is_stream:
                                        pass
                                    elif self._is_complex_type(field.type):
                                        f('std::unique_ptr<'
                                          '{0}> {1}(new {0}({2}));'.format(
                                                  self._type_name(field.type),
                                                  aprefix + field.name,
                                                  val))
                                        f('args.{0} = {1}.get();'.format(
                                                field.name,
                                                aprefix + field.name))
                                    else:
                                        # use uniform initialization syntax to
                                        # avoid most vexing parse
                                        f('{0} {1}{{{2}}};'.format(
                                                self._type_name(field.type),
                                                aprefix + field.name,
                                                val))
                                        ref_prefix = "&"
                                        if self.flag_stack_arguments:
                                            ref_prefix = ""
                                        f('args.{0} = {2}{1};'.format(
                                                field.name,
                                                aprefix + field.name,
                                                ref_prefix))
                                f(('std::unique_ptr<apache::thrift::' +
                                  'ContextStack> c(this->getContextStack' +
                                  '(this->getServiceName(), "{0}.{1}", ctx));'
                                   ).format(service.name, function.name))
                                f()
                                with f('try') as t:
                                    t('deserializeRequest(args, buf.get(), '
                                      'iprot.get(), c.get());')
                                with f('catch (const std::exception& ex)') as c:
                                    if function.oneway:
                                        t('LOG(ERROR) << ex.what() << " '
                                          'in function noResponse";')
                                        t('return;')
                                    else:
                                        t('ProtocolOut_ prot;')
                                        self._generate_app_ex(
                                            service, 'ex.what()',
                                            function.name, "iprot->getSeqId()",
                                            False, c, False, 'PROTOCOL_ERROR')
                                args = []
                                for member in function.arglist.members:
                                    if member.type.is_stream:
                                        pass
                                    elif self.flag_stack_arguments:
                                        args.append("args." + member.name)
                                    elif self._is_complex_type(member.type):
                                        args.append("std::move({0})".format(
                                                aprefix + member.name))
                                    else:
                                        args.append("*args." + member.name)

                                if function.oneway:
                                    c('std::unique_ptr<apache::thrift::' +
                                      'HandlerCallbackBase> callback(' +
                                      'new apache::thrift::' +
                                      'HandlerCallbackBase(std::move(req), ' +
                                      'std::move(c), nullptr, eb, ' +
                                      'tm, ctx));')
                                else:
                                    if self._function_uses_streams(function):
                                        rettype = ('apache::thrift::'
                                                    'StreamManager *')
                                    elif self._is_complex_type(
                                            function.returntype) and \
                                            not self.flag_stack_arguments:
                                        rettype = self._type_name(
                                                function.returntype)
                                        rettype = 'std::unique_ptr<' + \
                                                rettype + '>'
                                    else:
                                        rettype = self._type_name(
                                                function.returntype)

                                    c(('std::unique_ptr<apache::thrift::' +
                                       'HandlerCallback<{0}>> callback(' +
                                       'new apache::thrift::' +
                                       'HandlerCallback<{0}>(std::move(req), ' +
                                       'std::move(c), return_{1}<ProtocolIn_,' +
                                       'ProtocolOut_>, throw_{1}<ProtocolIn_,' +
                                       ' ProtocolOut_>, iprot->getSeqId(),' +
                                       ' eb, ' +
                                       'tm, ctx));').format(rettype,
                                                             function.name))

                                args.insert(0, 'std::move(callback)')
                                f('iface_->{0}({1});'.format(
                                  self._get_async_func_name(function),
                                  ", ".join(args)))

                if not function.oneway:
                    args = [
                        'int32_t protoSeqId',
                        'std::unique_ptr<apache::thrift::ContextStack> ctx']

                    if self._function_uses_streams(function):
                        args.append("apache::thrift::StreamManager"
                                    "* const& _return")
                    elif not function.returntype.is_void:
                        args.append("{0} const& _return".format(
                                self._type_name(function.returntype)))

                    with p.defn(
                        'template <class ProtocolIn_, class ProtocolOut_>\n' +
                                'folly::IOBufQueue {name}' + '({0})'
                                .format(", ".join(args)),
                                name="return_{0}".format(function.name),
                                output=self._out_tcc,
                                modifiers='static') as f:
                                    if self._function_uses_streams(function):
                                        f('_return->setInputProtocol('
                                          'ProtocolIn_::protocolType());')
                                        f('_return->setOutputProtocol('
                                         'ProtocolOut_::protocolType());')
                                        f()
                                    f('ProtocolOut_ prot;')
                                    result_type = '{0}_{1}_presult'.format(
                                            service.name, function.name)
                                    f('{0} result;'.format(result_type))
                                    if self._function_produces_result(function):
                                        f('result.success = const_cast' +
                                          '<{0}*>(&_return);'.format(
                                                  self._type_name(
                                                       function.returntype)))
                                        f('result.__isset.success = true;')
                                    f('return serializeResponse("{0}", '
                                      '&prot, protoSeqId, ctx.get(), result);'
                                      .format(function.name))

                def cast_xceptions(xceptions, f):
                    for xception in xceptions:
                        with f('catch (const {0}& e)'.format(
                            self._type_name(xception.type))) as e:
                            e('ctx->userException(' +
                              'folly::demangle(typeid(e)).toStdString());')
                            e('result.{0} = e;'.format(xception.name))
                            e('result.__isset.{0} = true;'.format(
                                xception.name))
                if not function.oneway:
                    with p.defn(
                        'template <class ProtocolIn_, class ProtocolOut_>\n' +
                        'void {name}(std::unique_ptr' +
                        '<apache::thrift::ResponseChannel::Request> req,' +
                        'int32_t protoSeqId,'
                        + 'std::unique_ptr<apache::thrift::ContextStack> ctx,' +
                        'std::exception_ptr ep)',
                                name="throw_{0}".format(function.name),
                                modifiers='static',
                                output=self._out_tcc) as f:
                                    f('ProtocolOut_ prot;')
                                    if len(function.xceptions.members) > 0:
                                        f('{0}_{1}_result result;'.format(
                                                service.name, function.name))
                                    with f('try') as tb:
                                        tb('std::rethrow_exception(ep);')
                                    cast_xceptions(
                                        function.xceptions.members, f)
                                    with f('catch (const std::exception& e)') \
                                        as e:
                                        self._generate_app_ex(
                                            service,
                                            "folly::exceptionStr(e)." +
                                            "toStdString()",
                                            function.name, "protoSeqId", True,
                                            e)
                                    with f('catch (...)') as e:
                                        self._generate_app_ex(
                                            service,
                                            "\"<unknown exception>\"",
                                            function.name, "protoSeqId", True,
                                            e, False)
                                    if len(function.xceptions.members) > 0:
                                        f('auto queue = serializeResponse('
                                          '"{0}", &prot, protoSeqId, ctx.get(),'
                                          ' result);'.format(function.name))
                                        f('return req->sendReply(' +
                                          'queue.move());')

            p.label('public:')
            init = OrderedDict()
            if service.extends:
                init[self._type_name(service.extends) + 'AsyncProcessor'] = \
                    'iface'
            init['iface_'] = 'iface'
            init['onewayMethods'] = '{' + ','.join('"' + function.name + '"'
                    for function in service.functions if function.oneway) + '}'
            for shortprot, protname, prottype in self.protocols:
                init['{0}ProcessMap_'.format(shortprot)] = '\n{' + ',\n'.join(
                    '{"' + function.name + '", &' + service.name +
                    'AsyncProcessor::' +
                    self._get_handler_function_name(function) +
                    '<apache::thrift::{0}Reader, '
                    'apache::thrift::{0}Writer>}}'.format(protname)
                        for function in service.functions) + '}'
            p.defn('{name}(' + service.name + 'SvIf* iface)',
                   name=service.name + 'AsyncProcessor',
                   init_dict=init,
                   in_header=True).scope.empty()
            p.defn('{name}()', name='~' + service.name + 'AsyncProcessor',
                   in_header=True, modifiers='virtual').scope.empty()

    def _get_handler_function_name(self, function):
        if self._is_processed_in_eb(function):
            return 'process_' + function.name
        else:
            return '_processInThread_' + function.name

    def _generate_client_sync_function(self, c, service, function,
                                       uses_rpc_options=False):

        signature = self._get_sync_function_signature(function,
                                                      uses_rpc_options)
        with c.defn(signature, name="sync_" + function.name,
                    modifiers='virtual') as f:
            common_args = [arg.name for arg in function.arglist.members]

            if not uses_rpc_options:
                if function.returntype.is_void:
                    args = ["::apache::thrift::RpcOptions()"]
                    args.extend(common_args)
                    args_list = ", ".join(args)
                    f("sync_{name}({args_list});".format(name=function.name,
                                                         args_list=args_list))
                elif self._function_uses_streams(function) or \
                     not self._is_complex_type(function.returntype):
                    args = ["::apache::thrift::RpcOptions()"]
                    args.extend(common_args)
                    args_list = ", ".join(args)

                    f("return sync_{name}({args_list});"
                         .format(name=function.name, args_list=args_list))
                else:
                    args = ["::apache::thrift::RpcOptions()", "_return"]
                    args.extend(common_args)
                    args_list = ", ".join(args)

                    f("sync_{name}({args_list});"
                         .format(name=function.name, args_list=args_list))

            elif self._function_uses_streams(function):
                serializer = service.name + "StreamSerializer"
                stream = self.tmp("stream")

                args = ["rpcOptions"]
                if function.returntype.is_stream:
                    template = ("apache::thrift::SyncInputStream<{type}> "
                                "{name};")
                    f(self._format_stream_declaration(template,
                                                      function.returntype,
                                                      stream))
                    args.append("{stream}.makeHandler<{serializer}>()"
                        .format(stream=stream, serializer=serializer))
                elif not function.returntype.is_void:
                    template = ("apache::thrift::StreamSingleton<{type}> "
                                "{name};")
                    f(self._format_stream_declaration(template,
                                                      function.returntype,
                                                      stream))
                    args.append("{stream}.makeHandler<{serializer}>()"
                        .format(stream=stream, serializer=serializer))

                for arg in function.arglist.members:
                    if not arg.type.is_stream:
                        args.append(arg.name)
                    else:
                        args.append("{name}.makeHandler<{serializer}>()"
                            .format(name=arg.name, serializer=serializer))

                args.append("nullptr")

                args_list = ", ".join(args)

                f("{name}({args});".format(name=function.name, args=args_list))

                if not function.returntype.is_void:
                    f("return std::move({stream});".format(stream=stream))

            else:
                f('apache::thrift::ClientReceiveState _returnState;')

                sync_callback_name = self.tmp("callback")
                f("std::unique_ptr<apache::thrift::RequestCallback> "
                  "{sync_callback_name}("
                  "new apache::thrift::ClientSyncCallback("
                  "&_returnState, getChannel()->getEventBase(), {isOneWay}));"
                  .format(sync_callback_name=sync_callback_name,
                      isOneWay=str(function.oneway).lower()))

                args = ["rpcOptions",
                        "std::move({0})".format(sync_callback_name)]
                args.extend(common_args)
                args_list = ", ".join(args)

                f("{name}({args_list});".format(name=function.name,
                                                args_list=args_list))

                f("getChannel()->getEventBase()->loopForever();")

                if not function.oneway:
                    with f("if (!_returnState.buf())") as i:
                        i("assert(_returnState.exception());")
                        i("std::rethrow_exception(_returnState.exception());")

                    if not function.returntype.is_void:
                        if not self._is_complex_type(function.returntype):
                            f("return recv_" + function.name +
                                "(_returnState);")
                        else:
                            f("recv_" + function.name +
                                "(_return, _returnState);")
                    else:
                        f("recv_" + function.name + "(_returnState);")

    def _get_sync_function_signature(self, function, uses_rpc_options=False):
        params = []

        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        if function.returntype.is_void:
            return_type = "void"
        elif function.returntype.is_stream:
            stream_type = self._get_true_type(function.returntype).as_stream
            inner_type = self._type_name(stream_type.elem_type)
            return_type = "apache::thrift::SyncInputStream<" + inner_type + ">"
        elif self._function_uses_streams(function):
            type_name = self._type_name(function.returntype)
            return_type = "apache::thrift::StreamSingleton<" + type_name + ">"
        elif not self._is_complex_type(function.returntype):
            return_type = self._type_name(function.returntype)
        else:
            return_type = "void"
            params.append(self._type_name(function.returntype) + "& _return")

        stream_type = "apache::thrift::SyncOutputStream<{type}>&"

        param_list = ", ".join(params)
        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False,
                                          stream_type=stream_type)

        return return_type + " {name}(" + param_list + ")"

    def _generate_client_future_gate_function(self, c, function):
        signature = self._get_future_gate_function_signature(function)

        with c.defn(signature, name="future_" + function.name,
                    modifiers='virtual') as f:
            if function.returntype.is_stream:
                return_type = "void"
            else:
                return_type = self._type_name(function.returntype)

            args = ["::apache::thrift::RpcOptions()"]
            if function.returntype.is_stream:
                args.append("_return")

            args.extend([arg.name for arg in function.arglist.members])
            args_list = ", ".join(args)

            f("return gate->gate<{2}>([=](){{return future_{0}({1});}});"
              .format(function.name, args_list, return_type))

    def _get_future_gate_function_signature(self, function):
        params = ["facebook::wangle::ThreadGate* gate"]

        if function.returntype.is_stream:
            return_type = "facebook::wangle::Future<void>"
            template = "apache::thrift::AsyncInputStream<{type}>& _return"
            params.append(self._format_stream_declaration(template,
                                                          function.returntype))
        else:
            result_type = self._type_name(function.returntype)
            return_type = "facebook::wangle::Future<" + result_type + ">"

        stream_type = "apache::thrift::AsyncOutputStream<{type}>&"

        param_list = ", ".join(params)
        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False,
                                          stream_type=stream_type)

        return return_type + " {name}(" + param_list + ")"

    def _generate_client_future_function(self, c, service, function,
                                         uses_rpc_options=False):

        function_name = "future_" + function.name
        signature = self._get_future_function_signature(function,
                                                        uses_rpc_options)
        with c.defn(signature, name=function_name,
                    modifiers='virtual') as f:
            if not uses_rpc_options:
                args = ["::apache::thrift::RpcOptions()"]
                if function.returntype.is_stream:
                    args.append("_return")

                args.extend([arg.name for arg in function.arglist.members])
                args_list = ", ".join(args)

                f("return {function}({args});"
                      .format(function=function_name, args=args_list))
            else:
                serializer_name = service.name + "StreamSerializer"

                common_args = []
                for arg in function.arglist.members:
                    if not arg.type.is_stream:
                        common_args.append(arg.name)
                    else:
                        common_args.append("{name}.makeHandler<{serializer}>()"
                                           .format(name=arg.name,
                                                   serializer=serializer_name))

                promise_name = self.tmp("promise")

                if function.returntype.is_stream:
                    return_type = "void"
                else:
                    return_type = self._type_name(function.returntype)

                f("facebook::wangle::Promise<{type}> {promise};"
                  .format(type=return_type, promise=promise_name))

                future_name = self.tmp("future")
                f("auto {future} = {promise}.getFuture();"
                  .format(future=future_name, promise=promise_name))

                args = ["rpcOptions"]
                end_args = []

                callback = self.tmp("callback")

                if (function.returntype.is_stream or
                   (function.returntype.is_void and
                   self._function_takes_stream_args(function))):

                    if function.returntype.is_stream:
                        args.append("_return.makeHandler<{serializer}>()"
                                      .format(serializer=serializer_name))

                    f("std::unique_ptr<apache::thrift::StreamEndCallback> "
                      "{callback}(new apache::thrift::FutureStreamEndCallback("
                      "std::move({promise})));"
                      .format(callback=callback, promise=promise_name))

                    end_args.append("std::move({0})".format(callback))

                elif function.returntype.is_void:
                    f("std::unique_ptr<apache::thrift::RequestCallback> "
                      "{callback}("
                      "new apache::thrift::FutureCallback<void>("
                      "std::move({promise}), {isOneWay}));"
                      .format(callback=callback,
                              promise=promise_name,
                              isOneWay=str(function.oneway).lower()))

                    args.append("std::move({0})".format(callback))

                elif self._function_takes_stream_args(function):
                    stream = self.tmp("stream")
                    type_name = self._type_name(function.returntype)

                    f("apache::thrift::AsyncInputStream<{type}> {name};"
                      .format(type=type_name, name=stream))

                    f("std::unique_ptr<apache::thrift::InputStreamCallback"
                      "<{type}>> {name}("
                      "new apache::thrift::FutureStreamItemCallback<{type}>("
                      "std::move({promise})));"
                        .format(type=type_name,
                                name=callback,
                                promise=promise_name))

                    f("{stream}.setCallback(std::move({callback}));"
                        .format(stream=stream, callback=callback))

                    args.append("{stream}.makeHandler<{serializer}>()"
                        .format(stream=stream, serializer=serializer_name))

                    end_args.append("nullptr")

                else:
                    f("std::unique_ptr<apache::thrift::RequestCallback> "
                      "{callback}("
                      "new apache::thrift::FutureCallback<{type}>("
                      "std::move({promise}), recv_{name}));"
                      .format(callback=callback,
                              type=return_type,
                              promise=promise_name,
                              name=function.name))

                    args.append("std::move({0})".format(callback))

                args.extend(common_args)
                args.extend(end_args)
                args_list = ", ".join(args)

                f("{name}({args_list});".format(name=function.name,
                                                args_list=args_list))

                f("return std::move({0});".format(future_name))

    def _get_future_function_signature(self, function, uses_rpc_options):
        params = []
        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        if function.returntype.is_stream:
            return_type = "facebook::wangle::Future<void>"
            template = "apache::thrift::AsyncInputStream<{type}>& _return"
            params.append(self._format_stream_declaration(template,
                                                          function.returntype))
        else:
            result_type = self._type_name(function.returntype)
            return_type = "facebook::wangle::Future<" + result_type + ">"

        stream_type = "apache::thrift::AsyncOutputStream<{type}>&"

        param_list = ", ".join(params)
        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False,
                                          stream_type=stream_type)

        return return_type + " {name}(" + param_list + ")"

    def _generate_client_async_function(self, c, service, function,
                                        uses_rpc_options=False,
                                        name_prefix=""):
        if not uses_rpc_options:
            signature = self._get_async_function_signature(function,
                                                           uses_rpc_options)
            with c.defn(signature, name=name_prefix + function.name,
                        modifiers='virtual') as f:
                args = ["::apache::thrift::RpcOptions()"]

                if not self._function_uses_streams(function):
                    args.append("std::move(callback)")
                elif not function.returntype.is_void:
                    args.append("_return")

                args.extend([arg.name for arg in function.arglist.members])
                args_list = ", ".join(args)

                f("{name}({args});".format(name=function.name, args=args_list))

        else:
            # we generate an extra function that accepts Async{In,Out}putStreams
            if self._function_uses_streams(function):
                signature = self._get_async_function_signature(
                        function, uses_rpc_options=True)
                with c.defn(signature, name=name_prefix + function.name,
                            modifiers='virtual') as f:
                    serializer = service.name + "StreamSerializer"

                    args = ["rpcOptions"]
                    if not function.returntype.is_void:
                        args.append("_return.makeHandler<{serializer}>()"
                                    .format(serializer=serializer))

                    for arg in function.arglist.members:
                        if not arg.type.is_stream:
                            args.append(arg.name)
                        else:
                            args.append("{name}.makeHandler<{serializer}>()"
                                .format(name=arg.name, serializer=serializer))

                    if self._function_uses_streams(function):
                        args.append("nullptr")

                    args_list = ", ".join(args)

                    f("{name}({args});".format(name=function.name,
                                               args=args_list))

            signature = self._get_async_function_signature(
                    function, uses_rpc_options=True, uses_callback_ptr=True)

            with c.defn(signature, name=name_prefix + function.name,
                        modifiers='virtual') as f:
                args = ["&writer", "rpcOptions"]
                if not self._function_uses_streams(function):
                    args.append("std::move(callback)")
                elif not function.returntype.is_void:
                    args.append("std::move(_return)")

                for arg in function.arglist.members:
                    if not arg.type.is_stream:
                        args.append(arg.name)
                    else:
                        args.append("std::move({name})".format(name=arg.name))

                if self._function_uses_streams(function):
                    args.append("std::move(_streamEndCallback)")

                args_list = ", ".join(args)

                with f("switch(getChannel()->getProtocolId())") as s:
                    for key, val, prot in self.protocols:
                        with s.case("apache::thrift::protocol::" + prot) as a:
                            a("apache::thrift::{0}Writer writer;".format(val))
                            a("{name}T({args});".
                              format(name=function.name, args=args_list))

                    with s.case("default", nobreak=True) as a:
                        a("throw apache::thrift::TApplicationException("
                          '"Could not find Protocol");')

    def _generate_templated_client_function(self, c, service, function):
        signature = self._get_async_function_signature(function,
                                                       uses_rpc_options=True,
                                                       uses_template=True,
                                                       uses_callback_ptr=True)

        func_name = function.name + "T"

        with c.defn(signature, name=func_name, output=self._out_tcc) as f:
            is_sync = self.tmp("isSync")
            if self._function_uses_streams(function):
                f("bool {sync} = false;".format(sync=is_sync))
                f()

                f("apache::thrift::StreamSource::StreamMap sourceMap;")
                if not function.returntype.is_void:
                    type_enum = self._stream_type_to_enum(function.returntype)

                    with f("if (_return)") as i:
                        i("{sync} = {sync} || _return->isSync();"
                          .format(sync=is_sync))
                        i("_return->setType({enum});".format(enum=type_enum))
                        i("sourceMap[0] = std::move(_return);")
                f()

                f("apache::thrift::StreamSink::StreamMap sinkMap;")
                for arg in function.arglist.members:
                    if arg.type.is_stream:
                        type_enum = self._stream_type_to_enum(arg.type)

                        with f("if ({arg})".format(arg=arg.name)) as i:
                            i("{sync} = {sync} || {arg}->isSync();"
                              .format(sync=is_sync, arg=arg.name))
                            i("{arg}->setType({enum});"
                              .format(arg=arg.name, enum=type_enum))
                            i("sinkMap[{key}] = std::move({arg});"
                              .format(key=arg.key, arg=arg.name))
                f()

                prefix = "{service}StreamSerializer::{func}Exception".format(
                            service=service.name, func=function.name)
                f("std::unique_ptr<apache::thrift::StreamManager> stream(")
                f("     new apache::thrift::StreamManager(")
                f("         getChannel()->getEventBase(),")
                f("         std::move(sourceMap),")
                f("         {prefix}Deserializer,".format(prefix=prefix))
                f("         std::move(sinkMap),")
                f("         {prefix}Serializer,".format(prefix=prefix))
                f("         std::move(_streamEndCallback)));")
                f()

                f("stream->setOutputProtocol(")
                f("    static_cast<apache::thrift::ProtocolType>(")
                f("        getChannel()->getProtocolId()));")
                f()

                f("apache::thrift::RpcOptions streamOptions(rpcOptions);")
                f("streamOptions.setStreaming(true);")
                f()

                f("std::unique_ptr<apache::thrift::StreamCallback> callback(")
                f("    new apache::thrift::StreamCallback(std::move(stream),")
                f("    getChannel()->getEventBase(), recv_{name}, {is_sync}));"
                    .format(name=function.name, is_sync=is_sync))
                f()

            f("std::unique_ptr<apache::thrift::ContextStack> ctx = "
              "this->getContextStack(this->getServiceName(), "
              '"{0}.{1}", connectionContext_.get());'
              .format(service.name, function.name))

            f("{0}_{1}_pargs args;".format(service.name, function.name))

            # Generate list of function args
            for field in function.arglist.members:
                rtype = self._get_true_type(field.type)
                if rtype.is_stream:
                    pass
                elif rtype.is_string or rtype.is_container \
                        or rtype.is_struct:
                    f("args.{1} = const_cast<{0}*>(&{2});".format(
                            self._type_name(rtype),
                            field.name, field.name))
                else:
                    f("args.{0} = &{0};".format(field.name))

            if self.flag_compatibility:
                f("size_t bufSize = "
                  "{0}_{1}_pargs_serializedSizeZC(prot, &args);".
                  format(service.name, function.name))
            else:
                f("size_t bufSize = args.serializedSizeZC(prot);")

            f('bufSize += prot->serializedMessageSize("{name}");'
                .format(name=function.name))
            f("folly::IOBufQueue queue(folly::IOBufQueue::cacheChainLength());")
            f("prot->setOutput(&queue, bufSize);")
            f("auto guard = folly::makeGuard([&]{prot->setOutput(nullptr);});")
            f()

            with f("try") as t:
                t('ctx->preWrite();')
                t("prot->writeMessageBegin"
                  "(\"{0}\", apache::thrift::T_CALL, 0);".format(
                              function.name))
                if self.flag_compatibility:
                    t("{0}_{1}_pargs_write(prot, &args);".format(
                            service.name, function.name))
                else:
                    t("args.write(prot);")
                t("prot->writeMessageEnd();")
                t("::apache::thrift::SerializedMessage smsg;")
                t("smsg.protocolType = prot->protocolType();")
                t("smsg.buffer = queue.front();")
                t("ctx->onWriteData(smsg);")
                t("ctx->postWrite(queue.chainLength());")

                with t.catch("apache::thrift::TException &ex") as h:
                    h("ctx->handlerError();")
                    h("throw;")
            f()

            if not function.oneway:
                optionName = "rpcOptions"
                if self._function_uses_streams(function):
                    optionName = "streamOptions"

                f("this->channel_->sendRequest(std::move(" + optionName + "), "
                                              "std::move(callback), "
                                              "std::move(ctx), "
                                              "queue.move());")

            else:
                # Calling asyncComplete before sending because
                # sendOnewayRequest moves from ctx and clears it.
                f("ctx->asyncComplete();")
                f("this->channel_->sendOnewayRequest(std::move(rpcOptions), "
                                                    "std::move(callback), "
                                                    "std::move(ctx), "
                                                    "queue.move());")

            if self._function_uses_streams(function):
                with f("if ({sync})".format(sync=is_sync)) as i:
                    i("this->channel_->getEventBase()->loopForever();")

    def _get_async_function_signature(self,
                                      function,
                                      uses_rpc_options,
                                      uses_template=False,
                                      uses_callback_ptr=False):
        signature_prefix = ""
        if uses_template:
            signature_prefix = "template <typename Protocol_>\n"

        params = []
        if uses_template:
            params.append("Protocol_* prot")

        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        if not self._function_uses_streams(function):
            params.append("std::unique_ptr<apache::thrift::RequestCallback> "
                          "callback")
        elif not function.returntype.is_void:
            if uses_callback_ptr:
                type = ("std::unique_ptr<apache::thrift::"
                        "InputStreamCallbackBase>&&")
            else:
                template = "apache::thrift::AsyncInputStream<{type}>&"
                type = self._format_stream_declaration(template,
                                                       function.returntype)
            params.append(type + " _return")

        param_list = ", ".join(params)

        if uses_callback_ptr:
            stream_type = ("std::unique_ptr<apache::thrift::"
                           "OutputStreamCallbackBase>&&")
            is_template = False
        else:
            stream_type = "apache::thrift::AsyncOutputStream<{type}>&"
            is_template = True

        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False,
                                          stream_type=stream_type,
                                          stream_type_is_template=is_template)

        if self._function_uses_streams(function) and uses_callback_ptr:
            param_list += (", std::unique_ptr<apache::thrift::"
                           "StreamEndCallback>&& _streamEndCallback")

        return signature_prefix + "void {name}(" + param_list + ")"

    def _generate_client_std_function(self, c, function, name_prefix=""):
        sig = ("void {name}(std::function<void ("
               "::apache::thrift::ClientReceiveState&&)> callback" +
               self._argument_list(function.arglist, True, unique=False) + ")")

        args = ["std::unique_ptr<apache::thrift::RequestCallback>("
                "new apache::thrift::FunctionReplyCallback("
                "std::move(callback)))"]
        args.extend([arg.name for arg in function.arglist.members])
        args_list = ",".join(args)

        name = name_prefix + function.name
        with c.defn(sig, name=name) as f:
            f("{name}({args});".format(name=function.name, args=args_list))

    def _generate_recv_function(self, c, function):
        with c.defn(self._get_recv_function_signature(function),
                    name="recv_" + function.name,
                    modifiers="static") as f:
            with f('if (state.exception())') as ex:
                ex('std::rethrow_exception(state.exception());')
            with f('if (!state.buf())') as e:
                e('throw apache::thrift::TApplicationException('
                  '"recv_ called without result");')

            with f("switch(state.protocolId())") as s:
                for key, value, prottype in self.protocols:
                    with s.case('apache::thrift::protocol::' + prottype) as a:
                        a("apache::thrift::{0}Reader reader;".format(value))

                        callee_name = "recv_" + function.name + "T"

                        args = ["&reader"]

                        if self._function_uses_streams(function):
                            args.append("std::move(stream)")
                        elif self._is_complex_type(function.returntype):
                            args.append("_return")

                        args.append("state")
                        args_list = ", ".join(args)

                        if function.returntype.is_void or \
                           self._is_complex_type(function.returntype) or \
                           self._function_uses_streams(function):
                            a(callee_name + "(" + args_list + ");")
                            a("return;")
                        else:
                            a("return " + callee_name + "(" + args_list + ");")

                with s.case("default", nobreak=True) as a:
                    pass
            f("throw apache::thrift::TApplicationException("
              '"Could not find Protocol");')

    def _generate_templated_recv_function(self, c, service, function):
        sig = self._get_recv_function_signature(function, uses_template=True)

        with c.defn(sig,
                    name="recv_" + function.name + "T",
                    modifiers="static",
                    output=self._out_tcc) as f:
            f("prot->setInput(state.buf());")
            f("auto guard = folly::makeGuard([&] {prot->setInput(nullptr);});")
            f("apache::thrift::ContextStack* ctx = state.ctx();")
            f("std::string fname;")
            f("int32_t protoSeqId = 0;")
            f("apache::thrift::MessageType mtype;")
            f("ctx->preRead();")

            with f("try") as t:
                t("prot->readMessageBegin(fname, mtype, protoSeqId);")

                with f("if (mtype == apache::thrift::T_EXCEPTION)") as e:
                    e("apache::thrift::TApplicationException x;")
                    e("x.read(prot);")
                    e("prot->readMessageEnd();")
                    e("throw x;")

                with f("if (mtype != apache::thrift::T_REPLY)") as e:
                    e("prot->skip(apache::thrift::protocol::T_STRUCT);")
                    e("prot->readMessageEnd();")
                    e("throw apache::thrift::TApplicationException"
                      "(apache::thrift::TApplicationException"
                      "::TApplicationExceptionType::INVALID_MESSAGE_TYPE);")

                with f('if (fname.compare("' + function.name + '") != 0)') as e:
                    e("prot->skip(apache::thrift::protocol::T_STRUCT);")
                    e("prot->readMessageEnd();")
                    e("throw apache::thrift::TApplicationException"
                      "(apache::thrift::TApplicationException"
                      "::TApplicationExceptionType::WRONG_METHOD_NAME);")

                f("::apache::thrift::SerializedMessage smsg;")
                f("smsg.protocolType = prot->protocolType();")
                f("smsg.buffer = state.buf();")
                f("ctx->onReadData(smsg);")

                if not function.returntype.is_void and \
                   not self._is_complex_type(function.returntype) and \
                   not self._function_uses_streams(function):
                    f(self._type_name(function.returntype) + " _return;")

                f("{0}_{1}_presult result;".format(service.name, function.name))

                if not function.returntype.is_void and \
                   not self._function_uses_streams(function):
                    f("result.success = &_return;")

                if self.flag_compatibility:
                    f("{0}_{1}_presult_read(prot, &result);".format(
                            service.name, function.name))
                else:
                    f("result.read(prot);")

                f("prot->readMessageEnd();")
                f('ctx->postRead(state.buf()->length());')

                if not function.returntype.is_void and \
                   not self._function_uses_streams(function):

                    if self._is_complex_type(function.returntype):
                        with f("if (result.__isset.success)") as e:
                            e("// _return pointer has been filled")
                            e("return;")
                    else:
                        with f("if (result.__isset.success)") as e:
                            e("return _return;")

                for xs in function.xceptions.members:
                    with f("if (result.__isset.{0})".format(xs.name)) as e:
                        e("throw result.{0};".format(xs.name))

                if not function.returntype.is_void and \
                   not self._function_uses_streams(function):
                    # else throw, no success
                    f("throw apache::thrift::TApplicationException("
                      "apache::thrift::TApplicationException::"
                      "TApplicationExceptionType::MISSING_RESULT, "
                      '"failed: unknown result");')

                with t.catch("apache::thrift::TException &ex") as h:
                    h("ctx->handlerError();")
                    h("throw;")

            if self._function_uses_streams(function):
                f("stream->setInputProtocol(")
                f("    static_cast<apache::thrift::ProtocolType>(")
                f("        state.protocolId()));")
                f()
                f("state.setStreamManager(std::move(stream));")
                f()

    def _get_recv_function_signature(self, function, uses_template=False):
        signature_prefix = ""

        if uses_template:
            signature_prefix = "template <typename Protocol_>\n"

        if function.returntype.is_void or \
           self._is_complex_type(function.returntype) or \
           self._function_uses_streams(function):
            signature_prefix += "void"
        else:
            signature_prefix += self._type_name(function.returntype)

        params = []
        if uses_template:
            params.append("Protocol_* prot")

        if self._function_uses_streams(function):
            params.append("std::unique_ptr<apache::thrift::StreamManager>&& "
                          "stream")
        elif self._is_complex_type(function.returntype):
            params.append(self._type_name(function.returntype) + "& _return")

        params.append("::apache::thrift::ClientReceiveState& state")

        param_list = ", ".join(params)
        return signature_prefix + " {name}(" + param_list + ")"

    def _recv_has_void_return_type(self, function):
        return not self._function_produces_result(function) or \
               self._recv_uses_return_parameter(function)

    def _recv_uses_return_parameter(self, function):
        return self._function_produces_result(function) and \
               self._is_complex_type(function.returntype)

    def _function_produces_result(self, function):
        return_type = function.returntype
        return not return_type.is_void and \
               not self._function_uses_streams(function)

    def _argument_list(self, arglist, add_comma, unique, stream_type=None,
                                                stream_type_is_template=True):
        out = ""
        for field in arglist.members:
            if not field.type.is_stream or stream_type is not None:
                if len(out) > 0 or add_comma:
                    out += ", "

                if field.type.is_stream:
                    if stream_type_is_template:
                        type_name = self._format_stream_declaration(stream_type,
                                                                    field.type)
                    else:
                        type_name = stream_type
                else:
                    type_name = self._type_name(field.type,
                                                arg=True, unique=unique)

                out += type_name + " " + field.name

        return out

    def _stream_type_to_enum(self, type):
        if type.is_stream:
            true_type = self._get_true_type(type)
            type = true_type.as_stream.elem_type
        return self._type_to_enum(type)

    def _format_stream_declaration(self, name_template, type=None, name=None):
        if not type:
            return name_template

        if type.is_stream:
            true_type = self._get_true_type(type)
            type = true_type.as_stream.elem_type
        type_name = self._type_name(type)

        if name:
            return name_template.format(type=type_name, name=name)
        else:
            return name_template.format(type=type_name)

    def _function_uses_streams(self, function):
        return (function.returntype.is_stream or
                self._function_takes_stream_args(function))

    def _function_takes_stream_args(self, function):
        for arg in function.arglist.members:
            if self._get_true_type(arg.type).is_stream:
                return True
        return False

    # ======================================================================
    # STRUCT GENERATION CODE + following two sections
    # ======================================================================

    def _default_value(self, t):
        t = self._get_true_type(t)
        if t.is_base_type or t.is_enum:
            dval = None
            if t.is_enum:
                dval = "({0})0".format(self._type_name(t))
            elif t.is_string:
                dval = '{0}()'.format(self._type_name(t))
            else:
                dval = '0'
            return dval
        else:
            return False

    def _should_generate_field(self, field):
        return (not field.type.is_stream and
               ('format' not in field.annotations or
                field.annotations['format'] != 'serialized'))

    def _member_default_value(self, member, explicit=False):
        t = self._get_true_type(member.type)
        if member.value:
            return self._render_const_value(t, member.value)
        if t.is_base_type and not t.is_string:
            return '0'
        if explicit:
            return '{0}()'.format(self._type_name(t))
        return ''

    def _get_serialized_fields_options(self, obj):
        keep_unknown_fields = ('keep_unknown_fields' in obj.annotations and
                               obj.annotations['keep_unknown_fields'] == '1')
        return SerializedFieldOptions(
            keep_unknown_fields=keep_unknown_fields,
            has_serialized_fields=keep_unknown_fields or any(
                    'format' in field.annotations and
                    field.annotations['format'] == 'serialized'
                    for field in obj.members)
        )

    def _gen_union_constructor(self, s, obj, is_operator, is_move):
        i = OrderedDict()
        if is_operator:
            if is_move:
                sig = '{name}& operator=({name}&& rhs)'
            else:
                sig = '{name}& operator=(const {name}& rhs)'
        else:
            i['type_'] = 'Type::__EMPTY__'
            if is_move:
                sig = '{name}({name}&& rhs)'
            else:
                sig = '{name}(const {name}& rhs)'

        with s.defn(sig, name=obj.name, in_header=True, init_dict=i) as d:
            if is_move or is_operator:
                d('__clear();')
            d('if (rhs.type_ == Type::__EMPTY__) {{ return{0}; }}'.format(
                ' *this' if is_operator else ''))

            if is_move:
                fmt = 'set_{field}(std::move(rhs.value_.{field}));'
            else:
                fmt = 'set_{field}(rhs.value_.{field});'
            self._gen_union_switch(d, obj.members, fmt, val='rhs.type_')

            if is_move:
                d('rhs.__clear();')
            if is_operator:
                d('return *this;')

    def _gen_union_switch(self, s, members, stmt,
                          val='type_', default='assert(false);'):
        with s('switch({0})'.format(val)).scope as s1:
            for member in members:
                with s1.case('Type::' + member.name) as s2:
                    s2(stmt.format(field=member.name))
            with s1.case('default') as s2:
                s2(default)

    def _generate_struct_complete(self, s, obj, is_exception,
                                    pointers, read, write, swap,
                                  result, has_isset=True):
        if self.flag_compatibility:
            base = self._namespace_prefix(
                    self._program.get_namespace('cpp')) + obj.name
            if obj.is_union:
                # Unlike structs, cpp1 unions have private members that the
                # read/write/size functions need to access. So instead of a
                # typedef, make a wrapper class that allows access to the
                # serialization functions
                with s.cls('class {0} : public{1}'.format(
                        obj.name, base)).scope as s1:
                    s1.label('public:')
                    s1('typedef{0} Base;'.format(base))
                    s1('{0}() : Base() {{}};'.format(obj.name))
                    s1('{0}(const {0}& rhs) : Base(rhs) {{}};'.format(
                        obj.name))
                    s1('{0}({0}&& rhs) : Base(rhs) {{}};'.format(obj.name))
                    s1('virtual ~{0}() throw() {{}}'.format(obj.name))
                    if read:
                        s1('template <class Protocol_>')
                        s1('friend uint32_t'
                            ' {0}_read(Protocol_* iprot, {0}* obj);'
                            .format(obj.name))
                    if write:
                        s1('template <class Protocol_>')
                        s1('friend uint32_t'
                            ' {0}_write(Protocol_* iprot, const {0}* obj);'
                            .format(obj.name))
                        for suffix in '', 'ZC':
                            s1('template <class Protocol_>')
                            s1('friend uint32_t {0}_serializedSize{1}'
                               '(Protocol_* iprot, const {0}* obj);'.format(
                                   obj.name, suffix))
            else:
                s('typedef{0} {1};'.format(base, obj.name))

            if read:
                self._generate_struct_reader(s, obj, pointers,
                                             has_isset=has_isset)
            if write:
                for zc in False, True:
                    self._generate_struct_compute_length(
                            s, obj, pointers, result, zero_copy=zc)
                self._generate_struct_writer(s, obj, pointers, result)
            return

        extends = ' : private boost::totally_ordered<{0}>'.format(obj.name)
        if is_exception:
            extends += ', public apache::thrift::TException'
        # Open struct def
        struct = s.cls('class {0}{1}'.format(obj.name, extends)).scope
        struct.acquire()
        struct.label('public:')
        # Get members
        members = filter(self._should_generate_field, obj.members)
        has_nonrequired_fields = any(member.req != e_req.required
                                        for member in members)
        struct_options = self._get_serialized_fields_options(obj)

        # Type enum for unions
        if obj.is_union:
            with struct('enum Type') as e:
                e('__EMPTY__ = 0,')
                i = 0
                for member in members:
                    i += 1
                    e('{0} = {1},'.format(member.name, i))
            struct.sameLine(';')

        if not pointers:
            # Default constructor
            i = OrderedDict()
            if not obj.is_union:
                for member in members:
                    value = self._member_default_value(member)
                    if value:
                        i[member.name] = value
                struct()
            else:
                i['type_'] = 'Type::__EMPTY__'
            c = struct.defn('{name}()', name=obj.name,
                                    in_header=True, init_dict=i).scope.empty()

            if not obj.is_union:
                # Generate a initializer_list type constructor
                init_vars = []
                init_vars.append('apache::thrift::FragileConstructor')
                for member in members:
                    t = self._get_true_type(member.type)
                    init_vars.append("{0} {1}".format(self._type_name(t),
                                                         member.name))
                i = OrderedDict()
                for member in members:
                    i[member.name] = 'std::move({name})'.format(
                        name=member.name)
                struct('// FragileConstructor for use in'
                       ' initialization lists only')
                c = struct.defn('{name}(' + ', '.join(init_vars) + ')',
                                name=obj.name,
                                in_header=True,
                                init_dict=i).scope.empty()

                is_copyable = self._is_copyable_struct(obj)
                # move constructor, move assignment, defaulted
                # (not implicitly declared because we have a destructor)
                if self._is_noex_move_ctor_struct(obj):
                    i = OrderedDict()
                    for member in members:
                        i[member.name] = 'std::move(other.{name})'.format(
                            name=member.name)
                    c = struct.defn('{name}({name}&& other)',
                                    name=obj.name,
                                    in_header=True,
                                    no_except=True,
                                    init_dict=i).scope.empty()
                else:
                    c = struct.defn('{name}({name}&&)',
                                    name=obj.name, in_header=True, default=True)
                if is_copyable:
                    c = struct.defn('{name}(const {name}&)',
                                    name=obj.name, in_header=True, default=True)
                c = struct.defn('{name}& operator=({name}&&)',
                                name=obj.name, in_header=True, default=True)
                if is_copyable:
                    c = struct.defn('{name}& operator=(const {name}&)',
                                    name=obj.name, in_header=True, default=True)
            else:
                # unions need to define the above constructors because of the
                # union member
                for op in False, True:
                    for mv in False, True:
                        self._gen_union_constructor(struct, obj, op, mv)

            if len(members) > 0:
                with struct.defn('void __clear()', in_header=True) as c:
                    if obj.is_union:
                        c('if (type_ == Type::__EMPTY__) { return; }')
                        self._gen_union_switch(c, members,
                            'destruct(value_.{field});')
                        c('type_ = Type::__EMPTY__;')
                    else:
                        for member in members:
                            t = self._get_true_type(member.type)
                            name = member.name + \
                                self._type_access_suffix(member.type)
                            if t.is_base_type or t.is_enum:
                                dval = self._member_default_value(
                                        member, explicit=True)
                                c('{0} = {1};'.format(name, dval))
                            elif t.is_struct or t.is_xception:
                                if len(member.type.as_struct.members) > 0:
                                    c('{0}.__clear();'.format(name))
                            elif t.is_container:
                                c('{0}.clear();'.format(name))
                            else:
                                raise TypeError('Unknown type for member:' +
                                                member.name)
                        if has_nonrequired_fields:
                            c('__isset.__clear();')
                        if struct_options.has_serialized_fields:
                            c('{0}.reset();'.format(
                                self._serialized_fields_name))

        # END if not pointers
        if 'final' not in obj.annotations:
            struct.defn('~{name}() throw()', name=obj.name,
                modifiers='virtual', in_header=True).scope.empty()
            struct()

        s1 = struct
        if obj.is_union:
            s1 = struct('union storage_type').scope
            s1.acquire()

        # Declare all fields.
        for member in members:
            s1(self._declare_field(member,
                pointers and not member.type.is_xception, not read))

        if s1 is not struct:
            s1()
            s1('storage_type() {}')
            s1('~storage_type() {}')
            s1.release()
            struct.sameLine(';')

        # Isset struct has boolean fields, but only for non-required fields
        if has_nonrequired_fields and \
                ((not pointers) or read) and not obj.is_union:
            struct()
            with struct.cls('struct __isset', epilogue=' __isset;') as ist:
                with ist.defn('__isset()', in_header=True) as s:
                    s('__clear();')
                with ist.defn('void __clear()', in_header=True) as c:
                    for member in members:
                        if member.req != e_req.required:
                            c("{0} = false;".format(member.name))
                # Declare boolean fields
                if has_nonrequired_fields:
                    ist()
                    for member in members:
                        if member.req != e_req.required:
                            ist('bool {0};'.format(member.name))
        if struct_options.has_serialized_fields:
            struct()
            struct('apache::thrift::ProtocolType {0};'.format(
                       self._serialized_fields_protocol_name))
            struct('{0} {1};'.format(self._serialized_fields_type,
                                     self._serialized_fields_name))
        if not pointers and not struct_options.has_serialized_fields:
            # Generate an equality testing operator. Make it inline since the
            # compiler will do a better job than we would when deciding whether
            # to inline it.

            with struct.defn('bool operator == (const {0}& {1}) const' \
              .format(obj.name, len(members) > 0 and 'rhs' or '/* rhs */'),
              in_header=True) as op:
                if obj.is_union:
                    op('if (type_ != rhs.type_) { return false; }')
                    self._gen_union_switch(op, members,
                        'return value_.{field} == rhs.value_.{field};',
                        default='return true;')
                else:
                    for m in members:
                        # Most existing Thrift code does not use isset or
                        # optional/required, so we treat "default" fields as
                        # required.
                        if m.req != e_req.optional:
                            with op('if (!({0} == rhs.{0}))'.format(
                                    m.name)) as x1:
                                x1('return false;')
                        else:
                            with op('if (__isset.{0} != rhs.__isset.{0})'
                                    .format(m.name)) as x1:
                                x1('return false;')
                            with op('else if'
                                    ' (__isset.{0} && !({0} == rhs.{0}))'
                                    .format(m.name)) as x1:
                                x1('return false;')
                    op('return true;')

            with struct.defn('bool operator != (const {0}& rhs) const'.format(
                             obj.name), in_header=True) as x1:
                x1('return !(*this == rhs);')

            # Generate the declaration of a less-than operator. This must be
            # implemented by the application developer if they wish to use it.
            # (They will get a link error if they try to use it without an
            # implementation.)i
            if self._is_orderable_type(obj) and \
              'no_default_comparators' not in obj.annotations:
                with struct.defn('bool operator < (const {0}& rhs) const'
                  .format(obj.name), in_header=True) as op:
                    if obj.is_union:
                        op('if (type_ != rhs.type_)'
                            ' { return type_ < rhs.type_; }')
                        self._gen_union_switch(op, members,
                            'return value_.{field} < rhs.value_.{field};',
                            default='return false;')
                    else:
                        for m in members:
                            with op('if (!({0} == rhs.{0}))'
                                    .format(m.name)) as x1:
                                x1('return {0} < rhs.{0};'.format(m.name))
                        op('return false;')
            else:
                struct('bool operator < (const {0}& rhs) const;'
                  .format(obj.name))

        # generate union accessors/settors
        if obj.is_union:
            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                with struct.defn('template<typename... T>\n'
                                 'void set_{name}(T&&... t)',
                                 in_header=True, name=member.name) as d:
                    d('__clear();')
                    d('type_ = Type::{0};'.format(member.name))
                    d('new (&value_.{0}) {1}(std::forward<T>(t)...);'.format(
                        member.name, t))

            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                with struct.defn('get_{name}() const', in_header=True,
                        name=member.name,
                        modifiers='const {0}&'.format(t)) as d:
                    d('assert(type_ == Type::{0});'.format(member.name))
                    d('return value_.{0};'.format(member.name))

            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                with struct.defn('move_{name}()', in_header=True,
                        name=member.name, modifiers=t) as d:
                    d('assert(type_ == Type::{0});'.format(member.name))
                    d('return std::move(value_.{0});'.format(member.name))

            struct()
            struct('Type getType() const { return type_; }')

        if read or write:
            struct()
        if read:
            self._generate_struct_reader(struct, obj, pointers)
        if write:
            for zc in False, True:
                self._generate_struct_compute_length(
                        struct, obj, pointers, result, zero_copy=zc)
            self._generate_struct_writer(struct, obj, pointers, result)
        if is_exception:
            if 'message' in obj.annotations:
                what = '{0}.c_str()'.format(obj.annotations['message'])
            else:
                what = '"{0}"'.format(self._type_name(obj))
            with struct.defn('virtual const char* what() const throw()',
                                   in_header=True) as x1:
                x1('return {0};'.format(what))

        # generate the union protected members
        if obj.is_union:
            struct.label('protected:')
            with struct.defn('template <class T>\n' + 'void destruct(T &val)',
                            in_header=True) as d:
                d('(&val)->~T();')
            struct()
            struct('Type type_;')
            struct('storage_type value_;')

        # we're done with the struct definition
        struct.release()

        if swap:
            s = self._types_scope
            # Generate a namespace-scope swap() function
            d = s.defn('void {{name}}({0}& a, {0}& b)'.format(obj.name),
                       name='swap').scope
            if obj.is_union:
                # For unions, the members cannot be swapped individually
                # so instead we use the logic in the copy constructors to
                # swap the object wholesale
                d('{0} temp = a;'.format(obj.name))
                d('a = std::move(b);')
                d('b = std::move(temp);')
            else:
                # Let argument-dependent name lookup find the correct swap()
                # function to use based on the argument types. If none is found
                # in the arguments' namespaces, fall back to ::std::swap().
                d('using ::std::swap;')
                has_nonrequired_fields = False
                for tfield in members:
                    ttype = self._get_true_type(tfield.type)
                    if tfield.req != e_req.required:
                        has_nonrequired_fields = True
                    d('swap(a.{0}, b.{0});'.format(tfield.name))
                if has_nonrequired_fields:
                    d('swap(a.__isset, b.__isset);')
                if struct_options.has_serialized_fields:
                    d('swap(a.{0}, b.{0});'.format(
                        self._serialized_fields_protocol_name))
                    d('swap(a.{0}, b.{0});'.format(
                        self._serialized_fields_name))
            d.release()

    # ======================================================================
    # DESERIALIZATION CODE
    # ======================================================================

    def _generate_struct_reader(self, scope, obj,
                                pointers=False, has_isset=True):
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_read'.format(obj.name)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* iprot, ' + obj.name +
                           '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\n'
                           'uint32_t {name}(Protocol_* iprot)', name='read',
                           output=self._out_tcc)
        if obj.is_union:
            has_isset = False
        fields = obj.members

        struct_options = self._get_serialized_fields_options(obj)
        # s = scope of the read() function
        s = d.scope
        # Declare stack tmp variables
        s('uint32_t xfer = 0;')
        s('std::string fname;')
        s('apache::thrift::protocol::TType ftype;')
        s('int16_t fid;')
        s()
        s('xfer += iprot->readStructBegin(fname);')
        s()
        s('using apache::thrift::TProtocolException;')
        s()
        # Special handling for serialized fields
        if struct_options.has_serialized_fields:
            s('{0}->{1} = Protocol_::protocolType();'.format(
                this, self._serialized_fields_protocol_name))
            s('std::unique_ptr<folly::IOBuf> serialized;')
        # Required variables aren't in __isset, so we need tmp vars to
        # check them.
        req_fields = ifilter(lambda field: field.req == e_req.required,
                             fields)
        for field in req_fields:
            s('bool isset_{0.name} = false;'.format(field))
        s()

        if obj.is_union:
            # Unions only have one member set, so don't loop
            s('xfer += iprot->readFieldBegin(fname, ftype, fid);')
            s1 = s('if (ftype == apache::thrift::protocol::T_STOP)').scope
            s1(this + '->__clear();')
            s1.release()
            s1 = s.sameLine('else').scope
        else:
            # Loop over reading in fields
            s1 = s('while (true)').scope
            # Save the position before the field beginning
            if struct_options.has_serialized_fields:
                s1('auto fbegin = iprot->getCurrentPosition();')
                s1('bool fserialized = false;')
            # Read beginning field marker
            s1('xfer += iprot->readFieldBegin(fname, ftype, fid);')
            # Check for field STOP marker
            with s1('if (ftype == apache::thrift::protocol::T_STOP)') as s2:
                s2('break;')

        # Switch statement on the field we are reading
        s2 = s1('switch (fid)').scope
        # Generate deserialization code for known cases
        for field in fields:
            if field.type.is_stream:
                continue

            s3 = s2.case(field.key).scope
            if ('format' in field.annotations and
                    field.annotations['format'] == 'serialized'):
                s3('fserialized = true;')
                s3('xfer += iprot->skip(ftype);')
                s3.release()  # "break;"
                continue
            s4 = s3('if (ftype == {0})'.format(self._type_to_enum(
                    field.type))).scope
            with s4:
                field_prefix = this + '->'
                if obj.is_union:
                    s4(field_prefix + 'set_{0}();'.format(field.name))
                    field_prefix += 'value_.'
                if pointers and not field.type.is_xception:
                    # This is only used for read pargs, so a const-cast is okay
                    # since the struct is exposed in generated code only.
                    self._generate_deserialize_field(
                        s4, field,
                        '(*const_cast<{0}*>('.format(
                                self._type_name(field.type)) +
                                                field_prefix, '))')
                else:
                    self._generate_deserialize_field(s4, field, field_prefix)
                if has_isset:
                    isset_prefix = (this + '->__isset.') if \
                        field.req != e_req.required else 'isset_'
                    s4('{0}{1} = true;'.format(isset_prefix, field.name))
            with s3.sameLine('else') as s4:
                s4('xfer += iprot->skip(ftype);')
                # TODO(dreiss): Make this an option when thrift structs have a
                # common base class.
                # s4('throw TProtocolException(TProtocolException::'
                #    'INVALID_DATA);')
            s3.release()  # "break;"
        # Default case
        with s2.case('default') as s3:
            s3('xfer += iprot->skip(ftype);')
            if struct_options.keep_unknown_fields:
                s3('fserialized = true;')
        s2.release()  # switch
        # Read field end marker
        s1('xfer += iprot->readFieldEnd();')
        if struct_options.has_serialized_fields:
            with s1('if (fserialized)').scope as s2:
                s2('iprot->readFromPositionAndAppend(fbegin, serialized);')
        s1.release()  # while(true)
        s('xfer += iprot->readStructEnd();')
        # Finalize serialized fields buffer if necessary
        if struct_options.has_serialized_fields:
            s()
            # Thrift is supposed to be called only with IOBuf that manage
            # underlying buffer. Thus it's safe to store IOBuf pointing to the
            # parts of original buffer inside the deserialized struct.
            # Note: it might be somewhat memory inefficient as we might be
            # pointing to a small chunk of the big buffer while keeping the
            # entire buffer around. However, the current implementation leaves
            # it to the application to call coalesce() on __serialized field
            # if necessary.
            with s('if (serialized)') as s1:
                s(('{0}->{1} = std::move(serialized);').format(
                       this, self._serialized_fields_name))
        # Throw if any required fields are missing.
        # We do this after reading the struct end so that there might possibly
        # be a chance of continuing.
        s()
        for field in filter(self._should_generate_field, fields):
            if not field.req == e_req.required:
                continue
            with s('if (!isset_{0.name})'.format(field)) as s1:
                s1('throw TProtocolException(TProtocolException::'
                   'MISSING_REQUIRED_FIELD);')
        s('return xfer;')
        s.release()  # the function

    def _generate_deserialize_field(self, scope, field, prefix='', suffix=''):
        'Deserializes a field of any type.'
        ttype = self._get_true_type(field.type)
        name = prefix + field.name + self._type_access_suffix(field.type) + \
                suffix
        self._generate_deserialize_type(scope, ttype, name)

    def _generate_deserialize_type(self, scope, ttype, name):
        'Deserializes a variable of any type.'

        s = scope
        if ttype.is_void:
            raise TypeError('CANNOT GENERATE DESERIALIZE CODE FOR void TYPE: '\
                            + name)
        if ttype.is_struct or ttype.is_xception:
            self._generate_deserialize_struct(scope, ttype.as_struct, name)
        elif ttype.is_container:
            self._generate_deserialize_container(scope, ttype.as_container,
                                                 name)
        elif ttype.is_base_type:
            btype = ttype.as_base_type
            base = btype.base
            if base == t_base.void:
                raise CompilerError("Cannot deserialize void field in a "
                    "struct: " + name)
            elif base == t_base.string:
                if btype.is_binary:
                    txt = 'readBinary({0})'
                else:
                    txt = 'readString({0})'
            elif base == t_base.bool:
                txt = 'readBool({0})'
            elif base == t_base.byte:
                txt = 'readByte({0})'
            elif base == t_base.i16:
                txt = 'readI16({0})'
            elif base == t_base.i32:
                txt = 'readI32({0})'
            elif base == t_base.i64:
                txt = 'readI64({0})'
            elif base == t_base.double:
                txt = 'readDouble({0})'
            elif base == t_base.float:
                txt = 'readFloat({0})'
            else:
                raise CompilerError('No C++ reader for base type ' + \
                        btype.t_base_name(base) + name)
            txt = 'xfer += iprot->{0};'.format(txt.format(name))
            s(txt)
        elif ttype.is_enum:
            t = self.tmp('ecast')
            s('int32_t {0};'.format(t))
            s('xfer += iprot->readI32({0});'.format(t))
            s('{0} = ({1}){2};'.format(name, self._type_name(ttype), t))
        elif ttype.is_stream:
            raise TypeError('CANNOT GENERATE DESERIALIZE CODE FOR stream TYPE: '
                            + name)
        else:
            raise TypeError(("DO NOT KNOW HOW TO DESERIALIZE '{0}' "
                             "TYPE {1}").format(name, self._type_name(ttype)))

    def _generate_deserialize_struct(self, scope, struct, prefix):
        scope('xfer += ::apache::thrift::Cpp2Ops< {0}>::read('
              'iprot, &{1});'.format(
                  self._type_name(struct),
                  prefix))

    def _generate_deserialize_container(self, scope, cont, prefix):
        s = scope
        size = self.tmp('_size')
        ktype = self.tmp('_ktype')
        vtype = self.tmp('_vtype')
        etype = self.tmp('_etype')
        use_push = bool(self._cpp_type_name(cont)) \
            or self._has_cpp_annotation(cont, 'template')
        s(prefix + '.clear();')
        s('uint32_t {0};'.format(size))
        # Declare variables, read header
        if cont.is_map:
            s('apache::thrift::protocol::TType {0};'.format(ktype))
            s('apache::thrift::protocol::TType {0};'.format(vtype))
            s('xfer += iprot->readMapBegin({0}, {1}, {2});'.format(
                ktype, vtype, size))
            if cont.as_map.is_unordered:
                s('{0}.reserve({1});'.format(prefix, size))
        elif cont.is_set:
            s('apache::thrift::protocol::TType {0};'.format(etype))
            s('xfer += iprot->readSetBegin({0}, {1});'.format(etype, size))
        elif cont.is_list:
            s('apache::thrift::protocol::TType {0};'.format(etype))
            txt = 'xfer += iprot->readListBegin({0}, {1});'.format(etype, size)
            s(txt)
            if not use_push:
                s('{0}.resize({1});'.format(prefix, size))
        # For loop iterates over elements
        i = self.tmp('_i')
        s('uint32_t {0};'.format(i))
        with s('for ({0} = 0; {0} < {1}; ++{0})'.format(i, size)) as s1:
            if cont.is_map:
                self._generate_deserialize_map_element(s1, cont.as_map, prefix)
            elif cont.is_set:
                self._generate_deserialize_set_element(s1, cont.as_set, prefix)
            elif cont.is_list:
                self._generate_deserialize_list_element(s1, cont.as_list,
                                                        prefix, use_push, i)
        # Read container end
        if cont.is_map:
            s('xfer += iprot->readMapEnd();')
        elif cont.is_set:
            s('xfer += iprot->readSetEnd();')
        elif cont.is_list:
            s('xfer += iprot->readListEnd();')

    def _generate_deserialize_map_element(self, scope, tmap, prefix):
        'Generates code to deserialize a map'
        key = self.tmp('_key')
        val = self.tmp('_val')
        fkey = frontend.t_field(tmap.key_type, key)
        fval = frontend.t_field(tmap.value_type, val)
        scope(self._declare_field(fkey))
        self._generate_deserialize_field(scope, fkey)
        txt = '{0} = {1}[{2}];'.format(
            self._declare_field(fval, reference=True), prefix, key)
        scope(txt)
        self._generate_deserialize_field(scope, fval)

    def _generate_deserialize_set_element(self, scope, tset, prefix):
        elem = self.tmp('_elem')
        felem = frontend.t_field(tset.elem_type, elem)
        scope(self._declare_field(felem))
        self._generate_deserialize_field(scope, felem)
        scope('{0}.insert({1});'.format(prefix, elem))

    def _generate_deserialize_list_element(self, scope, tlist, prefix,
                                           use_push, index):
        if use_push:
            elem = self.tmp('_elem')
            felem = frontend.t_field(tlist.elem_type, elem)
            scope(self._declare_field(felem))
            self._generate_deserialize_field(scope, felem)
            scope('{0}.push_back({1});'.format(prefix, elem))
        else:
            felem = frontend.t_field(tlist.elem_type, '{0}[{1}]'.format(prefix,
                                                                        index))
            self._generate_deserialize_field(scope, felem)

    # ======================================================================
    # SERIALIZATION CODE
    # ======================================================================

    def _generate_struct_compute_length(self, scope, obj,
                                        pointers=False,
                                        result=False,
                                        zero_copy=False):
        method = "serializedSizeZC" if zero_copy else "serializedSize"
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_{1}'.format(obj.name, method)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* prot_, const ' +
                           obj.name + '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\n'
                        'uint32_t {name}(Protocol_* prot_) const',
                        name=method,
                        output=self._out_tcc)

        struct_options = self._get_serialized_fields_options(obj)

        s = d.scope
        if struct_options.has_serialized_fields:
            with s('if ({0}->{1} && '
                    'Protocol_::protocolType() != {0}->{2})'.format(
                        this,
                        self._serialized_fields_name,
                        self._serialized_fields_protocol_name)).scope as s1:
                s1('using apache::thrift::TProtocolException;')
                s1('throw TProtocolException(TProtocolException::BAD_VERSION);')
        s('uint32_t xfer = 0;')
        s('xfer += prot_->serializedStructSize("{0}");'.format(obj.name))

        # unions need a case statement to select which member is active
        s0 = s
        if obj.is_union:
            s = s0('switch({0}->getType())'.format(this)).scope

        first = True
        for field in filter(self._should_generate_field, obj.members):
            if result == True:
                if first:
                    first = False
                    s1 = s('if (' + this + '->__isset.{0})'.format(
                            field.name)).scope
                else:
                    s1 = s('else if (' + this + '->__isset.{0})'.format(
                            field.name)).scope
            elif field.req == e_req.optional:
                s1 = s('if (' + this + '->__isset.{0})'.format(
                        field.name)).scope

            elif self.flag_terse_writes and not field.req == e_req.required:
                s1 = self._try_terse_write(field, this, s, pointers)
            elif obj.is_union:
                s1 = s.case(obj.name + '::Type::' + field.name).scope
            else:
                s1 = s
            # Add the size of field header + footer
            s1('xfer += prot_->serializedFieldSize("{0}", {1}, {2});'
               ''.format(field.name, self._type_to_enum(field.type),
                                field.key))
            # Add the sizes of field contents
            field_prefix = this + '->'
            if obj.is_union:
                field_prefix += 'value_.'
            if pointers and not field.type.is_xception:
                self._generate_serialize_field(
                    s1, field,
                    '(*const_cast<{0}*>('.format(
                            self._type_name(field.type)) + field_prefix, '))',
                    method="serializedSize",
                    struct_method=method,
                    binary_method=method)
            else:
                self._generate_serialize_field(s1, field, field_prefix,
                                               method="serializedSize",
                                               struct_method=method,
                                               binary_method=method)
            if s1 is not s:
                s1.release()  # if this->__isset.{0}
        if s0 is not s:
            s('case ' + obj.name + '::Type::__EMPTY__:;')
            s.release()
            s = s0

        if struct_options.has_serialized_fields:
            s('xfer += prot_->serializedSizeSerializedData({0}->{1});'
                    .format(this, self._serialized_fields_name))
        s('xfer += prot_->serializedSizeStop();')
        s('return xfer;')
        s.release()

    def _try_terse_write(self, field, this, s, pointers):
        'Generates a terse write predicate for unspecified field, if possible'
        t = self._get_true_type(field.type)
        # Not possible for void/struct/exception.
        if t.is_void or t.is_struct or t.is_xception:
            return s

        # Terse write is unsafe to use without explicitly setting default
        # value as in PHP / Python that would change result of deserialization
        # (comparing with the case when terse_writes is not used): field set
        # in C++ to default value would be deserialized as null / None.
        if self.safe_terse_writes and field.value is None:
            return s

        cmpval = (('(*' + this + '->{0})') if pointers else
                  ('' + this + '->{0}')).format(field.name)

        # For strings, containers - only support predicate if default
        # value is empty.
        if t.is_string:
            if not field.value or len(field.value.string) == 0:
                return s('if (!apache::thrift::StringTraits< {0}>::'
                         'isEmpty({1}))'.format(
                             self._type_name(t), cmpval)).scope
            else:
                return s

        if t.is_container:
            if not field.value:  # only support empty default.
                return s('if (!{0}.empty())'.format(cmpval)).scope
            else:
                return s  # Otherwise, no terse_write possible

        # For base type/enum, check vs. default const value.
        if t.is_base_type or t.is_enum:
            return s('if ({0} != {1})'.format(
                    cmpval, self._member_default_value(field,
                                                       explicit=True))).scope
        return s

    def _generate_struct_writer(self, scope, obj, pointers=False,
                                result=False):
        'Generates the write function.'
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_write'.format(obj.name)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* prot_, const ' +
                           obj.name + '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\nuint32_t {name}'
                           '(Protocol_* prot_) const', name='write',
                           output=self._out_tcc)
        s = d.scope
        name = obj.name
        fields = filter(self._should_generate_field, obj.members)

        struct_options = self._get_serialized_fields_options(obj)

        if struct_options.has_serialized_fields:
            with s('if ({0}->{1} && '
                    'Protocol_::protocolType() != {0}->{2})'.format(
                        this,
                        self._serialized_fields_name,
                        self._serialized_fields_protocol_name)).scope as s1:
                s1('using apache::thrift::TProtocolException;')
                s1('throw TProtocolException(TProtocolException::BAD_VERSION);')

        s('uint32_t xfer = 0;')
        s('xfer += prot_->writeStructBegin("{0}");'.format(name))

        # unions need a case statement to select which member is active
        s0 = s
        if obj.is_union:
            s = s0('switch({0}->getType())'.format(this)).scope

        first = True
        for field in fields:
            if result == True:
                if first:
                    first = False
                    s1 = s('if (' + this + '->__isset.{0})'.format(
                            field.name)).scope
                else:
                    s1 = s('else if (' + this + '->__isset.{0})'.format(
                            field.name)).scope
            elif field.req == e_req.optional:
                s1 = s('if (' + this + '->__isset.{0})'.format(
                        field.name)).scope
            elif self.flag_terse_writes and not field.req == e_req.required:
                s1 = self._try_terse_write(field, this, s, pointers)
            elif obj.is_union:
                s1 = s.case(obj.name + '::Type::' + field.name).scope
            else:
                s1 = s
            # Write field header
            s1('xfer += prot_->writeFieldBegin("{0}", {1}, {2});'.format(
                field.name, self._type_to_enum(field.type), field.key))
            # Write field contents
            field_prefix = this + '->'
            if obj.is_union:
                field_prefix += 'value_.'
            if pointers and not field.type.is_xception:
                self._generate_serialize_field(
                    s1, field, '(*const_cast<{0}*>('.format(
                            self._type_name(field.type)) + field_prefix,
                    '))')
            else:
                self._generate_serialize_field(s1, field, field_prefix)
            # Write field closer
            s1('xfer += prot_->writeFieldEnd();')
            if s1 is not s:
                s1.release()  # if this->_isset.{0}
        if s0 is not s:
            s('case ' + obj.name + '::Type::__EMPTY__:;')
            s.release()
            s = s0
        # Flush any fields stored in serialized form
        if struct_options.has_serialized_fields:
            s('xfer += prot_->writeSerializedData({0}->{1});'.format(
                this, self._serialized_fields_name))
        # Write the struct map
        s('xfer += prot_->writeFieldStop();')
        s('xfer += prot_->writeStructEnd();')
        s('return xfer;')
        s.release()  # the function

    def _generate_serialize_field(self, scope, tfield, prefix='', suffix='',
                                  method='write',
                                  struct_method=None,
                                  binary_method=None):
        'Serializes a field of any type.'
        ttype = self._get_true_type(tfield.type)
        name = prefix + tfield.name + self._type_access_suffix(tfield.type) + \
                suffix
        self._generate_serialize_type(scope, ttype, name, method,
                                      struct_method, binary_method)

    def _generate_serialize_type(self, scope, ttype, name,
                                 method='write',
                                 struct_method=None,
                                 binary_method=None):
        'Serializes a variable of any type.'
        if struct_method is None:
            struct_method = method
        if binary_method is None:
            binary_method = method

        # Do nothing for void types
        if ttype.is_void:
            raise TypeError('CANNOT GENERATE SERIALIZE CODE FOR void TYPE: '\
                            + name)
        if ttype.is_struct or ttype.is_xception:
            self._generate_serialize_struct(scope, ttype.as_struct, name,
                                            struct_method)
        elif ttype.is_container:
            self._generate_serialize_container(scope, ttype.as_container,
                                               name,
                                               method,
                                               struct_method=struct_method,
                                               binary_method=binary_method)
        elif ttype.is_base_type:
            btype = ttype.as_base_type
            base = btype.base
            if base == t_base.void:
                raise CompilerError('Cannot serialize void field in a '
                                    'struct: ' + name)
            elif base == t_base.string:
                if btype.is_binary:
                    txt = '{binary_method}Binary({name});'
                else:
                    txt = '{method}String({name});'
            elif base == t_base.bool:
                txt = '{method}Bool({name});'
            elif base == t_base.byte:
                txt = '{method}Byte({name});'
            elif base == t_base.i16:
                txt = '{method}I16({name});'
            elif base == t_base.i32:
                txt = '{method}I32({name});'
            elif base == t_base.i64:
                txt = '{method}I64({name});'
            elif base == t_base.double:
                txt = '{method}Double({name});'
            elif base == t_base.float:
                txt = '{method}Float({name});'
            else:
                raise CompilerError('No C++ writer for base type ' + \
                        btype.t_base_name(base) + name)
            txt = 'xfer += prot_->' + txt.format(name, **locals())
            scope(txt)
        elif ttype.is_enum:
            scope('xfer += prot_->{0}I32((int32_t){1});'.format(method, name))
        elif ttype.is_stream:
            raise TypeError('CANNOT GENERATE SERIALIZE CODE FOR stream TYPE: '
                            + name)
        else:
            raise TypeError(("DO NOT KNOW HOW TO SERIALIZE '{0}' "
                             "TYPE {1}").format(name, self._type_name(ttype)))

    def _generate_serialize_struct(self, scope, tstruct, prefix='',
                                   method='write'):
        scope('xfer += ::apache::thrift::Cpp2Ops< {0}>::{1}('
              'prot_, &{2});'.format(
                  self._type_name(tstruct),
                  method,
                  prefix))

    def _generate_serialize_container(self, scope, ttype, prefix='',
                                      method='write', **kwargs):
        tte = self._type_to_enum
        s = scope
        if ttype.is_map:
            s('xfer += prot_->{0}MapBegin({1}, {2}, {3}.size());'.format(
                    method,
                    tte(ttype.as_map.key_type),
                    tte(ttype.as_map.value_type),
                    prefix))
        elif ttype.is_set:
            s('xfer += prot_->{0}SetBegin({1}, {2}.size());'.format(
                    method,
                    tte(ttype.as_set.elem_type),
                    prefix))
        elif ttype.is_list:
            s('xfer += prot_->{0}ListBegin({1}, {2}.size());'.format(
                    method,
                    tte(ttype.as_list.elem_type),
                    prefix))
        ite = self.tmp('_iter')
        typename = self._type_name(ttype)
        with s('for (auto {0} = {1}.begin(); {0} != {1}.end(); ++{0})'.format(
                ite, prefix)) as s1:
            if ttype.is_map:
                self._generate_serialize_map_element(s1, ttype.as_map,
                                                     ite, method, **kwargs)
            elif ttype.is_set:
                self._generate_serialize_set_element(s1, ttype.as_set,
                                                     ite, method, **kwargs)
            elif ttype.is_list:
                self._generate_serialize_list_element(s1, ttype.as_list,
                                                      ite, method, **kwargs)
        if ttype.is_map:
            s('xfer += prot_->{0}MapEnd();'.format(method))
        elif ttype.is_set:
            s('xfer += prot_->{0}SetEnd();'.format(method))
        elif ttype.is_list:
            s('xfer += prot_->{0}ListEnd();'.format(method))

    def _generate_serialize_map_element(self, scope, tmap, iter_,
                                        method='write', **kwargs):
        kfield = frontend.t_field(tmap.key_type, iter_ + '->first')
        self._generate_serialize_field(scope, kfield, method=method, **kwargs)
        vfield = frontend.t_field(tmap.value_type, iter_ + '->second')
        self._generate_serialize_field(scope, vfield, method=method, **kwargs)

    def _generate_serialize_set_element(self, scope, tset, iter_,
                                        method='write', **kwargs):
        efield = frontend.t_field(tset.elem_type, "(*{0})".format(iter_))
        self._generate_serialize_field(scope, efield, method=method, **kwargs)

    def _generate_serialize_list_element(self, scope, tlist, iter_,
                                         method='write', **kwargs):
        efield = frontend.t_field(tlist.elem_type, "(*{0})".format(iter_))
        self._generate_serialize_field(scope, efield, method=method, **kwargs)

    # ======================================================================
    # GENERATE STRUCT
    # ======================================================================

    def _generate_cpp2ops(self, compat, obj, scope):
        ns = self._namespace_prefix(self._get_namespace())
        if self.flag_compatibility and compat:
            compat_ns = self._namespace_prefix(
                self._program.get_namespace('cpp'))
        else:
            compat_ns = ns
        compat_full_name = compat_ns + obj.name
        full_name = ns + obj.name

        ops = (('write', True),
               ('read', False),
               ('serializedSize', True),
               ('serializedSizeZC', True))

        for method, is_const in ops:
            const = 'const' if is_const else ''
            with scope.defn(
                ('template <> template <class Protocol> inline '
                 'uint32_t Cpp2Ops<{compat_full_name}>::{method}('
                 'Protocol* proto, {const} {full_name}* obj)'.
                 format(**locals())),
                name=method,
                in_header=True
            ) as f:
                if self.flag_compatibility:
                    f(('return {full_name}_{method}(proto, obj);'.
                      format(**locals())))
                else:
                    f('return obj->{method}(proto);'.format(**locals()))

    def _generate_cpp_struct(self, obj, is_exception=False):
        # We write all of these to the types scope
        scope = self._types_scope
        self._generate_struct_complete(scope, obj, is_exception,
                                       False, True, True, True, False)

        # We're at types scope now
        scope.release()
        scope = self._types_global.namespace('apache.thrift').scope

        scope.acquire()

        self._generate_cpp2ops(False, obj, self._types_scope)

        scope.release()

        # Re-enter types scope, but we can't actually re-enter a scope,
        # so let's recreate it
        scope = self._types_scope = \
                scope.namespace(self._get_namespace()).scope
        scope.acquire()


    def _generate_object(self, obj):
        if obj.is_xception:
            self._generate_cpp_struct(obj, True)
        else:
            self._generate_cpp_struct(obj)

    _generate_map = {
        frontend.t_typedef: _generate_typedef,
        frontend.t_enum: _generate_enum,
        frontend.t_struct: _generate_object,
        frontend.t_service: _generate_service,
    }

    def _generate(self, what):
        '''This uses a class-static map of (parse_type -> function that
        generates that kind of object), defined above.'''
        # TODO This feels a little hackish. Maybe change this into individual
        # per-type functions, and also change t_generator.generate_program() to
        # call those functions instead of only _generate().
        try:
            gen_func = self._generate_map[what.__class__]
            gen_func(self, what)
        except KeyError:
            print "Warning: Did not generate " + str(what)

    def _render_const_value(self, type_, value, explicit=False):
        ''' Returns an initializer list rval representing this const
        '''
        t = self._get_true_type(type_)
        if t.is_base_type:
            int32 = lambda x: str(x.integer)
            int64 = lambda x: str(x.integer) + "LL"

            bt = t.as_base_type
            mapping = {
                t_base.string: lambda x:
                ('apache::thrift::StringTraits< {0}>::fromStringLiteral(' +
                 '"{1}")').format(self._type_name(t), x.string),
                t_base.bool: lambda x: (x.integer > 0 and 'true' or 'false'),
                t_base.byte: lambda x: ("(int8_t)" + str(x.integer)),
                t_base.i16: lambda x: ("(int16_t)" + str(x.integer)),
                t_base.i32: int32,
                t_base.i64: int64,
                t_base.double:
                    lambda x: (x.type == e_cv_type.integer
                                 and str(x.integer)
                                 or str(x.double)),
                t_base.float:
                    lambda x: (x.type == e_cv_type.integer
                                 and str(x.integer)
                                 or str(x.double))
            }
            if not bt.base in mapping:
                # TODO replace bt.t_base_name(bt.base) with bt.base.LABEL
                # However, (afaik) boost::python apparently doesn't support
                # reverse label lookups for enums
                raise CompilerError("No const of base type " + \
                                    bt.t_base_name(bt.base))
            return mapping[bt.base](value)
        elif t.is_enum:
            return '{0}::{1}'.format(self._type_name(t),
                                    t.find_value(value.integer).name)
        elif t.is_struct or t.is_xception:
            value_map = {}
            for k, v in value.map.items():
                value_map[k.string] = v
            if not value_map:
                return '{0}()'.format(self._type_name(t)) if explicit else None
            fields = filter(self._should_generate_field, t.as_struct.members)
            out_list = ['apache::thrift::FRAGILE']
            for field in fields:
                if field.name in value_map:
                    val = self._render_const_value(field.type,
                                                   value_map[field.name],
                                                   explicit=True)
                else:
                    val = self._member_default_value(field, explicit=True)
                out_list.append(val or "")
            return '{0}({1})'.format(self._type_name(t), ', '.join(out_list))
        elif t.is_map:
            outlist = []
            for key, value in value.map.items():
                key_render = self._render_const_value(t.key_type, key,
                                                      explicit=True)
                value_render = self._render_const_value(t.value_type, value,
                                                        explicit=True)
                outlist.append('{{{0}, {1}}}'.format(key_render, value_render))
            if not outlist:
                return '{}' if explicit else None
            return '{' + ', '.join(outlist) + '}'
        elif t.is_list:
            outlist = []
            for item in value.list:
                field_render = self._render_const_value(
                    t.as_list.elem_type, item, explicit=True)
                outlist.append(field_render)
            if not outlist:
                return '{}' if explicit else None
            return 'std::initializer_list<' + \
                self._type_name(t.as_list.elem_type) + '>{' + \
                ', '.join(outlist) + '}'
        elif t.is_set:
            outlist = []
            for item in value.list:
                field_render = self._render_const_value(t.as_set.elem_type,
                                                        item, explicit=True)
                outlist.append(field_render)
            if not outlist:
                return '{}' if explicit else None
            return 'std::initializer_list<' + \
                self._type_name(t.as_set.elem_type) + '>{' + \
                ', '.join(outlist) + '}'
        else:
            raise TypeError('INVALID TYPE IN print_const_definition: ' + t.name)

    def _generate_consts(self, constants):
        name = self._program.name
        # build the const scope
        context = self._make_context(self._program.name + '_constants')
        sg = get_global_scope(CppPrimitiveFactory, context)
        # Include the types header
        sg('#include "{0}"'.format(self._with_include_prefix(self._program,
            self._program.name + '_types.h')))
        # Include the thrift1 constants for compatibility mode
        if self.flag_compatibility:
            sg('#include "{0}_constants.h"'
                .format(self._with_compatibility_include_prefix(self._program,
                                                                name)))
        # Open namespace
        sns = sg.namespace(self._get_namespace()).scope
        if self.flag_compatibility:
            instance_name = 'g_' + self._program.name + '_constants'
            cpp1_namespace = self._namespace_prefix(
                self._program.get_namespace('cpp')).lstrip()
            sns('using ' + cpp1_namespace + instance_name + ';')
            sns.release()
            sg.release()
            return
        s = sns.cls('class {0}Constants'.format(name)).scope
        s.label('public:')
        # Default constructor
        init_dict = OrderedDict()
        for c in constants:
            value = self._render_const_value(c.type, c.value)
            if value:
                init_dict[c.name] = value
        s.defn('{name}()', name=name + 'Constants', init_dict=init_dict,
               in_header=True).scope.empty()
        # Define the fields that hold the constants
        for c in constants:
            s()
            s('{0} {1};'.format(self._type_name(c.type), c.name))
        # define global constants singleton
        s.release()
        sns.extern('const {0}Constants g_{0}_constants'.format(name))
        sns.release()  # namespace
        sg.release()   # global scope

    def _make_context(self, filename, tcc=False):
        'Convenience method to get the context and outputs for some file pair'
        # open files and instantiate outputs
        output_h = self._write_to(filename + '.h')
        output_impl = self._write_to(filename + '.cpp')
        header_path = self._with_include_prefix(self._program, filename + '.h')
        if tcc:
            output_tcc = self._write_to(filename + '.tcc')
            tcc_path = self._with_include_prefix(
                self._program, filename + ".tcc")
            tcc_stuff = output_tcc, tcc_path
        else:
            tcc_stuff = ()

        context = CppOutputContext(output_impl, output_h, header_path,
                                   *tcc_stuff)

        print >>context.outputs, self._autogen_comment
        return context

    @property
    def out_dir(self):
        return os.path.join(self._program.out_path, self._out_dir_base)

    def in_out_dir(self, filename):
        return os.path.join(self.out_dir, filename)

    # TODO add out_dir(self, program) as well?

    def _include_prefix(self, program, dir_base):
        #assert isinstance(program, frontend.t_program)
        ip = program.include_prefix
        if not self.flag_include_prefix or ip.startswith('/'):
            return ""
        if '/' in ip:
            ip = os.path.dirname(ip)
            return os.path.join(ip, dir_base)
        return ""

    def _compatibility_include_prefix(self, program):
        return self._include_prefix(program, self._compatibility_dir_base)

    def _out_include_prefix(self, program):
        return self._include_prefix(program, self._out_dir_base)

    def _with_compatibility_include_prefix(self, program, *args):
        return os.path.join(self._compatibility_include_prefix(program), *args)

    def _with_include_prefix(self, program, *args):
        return os.path.join(self._out_include_prefix(program), *args)

    def _write_to(self, to):
        return IndentedOutput(open(self.in_out_dir(to), 'w'))

    def init_generator(self):
        name = self._program.name
        # Make output directory
        try:
            os.mkdir(self.out_dir)
        except OSError as exc:
            if exc.errno == errno.EEXIST and os.path.isdir(self.out_dir):
                pass
            else:
                raise

        self._const_scope = None

        # open files and instantiate outputs for types
        context = self._make_context(name + '_types', True)
        s = self._types_global = get_global_scope(CppPrimitiveFactory, context)
        self._types_out_impl = types_out_impl = context.impl
        self._types_out_h = types_out_h = context.h
        self._out_tcc = types_out_tcc = context.tcc
        # Enter the scope (prints guard)
        s.acquire()
        # Include base types
        s('#include "thrift/lib/cpp2/Thrift.h"')
        s('#include "thrift/lib/cpp2/protocol/Protocol.h"')
        s('#include "thrift/lib/cpp/protocol/TProtocol.h"')
        if not self.flag_bootstrap:
            s('#include "thrift/lib/cpp/TApplicationException.h"')
        s('#include "folly/io/IOBuf.h"')
        s('#include "folly/io/Cursor.h"')
        s('#include <boost/operators.hpp>')
        s()
        if self.flag_compatibility:
            # Transform the cpp2 include prefix path into a cpp prefix path.
            s('#include "{0}_types.h"'
              .format(self._with_compatibility_include_prefix(self._program,
                                                              name)))
        # Include other Thrift includes
        for inc in self._program.includes:
            s('#include "{0}_types.h"' \
              .format(self._with_include_prefix(inc, inc.name)))
            print >>types_out_tcc, '#include "{0}_types.tcc"'.format(
                self._with_include_prefix(inc, inc.name))
        print >>types_out_tcc
        s()
        # Include custom headers
        for inc in self._program.cpp_includes:
            if inc.startswith('<'):
                s('#include {0}'.format(inc))
            else:
                s('#include "{0}"'.format(inc))
        s()
        # The swap() code needs <algorithm> for std::swap()
        print >>types_out_impl, '#include <algorithm>\n'

        # using directives
        s()

        # Open namespace
        s = self._types_scope = \
                s.namespace(self._get_namespace()).scope
        s.acquire()

    def close_generator(self):
        # make sure that the main types namespace is closed
        self._types_scope.release()

        # Include the types.tcc file from the types header file,
        # so clients don't have to explicitly include the tcc file.
        # TODO(simpkins): Make this a separate option.
        s = self._types_global
        s()
        s('#include "{0}_types.tcc"'.format(
                self._with_include_prefix(self._program, self._program.name)))
        self._types_global.release()

    def _generate_comment(self, text, style='auto'):
        'Style = block, line or auto'
        lines = text.split('\n')
        if style == 'auto':
            style = len(lines) > 1 and 'block' or 'line'
        if style == 'block':
            return '\n'.join(chain(('/**',), \
                    (' * {0}'.format(line) for line in lines),
                    (' */',)))
        elif style == 'line':
            return '\n'.join('// {0}'.format(line) for line in lines)
        else:
            raise NotImplementedError

    def _is_processed_in_eb(self, function):
        if self.flag_future or self._function_uses_streams(function):
            return True
        if function.annotations is not None and \
          'thread' in function.annotations.annotations:
            return function.annotations.annotations['thread'] == 'eb'
        return self.flag_process_in_event_base

# register the generator factory
t_generator.GeneratorFactory(CppGenerator)
