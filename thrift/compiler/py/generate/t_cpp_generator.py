#!/usr/local/bin/python2.6 -tt
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from cStringIO import StringIO
from itertools import chain, ifilter
from collections import namedtuple
import copy
import errno
import os
import re
import sys

from thrift_compiler import frontend
# Easy access to the enum of t_base_type::t_base
from thrift_compiler.frontend import t_base
# Easy access to the enum of t_field::e_req
from thrift_compiler.frontend import e_req
# Easy access to the enum of t_const_value::t_const_value_type
from thrift_compiler.frontend import e_const_value_type as e_cv_type

from thrift_compiler.generate import t_generator

from thrift_compiler.generate.t_cpp_context import *
from thrift_compiler.generate.t_output_aggregator import get_global_scope
from thrift_compiler.generate.t_output_aggregator import out
from thrift_compiler.generate.t_output import IndentedOutput

# TODO move from here
class OrderedDict(dict):
    def __init__(self, *a, **b):
        dict.__init__(self, *a, **b)
        self._order = []

    def __setitem__(self, index, item):
        dict.__setitem__(self, index, item)
        self._order.append(index)

    def iteritems(self):
        return ((key, self[key]) for key in self._order)

# Same as map.get, but works for almost-dictionary-like types
# (like the ones generated by boost.python)
def _map_get(map, key, default=None):
    return map[key] if key in map else default

# ---------------------------------------------------------------
# Generator
# ---------------------------------------------------------------

class CompilerError(RuntimeError):
    pass

SerializedFieldOptions = namedtuple('SerializedFieldOptions',
        ['has_serialized_fields', 'keep_unknown_fields'])

class CppGenerator(t_generator.Generator):
    '''
    Plain ol' c++ generator
    Note: this is NOT legitimacy incarnate
    '''

    # Protocols to generate client/server code for.
    protocols = [("binary", "BinaryProtocol", "T_BINARY_PROTOCOL"),
                 ("compact", "CompactProtocol", "T_COMPACT_PROTOCOL")]
    short_name = 'cpp2'
    long_name = 'C++ version 2'
    supported_flags = {
        'include_prefix': 'Use full include paths in generated files.',
        'cob_style': '',
        'no_client_completion': '',
        'bootstrap': '',
        'compatibility': 'Use thrift1 structs instead of generating new ones',
        'terse_writes': 'Avoid emitting unspec fields whose values are default',
        'stack_arguments': 'Pass arguments on stack instead of heap',
        'process_in_event_base': 'Process request in event base thread',
        'frozen2': 'enable frozen structures',
        'json': 'enable simple json protocol',
        'implicit_templates' : 'templates are instantiated implicitly' +
                               'instead of explicitly',
    }
    _out_dir_base = 'gen-cpp2'
    _compatibility_dir_base = 'gen-cpp'

    _base_to_cpp_typename = {
        t_base.void: 'void',
        t_base.string: 'std::string',
        t_base.bool: 'bool',
        t_base.byte: 'int8_t',
        t_base.i16: 'int16_t',
        t_base.i32: 'int32_t',
        t_base.i64: 'int64_t',
        t_base.double: 'double',
        t_base.float: 'float',
    }

    _serialized_fields_name = '__serialized'
    _serialized_fields_type = 'apache::thrift::CloneableIOBuf'
    _serialized_fields_protocol_name = '__serialized_protocol'

    def __init__(self, *args, **kwargs):
        # super constructor
        t_generator.Generator.__init__(self, *args, **kwargs)
        prefix = self._flags.get('include_prefix')
        if isinstance(prefix, basestring):
            self.program.include_prefix = prefix
        terse_writes = self._flags.get('terse_writes')
        self.safe_terse_writes = (terse_writes == 'safe')
        if self.flag_json:
            self.protocols = copy.deepcopy(CppGenerator.protocols)
            self.protocols.append(
                ("simple_json", "SimpleJSONProtocol", "T_SIMPLE_JSON_PROTOCOL"))

    def _base_type_name(self, tbase):
        if tbase in self._base_to_cpp_typename:
            return self._base_to_cpp_typename[tbase]
        raise CompilerError('no C++ base type name for base type ' + tbase)

    def _cpp_annotation(self, type, key, default=None):
        t = _map_get(type.annotations, 'cpp2.' + key)
        if t:
            if self.flag_compatibility:
                raise CompilerError(
                    'cpp2.{0} annotation not allowed in compatibility mode: '
                    '{1}'.format(key, type))
            return t
        t = _map_get(type.annotations, 'cpp.' + key)
        if t:
            return t
        return default

    def _has_cpp_annotation(self, type, key):
        return self._cpp_annotation(type, key) is not None

    def _cpp_type_name(self, type, default=None):
        return self._cpp_annotation(type, 'type', default)

    def _type_name(self, ttype, in_typedef=False,
                   arg=False, scope=None, unique=False):
        unique = unique and not self.flag_stack_arguments
        if ttype.is_base_type:
            # cast it
            btype = ttype.as_base_type
            bname = self._base_type_name(btype.base)
            if arg and ttype.is_string:
                return self._reference_name(bname, unique)
            return self._cpp_type_name(ttype, bname)
        # Check for a custom overloaded C++ name
        if ttype.is_container:
            tcontainer = ttype.as_container
            inner_types = None
            template = self._cpp_annotation(tcontainer, 'template')
            cname = self._cpp_type_name(tcontainer)
            if cname:
                pass
            elif ttype.is_map:
                tmap = ttype.as_map
                if template:
                    cname = template
                elif tmap.is_unordered:
                    cname = 'std::unordered_map'
                else:
                    cname = 'std::map'
                inner_types = [self._type_name(tmap.key_type, in_typedef,
                                               scope=scope),
                               self._type_name(tmap.value_type, in_typedef,
                                               scope=scope)]
                cname = cname + '<{0}, {1}>'
            elif ttype.is_set:
                cname = 'std::set'
                if template:
                    cname = template
                tset = ttype.as_set
                inner_types = [self._type_name(tset.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            elif ttype.is_list:
                cname = 'std::vector'
                if template:
                    cname = template
                tlist = ttype.as_list
                inner_types = [self._type_name(tlist.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            if inner_types:
                cname = cname.format(*inner_types)
            if arg:
                return self._reference_name(cname, unique)
            else:
                return cname

        if in_typedef and (ttype.is_struct or ttype.is_xception) and \
                ttype.program == self._program:
            if self.flag_compatibility:
                scope('typedef ' + self._namespace_prefix(
                        self._program.get_namespace('cpp')) + ttype.name + \
                          ' ' + ttype.name + ';')
            else:
                scope('class ' + ttype.name + ';')

        tname = self._cpp_type_name(ttype)
        if not tname:
            # Check if it needs to be namespaced
            program = ttype.program
            if program is not None:
                tname = self._namespace_prefix(self._get_namespace(program)) + \
                        ttype.name
            else:
                tname = ttype.name

        if arg and self._is_complex_type(ttype):
            return self._reference_name(tname, unique)
        else:
            return tname

    def _is_orderable_type(self, ttype):
        if ttype.is_base_type:
            return True
        elif ttype.is_enum:
            return True
        elif ttype.is_struct or ttype.is_xception:
            for m in ttype.as_struct.members:
                if m.req == e_req.optional \
                  or self._has_cpp_annotation(m.type, 'template') \
                  or not self._is_orderable_type(m.type):
                    return False
            return True
        elif ttype.is_map and not ttype.as_map.is_unordered:
            return self._is_orderable_type(ttype.as_map.key_type) \
                    and self._is_orderable_type(ttype.as_map.value_type)
        elif ttype.is_set:
            return self._is_orderable_type(ttype.as_set.elem_type)
        elif ttype.is_list:
            return self._is_orderable_type(ttype.as_list.elem_type)
        else:
            return False

    def _is_reference(self, f):
        return self._has_cpp_annotation(f, "ref")

    def _has_isset(self, f):
        return not self._is_reference(f) and f.req != e_req.required

    # noncopyable is a hack to support gcc < 4.8, where declaring a constructor
    # as defaulted tries to generate it, even though it should be deleted.
    def _is_copyable_struct(self, ttype):
        assert ttype.is_struct or ttype.is_xception
        return not self._has_cpp_annotation(ttype, "noncopyable")

    def _is_noex_move_ctor_struct(self, ttype):
        return ttype.is_struct and \
            self._has_cpp_annotation(ttype, "noexcept_move_ctor")

    def _reference_name(self, name, unique):
        if unique:
            return "std::unique_ptr<{0}>".format(name)
        else:
            return "const {0}&".format(name)

    def _get_namespace(self, program=None):
        if program == None:
            program = self._program
        ns = program.get_namespace('cpp2')
        if ns == '':
            if len(program.get_namespace('cpp')) > 0:
                ns = program.get_namespace('cpp') + '.cpp2'
            else:
                ns = 'cpp2'
        return ns

    def _namespace_prefix(self, ns):
        'Return the absolute c++ prefix for the .-separated namespace param'
        prefix = ' ::' + '::'.join(ns.split('.'))
        if len(ns) > 0:
            prefix += '::'
        return prefix

    def _is_complex_type(self, ttype):
        ttype = self._get_true_type(ttype)
        return ttype.is_container or \
               ttype.is_struct or \
               ttype.is_xception or \
               ttype.is_base_type and \
                    ttype.as_base_type.base == frontend.t_base.string

    def _get_true_type(self, ttype):
        'Get the true type behind a series of typedefs'
        while ttype.is_typedef:
            ttype = ttype.as_typedef.type
        return ttype

    def _type_access_suffix(self, ttype):
        if not ttype.is_typedef:
            return ''
        return self._cpp_annotation(ttype.as_typedef.type, 'indirection', '')

    def _gen_forward_declaration(self, tstruct):
        if not self.flag_compatibility:
            out("class {0};".format(tstruct.name))

    def _generate_enum_constant_list(self, enum, constants, quote_names,
                                      include_values):
        if include_values:
            name_format = '{0.name}'
            value_format = ' = {0.value}'
        else:
            value_format = ''
            name_format = quote_names and '"{0.name}"' or enum + "::{0.name}"
        return ',\n'.join((name_format + value_format).format(const) \
                          for const in constants)

    def _generate_enum(self, tenum):
        '''
        Generates code for an enumerated type. In C++, this is essentially the
        same as the thrift defn itself, using the enum keyword in C++.

        @param  tenum    The enumeration
        '''
        constants = tenum.constants
        # get the scope inside the namespace definitions
        s = self._types_scope
        if self.flag_compatibility:
            s('typedef {0} {1};'.format(self._namespace_prefix(
                        self._program.get_namespace('cpp')) + tenum.name,
                                        tenum.name))
            return
        primitive = s.defn('enum class {0.name}'.format(tenum), in_header=True)
        # what follows after the closing brace
        primitive.epilogue = ';\n\n'
        with primitive:
            out(self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=False, include_values=True))
        # Generate a character array of enum values for debugging purposes.
        with s.impl('{0} _k{0}Values[] ='.format(tenum.name)):
            out(self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=False, include_values=False))
        with s.impl('const char* _k{0}Names[] ='.format(tenum.name)):
            out(self._generate_enum_constant_list(tenum.name, constants,
                    quote_names=True, include_values=False))
        s.extern('const std::map<{0}, const char*> _{0}_VALUES_TO_NAMES'.format(
            tenum.name), value=('(apache::thrift::TEnumIterator<{0}>({1}, '
                '_k{0}Values, _k{0}Names), apache::thrift::TEnumIterator<{0}>('
                '-1, nullptr, nullptr));\n').format(tenum.name, len(constants)))
        s.extern('const std::map<const char*, {0}, apache::thrift::ltstr> '
                '_{0}_NAMES_TO_VALUES'.format(tenum.name),
                 value=('(apache::thrift::TEnumInverseIterator<{0}>({1}, '
                        '_k{0}Values, _k{0}Names), '
                        'apache::thrift::TEnumInverseIterator<{0}>'
                        '(-1, nullptr, nullptr));\n').format(
                                tenum.name, len(constants)))
        s()
        s.impl('\n')

        # specialize TEnumTraitsBase
        s.release()

        ns = self._namespace_prefix(self._get_namespace())
        fullName = ns + tenum.name
        minName = None
        maxName = None

        if len(constants) > 0:
            sortedConstants = sorted(constants, key=lambda c: c.value)
            minName = sortedConstants[0].name
            maxName = sortedConstants[-1].name

        with self._types_global.namespace('apache.thrift').scope:

            with out().defn('template <> const char* TEnumTraitsBase<{fullName}>::'
                        'findName({fullName} value)'.format(**locals()),
                        name='findName'):
                out('return findName({ns}_{tenum.name}_VALUES_TO_NAMES, '
                    'value);'.format(**locals()))
            with out().defn('template <> bool TEnumTraitsBase<{fullName}>::'
                        'findValue(const char* name, {fullName}* outValue)'.
                        format(**locals()), name='findName'):
                out('return findValue({ns}_{tenum.name}_NAMES_TO_VALUES, '
                    'name, outValue);'.format(**locals()))
            if minName is not None and maxName is not None:
                with out().defn('template <> constexpr {fullName} '
                            'TEnumTraits<{fullName}>::min()'
                            .format(**locals()), name='min', in_header=True):
                    out('return {fullName}::{minName};'.format(**locals()))
                with out().defn('template <> constexpr {fullName} '
                            'TEnumTraits<{fullName}>::max()'
                            .format(**locals()), name='max', in_header=True):
                    out('return {fullName}::{maxName};'.format(**locals()))
        s = self._types_scope = \
                s.namespace(self._get_namespace()).scope
        s.acquire()

    def _generate_typedef(self, ttypedef):
        the_type = self._type_name(ttypedef.type, in_typedef=True,
                                   scope=self._types_scope)
        txt = 'typedef {0} {1};\n\n'.format(the_type, ttypedef.symbolic)
        # write it to the types scope
        self._types_scope(txt)

    def _declare_field(self, field, pointer=False, constant=False,
                        reference=False, unique=False):
        # I removed the 'init' argument, as all inits happen in default
        # constructor
        result = ''
        if constant:
            result += 'const '
        result += self._type_name(field.type)
        if pointer:
            result += '*'
        if reference:
            result += '&'
        if unique:
            result = "std::unique_ptr<" + result + ">"
        result += ' ' + field.name
        if not reference:
            result += ';'
        return result

    def _type_to_enum(self, ttype):
        'Converts the parse type to a C++ enum string for a given type.'
        t = self._get_true_type(ttype)
        suffix = None
        if t.is_base_type:
            base = t.as_base_type.base
            if base == t_base.void:
                raise ValueError('NO T_VOID CONSTRUCT')
            switch = {
                t_base.string: 'T_STRING',
                t_base.bool: 'T_BOOL',
                t_base.byte: 'T_BYTE',
                t_base.i16: 'T_I16',
                t_base.i32: 'T_I32',
                t_base.i64: 'T_I64',
                t_base.double: 'T_DOUBLE',
                t_base.float: 'T_FLOAT',
            }
            suffix = switch[base]
        elif t.is_enum:
            suffix = 'T_I32'
        elif t.is_struct or t.is_xception:
            suffix = 'T_STRUCT'
        elif t.is_map:
            suffix = 'T_MAP'
        elif t.is_set:
            suffix = 'T_SET'
        elif t.is_list:
            suffix = 'T_LIST'
        if suffix is None:
            raise TypeError('INVALID TYPE IN type_to_enum: ' + t.name)
        return 'apache::thrift::protocol::' + suffix

    # =====================================================================
    # SERVICE INTERFACE
    # =====================================================================

    def _generate_service(self, service):
        # open files and instantiate outputs
        context = self._make_context(service.name, True, True)
        self._out_tcc = context.tcc
        self._additional_outputs = context.additional_outputs
        s = self._service_global = get_global_scope(CppPrimitiveFactory,
                                                    context)
        # Enter the scope (prints guard)
        s.acquire()
        s('#include <thrift/lib/cpp2/ServiceIncludes.h>')
        if not self.flag_bootstrap:
            s('#include <thrift/lib/cpp/TApplicationException.h>')
        s('#include <thrift/lib/cpp2/async/FutureRequest.h>')
        s('#include <folly/futures/Future.h>')
        s('#include "{0}"'.format(self._with_include_prefix(self._program,
                                                             self._program.name
                                                             + '_types.h')))
        for shortprot, protname, prottype in self.protocols:
            s('#include <thrift/lib/cpp2/protocol/{0}.h>'.format(protname))
        s()
        if self.flag_compatibility:
            # Transform the cpp2 include prefix path into a cpp prefix path.
            s('#include "{0}.h"'
              .format(self._with_compatibility_include_prefix(self._program,
                                                    service.name)))
        # Include other Thrift includes
        for inc in self._program.includes:
            s('#include "{0}_types.h"' \
              .format(self._with_include_prefix(inc, inc.name)))
            if self.flag_implicit_templates:
                print >>self._out_tcc, '#include "{0}_types.tcc"'.format(
                    self._with_include_prefix(inc, inc.name))
        s()
        # Include custom headers
        for inc in self._program.cpp_includes:
            if inc.startswith('<'):
                s('#include {0}'.format(inc))
            else:
                s('#include "{0}"'.format(inc))

        if service.extends:
            s('#include "{0}.h"'.format(
                    self._with_include_prefix(service.extends.program,
                                              service.extends.name)))
        s()

        # Open namespace
        s = s.namespace(self._get_namespace()).scope
        s.acquire()

        self._generate_service_server_interface_async(service, s)
        s('class ' + service.name + 'AsyncProcessor;')
        self._generate_service_server_interface(service, s)
        self._generate_service_server_null(service, s)
        self._generate_processor(service, s)
        self._generate_service_client(service, s)
        self._generate_service_helpers(service, s)

        # make sure that the main types namespace is closed
        s.release()

        self._generate_service_helpers_serializers(service, s)

        if self.flag_implicit_templates:
            # Include the types.tcc file from the types header file
            s = self._service_global
            s()
            s('#include "{0}.tcc"'.format(
                self._with_include_prefix(self._program, service.name)))
            self._service_global.release()


    def _generate_service_helpers_serializers(self, service, s):
        s = s.namespace('apache.thrift').scope
        s.acquire()
        for function in service.functions:
            arglist = function.arglist
            if self.flag_stack_arguments:
                arglist.name = "{0}_{1}_args".format(service.name, function.name)
                self._generate_cpp2ops(True, arglist, s)
            arglist.name = "{0}_{1}_pargs".format(service.name, function.name)
            self._generate_cpp2ops(True, arglist, s)

            if not function.oneway:
                result = self._get_presult_object(service, function)
                self._generate_cpp2ops(True, result, s)
        s.release()

    def _get_presult_object(self, service, function):
        result = frontend.t_struct(
            self.program,
            "{0}_{1}_presult".format(service.name, function.name))
        success = frontend.t_field(function.returntype, "success", 0)
        if not function.returntype.is_void:
            result.append(success)
        xs = function.xceptions
        for field in xs.members:
            result.append(field)
        return result



    def _generate_service_helpers(self, service, s):
        for function in service.functions:
            arglist = function.arglist
            name_orig = arglist.name
            if self.flag_stack_arguments:
                arglist.name = "{0}_{1}_args".format(service.name, function.name)
                self._generate_struct_complete(s, arglist,
                                               is_exception=False,
                                               pointers=False,
                                               read=True,
                                               write=True,
                                               swap=False,
                                               result=False)
            arglist.name = "{0}_{1}_pargs".format(service.name, function.name)
            self._generate_struct_complete(s, arglist,
                                           is_exception=False,
                                           pointers=True,
                                           read=True,
                                           write=True,
                                           swap=False,
                                           result=False,
                                           has_isset=False)
            arglist.name = name_orig

            if not function.oneway:
                # WTF Using _get_presult_object causes a segmentation fault?
                result = frontend.t_struct(
                    self.program,
                    "{0}_{1}_presult".format(service.name, function.name))
                success = frontend.t_field(function.returntype, "success", 0)
                if not function.returntype.is_void:
                    result.append(success)
                xs = function.xceptions
                for field in xs.members:
                    result.append(field)
                self._generate_struct_complete(s, result,
                                               is_exception=False,
                                               pointers=True,
                                               read=True,
                                               write=True,
                                               swap=False,
                                               result=True)

    def _generate_service_client(self, service, s):
        classname = service.name + "AsyncClient"
        if not service.extends:
            class_signature = 'class ' + classname + \
                ' : public apache::thrift::TClientBase'
        else:
            class_signature = 'class ' + classname + \
                ' : public ' + self._type_name(service.extends) +\
                'AsyncClient'
        with s.cls(class_signature):
            out().label('public:')

            with out().defn('std::string {name}()', name='getServiceName',
                        modifiers='virtual'):
                out("return \"{0}\";".format(service.name))

            out("typedef std::unique_ptr<apache::thrift::RequestChannel"
              ", apache::thrift::async::TDelayedDestruction::Destructor>"
              " channel_ptr;")
            init = OrderedDict()
            if service.extends:
                init[self._type_name(service.extends) + 'AsyncClient'] = \
                    'channel'
            if not service.extends:
                init["channel_"] = "channel"
            # TODO: make it possible to create a connection context from a
            # thrift channel
            out().defn('~{name}()', name=classname,
                   modifiers='virtual', in_header=True).scope.empty()

            with out().defn('{name}(std::shared_ptr<' +
                            'apache::thrift::RequestChannel> channel)',
                        name=classname,
                        init_dict=init,
                        in_header=True):
                out('connectionContext_ = '
                  'std::unique_ptr<TClientBase::ConnContext>('
                  'new TClientBase::ConnContext(channel_->getHeader(),'
                     'nullptr));')

            if not service.extends:
                with out().defn('apache::thrift::RequestChannel* '
                            ' {name}()', name='getChannel',
                            in_header=True):
                    out("return this->channel_.get();")

            # Write out all the functions
            for function in service.functions:
                self._generate_client_async_function(service, function)
                self._generate_client_async_function(service, function,
                                                     name_prefix="callback_")

                self._generate_client_async_function(service, function,
                                                     uses_rpc_options=True)

                self._generate_client_sync_function(service, function)
                self._generate_client_sync_function(service, function,
                                                    uses_rpc_options=True)

                self._generate_client_std_function(function)
                self._generate_client_std_function(function,
                                                   name_prefix="functor_")

                self._generate_client_future_function(service, function)
                self._generate_client_future_function(service, function,
                                                      uses_rpc_options=True)
                if not function.oneway:
                    self._generate_recv_functions(function)

                self._generate_templated_client_function(service, function)

                if not function.oneway:
                    self._generate_templated_recv_function(service, function)

            if not service.extends:
                out().label('protected:')
                out("std::unique_ptr<apache::thrift::server::TConnectionContext>"
                  "connectionContext_;")
                out("std::shared_ptr<apache::thrift::RequestChannel> channel_;")

    def _get_async_func_name(self, function):
        if self._is_processed_in_eb(function):
            return 'async_eb_' + function.name
        else:
            return 'async_tm_' + function.name

    def _generate_service_server_null(self, service, s):
        classname = service.name + "SvNull"
        if not service.extends:
            class_signature = "class " + classname + " : public " + \
                service.name + \
                "SvIf"
        else:
            class_signature = "class " + classname + " : public " + \
                service.name + "SvIf, virtual public " + \
                self._type_name(service.extends) + "SvIf"
        with s.cls(class_signature):
            out().label('public:')
            out().defn('~{0}()'.format(classname), name=classname,
                   modifiers='virtual',
                   in_header=True).scope.empty()
            for function in service.functions:
                if not self._is_processed_in_eb(function):
                    with out().defn(
                            self._get_process_function_signature(service,
                                                                 function),
                            name=function.name,
                            modifiers='virtual'):
                        if not function.oneway and \
                          not function.returntype.is_void and \
                          not self._is_complex_type(function.returntype):
                            out('return ' +
                              self._default_value(function.returntype) + ';')

    def _generate_service_server_interface_async(self, service, s):
        classname = service.name + "SvAsyncIf"
        class_signature = "class " + classname
        with s.cls(class_signature):
            out().label('public:')
            out().defn('~{0}()'.format(classname), name=classname,
                   modifiers='virtual',
                   in_header=True).scope.empty()
            for function in service.functions:
                out().defn(self._get_process_function_signature_async(service,
                                                                  function),
                       name=self._get_async_func_name(function),
                       modifiers='virtual',
                       pure_virtual=True)

                # TODO: Remove this once everything has migrated to async_eb or
                # async_tm
                out().defn(self._get_process_function_signature_async(service,
                                                                  function),
                       name="async_" + function.name,
                       modifiers='virtual',
                       delete=True)
                out().defn(self._get_process_function_signature_future(
                        service, function),
                       name="future_" + function.name,
                       modifiers='virtual',
                       pure_virtual=True)

    def _generate_service_server_interface(self, service, s):
        classname = service.name + "SvIf"
        if not service.extends:
            class_signature = "class " + classname + " : public " + \
                service.name + \
                "SvAsyncIf, public apache::thrift::ServerInterface"
        else:
            class_signature = "class " + classname + " : public " + \
                service.name + "SvAsyncIf, virtual public " + \
                self._type_name(service.extends) + "SvIf"
        with s.cls(class_signature):
            out().label('public:')
            out('typedef ' + service.name + 'AsyncProcessor ProcessorType;')
            out().defn('~{0}()'.format(classname), name=classname,
                   modifiers='virtual',
                   in_header=True).scope.empty()
            with out().defn('std::unique_ptr<apache::thrift::AsyncProcessor>' +
                        ' {name}()',
                        name='getProcessor',
                        modifiers='virtual'):
                out('return std::unique_ptr<' +
                  'apache::thrift::AsyncProcessor>(' +
                  'new {0}AsyncProcessor(({0}SvIf*)this));'.format(
                          service.name))
            for function in service.functions:
                with out().defn(self._get_prio_function_signature(service,
                                                              function),
                            name="getprio_" + function.name):
                    if function.annotations is not None and \
                            'priority' in function.annotations.annotations:
                        prio = function.annotations.annotations['priority']
                    elif 'priority' in service.annotations:
                        prio = service.annotations['priority']
                    else:
                        prio = 'NORMAL'
                    PTM = 'apache::thrift::concurrency'
                    priovar = self.tmp('prio')
                    out('{0}::PRIORITY {1} = reqCtx->getCallPriority();'
                            .format(PTM, priovar))
                    with out('if ({0} != {1}::N_PRIORITIES)'.format(
                           priovar, PTM)):
                        out('return {0};'.format(priovar))
                    out('return {0}::{1};'.format(PTM, prio))
                with out().defn(self._get_process_function_signature(service,
                                                                 function),
                            name=function.name,
                            modifiers='virtual'):
                    out('throw apache::thrift::TApplicationException('
                      '"Function {0} is unimplemented");'
                      .format(function.name))
                    if not function.oneway and \
                      not function.returntype.is_void and \
                      not self._is_complex_type(function.returntype):
                        out('return ' +
                          self._default_value(function.returntype) + ';')
                self._generate_server_future_function(service, function)
                self._generate_server_async_function(service, function)

    def _generate_server_future_function(self, service, function):
        with out().defn(self._get_process_function_signature_future(service,
                                                                    function),
                    name="future_" + function.name):
            rettype = self._type_name(function.returntype)
            if self._is_complex_type(function.returntype) and \
                    not self.flag_stack_arguments:
                rettype = 'std::unique_ptr<' + rettype + '>'

            promise_name = self.tmp("promise")
            out("folly::Promise<{0}> {1};".format(rettype, promise_name))
            args = []
            for member in function.arglist.members:
                if self._is_complex_type(member.type) \
                  and not self.flag_stack_arguments:
                    args.append("std::move({0})".format(member.name))
                else:
                    args.append(member.name)

            if not function.oneway and self._is_complex_type(
                function.returntype
            ):
                if self.flag_stack_arguments:
                    args.insert(0, "_return")
                else:
                    args.insert(0, "*_return")
            with out("try"):
                if not function.oneway and not function.returntype.is_void:
                    if self._is_complex_type(function.returntype) \
                      and not self.flag_stack_arguments:
                        out("std::unique_ptr<{0}> _return(new {0});"
                          .format(self._type_name(function.returntype)))
                        out("{0}({1});".format(function.name,
                                             ", ".join(args)))
                        out("{0}.setValue(std::move(_return));".format(
                            promise_name))
                    elif self._is_complex_type(function.returntype):
                        out("{0} _return;".format(self._type_name(
                            function.returntype)))
                        out("{0}({1});".format(function.name,
                                             ", ".join(args)))
                        out("{0}.setValue(_return);".format(promise_name))
                    else:
                        out("{0}.setValue({1}({2}));"
                          .format(promise_name, function.name, ", ".join(args)))
                else:
                    out("{0}(".format(function.name) + ", ".join(args) + ");")
                    out("{0}.setValue();".format(promise_name))
                with out().catch("const std::exception& ex"):
                    out("{0}.setException(folly::exception_wrapper"
                        "(std::current_exception()));".format(
                            promise_name))
            out("return {0}.getFuture();".format(promise_name))

    def _generate_server_async_function_future(self, function):
        out('auto callbackp = callback.release();')
        out('setEventBase(callbackp->getEventBase());')
        out('setThreadManager(callbackp->getThreadManager());')
        captureArgs = []
        callArgs = []
        for member in function.arglist.members:
            if self._is_complex_type(member.type):
                tmpMovedArg = self.tmp("tmp_move_{0}".format(member.name))
                out("auto {0} = std::move({1});"
                        .format(tmpMovedArg, member.name))
                moveArg = self.tmp("move_{0}".format(member.name))
                out("auto {0} = folly::makeMoveWrapper(std::move({1}));"
                        .format(moveArg, tmpMovedArg))
                captureArgs.append(moveArg)
                callArgs.append("std::move(*{0})".format(moveArg))
            else:
                captureArgs.append(member.name)
                callArgs.append(member.name)

        if self._is_processed_in_eb(function):
            captures = "this, callbackp"
            if captureArgs:
                captures = "{0}, {1}".format(captures, ", ".join(captureArgs))
            with out("callbackp->runFuncInQueue([{0}]() mutable".format(captures)):
                self._generate_server_async_future_stuff(function, callArgs)
            out(");")
        else:
            self._generate_server_async_future_stuff(function, callArgs)

    def _generate_server_async_future_stuff(self, function, callArgs):
        rettype = "folly::Try<{0}>".format(
            self._type_name(function.returntype))
        if self._is_complex_type(function.returntype) and \
          not self.flag_stack_arguments:
            rettype = "folly::Try<std::unique_ptr" \
              "<{0}>>".format(self._type_name(function.returntype))
        future_name = self.tmp('future')
        out('setConnectionContext(callbackp->getConnectionContext());')
        with out("try"):
            if not function.oneway and \
              not function.returntype.is_void:
                out("auto {2} = future_{0}({1});".format(
                    function.name, ", ".join(callArgs), future_name))
                with out("{0}.then([=]({1}&& _return)".format(
                        future_name, rettype)):
                    with out("try"):
                        out("callbackp->resultInThread("
                          "std::move(_return.value()));")
                        with out().catch("..."):
                            out("callbackp->exceptionInThread("
                                "std::current_exception());")
                out(");")
            else:
                out("auto {1} = future_{0}(".format(
                    function.name, future_name)
                    + ", ".join(callArgs) + ");")
                if not function.oneway:
                    with out(("{0}.then([=](folly" +
                          "::Try<void>&& t)").format(future_name)):
                        with out("try"):
                            out("t.throwIfFailed();")
                            out("callbackp->doneInThread();")
                            with out().catch("..."):
                                out("callbackp->exceptionInThread("
                                    "std::current_exception());")
                    out(");")
                else:
                    out("delete callbackp;")
            with out().catch("const std::exception& ex"):
                if not function.oneway:
                    out("callbackp->exceptionInThread(std::"
                        "current_exception());")
                else:
                    out("delete callbackp;")


    def _generate_server_async_function(self, service, function):
        with out().defn(self._get_process_function_signature_async(service,
                                                                   function),
                    name=self._get_async_func_name(function),
                    modifiers='virtual'):
            self._generate_server_async_function_future(function)

    def _get_process_function_signature_async(self, service, function):
        sig = 'void {name}('
        if function.oneway:
            sig += 'std::unique_ptr<apache::thrift::HandlerCallbackBase>' + \
                ' callback'
        else:
            if self._is_complex_type(function.returntype) and \
                 not self.flag_stack_arguments:
                rettype = self._type_name(function.returntype)
                rettype = 'std::unique_ptr<' + rettype + '>'
            else:
                rettype = self._type_name(function.returntype)

            sig += ('std::unique_ptr<apache::thrift::HandlerCallback<{0}>>' + \
                        ' callback').format(rettype)

        sig += self._argument_list(function.arglist, True, unique=True)
        sig += ')'
        return sig

    def _get_process_function_signature_future(self, service, function):
        rettype = self._type_name(function.returntype)
        if self._is_complex_type(function.returntype) and \
                not self.flag_stack_arguments:
            rettype = 'std::unique_ptr<' + rettype + '>'
        sig = 'folly::Future<' + \
            rettype + '> {name}('

        sig += self._argument_list(function.arglist, False, unique=True)
        sig += ')'
        return sig

    def _get_process_function_signature(self, service, function):
        addcomma = False
        if not function.oneway:
            if self._is_complex_type(function.returntype):
                sig = 'void {name}' + '({0}& _return'.format(
                    self._type_name(function.returntype))
                addcomma = True
            else:
                sig = self._type_name(function.returntype)
                sig += ' {name}('
        else:
            sig = 'void {name}('
        sig += self._argument_list(function.arglist, addcomma, unique=True)
        sig += ')'
        return sig

    def _get_prio_function_signature(self, service, function):
        sig = 'apache::thrift::concurrency::PriorityThreadManager::PRIORITY ' \
              '{name}(apache::thrift::Cpp2RequestContext* reqCtx)'
        return sig

    def _generate_app_ex(self, service, errorstr, functionname, seqid, is_in_eb,
                         s, reqCtx, static=True, err_code=None,
                         uex_str='folly::demangle(typeid(e)).toStdString()'):
        with out('if (req)'):
            out('LOG(ERROR) << {0} << " in function {1}";'.format(
                    errorstr, functionname))
            code = '' if err_code is None else \
                    'apache::thrift::TApplicationException::' \
                    'TApplicationExceptionType::' + err_code + ', '
            out('apache::thrift::TApplicationException x({0}{1});'.
                format(code, errorstr))
            if static:
                ctx = 'ctx.get()'
                out('ctx->userException({});'.format(uex_str))
            else:
                ctx = 'nullptr'
            out('folly::IOBufQueue queue = serializeException("{0}", &prot, {1}, {2}, '
                'x);'.format(functionname, seqid, ctx))
            out('queue.append(apache::thrift::transport::THeader::transform('
                'queue.move(), '
                '{0}->getTransforms(), '
                '{0}->getMinCompressBytes()));'.format(reqCtx))
            if is_in_eb:
                out('req->sendReply(queue.move());')
            else:
                out('auto queue_mw = '
                        'folly::makeMoveWrapper(std::move(queue));')
                out('auto req_mw = folly::makeMoveWrapper(std::move(req));')
                with out('eb->runInEventBaseThread([=]() mutable'):
                    out('(*req_mw)->sendReply(queue_mw->move());')
                out(');')
            out('return;')
        with out('else'):
            out('LOG(ERROR) << {0} << " in oneway function {1}";'.format(
                    errorstr, functionname))

    def _generate_process_function(self, service, function):
        if function.oneway:
            if self._is_processed_in_eb(function):
                # Old clients may not send the special
                # oneway id, so we need to send a fake
                # response to them while in event base.
                with out('if (!req->isOneway())'):
                    out('req->sendReply(std::unique_ptr<folly::IOBuf>());')
        out("// make sure getConnectionContext is null")
        out("// so async calls don't accidentally use it")
        out('iface_->setConnectionContext(nullptr);')
        aprefix = 'uarg_'
        if self.flag_stack_arguments:
            out('{0}_{1}_args args;'.format(service.name, function.name))
        else:
            out('{0}_{1}_pargs args;'.format(service.name, function.name))
        for field in function.arglist.members:
            val = ""
            t = self._get_true_type(field.type)
            if t.is_base_type or t.is_enum:
                val = self._member_default_value(field)
            if self.flag_stack_arguments:
                pass
            elif self._is_complex_type(field.type):
                out('std::unique_ptr<{0}> {1}(new {0}({2}));'.format(
                        self._type_name(field.type), aprefix + field.name, val))
                out('args.{0} = {1}.get();'.format(
                        field.name, aprefix + field.name))
            else:
                # use uniform initialization syntax to avoid most vexing parse
                out('{0} {1}{{{2}}};'.format(
                        self._type_name(field.type), aprefix + field.name, val))
                ref_prefix = "&"
                if self.flag_stack_arguments:
                    ref_prefix = ""
                out('args.{0} = {2}{1};'.format(
                        field.name, aprefix + field.name, ref_prefix))
        out(('std::unique_ptr<apache::thrift::' +
           'ContextStack> c(this->getContextStack' +
           '(this->getServiceName(), "{0}.{1}", ctx));'
           ).format(service.name, function.name))
        out("")
        with out('try'):
            out('deserializeRequest(args, buf.get(), iprot.get(), c.get());')
        with out('catch (const std::exception& ex)'):
            if function.oneway:
                out('LOG(ERROR) << ex.what() << " in function noResponse";')
                out('return;')
            else:
                out('ProtocolOut_ prot;')
                self._generate_app_ex(service, 'ex.what()',
                                      function.name, "iprot->getSeqId()",
                                      False, out, 'ctx', False,
                                      'PROTOCOL_ERROR')
        args = []
        for member in function.arglist.members:
            if self.flag_stack_arguments:
                args.append("args." + member.name)
            elif self._is_complex_type(member.type):
                args.append("std::move({0})".format(
                        aprefix + member.name))
            else:
                args.append("*args." + member.name)
        if function.oneway:
            out('std::unique_ptr<apache::thrift::HandlerCallbackBase> callback(' +
              'new apache::thrift::HandlerCallbackBase(std::move(req), ' +
              'std::move(c), nullptr, nullptr, eb, tm, ctx));')
        else:
            if self._is_complex_type(function.returntype) and \
                    not self.flag_stack_arguments:
                rettype = self._type_name(function.returntype)
                rettype = 'std::unique_ptr<' + rettype + '>'
            else:
                rettype = self._type_name(function.returntype)
            out(('std::unique_ptr<apache::thrift::' +
               'HandlerCallback<{0}>> callback(new apache::thrift::' +
               'HandlerCallback<{0}>(std::move(req), ' +
               'std::move(c), return_{1}<ProtocolIn_,' +
               'ProtocolOut_>, throw_{1}<ProtocolIn_,' +
               ' ProtocolOut_>, throw_wrapped_{1}<ProtocolIn_,' +
               ' ProtocolOut_>, iprot->getSeqId(),' +
               ' eb, tm, ctx));').format(rettype, function.name))
        # Oneway request won't be canceled if expired. see D1006482 for
        # further details. TODO: fix this
        if not self._is_processed_in_eb(function) and not function.oneway:
            with out('if (!callback->isRequestActive())'):
                out('callback.release()->deleteInThread();')
                out('return;')
        args.insert(0, 'std::move(callback)')
        out('ctx->setStartedProcessing();')
        out('iface_->{0}({1});'.format(self._get_async_func_name(function),
                                     ", ".join(args)))

    def _generate_processor(self, service, s):
        if not service.extends:
            class_signature = 'class {0} : '.format(
                service.name + 'AsyncProcessor') + \
                'public ::apache::thrift::GeneratedAsyncProcessor'
        else:
            class_signature = 'class {0} : '.format(
                service.name + 'AsyncProcessor') + \
                'public ' + self._type_name(service.extends) + \
                'AsyncProcessor'
        with s.cls(class_signature):
            out().label('public:')
            with out().defn('std::string {name}()', name='getServiceName',
                        modifiers='virtual'):
                out("return \"{0}\";".format(service.name))

            out().label('protected:')

            out('{0}SvIf* iface_;'.format(service.name))
            with out().defn('void {name}(std::unique_ptr<' +
                        'apache::thrift::ResponseChannel::Request> req, ' +
                        'std::unique_ptr<folly::IOBuf> buf, ' +
                        'apache::thrift::protocol::PROTOCOL_TYPES protType,' +
                        'apache::thrift::Cpp2RequestContext* context,' +
                        'apache::thrift::async::TEventBase* eb, ' +
                        'apache::thrift::concurrency::ThreadManager* tm)',
                        name='process',
                        modifiers='virtual'):
                out('std::string fname;')
                out('apache::thrift::MessageType mtype;')
                out('int32_t protoSeqId = 0;')
                switch = out('switch(protType)').scope
                for shortprot, protname, prottype in self.protocols:
                    with switch.case('apache::thrift::protocol::' +
                                     prottype, nobreak=True):
                        out(('std::unique_ptr<apache::thrift::' +
                           '{0}Reader> ' +
                           'iprot(new apache::thrift::' +
                           '{0}Reader());').format(protname))
                        out('iprot->setInput(buf.get());')
                        with out('try'):
                            out('iprot->readMessageBegin(fname, mtype,' + \
                                  ' protoSeqId);')
                            with out().catch('const apache::thrift::'
                                             'TException& ex'):
                                out('LOG(ERROR) << "received invalid message' +
                                  ' from client: " << ex.what();')
                                out('apache::thrift::{0}Writer prot;'
                                  .format(protname))
                                self._generate_app_ex(
                                    service, '"invalid message from client"',
                                    "process", "protoSeqId", False, out(),
                                    'context', False)
                                out('return;')
                        with out('if (mtype != apache::thrift::T_CALL && ' +
                               'mtype != apache::thrift::T_ONEWAY)'):
                            out('LOG(ERROR) << "received invalid message of ' +
                              'type " << mtype;')
                            out('apache::thrift::{0}Writer prot;'
                              .format(protname))
                            self._generate_app_ex(
                                service, '"invalid message arguments"',
                                "process", "protoSeqId", False, out(),
                                'context', False)
                        out('auto pfn = {0}ProcessMap_.find(fname);'.format(
                                shortprot))
                        with out('if (pfn == {0}ProcessMap_.end())'.format(
                                shortprot)):
                            if not service.extends:
                                out('const std::string exMsg = ' +
                                  'folly::stringPrintf(' +
                                  ' "Method name %s not found",' +
                                  ' fname.c_str());')
                                out('apache::thrift::{0}Writer prot;'
                                  .format(protname))
                                self._generate_app_ex(
                                    service, 'exMsg',
                                    "process", "protoSeqId", False, out(),
                                    'context', False)
                            else:
                                out(self._type_name(service.extends) +
                                  'AsyncProcessor::process(std::move(req), ' +
                                  'std::move(buf), protType, context, eb, tm);')
                            out('return;')
                        out('(this->*(pfn->second))(std::move(req), ' +
                          'std::move(buf), std::move(iprot), context, eb, tm);')
                        out('return;')
                with switch.case('default'):
                    out('LOG(ERROR) << "invalid protType: " << protType;')
                    out('return;')
                switch.release()

            with out().defn('bool {name}(const folly::IOBuf* buf, ' +
                    'const apache::thrift::transport::THeader* header)',
                        name='isOnewayMethod',
                        modifiers='virtual'):
                out('std::string fname;')
                out('apache::thrift::MessageType mtype;')
                out('int32_t protoSeqId = 0;')
                out('apache::thrift::protocol::PROTOCOL_TYPES protType = ' +
                  'static_cast<apache::thrift::protocol::PROTOCOL_TYPES>' +
                  '(header->getProtocolId());')
                switch = out('switch(protType)').scope
                for shortprot, protname, prottype in self.protocols:
                    with switch.case('apache::thrift::protocol::' +
                                     prottype, nobreak=True):
                        out(('apache::thrift::{0}Reader iprot;')
                                .format(protname))
                        out('iprot.setInput(buf);')
                        with out('try'):
                            out('iprot.readMessageBegin(fname, mtype,' +
                                  ' protoSeqId);')
                            out('auto it = onewayMethods.find(fname);')
                            out('return it != onewayMethods.end();')
                            with out().catch('const apache::thrift::'
                                             'TException& ex'):
                                out('LOG(ERROR) << "received invalid message' +
                                  ' from client: " << ex.what();')
                                out('return false;')
                with switch.case('default'):
                    out('LOG(ERROR) << "invalid protType: " << protType;')
                switch.release()
                out('return false;')

            out().label('private:')
            oneways = out().defn('std::unordered_set<std::string> {name}',
                                 name='onewayMethods',
                                 modifiers='static')
            oneways.epilogue = ';\n'
            with oneways:
                out(',\n'.join('"' + function.name + '"'
                        for function in service.functions if function.oneway))
            prot = 0
            for shortprot, protname, prottype in self.protocols:
                out(('typedef void ({0}::*{1}ProcessFunction)(std::unique_ptr' +
                   '<apache::thrift::ResponseChannel::Request> req, ').format(
                           service.name + "AsyncProcessor", shortprot) +
                  'std::unique_ptr<folly::IOBuf> buf, ' +
                  'std::unique_ptr<apache::thrift::{0}Reader> iprot, '.format(
                          protname) +
                  'apache::thrift::Cpp2RequestContext* context, ' +
                  'apache::thrift::async::TEventBase* eb, ' +
                  'apache::thrift::concurrency::ThreadManager* tm' + ');')
                out('typedef std::unordered_map<std::string, ' +
                  '{0}ProcessFunction>'.format(shortprot) +
                  ' {0}ProcessMap;'.format(shortprot))
                map_type = '{0}::{1}ProcessMap'.format(
                    service.name + "AsyncProcessor",
                    shortprot)
                map_name = '{0}ProcessMap_'.format(shortprot)
                process_map = out().defn(map_type + ' {name}',
                                         name=map_name,
                                         modifiers='static')
                process_map.output = self._additional_outputs[prot]
                if prot < 1:  # TODO: fix build tool to use more than 2 outputs
                    prot = prot + 1
                process_map.epilogue = ';'

                with process_map:
                    out(',\n'.join('{"' + function.name + '", &' +
                        service.name + 'AsyncProcessor::' +
                        self._get_handler_function_name(function) +
                        '<apache::thrift::{0}Reader, '
                        'apache::thrift::{0}Writer>}}'.format(protname)
                            for function in service.functions))
            for function in service.functions:
                loadname = '"{0}.{1}"'.format(service.name, function.name)
                if not self._is_processed_in_eb(function):
                    with out().defn('template <typename ProtocolIn_, '
                                'typename ProtocolOut_>\n'
                                'void {name}(std::unique_ptr<'
                                'apache::thrift::ResponseChannel::Request> req,'
                                ' std::unique_ptr<folly::IOBuf> buf, '
                                'std::unique_ptr<ProtocolIn_> iprot, '
                                'apache::thrift::Cpp2RequestContext* ctx, '
                                'apache::thrift::async::TEventBase* eb, '
                                'apache::thrift::concurrency::ThreadManager* tm'
                                ')',
                                name="_processInThread_{0}"
                                .format(function.name),
                                output=self._out_tcc):
                        out('auto pri = iface_->getprio_{0}(ctx);'.format(
                                function.name))
                        out('processInThread<ProtocolIn_, ProtocolOut_>' +
                          '(std::move(req), std::move(buf),' +
                          'std::move(iprot), ctx, eb, tm, pri, '
                          + (function.oneway and 'true' or 'false') +
                          ', &{0}AsyncProcessor::process_{1}'.format(
                                  service.name, function.name) +
                          '<ProtocolIn_, ProtocolOut_>, this);')

                with out().defn('template <typename ProtocolIn_, ' +
                            'typename ProtocolOut_>\n' +
                            'void {name}(std::unique_ptr<' +
                            'apache::thrift::ResponseChannel::Request> req, ' +
                            'std::unique_ptr<folly::IOBuf> buf, ' +
                            'std::unique_ptr<ProtocolIn_> iprot,' +
                            'apache::thrift::Cpp2RequestContext* ctx,' +
                            'apache::thrift::async::TEventBase* eb, ' +
                            'apache::thrift::concurrency::ThreadManager* tm)',
                            name="process_{0}".format(function.name),
                            output=self._out_tcc):
                    self._generate_process_function(service, function)

                if not function.oneway:
                    args = [
                        'int32_t protoSeqId',
                        'std::unique_ptr<apache::thrift::ContextStack> ctx']

                    if not function.returntype.is_void:
                        args.append("{0} const& _return".format(
                                self._type_name(function.returntype)))

                    with out().defn(
                        'template <class ProtocolIn_, class ProtocolOut_>\n' +
                                'folly::IOBufQueue {name}' + '({0})'
                                .format(", ".join(args)),
                                name="return_{0}".format(function.name),
                                output=self._out_tcc,
                                modifiers='static'):
                        out('ProtocolOut_ prot;')
                        result_type = '{0}_{1}_presult'.format(
                                service.name, function.name)
                        out('{0} result;'.format(result_type))
                        if self._function_produces_result(function):
                            out('result.success = const_cast' +
                              '<{0}*>(&_return);'.format(
                                      self._type_name(
                                           function.returntype)))
                            out('result.__isset.success = true;')
                        out('return serializeResponse("{0}", '
                          '&prot, protoSeqId, ctx.get(), result);'
                          .format(function.name))

                def cast_xceptions(xceptions):
                    for xception in xceptions:
                        with out('catch (const {0}& e)'.format(
                            self._type_name(xception.type))):
                            out('ctx->userException(' +
                              'folly::demangle(typeid(e)).toStdString());')
                            out('result.{0} = e;'.format(xception.name))
                            out('result.__isset.{0} = true;'.format(
                                xception.name))
                if not function.oneway:
                    with out().defn(
                        'template <class ProtocolIn_, class ProtocolOut_>\n' +
                        'void {name}(std::unique_ptr' +
                        '<apache::thrift::ResponseChannel::Request> req,' +
                        'int32_t protoSeqId,'
                        + 'std::unique_ptr<apache::thrift::ContextStack> ctx,' +
                        'std::exception_ptr ep,' +
                        'apache::thrift::Cpp2RequestContext* reqCtx)',
                                name="throw_{0}".format(function.name),
                                modifiers='static',
                                output=self._out_tcc):
                        out('ProtocolOut_ prot;')
                        if len(function.xceptions.members) > 0:
                            out('{0}_{1}_presult result;'.format(
                                    service.name, function.name))
                        with out('try'):
                            out('std::rethrow_exception(ep);')
                        cast_xceptions(
                            function.xceptions.members)
                        with out('catch (const std::exception& e)'):
                            self._generate_app_ex(
                                service,
                                "folly::exceptionStr(e)." +
                                "toStdString()",
                                function.name, "protoSeqId", True,
                                out(), 'reqCtx')
                        with out('catch (...)'):
                            self._generate_app_ex(
                                service,
                                "\"<unknown exception>\"",
                                function.name, "protoSeqId", True,
                                out(), 'reqCtx', False)
                        if len(function.xceptions.members) > 0:
                            out('auto queue = serializeResponse('
                              '"{0}", &prot, protoSeqId, ctx.get(),'
                              ' result);'.format(function.name))
                            out('queue.append('
                                'apache::thrift::transport::THeader::transform('
                                'queue.move(), '
                                '{0}->getTransforms(), '
                                '{0}->getMinCompressBytes()));'.format('reqCtx'))
                            out('return req->sendReply(queue.move());')
                    with out().defn(
                        'template <class ProtocolIn_, class ProtocolOut_>\n' +
                        'void {name}(std::unique_ptr' +
                        '<apache::thrift::ResponseChannel::Request> req,' +
                        'int32_t protoSeqId,'
                        + 'std::unique_ptr<apache::thrift::ContextStack> ctx,' +
                        'folly::exception_wrapper ew,' +
                        'apache::thrift::Cpp2RequestContext* reqCtx)',
                        name="throw_wrapped_{0}".format(function.name),
                        modifiers='static',
                        output=self._out_tcc
                    ):
                        with out('if (!ew)'):
                            out('return;')

                        out('ProtocolOut_ prot;')
                        if len(function.xceptions.members) > 0:
                            out('{0}_{1}_presult result;'.format(
                                service.name, function.name))
                        for xception in function.xceptions.members:
                            xception_type = self._type_name(
                                xception.type)
                            with out('if (ew.with_exception<{0}>([&]({0}& e)'.
                                     format(xception_type)):
                                out('ctx->userException('
                                    'folly::demangle(typeid(e)).'
                                    'toStdString());')
                                out('result.{0} = e;'.format(
                                    xception.name))
                                out('result.__isset.{0} = true;'.format(
                                    xception.name))
                            out(')) {} else ')
                        with out(' '):
                            self._generate_app_ex(
                                service,
                                'ew.what().toStdString()',
                                function.name, "protoSeqId", True,
                                out(), 'reqCtx', True, None,
                                'ew.class_name().toStdString()')
                        if len(function.xceptions.members) > 0:
                            out('auto queue = serializeResponse('
                                '"{0}", &prot, protoSeqId, ctx.get(),'
                                ' result);'.format(function.name))
                            out('queue.append('
                                'apache::thrift::transport::THeader::transform('
                                'queue.move(), '
                                '{0}->getTransforms(), '
                                '{0}->getMinCompressBytes()));'.format('reqCtx'))
                            out('return req->sendReply(queue.move());')


            out().label('public:')
            init = OrderedDict()
            if service.extends:
                init[self._type_name(service.extends) + 'AsyncProcessor'] = \
                    'iface'
            init['iface_'] = 'iface'
            out().defn('{name}(' + service.name + 'SvIf* iface)',
                   name=service.name + 'AsyncProcessor',
                   init_dict=init,
                   in_header=True).scope.empty()
            out().defn('{name}()', name='~' + service.name + 'AsyncProcessor',
                   in_header=True, modifiers='virtual').scope.empty()

    def _get_handler_function_name(self, function):
        if self._is_processed_in_eb(function):
            return 'process_' + function.name
        else:
            return '_processInThread_' + function.name

    def _generate_client_sync_function(self, service, function,
                                       uses_rpc_options=False):

        signature = self._get_sync_function_signature(function,
                                                      uses_rpc_options)
        with out().defn(signature, name="sync_" + function.name,
                    modifiers='virtual'):
            common_args = [arg.name for arg in function.arglist.members]

            if not uses_rpc_options:
                if function.returntype.is_void:
                    args = ["::apache::thrift::RpcOptions()"]
                    args.extend(common_args)
                    args_list = ", ".join(args)
                    out("sync_{name}({args_list});".format(name=function.name,
                                                         args_list=args_list))
                elif not self._is_complex_type(function.returntype):
                    args = ["::apache::thrift::RpcOptions()"]
                    args.extend(common_args)
                    args_list = ", ".join(args)

                    out("return sync_{name}({args_list});"
                         .format(name=function.name, args_list=args_list))
                else:
                    args = ["::apache::thrift::RpcOptions()", "_return"]
                    args.extend(common_args)
                    args_list = ", ".join(args)

                    out("sync_{name}({args_list});"
                         .format(name=function.name, args_list=args_list))

            else:
                out('apache::thrift::ClientReceiveState _returnState;')

                sync_callback_name = self.tmp("callback")
                out("std::unique_ptr<apache::thrift::RequestCallback> "
                  "{sync_callback_name}("
                  "new apache::thrift::ClientSyncCallback("
                  "&_returnState, getChannel()->getEventBase(), {isOneWay}));"
                  .format(sync_callback_name=sync_callback_name,
                      isOneWay=str(function.oneway).lower()))

                args = ["rpcOptions",
                        "std::move({0})".format(sync_callback_name)]
                args.extend(common_args)
                args_list = ", ".join(args)

                out("{name}({args_list});".format(name=function.name,
                                                args_list=args_list))

                out("getChannel()->getEventBase()->loopForever();")

                if not function.oneway:
                    with out("if (!_returnState.buf())"):
                        out("assert(_returnState.exception());")
                        out("std::rethrow_exception(_returnState.exception());")

                    if not function.returntype.is_void:
                        if not self._is_complex_type(function.returntype):
                            out("return recv_" + function.name +
                                "(_returnState);")
                        else:
                            out("recv_" + function.name +
                                "(_return, _returnState);")
                    else:
                        out("recv_" + function.name + "(_returnState);")

    def _get_sync_function_signature(self, function, uses_rpc_options=False):
        params = []

        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        if function.returntype.is_void:
            return_type = "void"
        elif not self._is_complex_type(function.returntype):
            return_type = self._type_name(function.returntype)
        else:
            return_type = "void"
            params.append(self._type_name(function.returntype) + "& _return")

        param_list = ", ".join(params)
        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False)

        return return_type + " {name}(" + param_list + ")"

    def _generate_client_future_function(self, service, function,
                                         uses_rpc_options=False):

        function_name = "future_" + function.name
        signature = self._get_future_function_signature(function,
                                                        uses_rpc_options)
        with out().defn(signature, name=function_name,
                    modifiers='virtual'):
            if not uses_rpc_options:
                args = ["::apache::thrift::RpcOptions()"]

                args.extend([arg.name for arg in function.arglist.members])
                args_list = ", ".join(args)

                out("return {function}({args});"
                      .format(function=function_name, args=args_list))
            else:
                common_args = []
                for arg in function.arglist.members:
                    common_args.append(arg.name)

                promise_name = self.tmp("promise")

                return_type = self._type_name(function.returntype)

                out("folly::Promise<{type}> {promise};"
                  .format(type=return_type, promise=promise_name))

                future_name = self.tmp("future")
                out("auto {future} = {promise}.getFuture();"
                  .format(future=future_name, promise=promise_name))

                args = ["rpcOptions"]
                end_args = []

                callback = self.tmp("callback")

                if function.returntype.is_void:
                    out("std::unique_ptr<apache::thrift::RequestCallback> "
                      "{callback}("
                      "new apache::thrift::FutureCallback<void>("
                      "std::move({promise}), {isOneWay}));"
                      .format(callback=callback,
                              promise=promise_name,
                              isOneWay=str(function.oneway).lower()))

                    args.append("std::move({0})".format(callback))

                else:
                    out("std::unique_ptr<apache::thrift::RequestCallback> "
                      "{callback}("
                      "new apache::thrift::FutureCallback<{type}>("
                      "std::move({promise}), recv_wrapped_{name}));"
                      .format(callback=callback,
                              type=return_type,
                              promise=promise_name,
                              name=function.name))

                    args.append("std::move({0})".format(callback))

                args.extend(common_args)
                args.extend(end_args)
                args_list = ", ".join(args)

                out("{name}({args_list});".format(name=function.name,
                                                args_list=args_list))

                out("return std::move({0});".format(future_name))

    def _get_future_function_signature(self, function, uses_rpc_options):
        params = []
        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        result_type = self._type_name(function.returntype)
        return_type = "folly::Future<" + result_type + ">"

        param_list = ", ".join(params)
        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False)

        return return_type + " {name}(" + param_list + ")"

    def _generate_client_async_function(self, service, function,
                                        uses_rpc_options=False,
                                        name_prefix=""):
        if not uses_rpc_options:
            signature = self._get_async_function_signature(function,
                                                           uses_rpc_options)
            with out().defn(signature, name=name_prefix + function.name,
                        modifiers='virtual'):
                args = ["::apache::thrift::RpcOptions()"]

                args.append("std::move(callback)")

                args.extend([arg.name for arg in function.arglist.members])
                args_list = ", ".join(args)

                out("{name}({args});".format(name=function.name, args=args_list))

        else:
            signature = self._get_async_function_signature(
                    function, uses_rpc_options=True, uses_callback_ptr=True)

            with out().defn(signature, name=name_prefix + function.name,
                        modifiers='virtual'):
                args = ["&writer", "rpcOptions"]
                args.append("std::move(callback)")

                for arg in function.arglist.members:
                    args.append(arg.name)

                args_list = ", ".join(args)

                with out("switch(getChannel()->getProtocolId())"):
                    for key, val, prot in self.protocols:
                        with out().case("apache::thrift::protocol::" + prot):
                            out("apache::thrift::{0}Writer writer;".format(val))
                            out("{name}T({args});".
                              format(name=function.name, args=args_list))

                    with out().case("default", nobreak=True):
                        out("throw apache::thrift::TApplicationException("
                          '"Could not find Protocol");')

    def _generate_templated_client_function(self, service, function):
        signature = self._get_async_function_signature(function,
                                                       uses_rpc_options=True,
                                                       uses_template=True,
                                                       uses_callback_ptr=True)

        func_name = function.name + "T"

        with out().defn(signature, name=func_name, output=self._out_tcc):
            is_sync = self.tmp("isSync")
            out("std::unique_ptr<apache::thrift::ContextStack> ctx = "
              "this->getContextStack(this->getServiceName(), "
              '"{0}.{1}", connectionContext_.get());'
              .format(service.name, function.name))

            out("{0}_{1}_pargs args;".format(service.name, function.name))

            # Generate list of function args
            for field in function.arglist.members:
                rtype = self._get_true_type(field.type)
                if rtype.is_string or rtype.is_container \
                        or rtype.is_struct:
                    out("args.{1} = const_cast<{0}*>(&{2});".format(
                            self._type_name(field.type),
                            field.name, field.name))
                else:
                    out("args.{0} = &{0};".format(field.name))

            if self.flag_compatibility:
                out("size_t bufSize = "
                  "{0}_{1}_pargs_serializedSizeZC(prot, &args);".
                  format(service.name, function.name))
            else:
                out("size_t bufSize = args.serializedSizeZC(prot);")

            out('bufSize += prot->serializedMessageSize("{name}");'
                .format(name=function.name))
            out("folly::IOBufQueue queue(folly::IOBufQueue::cacheChainLength());")
            out("prot->setOutput(&queue, bufSize);")
            out("auto guard = folly::makeGuard([&]{prot->setOutput(nullptr);});")
            out("")

            with out("try"):
                out('ctx->preWrite();')
                out("prot->writeMessageBegin"
                  "(\"{0}\", apache::thrift::T_CALL, 0);".format(
                              function.name))
                if self.flag_compatibility:
                    out("{0}_{1}_pargs_write(prot, &args);".format(
                            service.name, function.name))
                else:
                    out("args.write(prot);")
                out("prot->writeMessageEnd();")
                out("::apache::thrift::SerializedMessage smsg;")
                out("smsg.protocolType = prot->protocolType();")
                out("smsg.buffer = queue.front();")
                out("ctx->onWriteData(smsg);")
                out("ctx->postWrite(queue.chainLength());")

                with out().catch("apache::thrift::TException &ex"):
                    out("ctx->handlerError();")
                    out("throw;")
            out("")

            def sendRequest(ctx, args):
                argsStr = ", ".join(args)
                if not function.oneway:
                    out("this->channel_->sendRequest(" + argsStr + ");")
                else:
                    # Calling asyncComplete before sending because
                    # sendOnewayRequest moves from ctx and clears it.
                    out(ctx + "->asyncComplete();")
                    out("this->channel_->sendOnewayRequest(" + argsStr + ");")

            # Switch to the event base thread if we're not already in it
            out("auto eb = this->channel_->getEventBase();")
            with out("if(!eb || eb->isInEventBaseThread())"):
                sendRequest("ctx", [
                    "rpcOptions",
                    "std::move(callback)",
                    "std::move(ctx)",
                    "queue.move()"])
            with out("else"):
                out("auto mvCb = folly::makeMoveWrapper(std::move(callback));")
                out("auto mvCtx = folly::makeMoveWrapper(std::move(ctx));")
                out("auto mvBuf = folly::makeMoveWrapper(queue.move());")
                with out("eb->runInEventBaseThread(" +
                        "[this, rpcOptions, mvCb, mvCtx, mvBuf] () mutable"):
                    sendRequest("(*mvCtx)", [
                        "rpcOptions",
                        "std::move(*mvCb)",
                        "std::move(*mvCtx)",
                        "std::move(*mvBuf)"])
                out(");")

    def _get_async_function_signature(self,
                                      function,
                                      uses_rpc_options,
                                      uses_template=False,
                                      uses_callback_ptr=False):
        signature_prefix = ""
        if uses_template:
            signature_prefix = "template <typename Protocol_>\n"

        params = []
        if uses_template:
            params.append("Protocol_* prot")

        if uses_rpc_options:
            params.append("const apache::thrift::RpcOptions& rpcOptions")

        params.append("std::unique_ptr<apache::thrift::RequestCallback> "
                      "callback")

        param_list = ", ".join(params)

        param_list += self._argument_list(function.arglist,
                                          add_comma=bool(params),
                                          unique=False)

        return signature_prefix + "void {name}(" + param_list + ")"

    def _generate_client_std_function(self, function, name_prefix=""):
        sig = ("void {name}(std::function<void ("
               "::apache::thrift::ClientReceiveState&&)> callback" +
               self._argument_list(function.arglist, True, unique=False) + ")")

        args = ["std::unique_ptr<apache::thrift::RequestCallback>("
                "new apache::thrift::FunctionReplyCallback("
                "std::move(callback)))"]
        args.extend([arg.name for arg in function.arglist.members])
        args_list = ",".join(args)

        name = name_prefix + function.name
        with out().defn(sig, name=name, modifiers="virtual"):
            out("{name}({args});".format(name=function.name, args=args_list))

    def _generate_throwing_recv_function(self, function, uses_template):
        callee_name = function.name
        if uses_template:
            callee_name = callee_name + 'T'
        output = None
        if uses_template:
            output = self._out_tcc
        with out().defn(self._get_recv_function_signature(function,
                                                          uses_template),
                        name='recv_' + callee_name,
                        modifiers='static',
                        output=output):
            simple_return = not function.returntype.is_void and \
                not self._is_complex_type(function.returntype)
            if simple_return:
                out(self._type_name(function.returntype) + ' _return;')

            params = []
            if uses_template:
                params.append('prot')
            if not function.returntype.is_void:
                params.append('_return')
            params.append('state')
            func_name = 'recv_wrapped_' + function.name
            if uses_template:
                func_name = func_name + 'T'
            out('auto ew = {0}({1});'.format(func_name, ', '.join(params)))
            with out('if (ew)'):
                out('ew.throwException();')
            if simple_return:
                out('return _return;')

    def _generate_recv_functions(self, function):
        with out().defn(self._get_recv_function_signature(function,
                                                          is_wrapped=True),
                        name="recv_wrapped_" + function.name,
                        modifiers="static"):
            out('auto ew = state.exceptionWrapper();')
            with out('if (ew)'):
                out('return ew;')
            with out('if (!state.buf())'):
                out('return folly::make_exception_wrapper<'
                    'apache::thrift::TApplicationException>('
                    '"recv_ called without result");')
            with out("switch(state.protocolId())"):
                for key, value, prottype in self.protocols:
                    with out().case('apache::thrift::protocol::' + prottype,
                                    nobreak=True):
                        out("apache::thrift::{0}Reader reader;".format(value))

                        callee_name = "recv_wrapped" + function.name + "T"

                        args = ["&reader"]

                        if not function.returntype.is_void:
                            args.append("_return")

                        args.append("state")
                        args_list = ", ".join(args)

                        out('return recv_wrapped_' + function.name + 'T(' +
                            args_list + ');')

                with out().case("default", nobreak=True):
                    pass
            out('return folly::make_exception_wrapper<'
                'apache::thrift::TApplicationException>('
                '"Could not find Protocol");')

        self._generate_throwing_recv_function(function, False)

        # Most mock frameworks require your functions to be virtual instance
        # functions. Generating a virtual instance version of recv_ so
        # that folks wanting to mock the thrift service clients can use
        # this function and override in their mock objects.
        out("// Mock friendly virtual instance method")
        with out().defn(self._get_recv_function_signature(function),
                    name="recv_" + "instance_" + function.name,
                    modifiers="virtual"):

            params = []
            if self._is_complex_type(function.returntype):
                params.append('_return')
            params.append('state')
            if not function.oneway:
                if not function.returntype.is_void:
                    out("return recv_" + function.name +
                        "(" + ", ".join(params) + ");")
                else:
                    out("recv_" + function.name + "(" + ", ".join(params) +
                        ");")

        with out().defn(self._get_recv_function_signature(function,
                                                          is_wrapped=True),
                    name="recv_instance_wrapped_" + function.name,
                    modifiers="virtual"):

            params = []
            if not function.returntype.is_void:
                params.append('_return')
            params.append('state')
            if not function.oneway:
                out("return recv_wrapped_" + function.name +
                    "(" + ", ".join(params) + ");")

    def _generate_templated_recv_function(self, service, function):
        sig = self._get_recv_function_signature(function,
                                                uses_template=True,
                                                is_wrapped=True)

        with out().defn(sig,
                    name="recv_wrapped_" + function.name + "T",
                    modifiers="static",
                    output=self._out_tcc):
            with out('if (state.isException())'):
                out('return state.exceptionWrapper();')
            out("prot->setInput(state.buf());")
            out("auto guard = folly::makeGuard([&] {prot->setInput(nullptr);});")
            out("apache::thrift::ContextStack* ctx = state.ctx();")
            out("std::string fname;")
            out("int32_t protoSeqId = 0;")
            out("apache::thrift::MessageType mtype;")
            out("ctx->preRead();")

            out("folly::exception_wrapper interior_ew;")
            with out("auto caught_ew = folly::try_and_catch<"
                     "apache::thrift::TException, "
                     "apache::thrift::protocol::TProtocolException>([&]() "):
                out("prot->readMessageBegin(fname, mtype, protoSeqId);")

                with out("if (mtype == apache::thrift::T_EXCEPTION)"):
                    out("apache::thrift::TApplicationException x;")
                    out("x.read(prot);")
                    out("prot->readMessageEnd();")
                    out("interior_ew = folly::make_exception_wrapper<"
                        "apache::thrift::TApplicationException>(x);")
                    out("return; // from try_and_catch")

                with out("if (mtype != apache::thrift::T_REPLY)"):
                    out("prot->skip(apache::thrift::protocol::T_STRUCT);")
                    out("prot->readMessageEnd();")
                    out("interior_ew = folly::make_exception_wrapper<"
                        "apache::thrift::TApplicationException>("
                        "apache::thrift::TApplicationException"
                        "::TApplicationExceptionType::INVALID_MESSAGE_TYPE);")
                    out("return; // from try_and_catch")

                with out('if (fname.compare("' + function.name + '") != 0)'):
                    out("prot->skip(apache::thrift::protocol::T_STRUCT);")
                    out("prot->readMessageEnd();")
                    out("interior_ew = folly::make_exception_wrapper<"
                        "apache::thrift::TApplicationException>("
                        "apache::thrift::TApplicationException"
                        "::TApplicationExceptionType::WRONG_METHOD_NAME);")
                    out("return; // from try_and_catch")
                out("::apache::thrift::SerializedMessage smsg;")
                out("smsg.protocolType = prot->protocolType();")
                out("smsg.buffer = state.buf();")
                out("ctx->onReadData(smsg);")

                out("{0}_{1}_presult result;".format(service.name, function.name))

                if not function.returntype.is_void:
                    out("result.success = &_return;")

                if self.flag_compatibility:
                    out("{0}_{1}_presult_read(prot, &result);".format(
                            service.name, function.name))
                else:
                    out("result.read(prot);")

                out("prot->readMessageEnd();")
                out('ctx->postRead(state.buf()->length());')

                if not function.returntype.is_void:
                    with out("if (result.__isset.success)"):
                        out("// _return pointer has been filled")
                        out("return; // from try_and_catch")
                for xs in function.xceptions.members:
                    with out("if (result.__isset.{0})".format(xs.name)):
                        out("interior_ew = folly::make_exception_wrapper<"
                            "{0}>(result.{1});".format(
                                self._type_name(xs.type), xs.name))
                        out("return; // from try_and_catch")

                if not function.returntype.is_void:
                    with out("else"):
                        # else throw, no success
                        out("interior_ew = folly::make_exception_wrapper<"
                            "apache::thrift::TApplicationException>("
                            "apache::thrift::TApplicationException::"
                            "TApplicationExceptionType::MISSING_RESULT, "
                            '"failed: unknown result");')
                        out("return; // from try_and_catch")
            out(");")
            with out("if (interior_ew || caught_ew)"):
                out("ctx->handlerError();")
                out("return interior_ew ? interior_ew : caught_ew;")
            out("return folly::exception_wrapper();")

        self._generate_throwing_recv_function(function, True)

    def _get_recv_function_signature(self, function, uses_template=False,
                                     is_wrapped=False):
        signature_prefix = ""

        if uses_template:
            signature_prefix = "template <typename Protocol_>\n"

        if is_wrapped:
            signature_prefix += 'folly::exception_wrapper'
        elif function.returntype.is_void or \
           self._is_complex_type(function.returntype):
            signature_prefix += "void"
        else:
            signature_prefix += self._type_name(function.returntype)

        params = []
        if uses_template:
            params.append("Protocol_* prot")

        if not function.returntype.is_void and (
            self._is_complex_type(function.returntype) or is_wrapped
        ):
            params.append(self._type_name(function.returntype) + "& _return")

        params.append("::apache::thrift::ClientReceiveState& state")
        param_list = ", ".join(params)
        return signature_prefix + " {name}(" + param_list + ")"

    def _recv_has_void_return_type(self, function):
        return not self._function_produces_result(function) or \
               self._recv_uses_return_parameter(function)

    def _recv_uses_return_parameter(self, function):
        return self._function_produces_result(function) and \
               self._is_complex_type(function.returntype)

    def _function_produces_result(self, function):
        return_type = function.returntype
        return not return_type.is_void

    def _argument_list(self, arglist, add_comma, unique):
        out = ""
        for field in arglist.members:
            if len(out) > 0 or add_comma:
                out += ", "

            type_name = self._type_name(field.type,
                                        arg=True, unique=unique)

            out += type_name + " " + field.name

        return out

    # ======================================================================
    # STRUCT GENERATION CODE + following two sections
    # ======================================================================

    def _default_value(self, t):
        t = self._get_true_type(t)
        if t.is_base_type or t.is_enum:
            dval = None
            if t.is_enum:
                dval = "({0})0".format(self._type_name(t))
            elif t.is_string:
                dval = '{0}()'.format(self._type_name(t))
            else:
                dval = '0'
            return dval
        else:
            return False

    def _should_generate_field(self, field):
        return ('format' not in field.annotations or
                field.annotations['format'] != 'serialized')

    def _member_default_value(self, member, explicit=False):
        t = self._get_true_type(member.type)
        if member.value:
            return self._render_const_value(t, member.value)
        if t.is_base_type and not t.is_string:
            return '0'
        if explicit:
            return '{0}()'.format(self._type_name(t))
        return ''

    def _get_serialized_fields_options(self, obj):
        keep_unknown_fields = ('keep_unknown_fields' in obj.annotations and
                               obj.annotations['keep_unknown_fields'] == '1')
        return SerializedFieldOptions(
            keep_unknown_fields=keep_unknown_fields,
            has_serialized_fields=keep_unknown_fields or any(
                    'format' in field.annotations and
                    field.annotations['format'] == 'serialized'
                    for field in obj.members)
        )

    def _gen_union_constructor(self, s, obj, is_operator, is_move):
        i = OrderedDict()
        if is_operator:
            if is_move:
                sig = '{name}& operator=({name}&& rhs)'
            else:
                sig = '{name}& operator=(const {name}& rhs)'
        else:
            i['type_'] = 'Type::__EMPTY__'
            if is_move:
                sig = '{name}({name}&& rhs)'
            else:
                sig = '{name}(const {name}& rhs)'

        with s.defn(sig, name=obj.name, in_header=True, init_dict=i):
            out('if (this == &rhs) {{return{0}; }}'.format(
                ' *this' if is_operator else ''))
            if is_operator:
                out('__clear();')
            out('if (rhs.type_ == Type::__EMPTY__) {{ return{0}; }}'.format(
                ' *this' if is_operator else ''))

            with out('switch(rhs.type_)'):
                for member in obj.members:
                    with out().case('Type::' + member.name):
                        if is_move:
                            if self._is_reference(member):
                                fmt = 'set_{field}(std::move(*rhs.value_.{field}));'
                            else:
                                fmt = 'set_{field}(std::move(rhs.value_.{field}));'
                        elif self._is_reference(member):
                            fmt = 'set_{field}(*rhs.value_.{field});'
                        else:
                            fmt = 'set_{field}(rhs.value_.{field});'
                        out(fmt.format(field=member.name))
                with out().case('default'):
                    out('assert(false);')

            if is_move:
                out('rhs.__clear();')
            if is_operator:
                out('return *this;')

    def _gen_union_switch(self, members, stmt,
                          val='type_', default='assert(false);'):
        with out('switch({0})'.format(val)):
            for member in members:
                with out().case('Type::' + member.name):
                    out(stmt.format(field=member.name))
            with out().case('default'):
                out(default)

    def _generate_struct_complete(self, s, obj, is_exception,
                                  pointers, read, write, swap,
                                  result, has_isset=True):
        if not self.flag_implicit_templates:
            for a,b,c in self.protocols:
                if not self.flag_compatibility:
                    s.impl(("template uint32_t {1}::read<apache::thrift::{0}Reader>"
                           "(apache::thrift::{0}Reader*);").format(b,obj.name))
                    s.impl(("template uint32_t {1}::write<"
                            "apache::thrift::{0}Writer"">("
                            "apache::thrift::{0}Writer*) const;").format(
                                    b,obj.name))
                    s.impl(("template uint32_t {1}::serializedSize"
                           "<apache::thrift::{0}Writer>(apache::thrift::{0}Writer*)"
                            " const;").format(b,obj.name))
                    s.impl(("template uint32_t {1}::serializedSizeZC"
                            "<apache::thrift::{0}Writer>("
                            "apache::thrift::{0}Writer*) const;").format(
                                        b,obj.name))
                else:
                    s.impl(("template uint32_t {1}_read<"
                            "apache::thrift::{0}Reader>("
                            "apache::thrift::{0}Reader*, {1}*);").format(
                                        b,obj.name))
                    s.impl(("template uint32_t {1}_write<"
                            "apache::thrift::{0}Writer>("
                            "apache::thrift::{0}Writer*, const {1}*);").format(
                                    b,obj.name))
                    s.impl(("template uint32_t {1}_serializedSize<"
                            "apache::thrift::{0}Writer>("
                            "apache::thrift::{0}Writer*, const {1}*);").format(
                                    b,obj.name))
                    s.impl(("template uint32_t {1}_serializedSizeZC<"
                            "apache::thrift::{0}Writer>("
                            "apache::thrift::{0}Writer*, const {1}*);").format(
                                        b,obj.name))
            # Special case a few protocols
            if not self.flag_compatibility:
                s.impl(("template uint32_t {0}::write<"
                       "apache::thrift::DebugProtocolWriter>("
                        "apache::thrift::DebugProtocolWriter*) const;").format(
                                obj.name))
                s.impl(("template uint32_t {0}::read<"
                        "apache::thrift::VirtualReaderBase>("
                        "apache::thrift::VirtualReaderBase*);").format(obj.name))
            else:
                s.impl(
                    ("template uint32_t {0}_write<"
                     "apache::thrift::DebugProtocolWriter>("
                     "apache::thrift::DebugProtocolWriter*, const {0}*);").format(
                             obj.name))
                s.impl(("template uint32_t {0}_read<"
                        "apache::thrift::VirtualReaderBase>("
                        "apache::thrift::VirtualReaderBase*, {0}*);").format(
                                obj.name))

        if self.flag_compatibility:
            base = self._namespace_prefix(
                    self._program.get_namespace('cpp')) + obj.name
            s('typedef{0} {1};'.format(base, obj.name))

            if read:
                self._generate_struct_reader(s, obj, pointers,
                                             has_isset=has_isset)
            if write:
                for zc in False, True:
                    self._generate_struct_compute_length(
                            s, obj, pointers, result, zero_copy=zc)
                self._generate_struct_writer(s, obj, pointers, result)
            return

        extends = ' : private boost::totally_ordered<{0}>'.format(obj.name)
        if is_exception:
            extends += ', public apache::thrift::TException'
        # Open struct def
        struct = s.cls('class {0}{1}'.format(obj.name, extends)).scope
        struct.acquire()
        struct.label('public:')
        # Get members
        members = filter(self._should_generate_field, obj.members)
        has_nonrequired_fields = any(member.req != e_req.required
                                        for member in members)
        should_generate_isset = has_nonrequired_fields and \
            ((not pointers) or read) and not obj.is_union
        struct_options = self._get_serialized_fields_options(obj)

        # Type enum for unions
        if obj.is_union:
            with struct('enum Type'):
                out('__EMPTY__ = 0,')
                i = 0
                for member in members:
                    i += 1
                    out('{0} = {1},'.format(member.name, i))
            struct.sameLine(';')

        if not pointers:
            # Default constructor
            i = OrderedDict()
            if not obj.is_union:
                for member in members:
                    value = self._member_default_value(member)
                    if value:
                        i[member.name] = value
                struct()
            else:
                i['type_'] = 'Type::__EMPTY__'
            c = struct.defn('{name}()', name=obj.name,
                                    in_header=True, init_dict=i).scope.empty()

            if not obj.is_union:
                # Generate a initializer_list type constructor
                init_vars = []
                init_vars.append('apache::thrift::FragileConstructor')
                for member in members:
                    t = self._get_true_type(member.type)
                    typename = self._type_name(member.type)
                    if self._is_reference(member):
                        typename = "std::unique_ptr<" + typename + ">"
                    init_vars.append("{0} {1}__arg".format(
                        typename, member.name))
                i = OrderedDict()
                for member in members:
                    i[member.name] = 'std::move({name}__arg)'.format(
                        name=member.name)
                struct('// FragileConstructor for use in'
                       ' initialization lists only')
                c = struct.defn('{name}(' + ', '.join(init_vars) + ')',
                                name=obj.name,
                                in_header=True,
                                init_dict=i).scope.empty()

                is_copyable = self._is_copyable_struct(obj)
                # move constructor, move assignment, defaulted
                # (not implicitly declared because we have a destructor)
                if self._is_noex_move_ctor_struct(obj):
                    i = OrderedDict()
                    for member in members:
                        i[member.name] = 'std::move(other.{name})'.format(
                            name=member.name)
                    if should_generate_isset:
                        i['__isset'] = 'other.__isset'
                    c = struct.defn('{name}({name}&& other)',
                                    name=obj.name,
                                    in_header=True,
                                    no_except=True,
                                    init_dict=i).scope.empty()
                else:
                    c = struct.defn('{name}({name}&&)',
                                    name=obj.name, in_header=True, default=True)
                if is_copyable:
                    needs_copy_constructor = False
                    for member in members:
                        if self._is_reference(member):
                            needs_copy_constructor = True
                    if needs_copy_constructor:
                        src = self.tmp('src')
                        with struct.defn('{{name}}(const {0}& {1})'
                                         .format(obj.name, src),
                                         name=obj.name):
                            for member in members:
                                if self._is_reference(member):
                                    out("if ({2}.{0}) {0}.reset("
                                        "new {1}(*{2}.{0}));".format(
                                        member.name, self._type_name(
                                            member.type), src))
                                else:
                                    out("{0} = {1}.{0};".format(
                                        member.name, src))
                                if self._has_isset(member):
                                    out('__isset.{0} = {1}.__isset.{0};'.format(
                                        member.name, src))
                    else:
                        c = struct.defn(
                            '{name}(const {name}&)',
                            name=obj.name, in_header=True, default=True)
                c = struct.defn('{name}& operator=({name}&&)',
                                name=obj.name, in_header=True, default=True)
                if is_copyable:
                    if needs_copy_constructor:
                        src = self.tmp('src')
                        tmp = self.tmp('tmp')
                        with struct.defn('{0}& {{name}}(const {0}& {1})'
                                         .format(obj.name, src),
                                         name='operator='):
                            out('{name} {tmp}({src});'.format(
                                name=obj.name, tmp=tmp, src=src))
                            out('swap(*this, {tmp});'.format(tmp=tmp))
                            out('return *this;')
                    else:
                        c = struct.defn('{name}& operator=(const {name}&)',
                                    name=obj.name, in_header=True, default=True)

            else:
                # unions need to define the above constructors because of the
                # union member
                for op in False, True:
                    for mv in False, True:
                        self._gen_union_constructor(struct, obj, op, mv)

            if len(members) > 0:
                with struct.defn('void {name}()', name="__clear"):
                    if obj.is_union:
                        out('if (type_ == Type::__EMPTY__) { return; }')
                        self._gen_union_switch(members,
                            'destruct(value_.{field});')
                        out('type_ = Type::__EMPTY__;')
                    else:
                        for member in members:
                            t = self._get_true_type(member.type)
                            name = member.name + \
                                self._type_access_suffix(member.type)
                            if t.is_base_type or t.is_enum:
                                dval = self._member_default_value(
                                        member, explicit=True)
                                out('{0} = {1};'.format(name, dval))
                            elif t.is_struct or t.is_xception:
                                stype = self._get_true_type(
                                    member.type.as_struct)
                                if len(stype.members) > 0:
                                    if self._is_reference(member):
                                        out(('if ({1}) ' +
                                             '::apache::thrift::Cpp2Ops< {0}>' +
                                             '::clear({1}.get());').format(
                                                 self._type_name(member.type),
                                                                 name))
                                    else:
                                        out(('::apache::thrift::Cpp2Ops< {0}>' +
                                             '::clear(&{1});').format(
                                                 self._type_name(member.type),
                                                                 name))
                            elif t.is_container:
                                out('{0}.clear();'.format(name))
                            else:
                                raise TypeError('Unknown type for member:' +
                                                member.name)
                        if should_generate_isset:
                            out('__isset.__clear();')
                        if struct_options.has_serialized_fields:
                            out('{0}.reset();'.format(
                                self._serialized_fields_name))
        # END if not pointers

        if 'final' not in obj.annotations:
            with struct.defn('~{name}() throw()', name=obj.name,
                             modifiers='virtual', in_header=True):
                if obj.is_union:
                    out('__clear();')
            struct()

        s1 = struct
        if obj.is_union:
            s1 = struct('union storage_type').scope
            s1.acquire()

        # Declare all fields.
        for member in members:
            s1(self._declare_field(
                member,
                pointers and not member.type.is_xception,
                not read, False,
                self._is_reference(member)))

        if s1 is not struct:
            s1()
            s1('storage_type() {}')
            s1('~storage_type() {}')
            s1.release()
            struct.sameLine(';')

        # Isset struct has boolean fields, but only for non-required fields
        if should_generate_isset:
            struct()
            with struct.cls('struct __isset', epilogue=' __isset;') as ist:
                with ist.defn('__isset()', in_header=True):
                    out('__clear();')
                with ist.defn('void __clear()', in_header=True):
                    for member in members:
                        if self._has_isset(member):
                            out("{0} = false;".format(member.name))
                # Declare boolean fields
                ist()
                for member in members:
                    if self._has_isset(member):
                        ist('bool {0};'.format(member.name))
        if struct_options.has_serialized_fields:
            struct()
            struct('apache::thrift::ProtocolType {0};'.format(
                       self._serialized_fields_protocol_name))
            struct('{0} {1};'.format(self._serialized_fields_type,
                                     self._serialized_fields_name))
        if not pointers and not struct_options.has_serialized_fields:
            # Generate an equality testing operator.
            with struct.defn('bool {{name}}(const {0}& {1}) const'
                             .format(obj.name,
                                len(members) > 0 and 'rhs' or '/* rhs */'),
                             name='operator=='):
                if obj.is_union:
                    out('if (type_ != rhs.type_) { return false; }')
                    self._gen_union_switch(members,
                        'return value_.{field} == rhs.value_.{field};',
                        default='return true;')
                else:
                    for m in members:
                        # Most existing Thrift code does not use isset or
                        # optional/required, so we treat "default" fields as
                        # required.
                        if self._is_reference(m):
                            check = ("(({0} && rhs.{0} && *{0} == *rhs.{0}) ||"
                                     "(!{0} && !rhs.{0}))").format(m.name)
                        else:
                            check = "({0} == rhs.{0})".format(m.name)

                        ctype = self._get_true_type(m.type)
                        if ctype.is_base_type and ctype.as_base_type.is_binary:
                            check = "apache::thrift::StringTraits<{0}>::" \
                                "isEqual({1}, rhs.{1})".format(
                                self._type_name(ctype), m.name)
                        if m.req != e_req.optional or not self._has_isset(m):
                            with out('if (!({0}))'.format(
                                    check)):
                                out('return false;')
                        else:
                            with out('if (__isset.{0} != rhs.__isset.{0})'
                                    .format(m.name)):
                                out('return false;')
                            with out('else if'
                                    ' (__isset.{0} && !({1}))'
                                    .format(m.name, check)):
                                out('return false;')
                    out('return true;')

            # Generate the declaration of a less-than operator. This must be
            # implemented by the application developer if they wish to use it.
            # (They will get a link error if they try to use it without an
            # implementation.)i
            if self._is_orderable_type(obj) and \
              'no_default_comparators' not in obj.annotations:
                with struct.defn('bool operator < (const {0}& rhs) const'
                  .format(obj.name), in_header=True):
                    if obj.is_union:
                        out('if (type_ != rhs.type_)'
                            ' { return type_ < rhs.type_; }')
                        self._gen_union_switch(members,
                            'return value_.{field} < rhs.value_.{field};',
                            default='return false;')
                    else:
                        for m in members:
                            with out('if (!({0} == rhs.{0}))'
                                    .format(m.name)):
                                out('return {0} < rhs.{0};'.format(m.name))
                        out('return false;')
            else:
                struct('bool operator < (const {0}& rhs) const;'
                  .format(obj.name))

        # generate union accessors/settors
        if obj.is_union:
            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                with struct.defn('template<typename... T>\n'
                                 'void set_{name}(T&&... t)',
                                 in_header=True, name=member.name):
                    out('__clear();')
                    out('type_ = Type::{0};'.format(member.name))
                    if self._is_reference(member):
                        out('new (&value_.{0}) std::unique_ptr<{1}>('
                                'new {1}(std::forward<T>(t)...));'.format(
                                    member.name, t))
                    else:
                        out('new (&value_.{0}) {1}(std::forward<T>(t)...);'
                                .format(member.name, t))

            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                if self._is_reference(member):
                    t = "std::unique_ptr<" + t + ">"
                with struct.defn('get_{name}() const', in_header=True,
                        name=member.name,
                        modifiers='const {0}&'.format(t)):
                    out('assert(type_ == Type::{0});'.format(member.name))
                    out('return value_.{0};'.format(member.name))

            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                if self._is_reference(member):
                    t = "std::unique_ptr<" + t + ">"
                with struct.defn('mutable_{name}()', in_header=True,
                        name=member.name,
                        modifiers='{0}&'.format(t)):
                    out('assert(type_ == Type::{0});'.format(member.name))
                    out('return value_.{0};'.format(member.name))

            for member in members:
                t = self._type_name(self._get_true_type(member.type))
                if self._is_reference(member):
                    t = "std::unique_ptr<" + t + ">"
                with struct.defn('move_{name}()', in_header=True,
                        name=member.name, modifiers=t):
                    out('assert(type_ == Type::{0});'.format(member.name))
                    out('return std::move(value_.{0});'.format(member.name))

            struct()
            struct('Type getType() const { return type_; }')

        if read or write:
            struct()
        if read:
            self._generate_struct_reader(struct, obj, pointers)
        if write:
            for zc in False, True:
                self._generate_struct_compute_length(
                        struct, obj, pointers, result, zero_copy=zc)
            self._generate_struct_writer(struct, obj, pointers, result)
        if is_exception:
            if 'message' in obj.annotations:
                what = '{0}.c_str()'.format(obj.annotations['message'])
            else:
                what = '"{0}"'.format(self._type_name(obj))
            with struct.defn('virtual const char* what() const throw()',
                                   in_header=True) as x1:
                x1('return {0};'.format(what))

        # generate the union protected members
        if obj.is_union:
            struct.label('protected:')
            with struct.defn('template <class T>\n' + 'void destruct(T &val)',
                            in_header=True):
                out('(&val)->~T();')
            struct()
            struct('Type type_;')
            struct('storage_type value_;')

        # we're done with the struct definition
        struct.release()

        if swap:
            s = self._types_scope
            # Generate a namespace-scope swap() function
            with s.defn('void {{name}}({0}& a, {0}& b)'.format(obj.name),
                        name='swap'):
                if obj.is_union:
                    # For unions, the members cannot be swapped individually
                    # so instead we use the logic in the copy constructors to
                    # swap the object wholesale
                    out('{0} temp = a;'.format(obj.name))
                    out('a = std::move(b);')
                    out('b = std::move(temp);')
                else:
                    # Let argument-dependent name lookup find the correct swap()
                    # function to use based on the argument types. If none is found
                    # in the arguments' namespaces, fall back to ::std::swap().
                    out('using ::std::swap;')
                    has_nonrequired_fields = False
                    for tfield in members:
                        ttype = self._get_true_type(tfield.type)
                        if tfield.req != e_req.required:
                            has_nonrequired_fields = True
                        out('swap(a.{0}, b.{0});'.format(tfield.name))
                    if has_nonrequired_fields:
                        out('swap(a.__isset, b.__isset);')
                    if struct_options.has_serialized_fields:
                        out('swap(a.{0}, b.{0});'.format(
                                self._serialized_fields_protocol_name))
                        out('swap(a.{0}, b.{0});'.format(
                                self._serialized_fields_name))

    # ======================================================================
    # DESERIALIZATION CODE
    # ======================================================================

    def _generate_struct_reader(self, scope, obj,
                                pointers=False, has_isset=True):
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_read'.format(obj.name)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* iprot, ' + obj.name +
                           '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\n'
                           'uint32_t {name}(Protocol_* iprot)', name='read',
                           output=self._out_tcc)
        if obj.is_union:
            has_isset = False
        fields = obj.members

        struct_options = self._get_serialized_fields_options(obj)
        # s = scope of the read() function
        s = d.scope
        # Declare stack tmp variables
        s('uint32_t xfer = 0;')
        s('std::string fname;')
        s('apache::thrift::protocol::TType ftype;')
        s('int16_t fid;')
        s()
        s('xfer += iprot->readStructBegin(fname);')
        s()
        s('using apache::thrift::TProtocolException;')
        s()
        # Special handling for serialized fields
        if struct_options.has_serialized_fields:
            s('{0}->{1} = iprot->protocolType();'.format(
                this, self._serialized_fields_protocol_name))
            s('std::unique_ptr<folly::IOBuf> serialized;')
        # Required variables aren't in __isset, so we need tmp vars to
        # check them.
        req_fields = ifilter(lambda field: field.req == e_req.required,
                             fields)
        for field in req_fields:
            s('bool isset_{0.name} = false;'.format(field))
        s()

        fields_scope = None
        if obj.is_union:
            # Unions only have one member set, so don't loop
            s('xfer += iprot->readFieldBegin(fname, ftype, fid);')
            s1 = s('if (ftype == apache::thrift::protocol::T_STOP)').scope
            s1(this + '->__clear();')
            s1.release()
            fields_scope = s1 = s.sameLine('else').scope
        else:
            # Loop over reading in fields
            s1 = s('while (true)').scope
            # Save the position before the field beginning
            if struct_options.has_serialized_fields:
                s1('auto fbegin = iprot->getCurrentPosition();')
                s1('bool fserialized = false;')
            # Read beginning field marker
            s1('xfer += iprot->readFieldBegin(fname, ftype, fid);')
            # Check for field STOP marker
            with s1('if (ftype == apache::thrift::protocol::T_STOP)'):
                out('break;')
            fields_scope = s

        with s1('if (fid == std::numeric_limits<int16_t>::min())'):
            cond_type = 'if'
            for field in fields:
                with s1('{0} (fname == "{1}")'.format(cond_type, field.name)):
                    s1('fid = {0};'.format(field.key))
                    s1('ftype = {0};'.format(self._type_to_enum(field.type)))
                    cond_type = 'else if'

        # Switch statement on the field we are reading
        s2 = fields_scope('switch (fid)').scope
        # Generate deserialization code for known cases
        for field in fields:

            s3 = s2.case(field.key).scope
            if ('format' in field.annotations and
                    field.annotations['format'] == 'serialized'):
                s3('fserialized = true;')
                s3('xfer += iprot->skip(ftype);')
                s3.release()  # "break;"
                continue
            s4 = s3('if (ftype == {0})'.format(self._type_to_enum(
                    field.type))).scope
            with s4:
                field_prefix = this + '->'
                field_suffix = ''
                if obj.is_union:
                    s4(field_prefix + 'set_{0}();'.format(field.name))
                    field_prefix += 'mutable_'
                    field_suffix = '()'
                if pointers and not field.type.is_xception:
                    # This is only used for read pargs, so a const-cast is okay
                    # since the struct is exposed in generated code only.
                    self._generate_deserialize_field(
                        s4, field,
                        '(*const_cast<{0}*>('.format(
                                self._type_name(field.type)) +
                                                field_prefix,
                                                field_suffix + '))')
                else:
                    self._generate_deserialize_field(s4, field, field_prefix,
                                                     field_suffix)
                if has_isset and self._has_isset(field):
                    s4('{0}->__isset.{1} = true;'.format(this, field.name))
                elif field.req == e_req.required:
                    s4('isset_{1} = true;'.format(this, field.name))
            with s3.sameLine('else'):
                out('xfer += iprot->skip(ftype);')
                # TODO(dreiss): Make this an option when thrift structs have a
                # common base class.
                # s4('throw TProtocolException(TProtocolException::'
                #    'INVALID_DATA);')
            s3.release()  # "break;"
        # Default case
        with s2.case('default'):
            out('xfer += iprot->skip(ftype);')
            if struct_options.keep_unknown_fields:
                out('fserialized = true;')
        s2.release()  # switch
        # Read field end marker
        s1('xfer += iprot->readFieldEnd();')
        # Eat the stop byte that terminates union content
        if obj.is_union:
            s1('xfer += iprot->readFieldBegin(fname, ftype, fid);')
            s1('xfer += iprot->readFieldEnd();')
        if struct_options.has_serialized_fields:
            with s1('if (fserialized)').scope:
                out('iprot->readFromPositionAndAppend(fbegin, serialized);')
        s1.release()  # while(true)
        s('xfer += iprot->readStructEnd();')
        # Finalize serialized fields buffer if necessary
        if struct_options.has_serialized_fields:
            s()
            # Thrift is supposed to be called only with IOBuf that manage
            # underlying buffer. Thus it's safe to store IOBuf pointing to the
            # parts of original buffer inside the deserialized struct.
            # Note: it might be somewhat memory inefficient as we might be
            # pointing to a small chunk of the big buffer while keeping the
            # entire buffer around. However, the current implementation leaves
            # it to the application to call coalesce() on __serialized field
            # if necessary.
            with s('if (serialized)'):
                out(('{0}->{1} = std::move(serialized);').format(
                       this, self._serialized_fields_name))
        # Throw if any required fields are missing.
        # We do this after reading the struct end so that there might possibly
        # be a chance of continuing.
        s()
        for field in filter(self._should_generate_field, fields):
            if not field.req == e_req.required:
                continue
            with s('if (!isset_{0.name})'.format(field)):
                out(('throw TProtocolException(TProtocolException::'
                'MISSING_REQUIRED_FIELD, "Required field \'{0}\' was not found'
                'in serialized data! Struct: {1}");').format(
                        field.name, obj.name))
        s('return xfer;')
        s.release()  # the function

    def _generate_deserialize_field(self, scope, field, prefix='', suffix=''):
        'Deserializes a field of any type.'
        name = prefix + field.name + self._type_access_suffix(field.type) + \
                suffix
        self._generate_deserialize_type(
            scope, field.type, name, self._is_reference(field))

    def _generate_deserialize_type(self, scope, otype, name, pointer=False):
        'Deserializes a variable of any type.'
        ttype = self._get_true_type(otype)
        s = scope
        if ttype.is_void:
            raise TypeError('CANNOT GENERATE DESERIALIZE CODE FOR void TYPE: '\
                            + name)
        if ttype.is_struct or ttype.is_xception:
            self._generate_deserialize_struct(
                scope, otype, ttype.as_struct, name, pointer)
        elif ttype.is_container:
            self._generate_deserialize_container(scope, ttype.as_container,
                                                 name)
        elif ttype.is_base_type:
            btype = ttype.as_base_type
            base = btype.base
            if base == t_base.void:
                raise CompilerError("Cannot deserialize void field in a "
                    "struct: " + name)
            elif base == t_base.string:
                if btype.is_binary:
                    txt = 'readBinary({0})'
                else:
                    txt = 'readString({0})'
            elif base == t_base.bool:
                txt = 'readBool({0})'
            elif base == t_base.byte:
                txt = 'readByte({0})'
            elif base == t_base.i16:
                txt = 'readI16({0})'
            elif base == t_base.i32:
                txt = 'readI32({0})'
            elif base == t_base.i64:
                txt = 'readI64({0})'
            elif base == t_base.double:
                txt = 'readDouble({0})'
            elif base == t_base.float:
                txt = 'readFloat({0})'
            else:
                raise CompilerError('No C++ reader for base type ' + \
                        btype.t_base_name(base) + name)
            txt = 'xfer += iprot->{0};'.format(txt.format(name))
            s(txt)
        elif ttype.is_enum:
            t = self.tmp('ecast')
            s('int32_t {0};'.format(t))
            s('xfer += iprot->readI32({0});'.format(t))
            s('{0} = ({1}){2};'.format(name, self._type_name(ttype), t))
        else:
            raise TypeError(("DO NOT KNOW HOW TO DESERIALIZE '{0}' "
                             "TYPE {1}").format(name, self._type_name(ttype)))

    def _generate_deserialize_struct(
            self, scope, otype, struct, prefix, pointer=False):
        if pointer:
            scope("{0} = std::unique_ptr<{1}>(new {1});".format(
                prefix, self._type_name(otype)))
            scope('xfer += ::apache::thrift::Cpp2Ops< {0}>::read('
                  'iprot, {1}.get());'.format(
                      self._type_name(otype), prefix))
            scope('if (false) {}')
            for member in struct.members:
                if self._is_reference(member):
                    scope('else if ({0}->{1}) {{}}'.format(
                            prefix, member.name))
                elif self._has_isset(member):
                    scope('else if ({0}->__isset.{1}) {{}}'.format(
                            prefix, member.name))
            with scope('else'):
                out("{0} = nullptr;".format(prefix))
        else:
            scope('xfer += ::apache::thrift::Cpp2Ops< {0}>::read('
                  'iprot, &{1});'.format(
                      self._type_name(otype), prefix))

    def _generate_deserialize_container(self, scope, cont, prefix):
        s = scope
        size = self.tmp('_size')
        ktype = self.tmp('_ktype')
        vtype = self.tmp('_vtype')
        etype = self.tmp('_etype')
        cpptype = self._cpp_type_name(cont)
        use_push = (cpptype is not None and 'list' in cpptype) \
            or self._has_cpp_annotation(cont, 'template')
        s(prefix + '.clear();')
        s('uint32_t {0};'.format(size))
        # Declare variables, read header
        if cont.is_map:
            s('apache::thrift::protocol::TType {0};'.format(ktype))
            s('apache::thrift::protocol::TType {0};'.format(vtype))
            s('xfer += iprot->readMapBegin({0}, {1}, {2});'.format(
                ktype, vtype, size))
        elif cont.is_set:
            s('apache::thrift::protocol::TType {0};'.format(etype))
            s('xfer += iprot->readSetBegin({0}, {1});'.format(etype, size))
        elif cont.is_list:
            s('apache::thrift::protocol::TType {0};'.format(etype))
            txt = 'xfer += iprot->readListBegin({0}, {1});'.format(etype, size)
            s(txt)
        # For loop iterates over elements
        i = self.tmp('_i')
        s('uint32_t {0};'.format(i))

        with s('if ({0} == {1})'
               .format(size, 'std::numeric_limits<uint32_t>::max()')):
            peek = 'false'
            if cont.is_map:
                peek = 'iprot->peekMap()'
            elif cont.is_set:
                peek = 'iprot->peekSet()'
            elif cont.is_list:
                peek = 'iprot->peekList()'

            with s('for ({0} = 0; {1}; {0}++)'.format(i, peek)):
                if cont.is_map:
                    self._generate_deserialize_map_element(
                            out(), cont.as_map, prefix)
                elif cont.is_set:
                    self._generate_deserialize_set_element(
                            out(), cont.as_set, prefix)
                elif cont.is_list:
                    if not use_push:
                        s('{0}.resize({1} + 1);'.format(prefix, i))
                    self._generate_deserialize_list_element(out(), cont.as_list,
                                                            prefix, use_push, i)
        with s('else'):
            if cont.is_list and not use_push:
                s('{0}.resize({1});'.format(prefix, size))
            elif cont.is_map and cont.as_map.is_unordered:
                s('{0}.reserve({1});'.format(prefix, size))
            with s('for ({0} = 0; {0} < {1}; ++{0})'.format(i, size)):
                if cont.is_map:
                    self._generate_deserialize_map_element(
                            out(), cont.as_map, prefix)
                elif cont.is_set:
                    self._generate_deserialize_set_element(
                            out(), cont.as_set, prefix)
                elif cont.is_list:
                    self._generate_deserialize_list_element(out(), cont.as_list,
                                                            prefix, use_push, i)
        # Read container end
        if cont.is_map:
            s('xfer += iprot->readMapEnd();')
        elif cont.is_set:
            s('xfer += iprot->readSetEnd();')
        elif cont.is_list:
            s('xfer += iprot->readListEnd();')

    def _generate_deserialize_map_element(self, scope, tmap, prefix):
        'Generates code to deserialize a map'
        key = self.tmp('_key')
        val = self.tmp('_val')
        fkey = frontend.t_field(tmap.key_type, key)
        fval = frontend.t_field(tmap.value_type, val)
        scope(self._declare_field(fkey))
        self._generate_deserialize_field(scope, fkey)
        scope('{0} = {1}[std::move({2})];'.format(
            self._declare_field(fval, reference=True), prefix, key))
        self._generate_deserialize_field(scope, fval)

    def _generate_deserialize_set_element(self, scope, tset, prefix):
        elem = self.tmp('_elem')
        felem = frontend.t_field(tset.elem_type, elem)
        scope(self._declare_field(felem))
        self._generate_deserialize_field(scope, felem)
        scope('{0}.insert(std::move({1}));'.format(prefix, elem))

    def _generate_deserialize_list_element(self, scope, tlist, prefix,
                                           use_push, index):
        if use_push:
            elem = self.tmp('_elem')
            felem = frontend.t_field(tlist.elem_type, elem)
            scope(self._declare_field(felem))
            self._generate_deserialize_field(scope, felem)
            scope('{0}.push_back(std::move({1}));'.format(prefix, elem))
        else:
            felem = frontend.t_field(tlist.elem_type, '{0}[{1}]'.format(prefix,
                                                                        index))
            self._generate_deserialize_field(scope, felem)

    # ======================================================================
    # SERIALIZATION CODE
    # ======================================================================

    def _generate_struct_compute_length(self, scope, obj,
                                        pointers=False,
                                        result=False,
                                        zero_copy=False):
        method = "serializedSizeZC" if zero_copy else "serializedSize"
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_{1}'.format(obj.name, method)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* prot_, const ' +
                           obj.name + '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\n'
                        'uint32_t {name}(Protocol_* prot_) const',
                        name=method,
                        output=self._out_tcc)

        struct_options = self._get_serialized_fields_options(obj)

        s = d.scope
        if struct_options.has_serialized_fields:
            with s('if ({0}->{1} && '
                    'prot_->protocolType() != {0}->{2})'.format(
                        this,
                        self._serialized_fields_name,
                        self._serialized_fields_protocol_name)):
                out('using apache::thrift::TProtocolException;')
                out('throw TProtocolException(TProtocolException::BAD_VERSION);')
        s('uint32_t xfer = 0;')
        s('xfer += prot_->serializedStructSize("{0}");'.format(obj.name))

        # unions need a case statement to select which member is active
        s0 = s
        if obj.is_union:
            s = s0('switch({0}->getType())'.format(this)).scope

        first = True
        for field in filter(self._should_generate_field, obj.members):
            isset_expr = ('{0}->{1}' if self._is_reference(field)
                          else '{0}->__isset.{1}').format(this, field.name)
            if result == True:
                if first:
                    first = False
                    s1 = s('if ({0})'.format(isset_expr)).scope
                else:
                    s1 = s('else if ({0})'.format(isset_expr)).scope
            elif field.req == e_req.optional:
                s1 = s('if ({0})'.format(isset_expr)).scope

            elif obj.is_union:
                s1 = s.case(obj.name + '::Type::' + field.name).scope
            elif self.flag_terse_writes and not field.req == e_req.required:
                s1 = self._try_terse_write(field, this, s, pointers)
            else:
                s1 = s
            # Add the size of field header + footer
            s1('xfer += prot_->serializedFieldSize("{0}", {1}, {2});'
               ''.format(field.name, self._type_to_enum(field.type),
                                field.key))
            # Add the sizes of field contents
            field_prefix = this + '->'
            field_suffix = ''
            if obj.is_union:
                field_prefix += 'get_'
                field_suffix = '()'
            if pointers and not field.type.is_xception:
                self._generate_serialize_field(
                    s1, field,
                    '(*const_cast<{0}*>('.format(
                            self._type_name(field.type)) + field_prefix,
                    field_suffix + '))',
                    method="serializedSize",
                    struct_method=method,
                    binary_method=method)
            else:
                self._generate_serialize_field(s1, field, field_prefix,
                                               field_suffix,
                                               method="serializedSize",
                                               struct_method=method,
                                               binary_method=method)
            if s1 is not s:
                s1.release()  # if this->__isset.{0}
        if s0 is not s:
            s('case ' + obj.name + '::Type::__EMPTY__:;')
            s.release()
            s = s0

        if struct_options.has_serialized_fields:
            s('xfer += prot_->serializedSizeSerializedData({0}->{1});'
                    .format(this, self._serialized_fields_name))
        s('xfer += prot_->serializedSizeStop();')
        s('return xfer;')
        s.release()

    def _try_terse_write(self, field, this, s, pointers):
        'Generates a terse write predicate for unspecified field, if possible'
        t = self._get_true_type(field.type)
        # Not possible for void/struct/exception.
        if t.is_void or t.is_struct or t.is_xception:
            return s

        # Terse write is unsafe to use without explicitly setting default
        # value as in PHP / Python that would change result of deserialization
        # (comparing with the case when terse_writes is not used): field set
        # in C++ to default value would be deserialized as null / None.
        if self.safe_terse_writes and field.value is None:
            return s

        cmpval = (('(*' + this + '->{0})') if pointers else
                  ('' + this + '->{0}')).format(field.name)

        # For strings, containers - only support predicate if default
        # value is empty.
        if t.is_string:
            if not field.value or len(field.value.string) == 0:
                return s('if (!apache::thrift::StringTraits< {0}>::'
                         'isEmpty({1}))'.format(
                             self._type_name(t), cmpval)).scope
            else:
                return s

        if t.is_container:
            if not field.value:  # only support empty default.
                return s('if (!{0}.empty())'.format(cmpval)).scope
            else:
                return s  # Otherwise, no terse_write possible

        # For base type/enum, check vs. default const value.
        if t.is_base_type or t.is_enum:
            return s('if ({0} != {1})'.format(
                    cmpval, self._member_default_value(field,
                                                       explicit=True))).scope
        return s

    def _generate_struct_writer(self, scope, obj, pointers=False,
                                result=False):
        'Generates the write function.'
        this = 'this'
        if self.flag_compatibility:
            this = 'obj'
            name = '{0}_write'.format(obj.name)
            d = scope.defn('template <class Protocol_>\n' +
                           'uint32_t {name}(Protocol_* prot_, const ' +
                           obj.name + '* obj)',
                           name=name,
                           output=self._out_tcc)
        else:
            d = scope.defn('template <class Protocol_>\nuint32_t {name}'
                           '(Protocol_* prot_) const', name='write',
                           output=self._out_tcc)
        s = d.scope
        name = obj.name
        fields = filter(self._should_generate_field, obj.members)

        struct_options = self._get_serialized_fields_options(obj)

        if struct_options.has_serialized_fields:
            with s('if ({0}->{1} && '
                    'Protocol_::protocolType() != {0}->{2})'.format(
                        this,
                        self._serialized_fields_name,
                        self._serialized_fields_protocol_name)).scope:
                out('using apache::thrift::TProtocolException;')
                out('throw TProtocolException(TProtocolException::BAD_VERSION);')

        s('uint32_t xfer = 0;')
        s('xfer += prot_->writeStructBegin("{0}");'.format(name))

        # unions need a case statement to select which member is active
        s0 = s
        if obj.is_union:
            s = s0('switch({0}->getType())'.format(this)).scope

        first = True
        for field in fields:
            isset_expr = ('{0}->{1}' if self._is_reference(field)
                          else '{0}->__isset.{1}').format(this, field.name)
            if result == True:
                if first:
                    first = False
                    s1 = s('if ({0})'.format(isset_expr)).scope
                else:
                    s1 = s('else if ({0})'.format(isset_expr)).scope
            elif field.req == e_req.optional:
                s1 = s('if ({0})'.format(isset_expr)).scope
            elif obj.is_union:
                s1 = s.case(obj.name + '::Type::' + field.name).scope
            elif self.flag_terse_writes and not field.req == e_req.required:
                s1 = self._try_terse_write(field, this, s, pointers)
            else:
                s1 = s
            # Write field header
            s1('xfer += prot_->writeFieldBegin("{0}", {1}, {2});'.format(
                field.name, self._type_to_enum(field.type), field.key))
            # Write field contents
            field_prefix = this + '->'
            field_suffix = ''
            if obj.is_union:
                field_prefix += 'get_'
                field_suffix = '()'
            if pointers and not field.type.is_xception:
                self._generate_serialize_field(
                    s1, field,
                    '(*const_cast<{0}*>('.format(
                        self._type_name(field.type)) + field_prefix,
                    field_suffix + '))')
            else:
                self._generate_serialize_field(s1, field, field_prefix,
                                               field_suffix)
            # Write field closer
            s1('xfer += prot_->writeFieldEnd();')
            if s1 is not s:
                s1.release()  # if this->_isset.{0}
        if s0 is not s:
            s('case ' + obj.name + '::Type::__EMPTY__:;')
            s.release()
            s = s0
        # Flush any fields stored in serialized form
        if struct_options.has_serialized_fields:
            s('xfer += prot_->writeSerializedData({0}->{1});'.format(
                this, self._serialized_fields_name))
        # Write the struct map
        s('xfer += prot_->writeFieldStop();')
        s('xfer += prot_->writeStructEnd();')
        s('return xfer;')
        s.release()  # the function

    def _generate_serialize_field(self, scope, tfield, prefix='', suffix='',
                                  method='write',
                                  struct_method=None,
                                  binary_method=None):
        'Serializes a field of any type.'
        name = prefix + tfield.name + self._type_access_suffix(tfield.type) + \
                suffix
        pointer = self._is_reference(tfield)
        self._generate_serialize_type(scope, tfield.type, name, method,
                                      struct_method, binary_method, pointer)

    def _generate_serialize_type(self, scope, otype, name,
                                 method='write',
                                 struct_method=None,
                                 binary_method=None,
                                 pointer=False):
        'Serializes a variable of any type.'
        ttype = self._get_true_type(otype)
        if struct_method is None:
            struct_method = method
        if binary_method is None:
            binary_method = method

        # Do nothing for void types
        if ttype.is_void:
            raise TypeError('CANNOT GENERATE SERIALIZE CODE FOR void TYPE: '\
                            + name)
        if ttype.is_struct or ttype.is_xception:
            self._generate_serialize_struct(scope, otype, ttype.as_struct, name,
                                            struct_method, pointer)
        elif ttype.is_container:
            self._generate_serialize_container(scope, ttype.as_container,
                                               name,
                                               method,
                                               struct_method=struct_method,
                                               binary_method=binary_method)
        elif ttype.is_base_type:
            btype = ttype.as_base_type
            base = btype.base
            if base == t_base.void:
                raise CompilerError('Cannot serialize void field in a '
                                    'struct: ' + name)
            elif base == t_base.string:
                if btype.is_binary:
                    txt = '{binary_method}Binary({name});'
                else:
                    txt = '{method}String({name});'
            elif base == t_base.bool:
                txt = '{method}Bool({name});'
            elif base == t_base.byte:
                txt = '{method}Byte({name});'
            elif base == t_base.i16:
                txt = '{method}I16({name});'
            elif base == t_base.i32:
                txt = '{method}I32({name});'
            elif base == t_base.i64:
                txt = '{method}I64({name});'
            elif base == t_base.double:
                txt = '{method}Double({name});'
            elif base == t_base.float:
                txt = '{method}Float({name});'
            else:
                raise CompilerError('No C++ writer for base type ' + \
                        btype.t_base_name(base) + name)
            txt = 'xfer += prot_->' + txt.format(name, **locals())
            scope(txt)
        elif ttype.is_enum:
            scope('xfer += prot_->{0}I32((int32_t){1});'.format(method, name))
        else:
            raise TypeError(("DO NOT KNOW HOW TO SERIALIZE '{0}' "
                             "TYPE {1}").format(name, self._type_name(ttype)))

    def _generate_serialize_struct(self, scope, otype, tstruct, prefix='',
                                   method='write', pointer=False):
        if pointer:
            with scope('if ({0})'.format(prefix)):
                out('xfer += ::apache::thrift::Cpp2Ops< {0}>::{1}('
                    'prot_, {2}.get());'.format(
                        self._type_name(otype),
                        method,
                        prefix))
            with scope('else'):
                out('prot_->writeStructBegin(\"{0}\");'.format(tstruct.name))
                out('prot_->writeStructEnd();')
                out('prot_->writeFieldStop();')
        else:
            scope('xfer += ::apache::thrift::Cpp2Ops< {0}>::{1}('
                  'prot_, &{2});'.format(
                      self._type_name(otype),
                      method,
                      prefix))

    def _generate_serialize_container(self, scope, ttype, prefix='',
                                      method='write', **kwargs):
        tte = self._type_to_enum
        s = scope
        if ttype.is_map:
            s('xfer += prot_->{0}MapBegin({1}, {2}, {3}.size());'.format(
                    method,
                    tte(ttype.as_map.key_type),
                    tte(ttype.as_map.value_type),
                    prefix))
        elif ttype.is_set:
            s('xfer += prot_->{0}SetBegin({1}, {2}.size());'.format(
                    method,
                    tte(ttype.as_set.elem_type),
                    prefix))
        elif ttype.is_list:
            s('xfer += prot_->{0}ListBegin({1}, {2}.size());'.format(
                    method,
                    tte(ttype.as_list.elem_type),
                    prefix))
        ite = self.tmp('_iter')
        typename = self._type_name(ttype)
        with s('for (auto {0} = {1}.begin(); {0} != {1}.end(); ++{0})'.format(
                ite, prefix)):
            if ttype.is_map:
                self._generate_serialize_map_element(out(), ttype.as_map,
                                                     ite, method, **kwargs)
            elif ttype.is_set:
                self._generate_serialize_set_element(out(), ttype.as_set,
                                                     ite, method, **kwargs)
            elif ttype.is_list:
                self._generate_serialize_list_element(out(), ttype.as_list,
                                                      ite, method, **kwargs)
        if ttype.is_map:
            s('xfer += prot_->{0}MapEnd();'.format(method))
        elif ttype.is_set:
            s('xfer += prot_->{0}SetEnd();'.format(method))
        elif ttype.is_list:
            s('xfer += prot_->{0}ListEnd();'.format(method))

    def _generate_serialize_map_element(self, scope, tmap, iter_,
                                        method='write', **kwargs):
        kfield = frontend.t_field(tmap.key_type, iter_ + '->first')
        self._generate_serialize_field(scope, kfield, method=method, **kwargs)
        vfield = frontend.t_field(tmap.value_type, iter_ + '->second')
        self._generate_serialize_field(scope, vfield, method=method, **kwargs)

    def _generate_serialize_set_element(self, scope, tset, iter_,
                                        method='write', **kwargs):
        efield = frontend.t_field(tset.elem_type, "(*{0})".format(iter_))
        self._generate_serialize_field(scope, efield, method=method, **kwargs)

    def _generate_serialize_list_element(self, scope, tlist, iter_,
                                         method='write', **kwargs):
        efield = frontend.t_field(tlist.elem_type, "(*{0})".format(iter_))
        self._generate_serialize_field(scope, efield, method=method, **kwargs)

    # ======================================================================
    # GENERATE STRUCT
    # ======================================================================

    def _generate_cpp2ops(self, compat, obj, scope):
        ns = self._namespace_prefix(self._get_namespace())
        if self.flag_compatibility and compat:
            compat_ns = self._namespace_prefix(
                self._program.get_namespace('cpp'))
        else:
            compat_ns = ns
        compat_full_name = compat_ns + obj.name
        full_name = ns + obj.name

        if not compat and len(obj.members) > 0:
            with scope.defn(
                ('template <> inline '
                 'void Cpp2Ops<{compat_full_name}>::clear('
                 '{full_name}* obj)'.
                 format(**locals())), in_header=True):
                out('return obj->__clear();')

        ops = (('write', True),
               ('read', False),
               ('serializedSize', True),
               ('serializedSizeZC', True))

        for method, is_const in ops:
            const = 'const' if is_const else ''
            with scope.defn(
                ('template <> template <class Protocol> inline '
                 'uint32_t Cpp2Ops<{compat_full_name}>::{method}('
                 'Protocol* proto, {const} {full_name}* obj)'.
                 format(**locals())), name=method, in_header=True):
                if self.flag_compatibility:
                    out(('return {full_name}_{method}(proto, obj);'.
                      format(**locals())))
                else:
                    out('return obj->{method}(proto);'.format(**locals()))

    def _generate_frozen_layout(self, obj, s):
        fields = sorted(obj.as_struct.members, key=lambda field: field.key)
        type_name = self._type_name(obj)

        def visitFields(fmt, fieldFmt, **kwargs):
            return fmt.format(
                type=type_name,
                fields=''.join([
                    fieldFmt.format(
                        type=self._type_name(f.type),
                        name=f.name,
                        _opt='_OPT' if f.req == e_req.optional else
                             '_REQ' if f.req == e_req.required else '',
                        id=f.key,
                        **kwargs) for f in fields]),
                **kwargs)
        s(visitFields(
            'FROZEN_TYPE({type},{fields}{view}{save}{load});',
            '\n  FROZEN_FIELD{_opt}({name}, {id}, {type})',
            view=visitFields(
                '\n  FROZEN_VIEW({fields})',
                '\n    FROZEN_VIEW_FIELD{_opt}({name}, {type})'),
            save=visitFields(
                '\n  FROZEN_SAVE_INLINE({fields})',
                '\n    FROZEN_SAVE_FIELD({name})'),
            load=visitFields(
                '\n  FROZEN_LOAD_INLINE({fields})',
                '\n    FROZEN_LOAD_FIELD({name}, {id})')))

        for (typeFmt, fieldFmt) in [
                ('CTOR', 'CTOR_FIELD{_opt}({name}, {id})'),
                ('LAYOUT', 'LAYOUT_FIELD{_opt}({name})'),
                ('FREEZE', 'FREEZE_FIELD{_opt}({name})'),
                ('THAW', 'THAW_FIELD{_opt}({name})'),
                ('DEBUG', 'DEBUG_FIELD({name})'),
                ('CLEAR', 'CLEAR_FIELD({name})')]:
            # TODO(5484874): Put these back in the .cpp
            s(visitFields('FROZEN_' + typeFmt + '({type},{fields})',
                          '\n  FROZEN_' + fieldFmt))

    def _generate_hash_equal_to(self, obj):
        # Don't generate these declarations if in compatibility mode since
        # they're already declared for cpp.
        if self.flag_compatibility:
            return

        gen_hash = self._has_cpp_annotation(obj, 'declare_hash')
        gen_equal_to = self._has_cpp_annotation(obj, 'declare_equal_to')
        if gen_hash or gen_equal_to:
            full_name = self._namespace_prefix(
                    self._program.get_namespace('cpp')) + obj.name
            with self._types_global.namespace('std').scope:
                if gen_hash:
                    out('template<> struct hash<typename ' + full_name + '> {')
                    out('size_t operator()(const ' + full_name + '&) const;')
                    out("};")

                if gen_equal_to:
                    out('template<> struct equal_to<typename ' + full_name + '> {')
                    out('bool operator()(const ' + full_name + '&,')
                    out('const ' + full_name + '&) const;')
                    out("};")

    def _generate_cpp_struct(self, obj, is_exception=False):
        # We write all of these to the types scope
        scope = self._types_scope
        self._generate_struct_complete(scope, obj, is_exception,
                                       False, True, True, True, False)

        # We're at types scope now
        scope.release()
        with self._types_global.namespace('apache.thrift').scope:
            self._generate_cpp2ops(False, obj, self._types_scope)

        # std::hash and std::equal_to declarations
        self._generate_hash_equal_to(obj)

        # Re-enter types scope, but we can't actually re-enter a scope,
        # so let's recreate it
        scope = self._types_scope = \
                scope.namespace(self._get_namespace()).scope
        scope.acquire()

    def _generate_object(self, obj):
        self._generate_cpp_struct(obj, obj.is_xception)

    _generate_map = {
        frontend.t_typedef: _generate_typedef,
        frontend.t_enum: _generate_enum,
        frontend.t_struct: _generate_object,
        frontend.t_service: _generate_service,
    }

    def _generate(self, what):
        '''This uses a class-static map of (parse_type -> function that
        generates that kind of object), defined above.'''
        # TODO This feels a little hackish. Maybe change this into individual
        # per-type functions, and also change t_generator.generate_program() to
        # call those functions instead of only _generate().
        try:
            gen_func = self._generate_map[what.__class__]
            gen_func(self, what)
        except KeyError:
            print("Warning: Did not generate {}".format(what))

    def _render_const_value(self, type_, value, explicit=False):
        ''' Returns an initializer list rval representing this const
        '''
        t = self._get_true_type(type_)
        if t.is_base_type:
            int32 = lambda x: str(x.integer)
            int64 = lambda x: str(x.integer) + "LL"

            bt = t.as_base_type
            mapping = {
                t_base.string: lambda x:
                ('apache::thrift::StringTraits< {0}>::fromStringLiteral(' +
                 '"{1}")').format(self._type_name(t), x.string),
                t_base.bool: lambda x: (x.integer > 0 and 'true' or 'false'),
                t_base.byte: lambda x: ("(int8_t)" + str(x.integer)),
                t_base.i16: lambda x: ("(int16_t)" + str(x.integer)),
                t_base.i32: int32,
                t_base.i64: int64,
                t_base.double:
                    lambda x: (x.type == e_cv_type.integer
                                 and str(x.integer)
                                 or str(x.double)),
                t_base.float:
                    lambda x: (x.type == e_cv_type.integer
                                 and str(x.integer)
                                 or str(x.double))
            }
            if not bt.base in mapping:
                # TODO replace bt.t_base_name(bt.base) with bt.base.LABEL
                # However, (afaik) boost::python apparently doesn't support
                # reverse label lookups for enums
                raise CompilerError("No const of base type " + \
                                    bt.t_base_name(bt.base))
            return mapping[bt.base](value)
        elif t.is_enum:
            return '{0}::{1}'.format(self._type_name(t),
                                    t.find_value(value.integer).name)
        elif t.is_struct or t.is_xception:
            value_map = {}
            for k, v in value.map.items():
                value_map[k.string] = v
            if not value_map:
                return '{0}()'.format(self._type_name(t)) if explicit else None
            fields = filter(self._should_generate_field, t.as_struct.members)
            out_list = ['apache::thrift::FRAGILE']
            for field in fields:
                if field.name in value_map:
                    val = self._render_const_value(field.type,
                                                   value_map[field.name],
                                                   explicit=True)
                else:
                    val = self._member_default_value(field, explicit=True)
                out_list.append(val or "")
            return '{0}({1})'.format(self._type_name(t), ', '.join(out_list))
        elif t.is_map:
            outlist = []
            for key, value in value.map.items():
                key_render = self._render_const_value(t.key_type, key,
                                                      explicit=True)
                value_render = self._render_const_value(t.value_type, value,
                                                        explicit=True)
                outlist.append('{{{0}, {1}}}'.format(key_render, value_render))
            if not outlist:
                return '{}' if explicit else None
            return '{' + ', '.join(outlist) + '}'
        elif t.is_list:
            outlist = []
            for item in value.list:
                field_render = self._render_const_value(
                    t.as_list.elem_type, item, explicit=True)
                outlist.append(field_render)
            if not outlist:
                return '{}' if explicit else None
            return 'std::initializer_list<' + \
                self._type_name(t.as_list.elem_type) + '>{' + \
                ', '.join(outlist) + '}'
        elif t.is_set:
            outlist = []
            for item in value.list:
                field_render = self._render_const_value(t.as_set.elem_type,
                                                        item, explicit=True)
                outlist.append(field_render)
            if not outlist:
                return '{}' if explicit else None
            return 'std::initializer_list<' + \
                self._type_name(t.as_set.elem_type) + '>{' + \
                ', '.join(outlist) + '}'
        else:
            raise TypeError('INVALID TYPE IN print_const_definition: ' + t.name)

    def _generate_layouts(self, objects):
        if not self.flag_frozen2:
            return
        context = self._make_context(self._program.name + '_layouts')
        # TODO(5484874): Remove this hack, which supresses the #include of
        #                layouts.h
        print >> context.impl, '#if 0 // all layouts inlined in layouts.h'
        s = get_global_scope(CppPrimitiveFactory, context)
        if self.flag_compatibility:
            # Delegate to cpp1 layouts
            s('#include "{0}"'.format(self._with_compatibility_include_prefix(
                self._program, self._program.name + '_layouts.h')))
        else:
            s('#include <thrift/lib/cpp2/frozen/Frozen.h>')
            s('#include "{0}"'.format(self._with_include_prefix(self._program,
                self._program.name + '_types.h')))
            # Include other layouts
            for inc in self._program.includes:
                s('#include  "{0}_layouts.h"'
                 .format(self._with_include_prefix(inc, inc.name)))
            with s.namespace('apache.thrift.frozen').scope:
                for obj in objects:
                    self._generate_frozen_layout(obj, out())
        print >> context.impl, '\n#endif'

    def _generate_consts(self, constants):
        name = self._program.name
        # build the const scope
        context = self._make_context(self._program.name + '_constants')
        sg = get_global_scope(CppPrimitiveFactory, context)
        # Include the types header
        sg('#include "{0}"'.format(self._with_include_prefix(self._program,
            self._program.name + '_types.h')))
        # Include the thrift1 constants for compatibility mode
        if self.flag_compatibility:
            sg('#include "{0}_constants.h"'
                .format(self._with_compatibility_include_prefix(self._program,
                                                                name)))
        # Open namespace
        sns = sg.namespace(self._get_namespace()).scope
        if self.flag_compatibility:
            instance_name = 'g_' + self._program.name + '_constants'
            cpp1_namespace = self._namespace_prefix(
                self._program.get_namespace('cpp')).lstrip()
            sns('using ' + cpp1_namespace + instance_name + ';')
            sns.release()
            sg.release()
            return
        s = sns.cls('class {0}Constants'.format(name)).scope
        s.label('public:')
        # Default constructor
        init_dict = OrderedDict()
        for c in constants:
            value = self._render_const_value(c.type, c.value)
            if value:
                init_dict[c.name] = value
        s.defn('{name}()', name=name + 'Constants', init_dict=init_dict,
               in_header=True).scope.empty()
        # Define the fields that hold the constants
        for c in constants:
            s()
            s('{0} {1};'.format(self._type_name(c.type), c.name))
        # define global constants singleton
        s.release()
        sns.extern('const {0}Constants g_{0}_constants'.format(name))
        sns.release()  # namespace
        sg.release()   # global scope

    def _make_context(self, filename, tcc=False, processmap = False):
        'Convenience method to get the context and outputs for some file pair'
        # open files and instantiate outputs
        output_h = self._write_to(filename + '.h')
        output_impl = self._write_to(filename + '.cpp')
        output_tcc = self._write_to(filename + '.tcc') if tcc else None
        additional_outputs = []
        if processmap:
            for a, b, c in self.protocols:
                additional_outputs.append(self._write_to(filename + "_processmap_" + a + ".cpp"))

        header_path = self._with_include_prefix(self._program, filename)

        context = CppOutputContext(output_impl, output_h, output_tcc,
                                   header_path, additional_outputs)

        print >>context.outputs, self._autogen_comment
        return context

    @property
    def out_dir(self):
        return os.path.join(self._program.out_path, self._out_dir_base)

    def in_out_dir(self, filename):
        return os.path.join(self.out_dir, filename)

    # TODO add out_dir(self, program) as well?

    def _include_prefix(self, program, dir_base):
        #assert isinstance(program, frontend.t_program)
        ip = program.include_prefix
        if not self.flag_include_prefix or ip.startswith('/'):
            return ""
        if '/' in ip:
            ip = os.path.dirname(ip)
            return os.path.join(ip, dir_base)
        return ""

    def _compatibility_include_prefix(self, program):
        return self._include_prefix(program, self._compatibility_dir_base)

    def _out_include_prefix(self, program):
        return self._include_prefix(program, self._out_dir_base)

    def _with_compatibility_include_prefix(self, program, *args):
        return os.path.join(self._compatibility_include_prefix(program), *args)

    def _with_include_prefix(self, program, *args):
        return os.path.join(self._out_include_prefix(program), *args)

    def _write_to(self, to):
        return IndentedOutput(open(self.in_out_dir(to), 'w'))

    def init_generator(self):
        name = self._program.name
        # Make output directory
        try:
            os.mkdir(self.out_dir)
        except OSError as exc:
            if exc.errno == errno.EEXIST and os.path.isdir(self.out_dir):
                pass
            else:
                raise

        self._const_scope = None

        # open files and instantiate outputs for types
        context = self._make_context(name + '_types', True)
        s = self._types_global = get_global_scope(CppPrimitiveFactory, context)
        self._types_out_impl = types_out_impl = context.impl
        self._types_out_h = types_out_h = context.h
        self._out_tcc = types_out_tcc = context.tcc
        # Enter the scope (prints guard)
        s.acquire()
        # Include base types
        s('#include <thrift/lib/cpp2/Thrift.h>')
        s('#include <thrift/lib/cpp2/protocol/Protocol.h>')
        for a, b, c in self.protocols:
            s('#include <thrift/lib/cpp2/protocol/{0}.h>'.format(b))
        s('#include <thrift/lib/cpp2/protocol/DebugProtocol.h>')
        s('#include <thrift/lib/cpp2/protocol/VirtualProtocol.h>')
        s('#include <thrift/lib/cpp/protocol/TProtocol.h>')
        if not self.flag_bootstrap:
            s('#include <thrift/lib/cpp/TApplicationException.h>')
        s('#include <folly/io/IOBuf.h>')
        s('#include <folly/io/Cursor.h>')
        s('#include <boost/operators.hpp>')
        s()
        if self.flag_compatibility:
            # Transform the cpp2 include prefix path into a cpp prefix path.
            s('#include "{0}_types.h"'
              .format(self._with_compatibility_include_prefix(self._program,
                                                              name)))
        # Include other Thrift includes
        for inc in self._program.includes:
            s('#include "{0}_types.h"' \
              .format(self._with_include_prefix(inc, inc.name)))
        print >>types_out_tcc
        s()
        # Include custom headers
        for inc in self._program.cpp_includes:
            if inc.startswith('<'):
                s('#include {0}'.format(inc))
            else:
                s('#include "{0}"'.format(inc))
        s()
        # The swap() code needs <algorithm> for std::swap()
        print >>types_out_impl, '#include <algorithm>\n'

        # using directives
        s()

        # Open namespace
        s = self._types_scope = \
                s.namespace(self._get_namespace()).scope
        s.acquire()

    def close_generator(self):
        # make sure that the main types namespace is closed
        self._types_scope.release()

        if self.flag_implicit_templates:
            # Include the types.tcc file from the types header file
            s = self._types_global
            s()
            s('#include "{0}_types.tcc"'.format(
                self._with_include_prefix(self._program, self._program.name)))
            self._types_global.release()

    def _generate_comment(self, text, style='auto'):
        'Style = block, line or auto'
        lines = text.split('\n')
        if style == 'auto':
            style = len(lines) > 1 and 'block' or 'line'
        if style == 'block':
            return '\n'.join(chain(('/**',), \
                    (' * {0}'.format(line) for line in lines),
                    (' */',)))
        elif style == 'line':
            return '\n'.join('// {0}'.format(line) for line in lines)
        else:
            raise NotImplementedError

    def _is_processed_in_eb(self, function):
        if function.annotations is not None and \
          'thread' in function.annotations.annotations:
            return function.annotations.annotations['thread'] == 'eb'
        return self.flag_process_in_event_base

# register the generator factory
t_generator.GeneratorFactory(CppGenerator)
