#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
from enum import Enum
import warnings
import builtins as _builtins


class MyEnumA(Enum):
    fieldA = <int> (MyEnumA__fieldA)
    fieldB = <int> (MyEnumA__fieldB)
    fieldC = <int> (MyEnumA__fieldC)

    __hash__ = Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value


cdef cMyEnumA MyEnumA_to_cpp(value):
    if value == MyEnumA.fieldA:
        return MyEnumA__fieldA
    elif value == MyEnumA.fieldB:
        return MyEnumA__fieldB
    elif value == MyEnumA.fieldC:
        return MyEnumA__fieldC


cdef cSmallStruct _SmallStruct_defaults = cSmallStruct()

cdef class SmallStruct(thrift.py3.types.Struct):

    def __init__(
        SmallStruct self, *,
        pbool small_A=None,
        small_B=None
    ):
        self._cpp_obj = move(SmallStruct._make_instance(
          NULL,
          small_A,
          small_B,
        ))

    def __call__(
        SmallStruct self,
        small_A=__NOTSET,
        small_B=__NOTSET
    ):
        changes = any((
            small_A is not __NOTSET,

            small_B is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not small_A is not __NOTSET:
            if not isinstance(small_A, bool):
                raise TypeError(f'small_A is not a { bool !r}.')

        if None is not small_B is not __NOTSET:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')

        inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        inst._cpp_obj = move(SmallStruct._make_instance(
          self._cpp_obj.get(),
          small_A,
          small_B,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cSmallStruct] _make_instance(
        cSmallStruct* base_instance,
        object small_A,
        object small_B
    ) except *:
        cdef unique_ptr[cSmallStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSmallStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSmallStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if small_A is None:
                deref(c_inst).small_A = _SmallStruct_defaults.small_A
                deref(c_inst).__isset.small_A = False
                pass
            elif small_A is __NOTSET:
                small_A = None

            if small_B is None:
                deref(c_inst).small_B = _SmallStruct_defaults.small_B
                deref(c_inst).__isset.small_B = False
                pass
            elif small_B is __NOTSET:
                small_B = None

        if small_A is not None:
            deref(c_inst).small_A = small_A
            deref(c_inst).__isset.small_A = True
        if small_B is not None:
            deref(c_inst).small_B = small_B
            deref(c_inst).__isset.small_B = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'small_A', self.small_A
        yield 'small_B', self.small_B

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cSmallStruct] cpp_obj):
        inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def small_A(self):

        return <pbool> self._cpp_obj.get().small_A

    @property
    def small_B(self):

        return self._cpp_obj.get().small_B


    def __hash__(SmallStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.small_A,
            self.small_B,
            ))
        return self.__hash

    def __repr__(SmallStruct self):
        return f'SmallStruct(small_A={repr(self.small_A)}, small_B={repr(self.small_B)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SmallStruct) and
                isinstance(other, SmallStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSmallStruct cself = deref((<SmallStruct>self)._cpp_obj)
        cdef cSmallStruct cother = deref((<SmallStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(SmallStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cSmallStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cSmallStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cSmallStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(SmallStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cSmallStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cSmallStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cSmallStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (SmallStruct, serialize(self)))


cdef ccontainerStruct _containerStruct_defaults = ccontainerStruct()

cdef class containerStruct(thrift.py3.types.Struct):

    def __init__(
        containerStruct self, *,
        pbool fieldA=None,
        fieldB=None,
        fieldC=None,
        str fieldD=None,
        str fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None,
        pbool fieldI=None,
        fieldJ=None,
        fieldK=None,
        fieldL=None,
        fieldM=None,
        fieldN=None,
        fieldO=None,
        fieldP=None,
        fieldQ=None,
        fieldR=None,
        SmallStruct fieldS=None,
        SmallStruct fieldT=None,
        SmallStruct fieldU=None,
        SmallStruct fieldX=None
    ):
        self._cpp_obj = move(containerStruct._make_instance(
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))

    def __call__(
        containerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET,
        fieldI=__NOTSET,
        fieldJ=__NOTSET,
        fieldK=__NOTSET,
        fieldL=__NOTSET,
        fieldM=__NOTSET,
        fieldN=__NOTSET,
        fieldO=__NOTSET,
        fieldP=__NOTSET,
        fieldQ=__NOTSET,
        fieldR=__NOTSET,
        fieldS=__NOTSET,
        fieldT=__NOTSET,
        fieldU=__NOTSET,
        fieldX=__NOTSET
    ):
        changes = any((
            fieldA is not __NOTSET,

            fieldB is not __NOTSET,

            fieldC is not __NOTSET,

            fieldD is not __NOTSET,

            fieldE is not __NOTSET,

            fieldF is not __NOTSET,

            fieldG is not __NOTSET,

            fieldH is not __NOTSET,

            fieldI is not __NOTSET,

            fieldJ is not __NOTSET,

            fieldK is not __NOTSET,

            fieldL is not __NOTSET,

            fieldM is not __NOTSET,

            fieldN is not __NOTSET,

            fieldO is not __NOTSET,

            fieldP is not __NOTSET,

            fieldQ is not __NOTSET,

            fieldR is not __NOTSET,

            fieldS is not __NOTSET,

            fieldT is not __NOTSET,

            fieldU is not __NOTSET,

            fieldX is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not fieldA is not __NOTSET:
            if not isinstance(fieldA, bool):
                raise TypeError(f'fieldA is not a { bool !r}.')

        if None is not fieldB is not __NOTSET:
            if not isinstance(fieldB, Map__string_bool):
                fieldB = Map__string_bool(fieldB)

        if None is not fieldC is not __NOTSET:
            if not isinstance(fieldC, Set__i32):
                fieldC = Set__i32(fieldC)

        if None is not fieldD is not __NOTSET:
            if not isinstance(fieldD, str):
                raise TypeError(f'fieldD is not a { str !r}.')

        if None is not fieldE is not __NOTSET:
            if not isinstance(fieldE, str):
                raise TypeError(f'fieldE is not a { str !r}.')

        if None is not fieldF is not __NOTSET:
            if not isinstance(fieldF, List__List__List__i32):
                fieldF = List__List__List__i32(fieldF)

        if None is not fieldG is not __NOTSET:
            if not isinstance(fieldG, Map__string_Map__string_Map__string_i32):
                fieldG = Map__string_Map__string_Map__string_i32(fieldG)

        if None is not fieldH is not __NOTSET:
            if not isinstance(fieldH, List__Set__i32):
                fieldH = List__Set__i32(fieldH)

        if None is not fieldI is not __NOTSET:
            if not isinstance(fieldI, bool):
                raise TypeError(f'fieldI is not a { bool !r}.')

        if None is not fieldJ is not __NOTSET:
            if not isinstance(fieldJ, Map__string_List__i32):
                fieldJ = Map__string_List__i32(fieldJ)

        if None is not fieldK is not __NOTSET:
            if not isinstance(fieldK, List__List__List__List__i32):
                fieldK = List__List__List__List__i32(fieldK)

        if None is not fieldL is not __NOTSET:
            if not isinstance(fieldL, Set__Set__Set__bool):
                fieldL = Set__Set__Set__bool(fieldL)

        if None is not fieldM is not __NOTSET:
            if not isinstance(fieldM, Map__Set__List__i32_Map__List__Set__string_string):
                fieldM = Map__Set__List__i32_Map__List__Set__string_string(fieldM)

        if None is not fieldN is not __NOTSET:
            if not isinstance(fieldN, List__i64):
                fieldN = List__i64(fieldN)

        if None is not fieldO is not __NOTSET:
            if not isinstance(fieldO, List__double):
                fieldO = List__double(fieldO)

        if None is not fieldP is not __NOTSET:
            if not isinstance(fieldP, List__i32):
                fieldP = List__i32(fieldP)

        if None is not fieldQ is not __NOTSET:
            if not isinstance(fieldQ, MyEnumA):
                raise TypeError(f'field fieldQ value: { fieldQ !r} is not of the enum type { MyEnumA }.')

        if None is not fieldR is not __NOTSET:
            if not isinstance(fieldR, Map__string_bool):
                fieldR = Map__string_bool(fieldR)

        if None is not fieldS is not __NOTSET:
            if not isinstance(fieldS, SmallStruct):
                raise TypeError(f'fieldS is not a { SmallStruct !r}.')

        if None is not fieldT is not __NOTSET:
            if not isinstance(fieldT, SmallStruct):
                raise TypeError(f'fieldT is not a { SmallStruct !r}.')

        if None is not fieldU is not __NOTSET:
            if not isinstance(fieldU, SmallStruct):
                raise TypeError(f'fieldU is not a { SmallStruct !r}.')

        if None is not fieldX is not __NOTSET:
            if not isinstance(fieldX, SmallStruct):
                raise TypeError(f'fieldX is not a { SmallStruct !r}.')

        inst = <containerStruct>containerStruct.__new__(containerStruct)
        inst._cpp_obj = move(containerStruct._make_instance(
          self._cpp_obj.get(),
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[ccontainerStruct] _make_instance(
        ccontainerStruct* base_instance,
        object fieldA,
        object fieldB,
        object fieldC,
        object fieldD,
        object fieldE,
        object fieldF,
        object fieldG,
        object fieldH,
        object fieldI,
        object fieldJ,
        object fieldK,
        object fieldL,
        object fieldM,
        object fieldN,
        object fieldO,
        object fieldP,
        object fieldQ,
        object fieldR,
        object fieldS,
        object fieldT,
        object fieldU,
        object fieldX
    ) except *:
        cdef unique_ptr[ccontainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[ccontainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[ccontainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if fieldA is None:
                deref(c_inst).fieldA = _containerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass
            elif fieldA is __NOTSET:
                fieldA = None

            if fieldB is None:
                deref(c_inst).fieldB = _containerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
                pass
            elif fieldB is __NOTSET:
                fieldB = None

            if fieldC is None:
                deref(c_inst).fieldC = _containerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
                pass
            elif fieldC is __NOTSET:
                fieldC = None

            if fieldD is None:
                deref(c_inst).fieldD = _containerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
                pass
            elif fieldD is __NOTSET:
                fieldD = None

            if fieldE is None:
                deref(c_inst).fieldE = _containerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
                pass
            elif fieldE is __NOTSET:
                fieldE = None

            if fieldF is None:
                deref(c_inst).fieldF = _containerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
                pass
            elif fieldF is __NOTSET:
                fieldF = None

            if fieldG is None:
                deref(c_inst).fieldG = _containerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
                pass
            elif fieldG is __NOTSET:
                fieldG = None

            if fieldH is None:
                deref(c_inst).fieldH = _containerStruct_defaults.fieldH
                deref(c_inst).__isset.fieldH = False
                pass
            elif fieldH is __NOTSET:
                fieldH = None

            if fieldI is None:
                deref(c_inst).fieldI = _containerStruct_defaults.fieldI
                deref(c_inst).__isset.fieldI = False
                pass
            elif fieldI is __NOTSET:
                fieldI = None

            if fieldJ is None:
                deref(c_inst).fieldJ = _containerStruct_defaults.fieldJ
                deref(c_inst).__isset.fieldJ = False
                pass
            elif fieldJ is __NOTSET:
                fieldJ = None

            if fieldK is None:
                deref(c_inst).fieldK = _containerStruct_defaults.fieldK
                deref(c_inst).__isset.fieldK = False
                pass
            elif fieldK is __NOTSET:
                fieldK = None

            if fieldL is None:
                deref(c_inst).fieldL = _containerStruct_defaults.fieldL
                deref(c_inst).__isset.fieldL = False
                pass
            elif fieldL is __NOTSET:
                fieldL = None

            if fieldM is None:
                deref(c_inst).fieldM = _containerStruct_defaults.fieldM
                deref(c_inst).__isset.fieldM = False
                pass
            elif fieldM is __NOTSET:
                fieldM = None

            if fieldN is None:
                deref(c_inst).fieldN = _containerStruct_defaults.fieldN
                deref(c_inst).__isset.fieldN = False
                pass
            elif fieldN is __NOTSET:
                fieldN = None

            if fieldO is None:
                deref(c_inst).fieldO = _containerStruct_defaults.fieldO
                deref(c_inst).__isset.fieldO = False
                pass
            elif fieldO is __NOTSET:
                fieldO = None

            if fieldP is None:
                deref(c_inst).fieldP = _containerStruct_defaults.fieldP
                deref(c_inst).__isset.fieldP = False
                pass
            elif fieldP is __NOTSET:
                fieldP = None

            if fieldQ is None:
                deref(c_inst).fieldQ = _containerStruct_defaults.fieldQ
                deref(c_inst).__isset.fieldQ = False
                pass
            elif fieldQ is __NOTSET:
                fieldQ = None

            if fieldR is None:
                deref(c_inst).fieldR.reset()
                pass
            elif fieldR is __NOTSET:
                fieldR = None

            if fieldS is None:
                deref(c_inst).fieldS.reset()
                pass
            elif fieldS is __NOTSET:
                fieldS = None

            if fieldT is None:
                deref(c_inst).fieldT.reset()
                pass
            elif fieldT is __NOTSET:
                fieldT = None

            if fieldU is None:
                deref(c_inst).fieldU.reset()
                pass
            elif fieldU is __NOTSET:
                fieldU = None

            if fieldX is None:
                deref(c_inst).fieldX.reset()
                pass
            elif fieldX is __NOTSET:
                fieldX = None

        if fieldA is not None:
            deref(c_inst).fieldA = fieldA
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB = <cmap[string,cbool]>deref(Map__string_bool(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC = <cset[int32_t]>deref(Set__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD = fieldD.encode('UTF-8')
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE = fieldE.encode('UTF-8')
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF = <vector[vector[vector[int32_t]]]>deref(List__List__List__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG = <cmap[string,cmap[string,cmap[string,int32_t]]]>deref(Map__string_Map__string_Map__string_i32(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH = <vector[cset[int32_t]]>deref(List__Set__i32(fieldH)._cpp_obj)
            deref(c_inst).__isset.fieldH = True
        if fieldI is not None:
            deref(c_inst).fieldI = fieldI
            deref(c_inst).__isset.fieldI = True
        if fieldJ is not None:
            deref(c_inst).fieldJ = <cmap[string,vector[int32_t]]>deref(Map__string_List__i32(fieldJ)._cpp_obj)
            deref(c_inst).__isset.fieldJ = True
        if fieldK is not None:
            deref(c_inst).fieldK = <vector[vector[vector[vector[int32_t]]]]>deref(List__List__List__List__i32(fieldK)._cpp_obj)
            deref(c_inst).__isset.fieldK = True
        if fieldL is not None:
            deref(c_inst).fieldL = <cset[cset[cset[cbool]]]>deref(Set__Set__Set__bool(fieldL)._cpp_obj)
            deref(c_inst).__isset.fieldL = True
        if fieldM is not None:
            deref(c_inst).fieldM = <cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]>deref(Map__Set__List__i32_Map__List__Set__string_string(fieldM)._cpp_obj)
            deref(c_inst).__isset.fieldM = True
        if fieldN is not None:
            deref(c_inst).fieldN = <vector[Foo]>deref(List__i64(fieldN)._cpp_obj)
            deref(c_inst).__isset.fieldN = True
        if fieldO is not None:
            deref(c_inst).fieldO = <vector[Bar]>deref(List__double(fieldO)._cpp_obj)
            deref(c_inst).__isset.fieldO = True
        if fieldP is not None:
            deref(c_inst).fieldP = <vector[Baz]>deref(List__i32(fieldP)._cpp_obj)
            deref(c_inst).__isset.fieldP = True
        if fieldQ is not None:
            deref(c_inst).fieldQ = MyEnumA_to_cpp(fieldQ)
            deref(c_inst).__isset.fieldQ = True
        if fieldR is not None:
            deref(c_inst).fieldR = make_unique[cmap[string,cbool]](deref((<Map__string_bool?>fieldR)._cpp_obj))
        if fieldS is not None:
            deref(c_inst).fieldS = make_unique[cSmallStruct](deref((<SmallStruct?>fieldS)._cpp_obj))
        if fieldT is not None:
            deref(c_inst).fieldT = (<SmallStruct?>fieldT)._cpp_obj
        if fieldU is not None:
            deref(c_inst).fieldU = const_pointer_cast((<SmallStruct?>fieldU)._cpp_obj)
        if fieldX is not None:
            deref(c_inst).fieldX = make_unique[cSmallStruct](deref((<SmallStruct?>fieldX)._cpp_obj))
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH
        yield 'fieldI', self.fieldI
        yield 'fieldJ', self.fieldJ
        yield 'fieldK', self.fieldK
        yield 'fieldL', self.fieldL
        yield 'fieldM', self.fieldM
        yield 'fieldN', self.fieldN
        yield 'fieldO', self.fieldO
        yield 'fieldP', self.fieldP
        yield 'fieldQ', self.fieldQ
        yield 'fieldR', self.fieldR
        yield 'fieldS', self.fieldS
        yield 'fieldT', self.fieldT
        yield 'fieldU', self.fieldU
        yield 'fieldX', self.fieldX

    def __bool__(self):
        return True or True or True or True or True or True or True or True or True or True or True or True or True or True or True or True or True or <bint>(deref(self._cpp_obj).fieldR) or <bint>(deref(self._cpp_obj).fieldS) or <bint>(deref(self._cpp_obj).fieldT) or <bint>(deref(self._cpp_obj).fieldU) or <bint>(deref(self._cpp_obj).fieldX)

    @staticmethod
    cdef create(shared_ptr[ccontainerStruct] cpp_obj):
        inst = <containerStruct>containerStruct.__new__(containerStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def fieldA(self):

        return <pbool> self._cpp_obj.get().fieldA

    @property
    def fieldB(self):

        if self.__fieldB is None:
            self.__fieldB = Map__string_bool.create(make_shared[cmap[string,cbool]](deref(self._cpp_obj).fieldB))
        return self.__fieldB

    @property
    def fieldC(self):

        if self.__fieldC is None:
            self.__fieldC = Set__i32.create(make_shared[cset[int32_t]](deref(self._cpp_obj).fieldC))
        return self.__fieldC

    @property
    def fieldD(self):

        return (<bytes>self._cpp_obj.get().fieldD).decode('UTF-8')

    @property
    def fieldE(self):

        return (<bytes>self._cpp_obj.get().fieldE).decode('UTF-8')

    @property
    def fieldF(self):

        if self.__fieldF is None:
            self.__fieldF = List__List__List__i32.create(make_shared[vector[vector[vector[int32_t]]]](deref(self._cpp_obj).fieldF))
        return self.__fieldF

    @property
    def fieldG(self):

        if self.__fieldG is None:
            self.__fieldG = Map__string_Map__string_Map__string_i32.create(make_shared[cmap[string,cmap[string,cmap[string,int32_t]]]](deref(self._cpp_obj).fieldG))
        return self.__fieldG

    @property
    def fieldH(self):

        if self.__fieldH is None:
            self.__fieldH = List__Set__i32.create(make_shared[vector[cset[int32_t]]](deref(self._cpp_obj).fieldH))
        return self.__fieldH

    @property
    def fieldI(self):

        return <pbool> self._cpp_obj.get().fieldI

    @property
    def fieldJ(self):

        if self.__fieldJ is None:
            self.__fieldJ = Map__string_List__i32.create(make_shared[cmap[string,vector[int32_t]]](deref(self._cpp_obj).fieldJ))
        return self.__fieldJ

    @property
    def fieldK(self):

        if self.__fieldK is None:
            self.__fieldK = List__List__List__List__i32.create(make_shared[vector[vector[vector[vector[int32_t]]]]](deref(self._cpp_obj).fieldK))
        return self.__fieldK

    @property
    def fieldL(self):

        if self.__fieldL is None:
            self.__fieldL = Set__Set__Set__bool.create(make_shared[cset[cset[cset[cbool]]]](deref(self._cpp_obj).fieldL))
        return self.__fieldL

    @property
    def fieldM(self):

        if self.__fieldM is None:
            self.__fieldM = Map__Set__List__i32_Map__List__Set__string_string.create(make_shared[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](deref(self._cpp_obj).fieldM))
        return self.__fieldM

    @property
    def fieldN(self):

        if self.__fieldN is None:
            self.__fieldN = List__i64.create(make_shared[vector[Foo]](deref(self._cpp_obj).fieldN))
        return self.__fieldN

    @property
    def fieldO(self):

        if self.__fieldO is None:
            self.__fieldO = List__double.create(make_shared[vector[Bar]](deref(self._cpp_obj).fieldO))
        return self.__fieldO

    @property
    def fieldP(self):

        if self.__fieldP is None:
            self.__fieldP = List__i32.create(make_shared[vector[Baz]](deref(self._cpp_obj).fieldP))
        return self.__fieldP

    @property
    def fieldQ(self):

        return translate_cpp_enum_to_python(MyEnumA, <int>(deref(self._cpp_obj).fieldQ))

    @property
    def fieldR(self):

        if self.__fieldR is None:
            if not deref(self._cpp_obj).fieldR:
                return None
            self.__fieldR = Map__string_bool.create(aliasing_constructor_fieldR(self._cpp_obj, (deref(self._cpp_obj).fieldR.get())))
        return self.__fieldR

    @property
    def fieldS(self):

        if self.__fieldS is None:
            if not deref(self._cpp_obj).fieldS:
                return None
            self.__fieldS = SmallStruct.create(aliasing_constructor_fieldS(self._cpp_obj, (deref(self._cpp_obj).fieldS.get())))
        return self.__fieldS

    @property
    def fieldT(self):

        if self.__fieldT is None:
            if not deref(self._cpp_obj).fieldT:
                return None
            self.__fieldT = SmallStruct.create(aliasing_constructor_fieldT(self._cpp_obj, (deref(self._cpp_obj).fieldT.get())))
        return self.__fieldT

    @property
    def fieldU(self):

        if self.__fieldU is None:
            if not deref(self._cpp_obj).fieldU:
                return None
            self.__fieldU = SmallStruct.create(aliasing_constructor_fieldU(self._cpp_obj, <cSmallStruct*>(deref(self._cpp_obj).fieldU.get())))
        return self.__fieldU

    @property
    def fieldX(self):

        if self.__fieldX is None:
            if not deref(self._cpp_obj).fieldX:
                return None
            self.__fieldX = SmallStruct.create(aliasing_constructor_fieldX(self._cpp_obj, (deref(self._cpp_obj).fieldX.get())))
        return self.__fieldX


    def __hash__(containerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            self.fieldI,
            self.fieldJ,
            self.fieldK,
            self.fieldL,
            self.fieldM,
            self.fieldN,
            self.fieldO,
            self.fieldP,
            self.fieldQ,
            self.fieldR,
            self.fieldS,
            self.fieldT,
            self.fieldU,
            self.fieldX,
            ))
        return self.__hash

    def __repr__(containerStruct self):
        return f'containerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)}, fieldI={repr(self.fieldI)}, fieldJ={repr(self.fieldJ)}, fieldK={repr(self.fieldK)}, fieldL={repr(self.fieldL)}, fieldM={repr(self.fieldM)}, fieldN={repr(self.fieldN)}, fieldO={repr(self.fieldO)}, fieldP={repr(self.fieldP)}, fieldQ={repr(self.fieldQ)}, fieldR={repr(self.fieldR)}, fieldS={repr(self.fieldS)}, fieldT={repr(self.fieldT)}, fieldU={repr(self.fieldU)}, fieldX={repr(self.fieldX)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, containerStruct) and
                isinstance(other, containerStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef ccontainerStruct cself = deref((<containerStruct>self)._cpp_obj)
        cdef ccontainerStruct cother = deref((<containerStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(containerStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[ccontainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[ccontainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[ccontainerStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(containerStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[ccontainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[ccontainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[ccontainerStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (containerStruct, serialize(self)))


cdef class Map__string_bool:
    def __init__(self, items=None):
        if isinstance(items, Map__string_bool):
            self._cpp_obj = (<Map__string_bool> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_bool._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cbool]] c_items):
        inst = <Map__string_bool>Map__string_bool.__new__(Map__string_bool)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,cbool]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,cbool]] c_inst = make_unique[cmap[string,cbool]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")

                deref(c_inst).insert(cpair[string,cbool](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cbool].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cbool citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cbool].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cbool citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cbool citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cbool citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_bool)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items is not None:
            for item in items:
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[int32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[int32_t]]] c_inst = make_unique[vector[vector[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(vector[int32_t](deref(List__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[int32_t]]] c_inst
        cdef vector[int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[int32_t]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        for citem in deref(self._cpp_obj):
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        cdef vector[vector[int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef vector[int32_t] citem = vector[int32_t](deref(List__i32(item)._cpp_obj.get()))
        cdef vector[vector[int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__i32)

cdef class List__List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__List__i32):
            self._cpp_obj = (<List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[int32_t]]]] c_items):
        inst = <List__List__List__i32>List__List__List__i32.__new__(List__List__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[vector[int32_t]]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[vector[int32_t]]]] c_inst = make_unique[vector[vector[vector[int32_t]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[int]]")
                if not isinstance(item, List__List__i32):
                    item = List__List__i32(item)
                deref(c_inst).push_back(vector[vector[int32_t]](deref(List__List__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[int32_t]]]] c_inst
        cdef vector[vector[int32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[int32_t]]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__List__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__List__i32.create(
    make_shared[vector[vector[int32_t]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef vector[vector[int32_t]] citem = vector[vector[int32_t]](deref(List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[int32_t]]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[vector[int32_t]] citem
        for citem in deref(self._cpp_obj):
            yield List__List__i32.create(
    make_shared[vector[vector[int32_t]]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[vector[int32_t]] citem
        cdef vector[vector[vector[int32_t]]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[vector[int32_t]]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__List__i32.create(
    make_shared[vector[vector[int32_t]]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef vector[vector[int32_t]] citem = vector[vector[int32_t]](deref(List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[int32_t]]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[vector[int32_t]]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef vector[vector[int32_t]] citem = vector[vector[int32_t]](deref(List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[int32_t]]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int32_t]] c_inst = make_unique[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")

                deref(c_inst).insert(cpair[string,int32_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,int32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,cmap[string,int32_t]]] c_inst = make_unique[cmap[string,cmap[string,int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst).insert(cpair[string,cmap[string,int32_t]](key.encode('UTF-8'),cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cmap[string,int32_t] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem)))



Mapping.register(Map__string_Map__string_i32)

cdef class Map__string_Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_Map__string_Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] c_items):
        inst = <Map__string_Map__string_Map__string_i32>Map__string_Map__string_Map__string_i32.__new__(Map__string_Map__string_Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] c_inst = make_unique[cmap[string,cmap[string,cmap[string,int32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, _typing.Mapping[str, int]]")
                if not isinstance(item, Map__string_Map__string_i32):
                    item = Map__string_Map__string_i32(item)

                deref(c_inst).insert(cpair[string,cmap[string,cmap[string,int32_t]]](key.encode('UTF-8'),cmap[string,cmap[string,int32_t]](deref(Map__string_Map__string_i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[string,cmap[string,int32_t]] citem = deref(iter).second
        return Map__string_Map__string_i32.create(
    make_shared[cmap[string,cmap[string,int32_t]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[string,cmap[string,int32_t]] citem = deref(iter).second
        return Map__string_Map__string_i32.create(
    make_shared[cmap[string,cmap[string,int32_t]]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[string,cmap[string,int32_t]] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__string_Map__string_i32.create(
    make_shared[cmap[string,cmap[string,int32_t]]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cmap[string,cmap[string,int32_t]] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), Map__string_Map__string_i32.create(
    make_shared[cmap[string,cmap[string,int32_t]]](citem)))



Mapping.register(Map__string_Map__string_Map__string_i32)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cset[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cset[int32_t]]] c_inst = make_unique[vector[cset[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(cset[int32_t](deref(Set__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[int32_t]]] c_inst
        cdef cset[int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[int32_t]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Set__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[int32_t] citem
        cdef vector[cset[int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cset[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._cpp_obj.get()))
        cdef vector[cset[int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__i32)

cdef class Map__string_List__i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__i32):
            self._cpp_obj = (<Map__string_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[int32_t]]] c_items):
        inst = <Map__string_List__i32>Map__string_List__i32.__new__(Map__string_List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,vector[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,vector[int32_t]]] c_inst = make_unique[cmap[string,vector[int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst).insert(cpair[string,vector[int32_t]](key.encode('UTF-8'),vector[int32_t](deref(List__i32(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[int32_t]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef vector[int32_t] citem = deref(iter).second
        return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[int32_t]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef vector[int32_t] citem = deref(iter).second
        return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef vector[int32_t] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef vector[int32_t] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), List__i32.create(
    make_shared[vector[int32_t]](citem)))



Mapping.register(Map__string_List__i32)

cdef class List__List__List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__List__List__i32):
            self._cpp_obj = (<List__List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__List__List__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[vector[int32_t]]]]] c_items):
        inst = <List__List__List__List__i32>List__List__List__List__i32.__new__(List__List__List__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[vector[vector[vector[int32_t]]]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[vector[vector[vector[int32_t]]]]] c_inst = make_unique[vector[vector[vector[vector[int32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]")
                if not isinstance(item, List__List__List__i32):
                    item = List__List__List__i32(item)
                deref(c_inst).push_back(vector[vector[vector[int32_t]]](deref(List__List__List__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[vector[int32_t]]]]] c_inst
        cdef vector[vector[vector[int32_t]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[vector[int32_t]]]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__List__List__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return List__List__List__i32.create(
    make_shared[vector[vector[vector[int32_t]]]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef vector[vector[vector[int32_t]]] citem = vector[vector[vector[int32_t]]](deref(List__List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[vector[int32_t]]]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[vector[vector[int32_t]]] citem
        for citem in deref(self._cpp_obj):
            yield List__List__List__i32.create(
    make_shared[vector[vector[vector[int32_t]]]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef vector[vector[vector[int32_t]]] citem
        cdef vector[vector[vector[vector[int32_t]]]] vec = deref(
            self._cpp_obj.get())
        cdef vector[vector[vector[vector[int32_t]]]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__List__List__i32.create(
    make_shared[vector[vector[vector[int32_t]]]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef vector[vector[vector[int32_t]]] citem = vector[vector[vector[int32_t]]](deref(List__List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[vector[int32_t]]]] vec = deref(self._cpp_obj.get())
        cdef vector[vector[vector[vector[int32_t]]]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef vector[vector[vector[int32_t]]] citem = vector[vector[vector[int32_t]]](deref(List__List__List__i32(item)._cpp_obj.get()))
        cdef vector[vector[vector[vector[int32_t]]]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__List__List__i32)

cdef class Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__bool):
            self._cpp_obj = (<Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__bool._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[cbool]] c_items):
        inst = <Set__bool>Set__bool.__new__(Set__bool)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[cbool]] _make_instance(object items) except *:
        cdef unique_ptr[cset[cbool]] c_inst = make_unique[cset[cbool]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[cbool] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__bool) and
                isinstance(other, Set__bool)):
            cself = deref((<Set__bool> self)._cpp_obj)
            cother = deref((<Set__bool> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()
        for citem in deref((<Set__bool> self)._cpp_obj):
            if deref((<Set__bool> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__bool.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()
        for citem in deref((<Set__bool> self)._cpp_obj):
            if deref((<Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__bool.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()
        for citem in deref((<Set__bool> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__bool> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__bool.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()
        for citem in deref((<Set__bool> self)._cpp_obj):
            if deref((<Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__bool> other)._cpp_obj):
            if deref((<Set__bool> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__bool.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__bool)

cdef class Set__Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__Set__bool):
            self._cpp_obj = (<Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__Set__bool._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[cset[cbool]]] c_items):
        inst = <Set__Set__bool>Set__Set__bool.__new__(Set__Set__bool)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[cset[cbool]]] _make_instance(object items) except *:
        cdef unique_ptr[cset[cset[cbool]]] c_inst = make_unique[cset[cset[cbool]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[bool]")
                if not isinstance(item, Set__bool):
                    item = Set__bool(item)
                deref(c_inst).insert(cset[cbool](deref(Set__bool(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(cset[cbool](deref(Set__bool(item)._cpp_obj.get()))))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield Set__bool.create(
    make_shared[cset[cbool]](citem))

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[cset[cbool]] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__Set__bool) and
                isinstance(other, Set__Set__bool)):
            cself = deref((<Set__Set__bool> self)._cpp_obj)
            cother = deref((<Set__Set__bool> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()
        for citem in deref((<Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__bool> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__Set__bool.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()
        for citem in deref((<Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Set__bool.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()
        for citem in deref((<Set__Set__bool> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__Set__bool> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__Set__bool.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()
        for citem in deref((<Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__Set__bool> other)._cpp_obj):
            if deref((<Set__Set__bool> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Set__bool.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__Set__bool)

cdef class Set__Set__Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__Set__Set__bool):
            self._cpp_obj = (<Set__Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__Set__Set__bool._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[cset[cset[cbool]]]] c_items):
        inst = <Set__Set__Set__bool>Set__Set__Set__bool.__new__(Set__Set__Set__bool)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[cset[cset[cbool]]]] _make_instance(object items) except *:
        cdef unique_ptr[cset[cset[cset[cbool]]]] c_inst = make_unique[cset[cset[cset[cbool]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.AbstractSet[bool]]")
                if not isinstance(item, Set__Set__bool):
                    item = Set__Set__bool(item)
                deref(c_inst).insert(cset[cset[cbool]](deref(Set__Set__bool(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(cset[cset[cbool]](deref(Set__Set__bool(item)._cpp_obj.get()))))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield Set__Set__bool.create(
    make_shared[cset[cset[cbool]]](citem))

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[cset[cset[cbool]]] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__Set__Set__bool) and
                isinstance(other, Set__Set__Set__bool)):
            cself = deref((<Set__Set__Set__bool> self)._cpp_obj)
            cother = deref((<Set__Set__Set__bool> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()
        for citem in deref((<Set__Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__Set__bool> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__Set__Set__bool.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()
        for citem in deref((<Set__Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Set__Set__bool.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()
        for citem in deref((<Set__Set__Set__bool> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__Set__Set__bool> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__Set__Set__bool.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()
        for citem in deref((<Set__Set__Set__bool> self)._cpp_obj):
            if deref((<Set__Set__Set__bool> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__Set__Set__bool> other)._cpp_obj):
            if deref((<Set__Set__Set__bool> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__Set__Set__bool.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__Set__Set__bool)

cdef class Set__List__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__List__i32):
            self._cpp_obj = (<Set__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[vector[int32_t]]] c_items):
        inst = <Set__List__i32>Set__List__i32.__new__(Set__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[vector[int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[cset[vector[int32_t]]] c_inst = make_unique[cset[vector[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).insert(vector[int32_t](deref(List__i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(vector[int32_t](deref(List__i32(item)._cpp_obj.get()))))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[vector[int32_t]] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__List__i32) and
                isinstance(other, Set__List__i32)):
            cself = deref((<Set__List__i32> self)._cpp_obj)
            cother = deref((<Set__List__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()
        for citem in deref((<Set__List__i32> self)._cpp_obj):
            if deref((<Set__List__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__List__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()
        for citem in deref((<Set__List__i32> self)._cpp_obj):
            if deref((<Set__List__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__List__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()
        for citem in deref((<Set__List__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__List__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__List__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()
        for citem in deref((<Set__List__i32> self)._cpp_obj):
            if deref((<Set__List__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__List__i32> other)._cpp_obj):
            if deref((<Set__List__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__List__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__List__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class List__Set__string:
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cset[string]]] c_inst = make_unique[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(cset[string](deref(Set__string(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef cset[string] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Set__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Set__string.create(
    make_shared[cset[string]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        for citem in deref(self._cpp_obj):
            yield Set__string.create(
    make_shared[cset[string]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cset[string] citem
        cdef vector[cset[string]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cset[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__string.create(
    make_shared[cset[string]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(self._cpp_obj.get())
        cdef vector[cset[string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cset[string] citem = cset[string](deref(Set__string(item)._cpp_obj.get()))
        cdef vector[cset[string]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__string)

cdef class Map__List__Set__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__List__Set__string_string):
            self._cpp_obj = (<Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__List__Set__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[vector[cset[string]],string]] c_items):
        inst = <Map__List__Set__string_string>Map__List__Set__string_string.__new__(Map__List__Set__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[vector[cset[string]],string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[vector[cset[string]],string]] c_inst = make_unique[cmap[vector[cset[string]],string]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.Sequence[_typing.AbstractSet[str]]")
                if not isinstance(key, List__Set__string):
                    key = List__Set__string(key)
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[vector[cset[string]],string](vector[cset[string]](deref(List__Set__string(key)._cpp_obj.get())),item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef vector[cset[string]] ckey = vector[cset[string]](deref(List__Set__string(key)._cpp_obj.get()))
        cdef cmap[vector[cset[string]],string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef vector[cset[string]] citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield List__Set__string.create(
    make_shared[vector[cset[string]]](citem))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef vector[cset[string]] ckey = vector[cset[string]](deref(List__Set__string(key)._cpp_obj.get()))
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef vector[cset[string]] ckey = vector[cset[string]](deref(List__Set__string(key)._cpp_obj.get()))
        cdef cmap[vector[cset[string]],string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef vector[cset[string]] ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (List__Set__string.create(make_shared[vector[cset[string]]](ckey)), bytes(citem).decode('UTF-8'))



Mapping.register(Map__List__Set__string_string)

cdef class Map__Set__List__i32_Map__List__Set__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__Set__List__i32_Map__List__Set__string_string):
            self._cpp_obj = (<Map__Set__List__i32_Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__Set__List__i32_Map__List__Set__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] c_items):
        inst = <Map__Set__List__i32_Map__List__Set__string_string>Map__Set__List__i32_Map__List__Set__string_string.__new__(Map__Set__List__i32_Map__List__Set__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] c_inst = make_unique[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.Sequence[int]]")
                if not isinstance(key, Set__List__i32):
                    key = Set__List__i32(key)
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]")
                if not isinstance(item, Map__List__Set__string_string):
                    item = Map__List__Set__string_string(item)

                deref(c_inst).insert(cpair[cset[vector[int32_t]],cmap[vector[cset[string]],string]](cset[vector[int32_t]](deref(Set__List__i32(key)._cpp_obj.get())),cmap[vector[cset[string]],string](deref(Map__List__Set__string_string(item)._cpp_obj.get()))))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef cset[vector[int32_t]] ckey = cset[vector[int32_t]](deref(Set__List__i32(key)._cpp_obj.get()))
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef cmap[vector[cset[string]],string] citem = deref(iter).second
        return Map__List__Set__string_string.create(
    make_shared[cmap[vector[cset[string]],string]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cset[vector[int32_t]] citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield Set__List__i32.create(
    make_shared[cset[vector[int32_t]]](citem))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef cset[vector[int32_t]] ckey = cset[vector[int32_t]](deref(Set__List__i32(key)._cpp_obj.get()))
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef cset[vector[int32_t]] ckey = cset[vector[int32_t]](deref(Set__List__i32(key)._cpp_obj.get()))
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef cmap[vector[cset[string]],string] citem = deref(iter).second
        return Map__List__Set__string_string.create(
    make_shared[cmap[vector[cset[string]],string]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cmap[vector[cset[string]],string] citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield Map__List__Set__string_string.create(
    make_shared[cmap[vector[cset[string]],string]](citem))

    def items(self):
        if not self:
            raise StopIteration
        cdef cset[vector[int32_t]] ckey
        cdef cmap[vector[cset[string]],string] citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (Set__List__i32.create(make_shared[cset[vector[int32_t]]](ckey)), Map__List__Set__string_string.create(
    make_shared[cmap[vector[cset[string]],string]](citem)))



Mapping.register(Map__Set__List__i32_Map__List__Set__string_string)

cdef class List__i64:
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i64._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[Foo]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[Foo]] _make_instance(object items) except *:
        cdef unique_ptr[vector[Foo]] c_inst = make_unique[vector[Foo]]()
        if items is not None:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Foo]] c_inst
        cdef Foo citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Foo]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__i64.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef Foo citem = item
        cdef vector[Foo] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef Foo citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef Foo citem
        cdef vector[Foo] vec = deref(
            self._cpp_obj.get())
        cdef vector[Foo].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef Foo citem = item
        cdef vector[Foo] vec = deref(self._cpp_obj.get())
        cdef vector[Foo].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef Foo citem = item
        cdef vector[Foo] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i64)

cdef class List__double:
    def __init__(self, items=None):
        if isinstance(items, List__double):
            self._cpp_obj = (<List__double> items)._cpp_obj
        else:
            self._cpp_obj = move(List__double._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[Bar]] c_items):
        inst = <List__double>List__double.__new__(List__double)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[Bar]] _make_instance(object items) except *:
        cdef unique_ptr[vector[Bar]] c_inst = make_unique[vector[Bar]]()
        if items is not None:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Bar]] c_inst
        cdef Bar citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Bar]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__double.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef Bar citem = item
        cdef vector[Bar] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef Bar citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef Bar citem
        cdef vector[Bar] vec = deref(
            self._cpp_obj.get())
        cdef vector[Bar].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef Bar citem = item
        cdef vector[Bar] vec = deref(self._cpp_obj.get())
        cdef vector[Bar].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef Bar citem = item
        cdef vector[Bar] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__double)

IndirectionA = int
IndirectionC = int
IndirectionB = float
