#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'OldStructure', 'NewStructure', 'NewStructure2', 'NewStructureNested', 'NewStructureNestedField']

class OldStructure:
  """
  Attributes:
   - features
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.features = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _key5 = iprot.readI16()
              _val6 = iprot.readDouble()
              self.features[_key5] = _val6
          else: 
            while iprot.peekMap():
              _key7 = iprot.readI16()
              _val8 = iprot.readDouble()
              self.features[_key7] = _val8
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OldStructure')
    if self.features != None:
      oprot.writeFieldBegin('features', TType.MAP, 1)
      oprot.writeMapBegin(TType.I16, TType.DOUBLE, len(self.features))
      for kiter9,viter10 in self.features.items():
        oprot.writeI16(kiter9)
        oprot.writeDouble(viter10)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.features, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    features=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewStructure:
  """
  Attributes:
   - features
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0, forward_compatibility=True)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2, forward_compatibility=True)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.features = {}
          (_ktype12, _vtype13, _size11 ) = iprot.readMapBegin() 
          _ktype12 = _ktype12 if _ktype12 != TType.STOP else TType.I16
          _vtype13 = _vtype13 if _vtype13 != TType.STOP else TType.DOUBLE
          if _size11 >= 0:
            for _i15 in six.moves.range(_size11):
              _key16 = iprot.readIntegral(_ktype12)
              _val17 = iprot.readFloatingPoint(_vtype13)
              self.features[_key16] = _val17
          else: 
            while iprot.peekMap():
              _key18 = iprot.readIntegral(_ktype12)
              _val19 = iprot.readFloatingPoint(_vtype13)
              self.features[_key18] = _val19
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewStructure')
    if self.features != None:
      oprot.writeFieldBegin('features', TType.MAP, 1)
      oprot.writeMapBegin(TType.I16, TType.DOUBLE, len(self.features))
      for kiter20,viter21 in self.features.items():
        oprot.writeI16(kiter20)
        oprot.writeDouble(viter21)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.features, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    features=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewStructure2:
  """
  Attributes:
   - features
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0, forward_compatibility=True)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2, forward_compatibility=True)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.features = {}
          (_ktype23, _vtype24, _size22 ) = iprot.readMapBegin() 
          _ktype23 = _ktype23 if _ktype23 != TType.STOP else TType.I16
          _vtype24 = _vtype24 if _vtype24 != TType.STOP else TType.FLOAT
          if _size22 >= 0:
            for _i26 in six.moves.range(_size22):
              _key27 = iprot.readIntegral(_ktype23)
              _val28 = iprot.readFloatingPoint(_vtype24)
              self.features[_key27] = _val28
          else: 
            while iprot.peekMap():
              _key29 = iprot.readIntegral(_ktype23)
              _val30 = iprot.readFloatingPoint(_vtype24)
              self.features[_key29] = _val30
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewStructure2')
    if self.features != None:
      oprot.writeFieldBegin('features', TType.MAP, 1)
      oprot.writeMapBegin(TType.I16, TType.FLOAT, len(self.features))
      for kiter31,viter32 in self.features.items():
        oprot.writeI16(kiter31)
        oprot.writeFloat(viter32)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.features, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    features=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewStructureNested:
  """
  Attributes:
   - lst
   - mp
   - s
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0, forward_compatibility=True)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2, forward_compatibility=True)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.lst = []
          (_etype36, _size33) = iprot.readListBegin()
          if _size33 >= 0:
            for _i37 in six.moves.range(_size33):
              _elem38 = {}
              (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
              _ktype40 = _ktype40 if _ktype40 != TType.STOP else TType.I16
              _vtype41 = _vtype41 if _vtype41 != TType.STOP else TType.FLOAT
              if _size39 >= 0:
                for _i43 in six.moves.range(_size39):
                  _key44 = iprot.readIntegral(_ktype40)
                  _val45 = iprot.readFloatingPoint(_vtype41)
                  _elem38[_key44] = _val45
              else: 
                while iprot.peekMap():
                  _key46 = iprot.readIntegral(_ktype40)
                  _val47 = iprot.readFloatingPoint(_vtype41)
                  _elem38[_key46] = _val47
              iprot.readMapEnd()
              self.lst.append(_elem38)
          else: 
            while iprot.peekList():
              _elem48 = {}
              (_ktype50, _vtype51, _size49 ) = iprot.readMapBegin() 
              _ktype50 = _ktype50 if _ktype50 != TType.STOP else TType.I16
              _vtype51 = _vtype51 if _vtype51 != TType.STOP else TType.FLOAT
              if _size49 >= 0:
                for _i53 in six.moves.range(_size49):
                  _key54 = iprot.readIntegral(_ktype50)
                  _val55 = iprot.readFloatingPoint(_vtype51)
                  _elem48[_key54] = _val55
              else: 
                while iprot.peekMap():
                  _key56 = iprot.readIntegral(_ktype50)
                  _val57 = iprot.readFloatingPoint(_vtype51)
                  _elem48[_key56] = _val57
              iprot.readMapEnd()
              self.lst.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.mp = {}
          (_ktype59, _vtype60, _size58 ) = iprot.readMapBegin() 
          if _size58 >= 0:
            for _i62 in six.moves.range(_size58):
              _key63 = iprot.readI16()
              _val64 = {}
              (_ktype66, _vtype67, _size65 ) = iprot.readMapBegin() 
              _ktype66 = _ktype66 if _ktype66 != TType.STOP else TType.I16
              _vtype67 = _vtype67 if _vtype67 != TType.STOP else TType.FLOAT
              if _size65 >= 0:
                for _i69 in six.moves.range(_size65):
                  _key70 = iprot.readIntegral(_ktype66)
                  _val71 = iprot.readFloatingPoint(_vtype67)
                  _val64[_key70] = _val71
              else: 
                while iprot.peekMap():
                  _key72 = iprot.readIntegral(_ktype66)
                  _val73 = iprot.readFloatingPoint(_vtype67)
                  _val64[_key72] = _val73
              iprot.readMapEnd()
              self.mp[_key63] = _val64
          else: 
            while iprot.peekMap():
              _key74 = iprot.readI16()
              _val75 = {}
              (_ktype77, _vtype78, _size76 ) = iprot.readMapBegin() 
              _ktype77 = _ktype77 if _ktype77 != TType.STOP else TType.I16
              _vtype78 = _vtype78 if _vtype78 != TType.STOP else TType.FLOAT
              if _size76 >= 0:
                for _i80 in six.moves.range(_size76):
                  _key81 = iprot.readIntegral(_ktype77)
                  _val82 = iprot.readFloatingPoint(_vtype78)
                  _val75[_key81] = _val82
              else: 
                while iprot.peekMap():
                  _key83 = iprot.readIntegral(_ktype77)
                  _val84 = iprot.readFloatingPoint(_vtype78)
                  _val75[_key83] = _val84
              iprot.readMapEnd()
              self.mp[_key74] = _val75
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.s = set()
          (_etype88, _size85) = iprot.readSetBegin()
          if _size85 >= 0:
            for _i89 in six.moves.range(_size85):
              _elem90 = {}
              (_ktype92, _vtype93, _size91 ) = iprot.readMapBegin() 
              _ktype92 = _ktype92 if _ktype92 != TType.STOP else TType.I16
              _vtype93 = _vtype93 if _vtype93 != TType.STOP else TType.FLOAT
              if _size91 >= 0:
                for _i95 in six.moves.range(_size91):
                  _key96 = iprot.readIntegral(_ktype92)
                  _val97 = iprot.readFloatingPoint(_vtype93)
                  _elem90[_key96] = _val97
              else: 
                while iprot.peekMap():
                  _key98 = iprot.readIntegral(_ktype92)
                  _val99 = iprot.readFloatingPoint(_vtype93)
                  _elem90[_key98] = _val99
              iprot.readMapEnd()
              self.s.add(_elem90)
          else: 
            while iprot.peekSet():
              _elem100 = {}
              (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
              _ktype102 = _ktype102 if _ktype102 != TType.STOP else TType.I16
              _vtype103 = _vtype103 if _vtype103 != TType.STOP else TType.FLOAT
              if _size101 >= 0:
                for _i105 in six.moves.range(_size101):
                  _key106 = iprot.readIntegral(_ktype102)
                  _val107 = iprot.readFloatingPoint(_vtype103)
                  _elem100[_key106] = _val107
              else: 
                while iprot.peekMap():
                  _key108 = iprot.readIntegral(_ktype102)
                  _val109 = iprot.readFloatingPoint(_vtype103)
                  _elem100[_key108] = _val109
              iprot.readMapEnd()
              self.s.add(_elem100)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewStructureNested')
    if self.lst != None:
      oprot.writeFieldBegin('lst', TType.LIST, 1)
      oprot.writeListBegin(TType.MAP, len(self.lst))
      for iter110 in self.lst:
        oprot.writeMapBegin(TType.I16, TType.FLOAT, len(iter110))
        for kiter111,viter112 in iter110.items():
          oprot.writeI16(kiter111)
          oprot.writeFloat(viter112)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mp != None:
      oprot.writeFieldBegin('mp', TType.MAP, 2)
      oprot.writeMapBegin(TType.I16, TType.MAP, len(self.mp))
      for kiter113,viter114 in self.mp.items():
        oprot.writeI16(kiter113)
        oprot.writeMapBegin(TType.I16, TType.FLOAT, len(viter114))
        for kiter115,viter116 in viter114.items():
          oprot.writeI16(kiter115)
          oprot.writeFloat(viter116)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.s != None:
      oprot.writeFieldBegin('s', TType.SET, 3)
      oprot.writeSetBegin(TType.MAP, len(self.s))
      for iter117 in self.s:
        oprot.writeMapBegin(TType.I16, TType.FLOAT, len(iter117))
        for kiter118,viter119 in iter117.items():
          oprot.writeI16(kiter118)
          oprot.writeFloat(viter119)
        oprot.writeMapEnd()
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.lst, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    lst=%s' % (value))
    value = pprint.pformat(self.mp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    mp=%s' % (value))
    value = pprint.pformat(self.s, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    s=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewStructureNestedField:
  """
  Attributes:
   - f
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0, forward_compatibility=True)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2, forward_compatibility=True)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.f = NewStructureNested()
          self.f.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewStructureNestedField')
    if self.f != None:
      oprot.writeFieldBegin('f', TType.STRUCT, 1)
      self.f.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.f, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    f=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

FloatFeatures = UnimplementedTypedef()
DoubleMapType = UnimplementedTypedef()
OldMapMap = UnimplementedTypedef()
NewMapMap = UnimplementedTypedef()
OldMapList = UnimplementedTypedef()
NewMapList = UnimplementedTypedef()
all_structs.append(OldStructure)
OldStructure.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'features', (TType.I16,None,TType.DOUBLE,None), None, 2, ), # 1
)

OldStructure.thrift_struct_annotations = {
}
OldStructure.thrift_field_annotations = {
}

def OldStructure__init__(self, features=None,):
  self.features = features

OldStructure.__init__ = OldStructure__init__

def OldStructure__setstate__(self, state):
  state.setdefault('features', None)
  self.__dict__ = state

OldStructure.__getstate__ = lambda self: self.__dict__.copy()
OldStructure.__setstate__ = OldStructure__setstate__

all_structs.append(NewStructure)
NewStructure.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'features', (TType.I16,None,TType.DOUBLE,None), None, 2, ), # 1
)

NewStructure.thrift_struct_annotations = {
}
NewStructure.thrift_field_annotations = {
}

def NewStructure__init__(self, features=None,):
  self.features = features

NewStructure.__init__ = NewStructure__init__

def NewStructure__setstate__(self, state):
  state.setdefault('features', None)
  self.__dict__ = state

NewStructure.__getstate__ = lambda self: self.__dict__.copy()
NewStructure.__setstate__ = NewStructure__setstate__

all_structs.append(NewStructure2)
NewStructure2.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'features', (TType.I16,None,TType.FLOAT,None), None, 2, ), # 1
)

NewStructure2.thrift_struct_annotations = {
}
NewStructure2.thrift_field_annotations = {
}

def NewStructure2__init__(self, features=None,):
  self.features = features

NewStructure2.__init__ = NewStructure2__init__

def NewStructure2__setstate__(self, state):
  state.setdefault('features', None)
  self.__dict__ = state

NewStructure2.__getstate__ = lambda self: self.__dict__.copy()
NewStructure2.__setstate__ = NewStructure2__setstate__

all_structs.append(NewStructureNested)
NewStructureNested.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'lst', (TType.MAP,(TType.I16,None,TType.FLOAT,None)), None, 2, ), # 1
  (2, TType.MAP, 'mp', (TType.I16,None,TType.MAP,(TType.I16,None,TType.FLOAT,None)), None, 2, ), # 2
  (3, TType.SET, 's', (TType.MAP,(TType.I16,None,TType.FLOAT,None)), None, 2, ), # 3
)

NewStructureNested.thrift_struct_annotations = {
}
NewStructureNested.thrift_field_annotations = {
}

def NewStructureNested__init__(self, lst=None, mp=None, s=None,):
  self.lst = lst
  self.mp = mp
  self.s = s

NewStructureNested.__init__ = NewStructureNested__init__

def NewStructureNested__setstate__(self, state):
  state.setdefault('lst', None)
  state.setdefault('mp', None)
  state.setdefault('s', None)
  self.__dict__ = state

NewStructureNested.__getstate__ = lambda self: self.__dict__.copy()
NewStructureNested.__setstate__ = NewStructureNested__setstate__

all_structs.append(NewStructureNestedField)
NewStructureNestedField.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'f', [NewStructureNested, NewStructureNested.thrift_spec, False], None, 2, ), # 1
)

NewStructureNestedField.thrift_struct_annotations = {
}
NewStructureNestedField.thrift_field_annotations = {
}

def NewStructureNestedField__init__(self, f=None,):
  self.f = f

NewStructureNestedField.__init__ = NewStructureNestedField__init__

def NewStructureNestedField__setstate__(self, state):
  state.setdefault('f', None)
  self.__dict__ = state

NewStructureNestedField.__getstate__ = lambda self: self.__dict__.copy()
NewStructureNestedField.__setstate__ = NewStructureNestedField__setstate__

fix_spec(all_structs)
del all_structs
