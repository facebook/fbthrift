/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/refs/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyEnum>::size;
folly::Range<::cpp2::MyEnum const*> const TEnumTraits<::cpp2::MyEnum>::values = folly::range(TEnumDataStorage<::cpp2::MyEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyEnum>::names = folly::range(TEnumDataStorage<::cpp2::MyEnum>::names);

char const* TEnumTraits<::cpp2::MyEnum>::findName(type value) {
  using factory = ::cpp2::_MyEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyEnum>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_MyEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyEnum_EnumMapFactory::ValuesToNamesMapType _MyEnum_VALUES_TO_NAMES = _MyEnum_EnumMapFactory::makeValuesToNamesMap();
const _MyEnum_EnumMapFactory::NamesToValuesMapType _MyEnum_NAMES_TO_VALUES = _MyEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::TypedEnum>::size;
folly::Range<::cpp2::TypedEnum const*> const TEnumTraits<::cpp2::TypedEnum>::values = folly::range(TEnumDataStorage<::cpp2::TypedEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::TypedEnum>::names = folly::range(TEnumDataStorage<::cpp2::TypedEnum>::names);

char const* TEnumTraits<::cpp2::TypedEnum>::findName(type value) {
  using factory = ::cpp2::_TypedEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::TypedEnum>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_TypedEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _TypedEnum_EnumMapFactory::ValuesToNamesMapType _TypedEnum_VALUES_TO_NAMES = _TypedEnum_EnumMapFactory::makeValuesToNamesMap();
const _TypedEnum_EnumMapFactory::NamesToValuesMapType _TypedEnum_NAMES_TO_VALUES = _TypedEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyUnion>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyUnion>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyUnion::Type>::size;
folly::Range<::cpp2::MyUnion::Type const*> const TEnumTraits<::cpp2::MyUnion::Type>::values = folly::range(TEnumDataStorage<::cpp2::MyUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyUnion::Type>::names = folly::range(TEnumDataStorage<::cpp2::MyUnion::Type>::names);

char const* TEnumTraits<::cpp2::MyUnion::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnion::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyUnion::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnion::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void MyUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::anInteger:
      destruct(value_.anInteger);
      break;
    case Type::aString:
      destruct(value_.aString);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool MyUnion::operator==(const MyUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::anInteger:
      return *value_.anInteger == *rhs.value_.anInteger;
    case Type::aString:
      return *value_.aString == *rhs.value_.aString;
    default:
      return true;
  }
}

bool MyUnion::operator<(const MyUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::anInteger:
      return lhs.value_.anInteger < rhs.value_.anInteger;
    case Type::aString:
      return lhs.value_.aString < rhs.value_.aString;
    default:
      return false;
  }
}

void swap(MyUnion& a, MyUnion& b) {
  MyUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void MyUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyField>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyField>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

MyField::MyField(const MyField& srcObj) {
  opt_value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::integral>(srcObj.opt_value);
  value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::integral>(srcObj.value);
  req_value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::integral>(srcObj.req_value);
  opt_enum_value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::enumeration>(srcObj.opt_enum_value);
  enum_value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::enumeration>(srcObj.enum_value);
  req_enum_value = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::enumeration>(srcObj.req_enum_value);
}

MyField& MyField::operator=(const MyField& src) {
  MyField tmp(src);
  swap(*this, tmp);
  return *this;
}

MyField::MyField() :
      opt_value(std::make_unique<::std::int64_t>()),
      value(std::make_unique<::std::int64_t>()),
      req_value(std::make_unique<::std::int64_t>()),
      opt_enum_value(std::make_unique<::cpp2::MyEnum>()),
      enum_value(std::make_unique<::cpp2::MyEnum>()),
      req_enum_value(std::make_unique<::cpp2::MyEnum>()) {
}


MyField::~MyField() {}

MyField::MyField(MyField&& other) noexcept  :
    opt_value(std::move(other.opt_value)),
    value(std::move(other.value)),
    req_value(std::move(other.req_value)),
    opt_enum_value(std::move(other.opt_enum_value)),
    enum_value(std::move(other.enum_value)),
    req_enum_value(std::move(other.req_enum_value)) {
}

MyField& MyField::operator=(FOLLY_MAYBE_UNUSED MyField&& other) noexcept {
    this->opt_value = std::move(other.opt_value);
    this->value = std::move(other.value);
    this->req_value = std::move(other.req_value);
    this->opt_enum_value = std::move(other.opt_enum_value);
    this->enum_value = std::move(other.enum_value);
    this->req_enum_value = std::move(other.req_enum_value);
    return *this;
}


MyField::MyField(apache::thrift::FragileConstructor, ::std::unique_ptr<::std::int64_t> opt_value__arg, ::std::unique_ptr<::std::int64_t> value__arg, ::std::unique_ptr<::std::int64_t> req_value__arg, ::std::unique_ptr<::cpp2::MyEnum> opt_enum_value__arg, ::std::unique_ptr<::cpp2::MyEnum> enum_value__arg, ::std::unique_ptr<::cpp2::MyEnum> req_enum_value__arg) :
    opt_value(std::move(opt_value__arg)),
    value(std::move(value__arg)),
    req_value(std::move(req_value__arg)),
    opt_enum_value(std::move(opt_enum_value__arg)),
    enum_value(std::move(enum_value__arg)),
    req_enum_value(std::move(req_enum_value__arg)) {
}


void MyField::__clear() {
  // clear all fields
  this->opt_value.reset();
  this->value = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::int64_t>>();
  this->req_value = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::int64_t>>();
  this->opt_enum_value.reset();
  this->enum_value = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::cpp2::MyEnum>>();
  this->req_enum_value = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::cpp2::MyEnum>>();
}

bool MyField::operator==(const MyField& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_value_ref(), rhs.opt_value_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.value_ref(), rhs.value_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_value_ref(), rhs.req_value_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_enum_value_ref(), rhs.opt_enum_value_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.enum_value_ref(), rhs.enum_value_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_enum_value_ref(), rhs.req_enum_value_ref()))) {
    return false;
  }
  return true;
}

bool MyField::operator<(const MyField& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_value_ref(), rhs.opt_value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_value_ref(), rhs.opt_value_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.value_ref(), rhs.value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.value_ref(), rhs.value_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_value_ref(), rhs.req_value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_value_ref(), rhs.req_value_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_enum_value_ref(), rhs.opt_enum_value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_enum_value_ref(), rhs.opt_enum_value_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.enum_value_ref(), rhs.enum_value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.enum_value_ref(), rhs.enum_value_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_enum_value_ref(), rhs.req_enum_value_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_enum_value_ref(), rhs.req_enum_value_ref());
  }
  return false;
}


void swap(MyField& a, MyField& b) {
  using ::std::swap;
  swap(a.opt_value, b.opt_value);
  swap(a.value, b.value);
  swap(a.req_value, b.req_value);
  swap(a.opt_enum_value, b.opt_enum_value);
  swap(a.enum_value, b.enum_value);
  swap(a.req_enum_value, b.req_enum_value);
}

template void MyField::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyField::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyField::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyField::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyField::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyField::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyField::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyField::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

MyStruct::MyStruct(const MyStruct& srcObj) {
  opt_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.opt_ref);
  ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.ref);
  req_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.req_ref);
}

MyStruct& MyStruct::operator=(const MyStruct& src) {
  MyStruct tmp(src);
  swap(*this, tmp);
  return *this;
}

MyStruct::MyStruct(MyStruct&& other) noexcept  :
    opt_ref(std::move(other.opt_ref)),
    ref(std::move(other.ref)),
    req_ref(std::move(other.req_ref)) {
}

MyStruct& MyStruct::operator=(FOLLY_MAYBE_UNUSED MyStruct&& other) noexcept {
    this->opt_ref = std::move(other.opt_ref);
    this->ref = std::move(other.ref);
    this->req_ref = std::move(other.req_ref);
    return *this;
}


MyStruct::MyStruct(apache::thrift::FragileConstructor, ::std::unique_ptr<::cpp2::MyField> opt_ref__arg, ::std::unique_ptr<::cpp2::MyField> ref__arg, ::std::unique_ptr<::cpp2::MyField> req_ref__arg) :
    opt_ref(std::move(opt_ref__arg)),
    ref(std::move(ref__arg)),
    req_ref(std::move(req_ref__arg)) {
}


void MyStruct::__clear() {
  // clear all fields
  this->opt_ref.reset();
  if (this->ref) this->ref->__clear();
  if (this->req_ref) this->req_ref->__clear();
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_ref_ref(), rhs.opt_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.ref_ref(), rhs.ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_ref_ref(), rhs.req_ref_ref()))) {
    return false;
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_ref_ref(), rhs.opt_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_ref_ref(), rhs.opt_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.ref_ref(), rhs.ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.ref_ref(), rhs.ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_ref_ref(), rhs.req_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_ref_ref(), rhs.req_ref_ref());
  }
  return false;
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.opt_ref, b.opt_ref);
  swap(a.ref, b.ref);
  swap(a.req_ref, b.req_ref);
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithUnion>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithUnion>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithUnion::StructWithUnion(const StructWithUnion& srcObj) {
  u = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::variant>(srcObj.u);
  aDouble = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::floating_point>(srcObj.aDouble);
  __fbthrift_field_f = srcObj.__fbthrift_field_f;
  __isset.set(folly::index_constant<0>(),srcObj.__isset.get(folly::index_constant<0>()));
}

StructWithUnion& StructWithUnion::operator=(const StructWithUnion& src) {
  StructWithUnion tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithUnion::StructWithUnion(StructWithUnion&& other) noexcept  :
    u(std::move(other.u)),
    aDouble(std::move(other.aDouble)),
    __fbthrift_field_f(std::move(other.__fbthrift_field_f)),
    __isset(other.__isset) {
}

StructWithUnion& StructWithUnion::operator=(FOLLY_MAYBE_UNUSED StructWithUnion&& other) noexcept {
    this->u = std::move(other.u);
    this->aDouble = std::move(other.aDouble);
    this->__fbthrift_field_f = std::move(other.__fbthrift_field_f);
    __isset = other.__isset;
    return *this;
}


StructWithUnion::StructWithUnion(apache::thrift::FragileConstructor, ::std::unique_ptr<::cpp2::MyUnion> u__arg, ::std::unique_ptr<double> aDouble__arg, ::cpp2::MyField f__arg) :
    u(std::move(u__arg)),
    aDouble(std::move(aDouble__arg)),
    __fbthrift_field_f(std::move(f__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void StructWithUnion::__clear() {
  // clear all fields
  if (this->u) this->u->__clear();
  this->aDouble = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<double>>();
  this->__fbthrift_field_f.__clear();
  __isset = {};
}

bool StructWithUnion::operator==(const StructWithUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.u_ref(), rhs.u_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aDouble_ref(), rhs.aDouble_ref()))) {
    return false;
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return false;
  }
  return true;
}

bool StructWithUnion::operator<(const StructWithUnion& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.u_ref(), rhs.u_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.u_ref(), rhs.u_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aDouble_ref(), rhs.aDouble_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.aDouble_ref(), rhs.aDouble_ref());
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return lhs.f_ref() < rhs.f_ref();
  }
  return false;
}

const ::cpp2::MyField& StructWithUnion::get_f() const& {
  return __fbthrift_field_f;
}

::cpp2::MyField StructWithUnion::get_f() && {
  return std::move(__fbthrift_field_f);
}


void swap(StructWithUnion& a, StructWithUnion& b) {
  using ::std::swap;
  swap(a.u, b.u);
  swap(a.aDouble, b.aDouble);
  swap(a.f_ref().value(), b.f_ref().value());
  swap(a.__isset, b.__isset);
}

template void StructWithUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithUnion,
        ::apache::thrift::type_class::variant,
        ::cpp2::MyUnion>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithUnion,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithUnion,
        ::apache::thrift::type_class::variant,
        ::cpp2::MyUnion>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithUnion,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::RecursiveStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::RecursiveStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

RecursiveStruct::RecursiveStruct(const RecursiveStruct&) = default;
RecursiveStruct& RecursiveStruct::operator=(const RecursiveStruct&) = default;
RecursiveStruct::RecursiveStruct(RecursiveStruct&& other) noexcept  :
    __fbthrift_field_mes(std::move(other.__fbthrift_field_mes)),
    __isset(other.__isset) {
}

RecursiveStruct& RecursiveStruct::operator=(FOLLY_MAYBE_UNUSED RecursiveStruct&& other) noexcept {
    this->__fbthrift_field_mes = std::move(other.__fbthrift_field_mes);
    __isset = other.__isset;
    return *this;
}


RecursiveStruct::RecursiveStruct(apache::thrift::FragileConstructor, ::std::vector<::cpp2::RecursiveStruct> mes__arg) :
    __fbthrift_field_mes(std::move(mes__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void RecursiveStruct::__clear() {
  // clear all fields
  this->__fbthrift_field_mes.clear();
  __isset = {};
}

bool RecursiveStruct::operator==(const RecursiveStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.mes_ref() == rhs.mes_ref())) {
    return false;
  }
  return true;
}

bool RecursiveStruct::operator<(const RecursiveStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.mes_ref() == rhs.mes_ref())) {
    return lhs.mes_ref() < rhs.mes_ref();
  }
  return false;
}

const ::std::vector<::cpp2::RecursiveStruct>* RecursiveStruct::get_mes() const& {
  return mes_ref().has_value() ? std::addressof(__fbthrift_field_mes) : nullptr;
}

::std::vector<::cpp2::RecursiveStruct>* RecursiveStruct::get_mes() & {
  return mes_ref().has_value() ? std::addressof(__fbthrift_field_mes) : nullptr;
}


void swap(RecursiveStruct& a, RecursiveStruct& b) {
  using ::std::swap;
  swap(a.mes_ref().value_unchecked(), b.mes_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void RecursiveStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RecursiveStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RecursiveStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RecursiveStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RecursiveStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RecursiveStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RecursiveStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RecursiveStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithContainers>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithContainers>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithContainers::StructWithContainers(const StructWithContainers& srcObj) {
  list_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>(srcObj.list_ref);
  set_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::set<::apache::thrift::type_class::integral>>(srcObj.set_ref);
  map_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::integral>>(srcObj.map_ref);
  list_ref_unique = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>(srcObj.list_ref_unique);
  set_ref_shared = srcObj.set_ref_shared;
  list_ref_shared_const = srcObj.list_ref_shared_const;
}

StructWithContainers& StructWithContainers::operator=(const StructWithContainers& src) {
  StructWithContainers tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithContainers::StructWithContainers() :
      list_ref(std::make_unique<::std::vector<::std::int32_t>>()),
      set_ref(std::make_unique<::std::set<::std::int32_t>>()),
      map_ref(std::make_unique<::std::map<::std::int32_t, ::std::int32_t>>()),
      list_ref_unique(std::make_unique<::std::vector<::std::int32_t>>()),
      set_ref_shared(std::make_shared<::std::set<::std::int32_t>>()),
      list_ref_shared_const(std::make_shared<::std::vector<::std::int32_t>>()) {
}


StructWithContainers::~StructWithContainers() {}

StructWithContainers::StructWithContainers(StructWithContainers&& other) noexcept  :
    list_ref(std::move(other.list_ref)),
    set_ref(std::move(other.set_ref)),
    map_ref(std::move(other.map_ref)),
    list_ref_unique(std::move(other.list_ref_unique)),
    set_ref_shared(std::move(other.set_ref_shared)),
    list_ref_shared_const(std::move(other.list_ref_shared_const)) {
}

StructWithContainers& StructWithContainers::operator=(FOLLY_MAYBE_UNUSED StructWithContainers&& other) noexcept {
    this->list_ref = std::move(other.list_ref);
    this->set_ref = std::move(other.set_ref);
    this->map_ref = std::move(other.map_ref);
    this->list_ref_unique = std::move(other.list_ref_unique);
    this->set_ref_shared = std::move(other.set_ref_shared);
    this->list_ref_shared_const = std::move(other.list_ref_shared_const);
    return *this;
}


StructWithContainers::StructWithContainers(apache::thrift::FragileConstructor, ::std::unique_ptr<::std::vector<::std::int32_t>> list_ref__arg, ::std::unique_ptr<::std::set<::std::int32_t>> set_ref__arg, ::std::unique_ptr<::std::map<::std::int32_t, ::std::int32_t>> map_ref__arg, ::std::unique_ptr<::std::vector<::std::int32_t>> list_ref_unique__arg, ::std::shared_ptr<::std::set<::std::int32_t>> set_ref_shared__arg, ::std::shared_ptr<const ::std::vector<::std::int32_t>> list_ref_shared_const__arg) :
    list_ref(std::move(list_ref__arg)),
    set_ref(std::move(set_ref__arg)),
    map_ref(std::move(map_ref__arg)),
    list_ref_unique(std::move(list_ref_unique__arg)),
    set_ref_shared(std::move(set_ref_shared__arg)),
    list_ref_shared_const(std::move(list_ref_shared_const__arg)) {
}


void StructWithContainers::__clear() {
  // clear all fields
  this->list_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::vector<::std::int32_t>>>();
  this->set_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::set<::std::int32_t>>>();
  this->map_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::map<::std::int32_t, ::std::int32_t>>>();
  this->list_ref_unique = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::vector<::std::int32_t>>>();
  this->set_ref_shared = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<::std::set<::std::int32_t>>>();
  this->list_ref_shared_const = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<const ::std::vector<::std::int32_t>>>();
}

bool StructWithContainers::operator==(const StructWithContainers& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_ref(), rhs.list_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.set_ref_ref(), rhs.set_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.map_ref_ref(), rhs.map_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_unique_ref(), rhs.list_ref_unique_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.set_ref_shared_ref(), rhs.set_ref_shared_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_shared_const_ref(), rhs.list_ref_shared_const_ref()))) {
    return false;
  }
  return true;
}

bool StructWithContainers::operator<(const StructWithContainers& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_ref(), rhs.list_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.list_ref_ref(), rhs.list_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.set_ref_ref(), rhs.set_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.set_ref_ref(), rhs.set_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.map_ref_ref(), rhs.map_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.map_ref_ref(), rhs.map_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_unique_ref(), rhs.list_ref_unique_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.list_ref_unique_ref(), rhs.list_ref_unique_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.set_ref_shared_ref(), rhs.set_ref_shared_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.set_ref_shared_ref(), rhs.set_ref_shared_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.list_ref_shared_const_ref(), rhs.list_ref_shared_const_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.list_ref_shared_const_ref(), rhs.list_ref_shared_const_ref());
  }
  return false;
}


void swap(StructWithContainers& a, StructWithContainers& b) {
  using ::std::swap;
  swap(a.list_ref, b.list_ref);
  swap(a.set_ref, b.set_ref);
  swap(a.map_ref, b.map_ref);
  swap(a.list_ref_unique, b.list_ref_unique);
  swap(a.set_ref_shared, b.set_ref_shared);
  swap(a.list_ref_shared_const, b.list_ref_shared_const);
}

template void StructWithContainers::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithContainers::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithContainers::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithContainers::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithContainers::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithContainers::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithContainers::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithContainers::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithSharedConst>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithSharedConst>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithSharedConst::StructWithSharedConst(const StructWithSharedConst&) = default;
StructWithSharedConst& StructWithSharedConst::operator=(const StructWithSharedConst&) = default;
StructWithSharedConst::StructWithSharedConst(StructWithSharedConst&& other) noexcept  :
    opt_shared_const(std::move(other.opt_shared_const)),
    shared_const(std::move(other.shared_const)),
    req_shared_const(std::move(other.req_shared_const)) {
}

StructWithSharedConst& StructWithSharedConst::operator=(FOLLY_MAYBE_UNUSED StructWithSharedConst&& other) noexcept {
    this->opt_shared_const = std::move(other.opt_shared_const);
    this->shared_const = std::move(other.shared_const);
    this->req_shared_const = std::move(other.req_shared_const);
    return *this;
}


StructWithSharedConst::StructWithSharedConst(apache::thrift::FragileConstructor, ::std::shared_ptr<const ::cpp2::MyField> opt_shared_const__arg, ::std::shared_ptr<const ::cpp2::MyField> shared_const__arg, ::std::shared_ptr<const ::cpp2::MyField> req_shared_const__arg) :
    opt_shared_const(std::move(opt_shared_const__arg)),
    shared_const(std::move(shared_const__arg)),
    req_shared_const(std::move(req_shared_const__arg)) {
}


void StructWithSharedConst::__clear() {
  // clear all fields
  this->opt_shared_const.reset();
  if (this->shared_const) this->shared_const = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<const ::cpp2::MyField>>();
  if (this->req_shared_const) this->req_shared_const = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<const ::cpp2::MyField>>();
}

bool StructWithSharedConst::operator==(const StructWithSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_shared_const_ref(), rhs.opt_shared_const_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.shared_const_ref(), rhs.shared_const_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_shared_const_ref(), rhs.req_shared_const_ref()))) {
    return false;
  }
  return true;
}

bool StructWithSharedConst::operator<(const StructWithSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_shared_const_ref(), rhs.opt_shared_const_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_shared_const_ref(), rhs.opt_shared_const_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.shared_const_ref(), rhs.shared_const_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.shared_const_ref(), rhs.shared_const_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_shared_const_ref(), rhs.req_shared_const_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_shared_const_ref(), rhs.req_shared_const_ref());
  }
  return false;
}


void swap(StructWithSharedConst& a, StructWithSharedConst& b) {
  using ::std::swap;
  swap(a.opt_shared_const, b.opt_shared_const);
  swap(a.shared_const, b.shared_const);
  swap(a.req_shared_const, b.req_shared_const);
}

template void StructWithSharedConst::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithSharedConst::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithSharedConst::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithSharedConst::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithSharedConst::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithSharedConst::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithSharedConst::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithSharedConst::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyField>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::Empty>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::Empty>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {


Empty::Empty(apache::thrift::FragileConstructor) {}


void Empty::__clear() {
  // clear all fields
}

bool Empty::operator==(const Empty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool Empty::operator<(const Empty& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(Empty& a, Empty& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void Empty::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Empty::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithRef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRef::StructWithRef(const StructWithRef& srcObj) {
  def_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.def_field);
  opt_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.opt_field);
  req_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.req_field);
}

StructWithRef& StructWithRef::operator=(const StructWithRef& src) {
  StructWithRef tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithRef::StructWithRef(StructWithRef&& other) noexcept  :
    def_field(std::move(other.def_field)),
    opt_field(std::move(other.opt_field)),
    req_field(std::move(other.req_field)) {
}

StructWithRef& StructWithRef::operator=(FOLLY_MAYBE_UNUSED StructWithRef&& other) noexcept {
    this->def_field = std::move(other.def_field);
    this->opt_field = std::move(other.opt_field);
    this->req_field = std::move(other.req_field);
    return *this;
}


StructWithRef::StructWithRef(apache::thrift::FragileConstructor, ::std::unique_ptr<::cpp2::Empty> def_field__arg, ::std::unique_ptr<::cpp2::Empty> opt_field__arg, ::std::unique_ptr<::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {
}


void StructWithRef::__clear() {
  // clear all fields
}

bool StructWithRef::operator==(const StructWithRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return false;
  }
  return true;
}

bool StructWithRef::operator<(const StructWithRef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_field_ref(), rhs.def_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_field_ref(), rhs.opt_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_field_ref(), rhs.req_field_ref());
  }
  return false;
}


void swap(StructWithRef& a, StructWithRef& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRef,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithBox>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithBox>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithBox::StructWithBox(const StructWithBox&) = default;
StructWithBox& StructWithBox::operator=(const StructWithBox&) = default;
StructWithBox::StructWithBox(StructWithBox&& other) noexcept  :
    a(std::move(other.a)),
    b(std::move(other.b)),
    c(std::move(other.c)) {
}

StructWithBox& StructWithBox::operator=(FOLLY_MAYBE_UNUSED StructWithBox&& other) noexcept {
    this->a = std::move(other.a);
    this->b = std::move(other.b);
    this->c = std::move(other.c);
    return *this;
}


StructWithBox::StructWithBox(apache::thrift::FragileConstructor, ::apache::thrift::detail::boxed_value_ptr<::std::string> a__arg, ::apache::thrift::detail::boxed_value_ptr<::std::vector<::std::int64_t>> b__arg, ::apache::thrift::detail::boxed_value_ptr<::cpp2::StructWithRef> c__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)),
    c(std::move(c__arg)) {
}


void StructWithBox::__clear() {
  // clear all fields
  this->a.reset();
  this->b.reset();
  this->c.reset();
}

bool StructWithBox::operator==(const StructWithBox& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.a_ref(), rhs.a_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.b_ref(), rhs.b_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.c_ref(), rhs.c_ref()))) {
    return false;
  }
  return true;
}

bool StructWithBox::operator<(const StructWithBox& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.a_ref(), rhs.a_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.a_ref(), rhs.a_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.b_ref(), rhs.b_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.b_ref(), rhs.b_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.c_ref(), rhs.c_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.c_ref(), rhs.c_ref());
  }
  return false;
}


void swap(StructWithBox& a, StructWithBox& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
}

template void StructWithBox::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithBox::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithBox::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithBox::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithBox::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithBox::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithBox::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithBox::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithBox,
        ::apache::thrift::type_class::structure,
        ::cpp2::StructWithRef>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithBox,
        ::apache::thrift::type_class::structure,
        ::cpp2::StructWithRef>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeUnique>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithRefTypeUnique>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefTypeUnique::StructWithRefTypeUnique(const StructWithRefTypeUnique& srcObj) {
  def_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.def_field);
  opt_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.opt_field);
  req_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.req_field);
}

StructWithRefTypeUnique& StructWithRefTypeUnique::operator=(const StructWithRefTypeUnique& src) {
  StructWithRefTypeUnique tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithRefTypeUnique::StructWithRefTypeUnique(StructWithRefTypeUnique&& other) noexcept  :
    def_field(std::move(other.def_field)),
    opt_field(std::move(other.opt_field)),
    req_field(std::move(other.req_field)) {
}

StructWithRefTypeUnique& StructWithRefTypeUnique::operator=(FOLLY_MAYBE_UNUSED StructWithRefTypeUnique&& other) noexcept {
    this->def_field = std::move(other.def_field);
    this->opt_field = std::move(other.opt_field);
    this->req_field = std::move(other.req_field);
    return *this;
}


StructWithRefTypeUnique::StructWithRefTypeUnique(apache::thrift::FragileConstructor, ::std::unique_ptr<::cpp2::Empty> def_field__arg, ::std::unique_ptr<::cpp2::Empty> opt_field__arg, ::std::unique_ptr<::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {
}


void StructWithRefTypeUnique::__clear() {
  // clear all fields
}

bool StructWithRefTypeUnique::operator==(const StructWithRefTypeUnique& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return false;
  }
  return true;
}

bool StructWithRefTypeUnique::operator<(const StructWithRefTypeUnique& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_field_ref(), rhs.def_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_field_ref(), rhs.opt_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_field_ref(), rhs.req_field_ref());
  }
  return false;
}


void swap(StructWithRefTypeUnique& a, StructWithRefTypeUnique& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeUnique::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeUnique::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeUnique::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeUnique::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeUnique::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeUnique::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeUnique::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeUnique::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeUnique,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeShared>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithRefTypeShared>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefTypeShared::StructWithRefTypeShared(const StructWithRefTypeShared&) = default;
StructWithRefTypeShared& StructWithRefTypeShared::operator=(const StructWithRefTypeShared&) = default;
StructWithRefTypeShared::StructWithRefTypeShared(StructWithRefTypeShared&& other) noexcept  :
    def_field(std::move(other.def_field)),
    opt_field(std::move(other.opt_field)),
    req_field(std::move(other.req_field)) {
}

StructWithRefTypeShared& StructWithRefTypeShared::operator=(FOLLY_MAYBE_UNUSED StructWithRefTypeShared&& other) noexcept {
    this->def_field = std::move(other.def_field);
    this->opt_field = std::move(other.opt_field);
    this->req_field = std::move(other.req_field);
    return *this;
}


StructWithRefTypeShared::StructWithRefTypeShared(apache::thrift::FragileConstructor, ::std::shared_ptr<::cpp2::Empty> def_field__arg, ::std::shared_ptr<::cpp2::Empty> opt_field__arg, ::std::shared_ptr<::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {
}


void StructWithRefTypeShared::__clear() {
  // clear all fields
}

bool StructWithRefTypeShared::operator==(const StructWithRefTypeShared& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return false;
  }
  return true;
}

bool StructWithRefTypeShared::operator<(const StructWithRefTypeShared& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_field_ref(), rhs.def_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_field_ref(), rhs.opt_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_field_ref(), rhs.req_field_ref());
  }
  return false;
}


void swap(StructWithRefTypeShared& a, StructWithRefTypeShared& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeShared::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeShared::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeShared::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeShared::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeShared::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeShared::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeShared::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeShared::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeShared,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefTypeSharedConst>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithRefTypeSharedConst>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefTypeSharedConst::StructWithRefTypeSharedConst(const StructWithRefTypeSharedConst&) = default;
StructWithRefTypeSharedConst& StructWithRefTypeSharedConst::operator=(const StructWithRefTypeSharedConst&) = default;
StructWithRefTypeSharedConst::StructWithRefTypeSharedConst(StructWithRefTypeSharedConst&& other) noexcept  :
    def_field(std::move(other.def_field)),
    opt_field(std::move(other.opt_field)),
    req_field(std::move(other.req_field)) {
}

StructWithRefTypeSharedConst& StructWithRefTypeSharedConst::operator=(FOLLY_MAYBE_UNUSED StructWithRefTypeSharedConst&& other) noexcept {
    this->def_field = std::move(other.def_field);
    this->opt_field = std::move(other.opt_field);
    this->req_field = std::move(other.req_field);
    return *this;
}


StructWithRefTypeSharedConst::StructWithRefTypeSharedConst(apache::thrift::FragileConstructor, ::std::shared_ptr<const ::cpp2::Empty> def_field__arg, ::std::shared_ptr<const ::cpp2::Empty> opt_field__arg, ::std::shared_ptr<const ::cpp2::Empty> req_field__arg) :
    def_field(std::move(def_field__arg)),
    opt_field(std::move(opt_field__arg)),
    req_field(std::move(req_field__arg)) {
}


void StructWithRefTypeSharedConst::__clear() {
  // clear all fields
}

bool StructWithRefTypeSharedConst::operator==(const StructWithRefTypeSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return false;
  }
  return true;
}

bool StructWithRefTypeSharedConst::operator<(const StructWithRefTypeSharedConst& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_field_ref(), rhs.def_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.opt_field_ref(), rhs.opt_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.opt_field_ref(), rhs.opt_field_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.req_field_ref(), rhs.req_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.req_field_ref(), rhs.req_field_ref());
  }
  return false;
}


void swap(StructWithRefTypeSharedConst& a, StructWithRefTypeSharedConst& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
  swap(a.opt_field, b.opt_field);
  swap(a.req_field, b.req_field);
}

template void StructWithRefTypeSharedConst::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefTypeSharedConst::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefTypeSharedConst::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefTypeSharedConst::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefTypeSharedConst::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefTypeSharedConst,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithRefAndAnnotCppNoexceptMoveCtor>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithRefAndAnnotCppNoexceptMoveCtor>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithRefAndAnnotCppNoexceptMoveCtor::StructWithRefAndAnnotCppNoexceptMoveCtor(const StructWithRefAndAnnotCppNoexceptMoveCtor& srcObj) {
  def_field = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.def_field);
}

StructWithRefAndAnnotCppNoexceptMoveCtor& StructWithRefAndAnnotCppNoexceptMoveCtor::operator=(const StructWithRefAndAnnotCppNoexceptMoveCtor& src) {
  StructWithRefAndAnnotCppNoexceptMoveCtor tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithRefAndAnnotCppNoexceptMoveCtor::StructWithRefAndAnnotCppNoexceptMoveCtor(StructWithRefAndAnnotCppNoexceptMoveCtor&& other) noexcept  :
    def_field(std::move(other.def_field)) {
}

StructWithRefAndAnnotCppNoexceptMoveCtor& StructWithRefAndAnnotCppNoexceptMoveCtor::operator=(FOLLY_MAYBE_UNUSED StructWithRefAndAnnotCppNoexceptMoveCtor&& other) noexcept {
    this->def_field = std::move(other.def_field);
    return *this;
}


StructWithRefAndAnnotCppNoexceptMoveCtor::StructWithRefAndAnnotCppNoexceptMoveCtor(apache::thrift::FragileConstructor, ::std::unique_ptr<::cpp2::Empty> def_field__arg) :
    def_field(std::move(def_field__arg)) {
}


void StructWithRefAndAnnotCppNoexceptMoveCtor::__clear() {
  // clear all fields
}

bool StructWithRefAndAnnotCppNoexceptMoveCtor::operator==(const StructWithRefAndAnnotCppNoexceptMoveCtor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return false;
  }
  return true;
}

bool StructWithRefAndAnnotCppNoexceptMoveCtor::operator<(const StructWithRefAndAnnotCppNoexceptMoveCtor& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_field_ref(), rhs.def_field_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_field_ref(), rhs.def_field_ref());
  }
  return false;
}


void swap(StructWithRefAndAnnotCppNoexceptMoveCtor& a, StructWithRefAndAnnotCppNoexceptMoveCtor& b) {
  using ::std::swap;
  swap(a.def_field, b.def_field);
}

template void StructWithRefAndAnnotCppNoexceptMoveCtor::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithRefAndAnnotCppNoexceptMoveCtor::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithRefAndAnnotCppNoexceptMoveCtor::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        StructWithRefAndAnnotCppNoexceptMoveCtor,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        StructWithRefAndAnnotCppNoexceptMoveCtor,
        ::apache::thrift::type_class::structure,
        ::cpp2::Empty>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::StructWithString>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::StructWithString>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

StructWithString::StructWithString(const StructWithString& srcObj) {
  def_unique_string_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::string>(srcObj.def_unique_string_ref);
  def_shared_string_ref = srcObj.def_shared_string_ref;
  def_shared_string_const_ref = srcObj.def_shared_string_const_ref;
  unique_string_ref = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::string>(srcObj.unique_string_ref);
  shared_string_ref = srcObj.shared_string_ref;
}

StructWithString& StructWithString::operator=(const StructWithString& src) {
  StructWithString tmp(src);
  swap(*this, tmp);
  return *this;
}

StructWithString::StructWithString() :
      def_unique_string_ref(std::make_unique<::std::string>(apache::thrift::StringTraits<std::string>::fromStringLiteral("..."))),
      def_shared_string_ref(std::make_shared<::std::string>(apache::thrift::StringTraits<std::string>::fromStringLiteral("..."))),
      def_shared_string_const_ref(std::make_shared<::std::string>(apache::thrift::StringTraits<std::string>::fromStringLiteral("..."))) {
}


StructWithString::~StructWithString() {}

StructWithString::StructWithString(StructWithString&& other) noexcept  :
    def_unique_string_ref(std::move(other.def_unique_string_ref)),
    def_shared_string_ref(std::move(other.def_shared_string_ref)),
    def_shared_string_const_ref(std::move(other.def_shared_string_const_ref)),
    unique_string_ref(std::move(other.unique_string_ref)),
    shared_string_ref(std::move(other.shared_string_ref)) {
}

StructWithString& StructWithString::operator=(FOLLY_MAYBE_UNUSED StructWithString&& other) noexcept {
    this->def_unique_string_ref = std::move(other.def_unique_string_ref);
    this->def_shared_string_ref = std::move(other.def_shared_string_ref);
    this->def_shared_string_const_ref = std::move(other.def_shared_string_const_ref);
    this->unique_string_ref = std::move(other.unique_string_ref);
    this->shared_string_ref = std::move(other.shared_string_ref);
    return *this;
}


StructWithString::StructWithString(apache::thrift::FragileConstructor, ::std::unique_ptr<::std::string> def_unique_string_ref__arg, ::std::shared_ptr<::std::string> def_shared_string_ref__arg, ::std::shared_ptr<const ::std::string> def_shared_string_const_ref__arg, ::std::unique_ptr<::std::string> unique_string_ref__arg, ::std::shared_ptr<::std::string> shared_string_ref__arg) :
    def_unique_string_ref(std::move(def_unique_string_ref__arg)),
    def_shared_string_ref(std::move(def_shared_string_ref__arg)),
    def_shared_string_const_ref(std::move(def_shared_string_const_ref__arg)),
    unique_string_ref(std::move(unique_string_ref__arg)),
    shared_string_ref(std::move(shared_string_ref__arg)) {
}


void StructWithString::__clear() {
  // clear all fields
  this->def_unique_string_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::string>>();
  this->def_shared_string_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<::std::string>>();
  this->def_shared_string_const_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<const ::std::string>>();
  this->unique_string_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::string>>();
  this->shared_string_ref = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<::std::string>>();
}

bool StructWithString::operator==(const StructWithString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_unique_string_ref_ref(), rhs.def_unique_string_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_shared_string_ref_ref(), rhs.def_shared_string_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_shared_string_const_ref_ref(), rhs.def_shared_string_const_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.unique_string_ref_ref(), rhs.unique_string_ref_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.shared_string_ref_ref(), rhs.shared_string_ref_ref()))) {
    return false;
  }
  return true;
}

bool StructWithString::operator<(const StructWithString& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_unique_string_ref_ref(), rhs.def_unique_string_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_unique_string_ref_ref(), rhs.def_unique_string_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_shared_string_ref_ref(), rhs.def_shared_string_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_shared_string_ref_ref(), rhs.def_shared_string_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.def_shared_string_const_ref_ref(), rhs.def_shared_string_const_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.def_shared_string_const_ref_ref(), rhs.def_shared_string_const_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.unique_string_ref_ref(), rhs.unique_string_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.unique_string_ref_ref(), rhs.unique_string_ref_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.shared_string_ref_ref(), rhs.shared_string_ref_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.shared_string_ref_ref(), rhs.shared_string_ref_ref());
  }
  return false;
}


void swap(StructWithString& a, StructWithString& b) {
  using ::std::swap;
  swap(a.def_unique_string_ref, b.def_unique_string_ref);
  swap(a.def_shared_string_ref, b.def_shared_string_ref);
  swap(a.def_shared_string_const_ref, b.def_shared_string_const_ref);
  swap(a.unique_string_ref, b.unique_string_ref);
  swap(a.shared_string_ref, b.shared_string_ref);
}

template void StructWithString::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithString::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithString::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithString::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithString::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithString::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithString::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithString::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace cpp2 { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}} // cpp2
