#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.std_libcpp cimport sv_to_str as __sv_to_str, string_view as __cstring_view
from thrift.py3.types cimport (
    cSetOp as __cSetOp,
    richcmp as __richcmp,
    set_op as __set_op,
    setcmp as __setcmp,
    list_index as __list_index,
    list_count as __list_count,
    list_slice as __list_slice,
    list_getitem as __list_getitem,
    set_iter as __set_iter,
    map_iter as __map_iter,
    map_contains as __map_contains,
    map_getitem as __map_getitem,
    reference_shared_ptr as __reference_shared_ptr,
    get_field_name_by_index as __get_field_name_by_index,
    reset_field as __reset_field,
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    const_pointer_cast,
    constant_shared_ptr,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
import folly.iobuf as _fbthrift_iobuf
from folly.optional cimport cOptional
from folly.memory cimport to_shared_ptr as __to_shared_ptr
from folly.range cimport Range as __cRange

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection


cdef __EnumData __MyEnum_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cMyEnum](), MyEnum)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __MyEnum_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __MyEnum_enum_data.get_all_names()

    def __len__(cls):
        return __MyEnum_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __MyEnum_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class MyEnum(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyEnum_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cMyEnum].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyEnum"


__SetMetaClass(<PyTypeObject*> MyEnum, <PyTypeObject*> __MyEnumMeta)


cdef __EnumData __TypedEnum_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cTypedEnum](), TypedEnum)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __TypedEnumMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __TypedEnum_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __TypedEnum_enum_data.get_all_names()

    def __len__(cls):
        return __TypedEnum_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __TypedEnum_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class TypedEnum(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __TypedEnum_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cTypedEnum].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.TypedEnum"


__SetMetaClass(<PyTypeObject*> TypedEnum, <PyTypeObject*> __TypedEnumMeta)



cdef __UnionTypeEnumData __MyUnion_union_type_enum_data  = __UnionTypeEnumData.create(
    __createEnumDataForUnionType[cMyUnion](),
    __MyUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __MyUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __MyUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __MyUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __MyUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __MyUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __MyUnionType, <PyTypeObject*> __MyUnion_Union_TypeMeta)




@__cython.auto_pickle(False)
cdef class MyUnion(thrift.py3.types.Union):
    Type = __MyUnionType

    def __init__(
        self, *,
        anInteger=None,
        str aString=None
    ):
        if anInteger is not None:
            if not isinstance(anInteger, int):
                raise TypeError(f'anInteger is not a { int !r}.')
            anInteger = <cint32_t> anInteger

        self._cpp_obj = __to_shared_ptr(cmove(MyUnion._make_instance(
          NULL,
          anInteger,
          aString,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return MyUnion()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <cint32_t> value
                    return MyUnion(anInteger=value)
                except OverflowError:
                    pass
        if isinstance(value, str):
            return MyUnion(aString=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cMyUnion] _make_instance(
        cMyUnion* base_instance,
        object anInteger,
        str aString
    ) except *:
        cdef unique_ptr[cMyUnion] c_inst = make_unique[cMyUnion]()
        cdef bint any_set = False
        if anInteger is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_anInteger(cint32_t(deref((<cint32_t?>anInteger)._cpp_obj)))
            any_set = True
        if aString is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_aString(string(deref((<str?>aString)._cpp_obj)))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef create(shared_ptr[cMyUnion] cpp_obj):
        __fbthrift_inst = <MyUnion>MyUnion.__new__(MyUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def anInteger(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not anInteger')
        return self.value

    @property
    def aString(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not aString')
        return self.value


    def __hash__(MyUnion self):
        return  super().__hash__()

    cdef _load_cache(MyUnion self):
        self.type = MyUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            if not deref(self._cpp_obj).get_anInteger():
                self.value = None
            else:
                self.value = cint32_t.create(__reference_shared_ptr(deref(deref(self._cpp_obj).get_anInteger()), self._cpp_obj))
        elif type == 2:
            if not deref(self._cpp_obj).get_aString():
                self.value = None
            else:
                self.value = str.create(__reference_shared_ptr(deref(deref(self._cpp_obj).get_aString()), self._cpp_obj))

    def __copy__(MyUnion self):
        cdef shared_ptr[cMyUnion] cpp_obj = make_shared[cMyUnion](
            deref(self._cpp_obj)
        )
        return MyUnion.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyUnion](
            self._cpp_obj,
            (<MyUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyUnion"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cMyUnion](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 2

    cdef _fbthrift_iobuf.IOBuf _serialize(MyUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(MyUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyUnion]()
        with nogil:
            needed = serializer.cdeserialize[cMyUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


@__cython.auto_pickle(False)
cdef class MyField(thrift.py3.types.Struct):
    def __init__(MyField self, **kwargs):
        self._cpp_obj = make_shared[cMyField]()
        self._fields_setter = _fbthrift_types_fields.__MyField_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(MyField self, **kwargs):
        if not kwargs:
            return self
        cdef MyField __fbthrift_inst = MyField.__new__(MyField)
        __fbthrift_inst._cpp_obj = make_shared[cMyField](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__MyField_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("MyField", {
        })

    @staticmethod
    cdef create(shared_ptr[cMyField] cpp_obj):
        __fbthrift_inst = <MyField>MyField.__new__(MyField)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def opt_value(self):

        if self.__fbthrift_cached_opt_value is None:
            if not deref(self._cpp_obj).opt_value_ref():
                return None
            self.__fbthrift_cached_opt_value = cint64_t.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_value

    @property
    def value(self):

        if self.__fbthrift_cached_value is None:
            if not deref(self._cpp_obj).value_ref():
                return None
            self.__fbthrift_cached_value = cint64_t.create(__reference_shared_ptr(deref(deref(self._cpp_obj).value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_value

    @property
    def req_value(self):

        if self.__fbthrift_cached_req_value is None:
            if not deref(self._cpp_obj).req_value_ref():
                return None
            self.__fbthrift_cached_req_value = cint64_t.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_value

    @property
    def opt_enum_value(self):

        if self.__fbthrift_cached_opt_enum_value is None:
            if not deref(self._cpp_obj).opt_enum_value_ref():
                return None
            self.__fbthrift_cached_opt_enum_value = MyEnum.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_enum_value

    @property
    def enum_value(self):

        if self.__fbthrift_cached_enum_value is None:
            if not deref(self._cpp_obj).enum_value_ref():
                return None
            self.__fbthrift_cached_enum_value = MyEnum.create(__reference_shared_ptr(deref(deref(self._cpp_obj).enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_enum_value

    @property
    def req_enum_value(self):

        if self.__fbthrift_cached_req_enum_value is None:
            if not deref(self._cpp_obj).req_enum_value_ref():
                return None
            self.__fbthrift_cached_req_enum_value = MyEnum.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_enum_value


    def __hash__(MyField self):
        return  super().__hash__()

    def __copy__(MyField self):
        cdef shared_ptr[cMyField] cpp_obj = make_shared[cMyField](
            deref(self._cpp_obj)
        )
        return MyField.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyField](
            self._cpp_obj,
            (<MyField>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyField()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyField].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyField"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cMyField](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 6

    cdef _fbthrift_iobuf.IOBuf _serialize(MyField self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyField](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(MyField self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyField]()
        with nogil:
            needed = serializer.cdeserialize[cMyField](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class MyStruct(thrift.py3.types.Struct):
    def __init__(MyStruct self, **kwargs):
        self._cpp_obj = make_shared[cMyStruct]()
        self._fields_setter = _fbthrift_types_fields.__MyStruct_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(MyStruct self, **kwargs):
        if not kwargs:
            return self
        cdef MyStruct __fbthrift_inst = MyStruct.__new__(MyStruct)
        __fbthrift_inst._cpp_obj = make_shared[cMyStruct](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__MyStruct_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("MyStruct", {
        })

    @staticmethod
    cdef create(shared_ptr[cMyStruct] cpp_obj):
        __fbthrift_inst = <MyStruct>MyStruct.__new__(MyStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def opt_ref(self):

        if self.__fbthrift_cached_opt_ref is None:
            if not deref(self._cpp_obj).opt_ref_ref():
                return None
            self.__fbthrift_cached_opt_ref = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_ref

    @property
    def ref(self):

        if self.__fbthrift_cached_ref is None:
            if not deref(self._cpp_obj).ref_ref():
                return None
            self.__fbthrift_cached_ref = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_ref

    @property
    def req_ref(self):

        if self.__fbthrift_cached_req_ref is None:
            if not deref(self._cpp_obj).req_ref_ref():
                return None
            self.__fbthrift_cached_req_ref = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_ref


    def __hash__(MyStruct self):
        return  super().__hash__()

    def __copy__(MyStruct self):
        cdef shared_ptr[cMyStruct] cpp_obj = make_shared[cMyStruct](
            deref(self._cpp_obj)
        )
        return MyStruct.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyStruct](
            self._cpp_obj,
            (<MyStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyStruct()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyStruct].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyStruct"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cMyStruct](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(MyStruct self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyStruct](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(MyStruct self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyStruct]()
        with nogil:
            needed = serializer.cdeserialize[cMyStruct](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithUnion(thrift.py3.types.Struct):
    def __init__(StructWithUnion self, **kwargs):
        self._cpp_obj = make_shared[cStructWithUnion]()
        self._fields_setter = _fbthrift_types_fields.__StructWithUnion_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithUnion self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithUnion __fbthrift_inst = StructWithUnion.__new__(StructWithUnion)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithUnion](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithUnion_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithUnion", {
          "f": deref(self._cpp_obj).f_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithUnion] cpp_obj):
        __fbthrift_inst = <StructWithUnion>StructWithUnion.__new__(StructWithUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def u(self):

        if self.__fbthrift_cached_u is None:
            if not deref(self._cpp_obj).u_ref():
                return None
            self.__fbthrift_cached_u = MyUnion.create(__reference_shared_ptr(deref(deref(self._cpp_obj).u_ref()), self._cpp_obj))
        return self.__fbthrift_cached_u

    @property
    def aDouble(self):

        if self.__fbthrift_cached_aDouble is None:
            if not deref(self._cpp_obj).aDouble_ref():
                return None
            self.__fbthrift_cached_aDouble = double.create(__reference_shared_ptr(deref(deref(self._cpp_obj).aDouble_ref()), self._cpp_obj))
        return self.__fbthrift_cached_aDouble

    @property
    def f(self):

        if self.__fbthrift_cached_f is None:
            self.__fbthrift_cached_f = MyField.create(__reference_shared_ptr(deref(self._cpp_obj).f_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_f


    def __hash__(StructWithUnion self):
        return  super().__hash__()

    def __copy__(StructWithUnion self):
        cdef shared_ptr[cStructWithUnion] cpp_obj = make_shared[cStructWithUnion](
            deref(self._cpp_obj)
        )
        return StructWithUnion.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithUnion](
            self._cpp_obj,
            (<StructWithUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithUnion"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithUnion](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithUnion]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithUnion](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class RecursiveStruct(thrift.py3.types.Struct):
    def __init__(RecursiveStruct self, **kwargs):
        self._cpp_obj = make_shared[cRecursiveStruct]()
        self._fields_setter = _fbthrift_types_fields.__RecursiveStruct_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(RecursiveStruct self, **kwargs):
        if not kwargs:
            return self
        cdef RecursiveStruct __fbthrift_inst = RecursiveStruct.__new__(RecursiveStruct)
        __fbthrift_inst._cpp_obj = make_shared[cRecursiveStruct](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__RecursiveStruct_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("RecursiveStruct", {
          "mes": deref(self._cpp_obj).mes_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cRecursiveStruct] cpp_obj):
        __fbthrift_inst = <RecursiveStruct>RecursiveStruct.__new__(RecursiveStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def mes(self):
        if not deref(self._cpp_obj).mes_ref().has_value():
            return None

        if self.__fbthrift_cached_mes is None:
            self.__fbthrift_cached_mes = List__RecursiveStruct.create(__reference_shared_ptr(deref(self._cpp_obj).mes_ref().ref_unchecked(), self._cpp_obj))
        return self.__fbthrift_cached_mes


    def __hash__(RecursiveStruct self):
        return  super().__hash__()

    def __copy__(RecursiveStruct self):
        cdef shared_ptr[cRecursiveStruct] cpp_obj = make_shared[cRecursiveStruct](
            deref(self._cpp_obj)
        )
        return RecursiveStruct.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cRecursiveStruct](
            self._cpp_obj,
            (<RecursiveStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__RecursiveStruct()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cRecursiveStruct].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.RecursiveStruct"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cRecursiveStruct](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(RecursiveStruct self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cRecursiveStruct](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(RecursiveStruct self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cRecursiveStruct]()
        with nogil:
            needed = serializer.cdeserialize[cRecursiveStruct](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithContainers(thrift.py3.types.Struct):
    def __init__(StructWithContainers self, **kwargs):
        self._cpp_obj = make_shared[cStructWithContainers]()
        self._fields_setter = _fbthrift_types_fields.__StructWithContainers_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithContainers self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithContainers __fbthrift_inst = StructWithContainers.__new__(StructWithContainers)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithContainers](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithContainers_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithContainers", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithContainers] cpp_obj):
        __fbthrift_inst = <StructWithContainers>StructWithContainers.__new__(StructWithContainers)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def list_ref(self):

        if self.__fbthrift_cached_list_ref is None:
            if not deref(self._cpp_obj).list_ref_ref():
                return None
            self.__fbthrift_cached_list_ref = List__i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref

    @property
    def set_ref(self):

        if self.__fbthrift_cached_set_ref is None:
            if not deref(self._cpp_obj).set_ref_ref():
                return None
            self.__fbthrift_cached_set_ref = Set__i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).set_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_set_ref

    @property
    def map_ref(self):

        if self.__fbthrift_cached_map_ref is None:
            if not deref(self._cpp_obj).map_ref_ref():
                return None
            self.__fbthrift_cached_map_ref = Map__i32_i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).map_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_map_ref

    @property
    def list_ref_unique(self):

        if self.__fbthrift_cached_list_ref_unique is None:
            if not deref(self._cpp_obj).list_ref_unique_ref():
                return None
            self.__fbthrift_cached_list_ref_unique = List__i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_unique_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref_unique

    @property
    def set_ref_shared(self):

        if self.__fbthrift_cached_set_ref_shared is None:
            if not deref(self._cpp_obj).set_ref_shared_ref():
                return None
            self.__fbthrift_cached_set_ref_shared = Set__i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).set_ref_shared_ref()), self._cpp_obj))
        return self.__fbthrift_cached_set_ref_shared

    @property
    def list_ref_shared_const(self):

        if self.__fbthrift_cached_list_ref_shared_const is None:
            if not deref(self._cpp_obj).list_ref_shared_const_ref():
                return None
            self.__fbthrift_cached_list_ref_shared_const = List__i32.create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref_shared_const


    def __hash__(StructWithContainers self):
        return  super().__hash__()

    def __copy__(StructWithContainers self):
        cdef shared_ptr[cStructWithContainers] cpp_obj = make_shared[cStructWithContainers](
            deref(self._cpp_obj)
        )
        return StructWithContainers.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithContainers](
            self._cpp_obj,
            (<StructWithContainers>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithContainers()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithContainers].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithContainers"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithContainers](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 6

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithContainers self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithContainers](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithContainers self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithContainers]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithContainers](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithSharedConst(thrift.py3.types.Struct):
    def __init__(StructWithSharedConst self, **kwargs):
        self._cpp_obj = make_shared[cStructWithSharedConst]()
        self._fields_setter = _fbthrift_types_fields.__StructWithSharedConst_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithSharedConst self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithSharedConst __fbthrift_inst = StructWithSharedConst.__new__(StructWithSharedConst)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithSharedConst](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithSharedConst_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithSharedConst", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithSharedConst] cpp_obj):
        __fbthrift_inst = <StructWithSharedConst>StructWithSharedConst.__new__(StructWithSharedConst)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def opt_shared_const(self):

        if self.__fbthrift_cached_opt_shared_const is None:
            if not deref(self._cpp_obj).opt_shared_const_ref():
                return None
            self.__fbthrift_cached_opt_shared_const = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_shared_const

    @property
    def shared_const(self):

        if self.__fbthrift_cached_shared_const is None:
            if not deref(self._cpp_obj).shared_const_ref():
                return None
            self.__fbthrift_cached_shared_const = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_shared_const

    @property
    def req_shared_const(self):

        if self.__fbthrift_cached_req_shared_const is None:
            if not deref(self._cpp_obj).req_shared_const_ref():
                return None
            self.__fbthrift_cached_req_shared_const = MyField.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_shared_const


    def __hash__(StructWithSharedConst self):
        return  super().__hash__()

    def __copy__(StructWithSharedConst self):
        cdef shared_ptr[cStructWithSharedConst] cpp_obj = make_shared[cStructWithSharedConst](
            deref(self._cpp_obj)
        )
        return StructWithSharedConst.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithSharedConst](
            self._cpp_obj,
            (<StructWithSharedConst>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithSharedConst()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithSharedConst].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithSharedConst"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithSharedConst](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithSharedConst self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithSharedConst](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithSharedConst self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithSharedConst]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithSharedConst](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class Empty(thrift.py3.types.Struct):
    def __init__(Empty self, **kwargs):
        self._cpp_obj = make_shared[cEmpty]()
        self._fields_setter = _fbthrift_types_fields.__Empty_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(Empty self, **kwargs):
        return self

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("Empty", {
        })

    @staticmethod
    cdef create(shared_ptr[cEmpty] cpp_obj):
        __fbthrift_inst = <Empty>Empty.__new__(Empty)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst


    def __hash__(Empty self):
        return  super().__hash__()

    def __copy__(Empty self):
        cdef shared_ptr[cEmpty] cpp_obj = make_shared[cEmpty](
            deref(self._cpp_obj)
        )
        return Empty.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cEmpty](
            self._cpp_obj,
            (<Empty>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Empty()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cEmpty].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.Empty"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cEmpty](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 0

    cdef _fbthrift_iobuf.IOBuf _serialize(Empty self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cEmpty](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(Empty self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cEmpty]()
        with nogil:
            needed = serializer.cdeserialize[cEmpty](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithRef(thrift.py3.types.Struct):
    def __init__(StructWithRef self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRef]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRef_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRef self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRef __fbthrift_inst = StructWithRef.__new__(StructWithRef)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRef](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRef_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRef", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithRef] cpp_obj):
        __fbthrift_inst = <StructWithRef>StructWithRef.__new__(StructWithRef)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def def_field(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def opt_field(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def req_field(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field


    def __hash__(StructWithRef self):
        return  super().__hash__()

    def __copy__(StructWithRef self):
        cdef shared_ptr[cStructWithRef] cpp_obj = make_shared[cStructWithRef](
            deref(self._cpp_obj)
        )
        return StructWithRef.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRef](
            self._cpp_obj,
            (<StructWithRef>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRef()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRef].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRef"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithRef](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithRef self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRef](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithRef self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRef]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRef](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithRefTypeUnique(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeUnique self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeUnique]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeUnique_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeUnique self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeUnique __fbthrift_inst = StructWithRefTypeUnique.__new__(StructWithRefTypeUnique)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeUnique](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeUnique_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeUnique", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithRefTypeUnique] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeUnique>StructWithRefTypeUnique.__new__(StructWithRefTypeUnique)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def def_field(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def opt_field(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def req_field(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field


    def __hash__(StructWithRefTypeUnique self):
        return  super().__hash__()

    def __copy__(StructWithRefTypeUnique self):
        cdef shared_ptr[cStructWithRefTypeUnique] cpp_obj = make_shared[cStructWithRefTypeUnique](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeUnique.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeUnique](
            self._cpp_obj,
            (<StructWithRefTypeUnique>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeUnique()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeUnique].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeUnique"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithRefTypeUnique](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithRefTypeUnique self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeUnique](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithRefTypeUnique self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeUnique]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeUnique](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithRefTypeShared(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeShared self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeShared]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeShared_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeShared self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeShared __fbthrift_inst = StructWithRefTypeShared.__new__(StructWithRefTypeShared)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeShared](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeShared_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeShared", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithRefTypeShared] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeShared>StructWithRefTypeShared.__new__(StructWithRefTypeShared)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def def_field(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def opt_field(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def req_field(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field


    def __hash__(StructWithRefTypeShared self):
        return  super().__hash__()

    def __copy__(StructWithRefTypeShared self):
        cdef shared_ptr[cStructWithRefTypeShared] cpp_obj = make_shared[cStructWithRefTypeShared](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeShared.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeShared](
            self._cpp_obj,
            (<StructWithRefTypeShared>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeShared()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeShared].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeShared"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithRefTypeShared](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithRefTypeShared self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeShared](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithRefTypeShared self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeShared]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeShared](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithRefTypeSharedConst(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeSharedConst self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeSharedConst]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeSharedConst_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeSharedConst self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeSharedConst __fbthrift_inst = StructWithRefTypeSharedConst.__new__(StructWithRefTypeSharedConst)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeSharedConst](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeSharedConst_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeSharedConst", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithRefTypeSharedConst] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeSharedConst>StructWithRefTypeSharedConst.__new__(StructWithRefTypeSharedConst)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def def_field(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def opt_field(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def req_field(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field


    def __hash__(StructWithRefTypeSharedConst self):
        return  super().__hash__()

    def __copy__(StructWithRefTypeSharedConst self):
        cdef shared_ptr[cStructWithRefTypeSharedConst] cpp_obj = make_shared[cStructWithRefTypeSharedConst](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeSharedConst.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeSharedConst](
            self._cpp_obj,
            (<StructWithRefTypeSharedConst>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeSharedConst()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeSharedConst].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeSharedConst"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithRefTypeSharedConst](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithRefTypeSharedConst self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeSharedConst](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithRefTypeSharedConst self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeSharedConst]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeSharedConst](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class StructWithRefAndAnnotCppNoexceptMoveCtor(thrift.py3.types.Struct):
    def __init__(StructWithRefAndAnnotCppNoexceptMoveCtor self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefAndAnnotCppNoexceptMoveCtor_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefAndAnnotCppNoexceptMoveCtor self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefAndAnnotCppNoexceptMoveCtor __fbthrift_inst = StructWithRefAndAnnotCppNoexceptMoveCtor.__new__(StructWithRefAndAnnotCppNoexceptMoveCtor)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefAndAnnotCppNoexceptMoveCtor_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefAndAnnotCppNoexceptMoveCtor", {
        })

    @staticmethod
    cdef create(shared_ptr[cStructWithRefAndAnnotCppNoexceptMoveCtor] cpp_obj):
        __fbthrift_inst = <StructWithRefAndAnnotCppNoexceptMoveCtor>StructWithRefAndAnnotCppNoexceptMoveCtor.__new__(StructWithRefAndAnnotCppNoexceptMoveCtor)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def def_field(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty.create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field


    def __hash__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        return  super().__hash__()

    def __copy__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        cdef shared_ptr[cStructWithRefAndAnnotCppNoexceptMoveCtor] cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor](
            deref(self._cpp_obj)
        )
        return StructWithRefAndAnnotCppNoexceptMoveCtor.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefAndAnnotCppNoexceptMoveCtor](
            self._cpp_obj,
            (<StructWithRefAndAnnotCppNoexceptMoveCtor>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefAndAnnotCppNoexceptMoveCtor()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefAndAnnotCppNoexceptMoveCtor].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefAndAnnotCppNoexceptMoveCtor"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cStructWithRefAndAnnotCppNoexceptMoveCtor](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(StructWithRefAndAnnotCppNoexceptMoveCtor self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefAndAnnotCppNoexceptMoveCtor](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(StructWithRefAndAnnotCppNoexceptMoveCtor self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefAndAnnotCppNoexceptMoveCtor](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class List__RecursiveStruct(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__RecursiveStruct):
            self._cpp_obj = (<List__RecursiveStruct> items)._cpp_obj
        else:
            self._cpp_obj = List__RecursiveStruct._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cRecursiveStruct]] c_items):
        __fbthrift_inst = <List__RecursiveStruct>List__RecursiveStruct.__new__(List__RecursiveStruct)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__RecursiveStruct self):
        cdef shared_ptr[vector[cRecursiveStruct]] cpp_obj = make_shared[vector[cRecursiveStruct]](
            deref(self._cpp_obj)
        )
        return List__RecursiveStruct.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cRecursiveStruct]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cRecursiveStruct]] c_inst = make_shared[vector[cRecursiveStruct]]()
        if items is not None:
            for item in items:
                if not isinstance(item, RecursiveStruct):
                    raise TypeError(f"{item!r} is not of type 'RecursiveStruct'")
                deref(c_inst).push_back(deref((<RecursiveStruct>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__RecursiveStruct.create(
            __list_slice[vector[cRecursiveStruct]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[cRecursiveStruct] citem
        __list_getitem(self._cpp_obj, index, citem)
        return RecursiveStruct.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, RecursiveStruct):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cRecursiveStruct citem = deref((<RecursiveStruct>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cRecursiveStruct]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cRecursiveStruct citem = deref((<RecursiveStruct>item)._cpp_obj)
        return __list_count[vector[cRecursiveStruct]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__RecursiveStruct()


Sequence.register(List__RecursiveStruct)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i32.create(
            __list_slice[vector[cint32_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint32_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint32_t citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cint32_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint32_t citem = item
        return __list_count[vector[cint32_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cint32_t]] itr = __set_iter[cset[cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield citem

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__i32):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__i32> other)._cpp_obj,
                op,
            )
        return self._fbthrift_py_richcmp(other, op)

    cdef _fbthrift_do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__i32):
            other = Set__i32(other)
        cdef shared_ptr[cset[cint32_t]] result
        return Set__i32.create(__set_op[cset[cint32_t]](
            self._cpp_obj,
            (<Set__i32>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cint32_t,cint32_t]] c_items):
        __fbthrift_inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_i32 self):
        cdef shared_ptr[cmap[cint32_t,cint32_t]] cpp_obj = make_shared[cmap[cint32_t,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__i32_i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,cint32_t]] c_inst = make_shared[cmap[cint32_t,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key] = item
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, int):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef cint32_t ckey = key
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef cint32_t citem = 0
        __map_getitem(self._cpp_obj, ckey, citem)
        return citem

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield citem

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef cint32_t ckey = key
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield citem

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t ckey = 0
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_i32()

Mapping.register(Map__i32_i32)

kStructWithRef = StructWithRef.create(constant_shared_ptr(ckStructWithRef()))
kStructWithRefTypeUnique = StructWithRefTypeUnique.create(constant_shared_ptr(ckStructWithRefTypeUnique()))
kStructWithRefTypeShared = StructWithRefTypeShared.create(constant_shared_ptr(ckStructWithRefTypeShared()))
kStructWithRefTypeSharedConst = StructWithRefTypeSharedConst.create(constant_shared_ptr(ckStructWithRefTypeSharedConst()))
