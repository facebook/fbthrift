/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}




enum TypedEnum : short {
  VAL1 = 0,
  VAL2 = 1,
};

using _TypedEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<TypedEnum, short>;

extern const _TypedEnum_EnumMapFactory::ValuesToNamesMapType _TypedEnum_VALUES_TO_NAMES;

extern const _TypedEnum_EnumMapFactory::NamesToValuesMapType _TypedEnum_NAMES_TO_VALUES;


namespace apache { namespace thrift {
template <> struct TEnumDataStorage< ::TypedEnum>;
template <> const std::size_t TEnumTraits< ::TypedEnum>::size;
template <> const folly::Range<const  ::TypedEnum*> TEnumTraits< ::TypedEnum>::values;
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::TypedEnum>::names;
template <> inline constexpr  ::TypedEnum TEnumTraits< ::TypedEnum>::min() {
return  ::TypedEnum::VAL1;
}
template <> inline constexpr  ::TypedEnum TEnumTraits< ::TypedEnum>::max() {
return  ::TypedEnum::VAL2;
}
}} // apache::thrift



class MyUnion;

class MyField;

class MyStruct;

class StructWithUnion;

class RecursiveStruct;

class StructWithContainers;

class StructWithSharedConst;

class Empty;

class StructWithRef;

class StructWithRefTypeUnique;

class StructWithRefTypeShared;

class StructWithRefTypeSharedConst;

class MyUnion : public apache::thrift::TStructType<MyUnion> {
 public:
  enum class Type {
    __EMPTY__ = 0,
    anInteger = 1,
    aString = 2,
  };

  MyUnion() : type_(Type::__EMPTY__) {}
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit MyUnion(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_anInteger(arg.move());
  }
  template <typename T__ThriftWrappedArgument__Ctor>
  explicit MyUnion(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg):
    type_(Type::__EMPTY__)
  {
    set_aString(arg.move());
  }
  MyUnion(const MyUnion& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::anInteger: {
        set_anInteger(rhs.value_.anInteger);
        break;
      }
      case Type::aString: {
        set_aString(rhs.value_.aString);
        break;
      }
      default: assert(false);
    }
  }

  MyUnion& operator=(const MyUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::anInteger: {
        set_anInteger(rhs.value_.anInteger);
        break;
      }
      case Type::aString: {
        set_aString(rhs.value_.aString);
        break;
      }
      default: assert(false);
    }
    return *this;
  }

  MyUnion(MyUnion&& rhs) : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::anInteger: {
        set_anInteger(std::move(rhs.value_.anInteger));
        break;
      }
      case Type::aString: {
        set_aString(std::move(rhs.value_.aString));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
  }

  MyUnion& operator=(MyUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::anInteger: {
        set_anInteger(std::move(rhs.value_.anInteger));
        break;
      }
      case Type::aString: {
        set_aString(std::move(rhs.value_.aString));
        break;
      }
      default: assert(false);
    }
    rhs.__clear();
    return *this;
  }


  void __clear() {
    if (type_ == Type::__EMPTY__) { return; }
    switch (type_) {
      case Type::anInteger: {
        
        break;
      }
      case Type::aString: {
        using namespace std; value_.aString.~string();
        break;
      }
      default: assert(false);
    }
    type_ = Type::__EMPTY__;
  }
  virtual ~MyUnion() noexcept {
    __clear();
  }

  union storage_type {
    int32_t anInteger;
    std::string aString;
    
    storage_type() {}
    ~storage_type() {}
  };

  bool operator==(const MyUnion& rhs) const {
    if (type_ != rhs.type_) { return false; }
    switch (type_) {
      case Type::anInteger: {
        return value_.anInteger == rhs.value_.anInteger;

        break;
      }
      case Type::aString: {
        return value_.aString == rhs.value_.aString;

        break;
      }
      default: return true;
    }
  }

  bool operator!=(const MyUnion& rhs) const {
    return !(*this == rhs);
  }

  bool operator<(const MyUnion& rhs) const {
    if (type_ != rhs.type_) return type_ < rhs.type_;
    switch (type_) {
      case Type::anInteger: {
        return value_.anInteger < rhs.value_.anInteger;

        break;
      }
      case Type::aString: {
        return value_.aString < rhs.value_.aString;

        break;
      }
      default: return false;
    }
    return false;
  }

  template<typename... T>
  void set_anInteger(T&&... t) {
    __clear();
    type_ = Type::anInteger;
    new (&value_.anInteger) int32_t(std::forward<T>(t)...);
  }

  template<typename... T>
  void set_aString(T&&... t) {
    __clear();
    type_ = Type::aString;
    new (&value_.aString) std::string(std::forward<T>(t)...);
  }

  const int32_t& get_anInteger() const {
    assert(type_ == Type::anInteger);
    return value_.anInteger;
  }

  const std::string& get_aString() const {
    assert(type_ == Type::aString);
    return value_.aString;
  }

  int32_t& mutable_anInteger() {
    assert(type_ == Type::anInteger);
    return value_.anInteger;
  }

  std::string& mutable_aString() {
    assert(type_ == Type::aString);
    return value_.aString;
  }

  int32_t move_anInteger() {
    assert(type_ == Type::anInteger);
    return std::move(value_.anInteger);
  }

  std::string move_aString() {
    assert(type_ == Type::aString);
    return std::move(value_.aString);
  }

  Type getType() const { return type_; }

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;
  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
 private:
  Type type_;
  storage_type value_;

};

void swap(MyField &a, MyField &b);

class MyField : public apache::thrift::TStructType<MyField> {
 public:

  static const uint64_t _reflection_id = 16778989117799402412U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyField() : opt_value(0), value(0), req_value(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyField(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyField(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_value = arg.move();
    __isset.opt_value = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyField(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyField(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyField(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyField(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_value = arg.move();
  }

  MyField(const MyField&) = default;
  MyField& operator=(const MyField& src)= default;
  MyField(MyField&&) = default;
  MyField& operator=(MyField&&) = default;

  void __clear();

  virtual ~MyField() noexcept {}

  int64_t opt_value;
  int64_t value;
  int64_t req_value;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      opt_value = false;
      value = false;
    }
    bool opt_value;
    bool value;
  } __isset;

  bool operator == (const MyField &) const;
  bool operator != (const MyField& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyField & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyField;
void merge(const MyField& from, MyField& to);
void merge(MyField&& from, MyField& to);
void swap(MyStruct &a, MyStruct &b);

class MyStruct : public apache::thrift::TStructType<MyStruct> {
 public:

  static const uint64_t _reflection_id = 7958971832214294220U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyStruct() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyStruct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyStruct(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyStruct(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  MyStruct(const MyStruct&);
  MyStruct& operator=(const MyStruct& src) {
    MyStruct tmp(src);
    swap(*this, tmp);
    return *this;
  }
  MyStruct(MyStruct&&) = default;
  MyStruct& operator=(MyStruct&&) = default;

  void __clear();

  virtual ~MyStruct() noexcept {}

  std::unique_ptr<MyField> opt_ref;
  std::unique_ptr<MyField> ref;
  std::unique_ptr<MyField> req_ref;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const MyStruct &) const;
  bool operator != (const MyStruct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyStruct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyStruct;
void merge(const MyStruct& from, MyStruct& to);
void merge(MyStruct&& from, MyStruct& to);
void swap(StructWithUnion &a, StructWithUnion &b);

class StructWithUnion : public apache::thrift::TStructType<StructWithUnion> {
 public:

  static const uint64_t _reflection_id = 11295191354176986988U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithUnion() : aDouble(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithUnion(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithUnion(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    u = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithUnion(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithUnion(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    aDouble = arg.move();
    __isset.aDouble = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithUnion(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithUnion(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    f = arg.move();
    __isset.f = true;
  }

  StructWithUnion(const StructWithUnion&);
  StructWithUnion& operator=(const StructWithUnion& src) {
    StructWithUnion tmp(src);
    swap(*this, tmp);
    return *this;
  }
  StructWithUnion(StructWithUnion&&) = default;
  StructWithUnion& operator=(StructWithUnion&&) = default;

  void __clear();

  virtual ~StructWithUnion() noexcept {}

  std::unique_ptr<MyUnion> u;
  double aDouble;
  MyField f;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      aDouble = false;
      f = false;
    }
    bool aDouble;
    bool f;
  } __isset;

  bool operator == (const StructWithUnion &) const;
  bool operator != (const StructWithUnion& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithUnion & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithUnion;
void merge(const StructWithUnion& from, StructWithUnion& to);
void merge(StructWithUnion&& from, StructWithUnion& to);
void swap(RecursiveStruct &a, RecursiveStruct &b);

class RecursiveStruct : public apache::thrift::TStructType<RecursiveStruct> {
 public:

  static const uint64_t _reflection_id = 2826922994162023308U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  RecursiveStruct() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit RecursiveStruct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    RecursiveStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    mes = arg.move();
    __isset.mes = true;
  }

  RecursiveStruct(const RecursiveStruct&) = default;
  RecursiveStruct& operator=(const RecursiveStruct& src)= default;
  RecursiveStruct(RecursiveStruct&&) = default;
  RecursiveStruct& operator=(RecursiveStruct&&) = default;

  void __clear();

  virtual ~RecursiveStruct() noexcept {}

  std::vector<RecursiveStruct>  mes;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      mes = false;
    }
    bool mes;
  } __isset;

  bool operator == (const RecursiveStruct &) const;
  bool operator != (const RecursiveStruct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecursiveStruct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class RecursiveStruct;
void merge(const RecursiveStruct& from, RecursiveStruct& to);
void merge(RecursiveStruct&& from, RecursiveStruct& to);
void swap(StructWithContainers &a, StructWithContainers &b);

class StructWithContainers : public apache::thrift::TStructType<StructWithContainers> {
 public:

  static const uint64_t _reflection_id = 18101585657679500556U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithContainers() {
    list_ref.reset(new typename decltype(list_ref)::element_type());
    set_ref.reset(new typename decltype(set_ref)::element_type());
    map_ref.reset(new typename decltype(map_ref)::element_type());
    list_ref_unique.reset(new typename decltype(list_ref_unique)::element_type());
    set_ref_shared.reset(new typename decltype(set_ref_shared)::element_type());
    list_ref_shared_const.reset(new typename decltype(list_ref_shared_const)::element_type());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    list_ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    map_ref = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    list_ref_unique = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    set_ref_shared = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithContainers(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithContainers(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    list_ref_shared_const = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithContainers(const StructWithContainers&);
  StructWithContainers& operator=(const StructWithContainers& src) {
    StructWithContainers tmp(src);
    swap(*this, tmp);
    return *this;
  }
  StructWithContainers(StructWithContainers&&) = default;
  StructWithContainers& operator=(StructWithContainers&&) = default;

  void __clear();

  virtual ~StructWithContainers() noexcept {}

  std::unique_ptr<std::vector<int32_t> > list_ref;
  std::unique_ptr<std::set<int32_t> > set_ref;
  std::unique_ptr<std::map<int32_t, int32_t> > map_ref;
  std::unique_ptr<std::vector<int32_t> > list_ref_unique;
  std::shared_ptr<std::set<int32_t> > set_ref_shared;
  std::shared_ptr<const std::vector<int32_t> > list_ref_shared_const;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithContainers &) const;
  bool operator != (const StructWithContainers& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithContainers & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithContainers;
void merge(const StructWithContainers& from, StructWithContainers& to);
void merge(StructWithContainers&& from, StructWithContainers& to);
void swap(StructWithSharedConst &a, StructWithSharedConst &b);

class StructWithSharedConst : public apache::thrift::TStructType<StructWithSharedConst> {
 public:

  static const uint64_t _reflection_id = 17232433652683371404U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithSharedConst() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithSharedConst(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_shared_const = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithSharedConst(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    shared_const = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithSharedConst(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_shared_const = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithSharedConst(const StructWithSharedConst&) = default;
  StructWithSharedConst& operator=(const StructWithSharedConst& src)= default;
  StructWithSharedConst(StructWithSharedConst&&) = default;
  StructWithSharedConst& operator=(StructWithSharedConst&&) = default;

  void __clear();

  virtual ~StructWithSharedConst() noexcept {}

  std::shared_ptr<const MyField> opt_shared_const;
  std::shared_ptr<const MyField> shared_const;
  std::shared_ptr<const MyField> req_shared_const;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithSharedConst &) const;
  bool operator != (const StructWithSharedConst& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithSharedConst & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithSharedConst;
void merge(const StructWithSharedConst& from, StructWithSharedConst& to);
void merge(StructWithSharedConst&& from, StructWithSharedConst& to);
void swap(Empty &a, Empty &b);

class Empty : public apache::thrift::TStructType<Empty> {
 public:

  static const uint64_t _reflection_id = 14313748354111837868U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Empty() {
  }

  Empty(const Empty&) = default;
  Empty& operator=(const Empty& src)= default;
  Empty(Empty&&) = default;
  Empty& operator=(Empty&&) = default;

  void __clear();

  virtual ~Empty() noexcept {}


  bool operator == (const Empty &) const;
  bool operator != (const Empty& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Empty & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class Empty;
void merge(const Empty& from, Empty& to);
void merge(Empty&& from, Empty& to);
void swap(StructWithRef &a, StructWithRef &b);

class StructWithRef : public apache::thrift::TStructType<StructWithRef> {
 public:

  static const uint64_t _reflection_id = 11749517231251122252U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithRef() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRef(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRef(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    def_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRef(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRef(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRef(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRef(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithRef(const StructWithRef&);
  StructWithRef& operator=(const StructWithRef& src) {
    StructWithRef tmp(src);
    swap(*this, tmp);
    return *this;
  }
  StructWithRef(StructWithRef&&) = default;
  StructWithRef& operator=(StructWithRef&&) = default;

  void __clear();

  virtual ~StructWithRef() noexcept {}

  std::unique_ptr<Empty> def_field;
  std::unique_ptr<Empty> opt_field;
  std::unique_ptr<Empty> req_field;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithRef &) const;
  bool operator != (const StructWithRef& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithRef & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithRef;
void merge(const StructWithRef& from, StructWithRef& to);
void merge(StructWithRef&& from, StructWithRef& to);
void swap(StructWithRefTypeUnique &a, StructWithRefTypeUnique &b);

class StructWithRefTypeUnique : public apache::thrift::TStructType<StructWithRefTypeUnique> {
 public:

  static const uint64_t _reflection_id = 215755688094406540U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithRefTypeUnique() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeUnique(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeUnique(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    def_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeUnique(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeUnique(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeUnique(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeUnique(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_field = std::make_unique<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithRefTypeUnique(const StructWithRefTypeUnique&);
  StructWithRefTypeUnique& operator=(const StructWithRefTypeUnique& src) {
    StructWithRefTypeUnique tmp(src);
    swap(*this, tmp);
    return *this;
  }
  StructWithRefTypeUnique(StructWithRefTypeUnique&&) = default;
  StructWithRefTypeUnique& operator=(StructWithRefTypeUnique&&) = default;

  void __clear();

  virtual ~StructWithRefTypeUnique() noexcept {}

  std::unique_ptr<Empty> def_field;
  std::unique_ptr<Empty> opt_field;
  std::unique_ptr<Empty> req_field;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithRefTypeUnique &) const;
  bool operator != (const StructWithRefTypeUnique& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithRefTypeUnique & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithRefTypeUnique;
void merge(const StructWithRefTypeUnique& from, StructWithRefTypeUnique& to);
void merge(StructWithRefTypeUnique&& from, StructWithRefTypeUnique& to);
void swap(StructWithRefTypeShared &a, StructWithRefTypeShared &b);

class StructWithRefTypeShared : public apache::thrift::TStructType<StructWithRefTypeShared> {
 public:

  static const uint64_t _reflection_id = 12352376109981065772U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithRefTypeShared() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeShared(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeShared(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    def_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeShared(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeShared(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeShared(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeShared(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithRefTypeShared(const StructWithRefTypeShared&) = default;
  StructWithRefTypeShared& operator=(const StructWithRefTypeShared& src)= default;
  StructWithRefTypeShared(StructWithRefTypeShared&&) = default;
  StructWithRefTypeShared& operator=(StructWithRefTypeShared&&) = default;

  void __clear();

  virtual ~StructWithRefTypeShared() noexcept {}

  std::shared_ptr<Empty> def_field;
  std::shared_ptr<Empty> opt_field;
  std::shared_ptr<Empty> req_field;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithRefTypeShared &) const;
  bool operator != (const StructWithRefTypeShared& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithRefTypeShared & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithRefTypeShared;
void merge(const StructWithRefTypeShared& from, StructWithRefTypeShared& to);
void merge(StructWithRefTypeShared&& from, StructWithRefTypeShared& to);
void swap(StructWithRefTypeSharedConst &a, StructWithRefTypeSharedConst &b);

class StructWithRefTypeSharedConst : public apache::thrift::TStructType<StructWithRefTypeSharedConst> {
 public:

  static const uint64_t _reflection_id = 11678635121852876428U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  StructWithRefTypeSharedConst() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeSharedConst(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    def_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeSharedConst(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    opt_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit StructWithRefTypeSharedConst(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    StructWithRefTypeSharedConst(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    req_field = std::make_shared<folly::_t<std::decay<T__ThriftWrappedArgument__Ctor>>>(arg.move());
  }

  StructWithRefTypeSharedConst(const StructWithRefTypeSharedConst&) = default;
  StructWithRefTypeSharedConst& operator=(const StructWithRefTypeSharedConst& src)= default;
  StructWithRefTypeSharedConst(StructWithRefTypeSharedConst&&) = default;
  StructWithRefTypeSharedConst& operator=(StructWithRefTypeSharedConst&&) = default;

  void __clear();

  virtual ~StructWithRefTypeSharedConst() noexcept {}

  std::shared_ptr<const Empty> def_field;
  std::shared_ptr<const Empty> opt_field;
  std::shared_ptr<const Empty> req_field;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
    }
  } __isset;

  bool operator == (const StructWithRefTypeSharedConst &) const;
  bool operator != (const StructWithRefTypeSharedConst& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StructWithRefTypeSharedConst & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class StructWithRefTypeSharedConst;
void merge(const StructWithRefTypeSharedConst& from, StructWithRefTypeSharedConst& to);
void merge(StructWithRefTypeSharedConst&& from, StructWithRefTypeSharedConst& to);


