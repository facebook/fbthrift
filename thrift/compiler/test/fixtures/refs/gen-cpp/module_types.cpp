/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_types.h"
#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_data.h"

#include "thrift/compiler/test/fixtures/refs/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>



const typename apache::thrift::detail::TEnumMapFactory<TypedEnum, short>::ValuesToNamesMapType _TypedEnum_VALUES_TO_NAMES = apache::thrift::detail::TEnumMapFactory<TypedEnum, short>::makeValuesToNamesMap();

const typename apache::thrift::detail::TEnumMapFactory<TypedEnum, short>::NamesToValuesMapType _TypedEnum_NAMES_TO_VALUES = apache::thrift::detail::TEnumMapFactory<TypedEnum, short>::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraitsBase< ::TypedEnum>::size = 2;
template <>const folly::Range<const  ::TypedEnum*> TEnumTraitsBase< ::TypedEnum>::values = folly::range( ::_TypedEnumEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraitsBase< ::TypedEnum>::names = folly::range( ::_TypedEnumEnumDataStorage::names);

template<>
const char* TEnumTraitsBase< ::TypedEnum>::findName( ::TypedEnum value) {
return findName( ::_TypedEnum_VALUES_TO_NAMES, value);
}

template<>
bool TEnumTraitsBase< ::TypedEnum>::findValue(const char* name,  ::TypedEnum* out) {
return findValue( ::_TypedEnum_NAMES_TO_VALUES, name, out);
}
}} // apache::thrift


uint32_t MyUnion::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_anInteger();
          xfer += iprot->readI32(this->value_.anInteger);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_aString();
          xfer += iprot->readString(this->value_.aString);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (UNLIKELY(ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MyUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyUnion");
  switch (type_) {
    case Type::anInteger: {
      xfer += oprot->writeFieldBegin("anInteger", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.anInteger);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::aString: {
      xfer += oprot->writeFieldBegin("aString", apache::thrift::protocol::T_STRING, 2);
      xfer += oprot->writeString(this->value_.aString);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t MyField::_reflection_id;
void MyField::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_16778989117799402412(schema);
}

bool MyField::operator == (const MyField & rhs) const {
  if (__isset.opt_value != rhs.__isset.opt_value)
    return false;
  else if (__isset.opt_value && !(opt_value == rhs.opt_value))
    return false;
  if (!(this->value == rhs.value))
    return false;
  if (!(this->req_value == rhs.req_value))
    return false;
  return true;
}

uint32_t MyField::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_16778989117799402412(*schema);
    iprot->setNextStructType(MyField::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_req_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->opt_value);
          this->__isset.opt_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->req_value);
          isset_req_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_req_value)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_value' was not found in serialized data! Struct: MyField");
  return xfer;
}

void MyField::__clear() {
  opt_value = 0;
  value = 0;
  req_value = 0;
  __isset.__clear();
}
uint32_t MyField::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyField");
  if (this->__isset.opt_value) {
    xfer += oprot->writeFieldBegin("opt_value", apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->opt_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("req_value", apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->req_value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyField &a, MyField &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_value, b.opt_value);
  swap(a.value, b.value);
  swap(a.req_value, b.req_value);
  swap(a.__isset, b.__isset);
}

void merge(const MyField& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(from.opt_value, to.opt_value);
    to.__isset.opt_value = true;
  }
  merge(from.value, to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(from.req_value, to.req_value);
}

void merge(MyField&& from, MyField& to) {
  using apache::thrift::merge;
  if (from.__isset.opt_value) {
    merge(std::move(from.opt_value), to.opt_value);
    to.__isset.opt_value = true;
  }
  merge(std::move(from.value), to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(std::move(from.req_value), to.req_value);
}

const uint64_t MyStruct::_reflection_id;
void MyStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_7958971832214294220(schema);
}

MyStruct::MyStruct(const MyStruct& src1) {
  if (src1.opt_ref)
    opt_ref.reset(new MyField(*src1.opt_ref));
  if (src1.ref)
    ref.reset(new MyField(*src1.ref));
  if (src1.req_ref)
    req_ref.reset(new MyField(*src1.req_ref));
}
bool MyStruct::operator == (const MyStruct & rhs) const {
  if (bool(opt_ref) != bool(rhs.opt_ref))
    return false;
  else if (bool(opt_ref) && !(*opt_ref == *rhs.opt_ref))
    return false;
  if (bool(ref) != bool(rhs.ref))
    return false;
  else if (bool(ref) && !(*ref == *rhs.ref))
    return false;
  if (bool(req_ref) != bool(rhs.req_ref))
    return false;
  else if (bool(req_ref) && !(*req_ref == *rhs.req_ref))
    return false;
  return true;
}

uint32_t MyStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_7958971832214294220(*schema);
    iprot->setNextStructType(MyStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;

  bool isset_req_ref = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype3(new element_type());
            xfer += _ptype3->read(iprot);
            this->opt_ref = std::move(_ptype3);
            if (false) {
            } else if (this->opt_ref->__isset.opt_value) {
            } else if (this->opt_ref->__isset.value) {
            } else { this->opt_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype4(new element_type());
            xfer += _ptype4->read(iprot);
            this->ref = std::move(_ptype4);
            if (false) {
            } else if (this->ref->__isset.opt_value) {
            } else if (this->ref->__isset.value) {
            } else { this->ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype5(new element_type());
            xfer += _ptype5->read(iprot);
            this->req_ref = std::move(_ptype5);
            if (false) {
            } else if (this->req_ref->__isset.opt_value) {
            } else if (this->req_ref->__isset.value) {
            } else { this->req_ref = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          isset_req_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  if (!isset_req_ref)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_ref' was not found in serialized data! Struct: MyStruct");
  return xfer;
}

void MyStruct::__clear() {
  if (opt_ref) opt_ref->__clear();
  if (ref) ref->__clear();
  if (req_ref) req_ref->__clear();
  __isset.__clear();
}
uint32_t MyStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MyStruct");
  if (this->opt_ref) {
    xfer += oprot->writeFieldBegin("opt_ref", apache::thrift::protocol::T_STRUCT, 1);
    if (this->opt_ref) {xfer += this->opt_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->ref) {
    xfer += oprot->writeFieldBegin("ref", apache::thrift::protocol::T_STRUCT, 2);
    if (this->ref) {xfer += this->ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_ref) {
    xfer += oprot->writeFieldBegin("req_ref", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_ref) {xfer += this->req_ref->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MyStruct &a, MyStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_ref, b.opt_ref);
  swap(a.ref, b.ref);
  swap(a.req_ref, b.req_ref);
  swap(a.__isset, b.__isset);
}

void merge(const MyStruct& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(from.opt_ref, to.opt_ref);
  merge(from.ref, to.ref);
  merge(from.req_ref, to.req_ref);
}

void merge(MyStruct&& from, MyStruct& to) {
  using apache::thrift::merge;
  merge(std::move(from.opt_ref), to.opt_ref);
  merge(std::move(from.ref), to.ref);
  merge(std::move(from.req_ref), to.req_ref);
}

const uint64_t StructWithUnion::_reflection_id;
void StructWithUnion::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_11295191354176986988(schema);
}

StructWithUnion::StructWithUnion(const StructWithUnion& src6) {
  if (src6.u)
    u.reset(new MyUnion(*src6.u));
  aDouble = src6.aDouble;
  __isset.aDouble = src6.__isset.aDouble;
  f = src6.f;
  __isset.f = src6.__isset.f;
}
bool StructWithUnion::operator == (const StructWithUnion & rhs) const {
  if (bool(u) != bool(rhs.u))
    return false;
  else if (bool(u) && !(*u == *rhs.u))
    return false;
  if (!(this->aDouble == rhs.aDouble))
    return false;
  if (!(this->f == rhs.f))
    return false;
  return true;
}

uint32_t StructWithUnion::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_11295191354176986988(*schema);
    iprot->setNextStructType(StructWithUnion::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->u)>::type::element_type>::type;
          std::unique_ptr<element_type> _ptype8(new element_type());
          xfer += _ptype8->read(iprot);
          this->u = std::move(_ptype8);
          if (this->u->getType() == MyUnion::Type::__EMPTY__) {
            this->u = nullptr; 
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->aDouble);
          this->__isset.aDouble = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->f.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void StructWithUnion::__clear() {
  if (u) u->__clear();
  aDouble = 0;
  f.__clear();
  __isset.__clear();
}
uint32_t StructWithUnion::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithUnion");
  if (this->u) {
    xfer += oprot->writeFieldBegin("u", apache::thrift::protocol::T_STRUCT, 1);
    if (this->u) {xfer += this->u->write(oprot); 
} else {oprot->writeStructBegin("MyUnion"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("aDouble", apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->aDouble);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->f.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithUnion &a, StructWithUnion &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.u, b.u);
  swap(a.aDouble, b.aDouble);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithUnion& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(from.u, to.u);
  merge(from.aDouble, to.aDouble);
  to.__isset.aDouble = to.__isset.aDouble || from.__isset.aDouble;
  merge(from.f, to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
}

void merge(StructWithUnion&& from, StructWithUnion& to) {
  using apache::thrift::merge;
  merge(std::move(from.u), to.u);
  merge(std::move(from.aDouble), to.aDouble);
  to.__isset.aDouble = to.__isset.aDouble || from.__isset.aDouble;
  merge(std::move(from.f), to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
}

const uint64_t RecursiveStruct::_reflection_id;
void RecursiveStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_2826922994162023308(schema);
}

bool RecursiveStruct::operator == (const RecursiveStruct & rhs) const {
  if (__isset.mes != rhs.__isset.mes)
    return false;
  else if (__isset.mes && !(mes == rhs.mes))
    return false;
  return true;
}

uint32_t RecursiveStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_2826922994162023308(*schema);
    iprot->setNextStructType(RecursiveStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->mes.clear();
            uint32_t _size10;
            bool _sizeUnknown11;
            apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size10, _sizeUnknown11);
            if (!_sizeUnknown11) {
              this->mes.resize(_size10);
              uint32_t _i16;
              for (_i16 = 0; _i16 < _size10; ++_i16)
              {
                xfer += this->mes[_i16].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                RecursiveStruct _elem17;
                xfer += _elem17.read(iprot);
                this->mes.push_back(_elem17);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void RecursiveStruct::__clear() {
  mes.clear();
  __isset.__clear();
}
uint32_t RecursiveStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RecursiveStruct");
  if (this->__isset.mes) {
    xfer += oprot->writeFieldBegin("mes", apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->mes.size());
      std::vector<RecursiveStruct> ::const_iterator _iter18;
      for (_iter18 = this->mes.begin(); _iter18 != this->mes.end(); ++_iter18)
      {
        xfer += (*_iter18).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecursiveStruct &a, RecursiveStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.mes, b.mes);
  swap(a.__isset, b.__isset);
}

void merge(const RecursiveStruct& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(from.mes, to.mes);
    to.__isset.mes = true;
  }
}

void merge(RecursiveStruct&& from, RecursiveStruct& to) {
  using apache::thrift::merge;
  if (from.__isset.mes) {
    merge(std::move(from.mes), to.mes);
    to.__isset.mes = true;
  }
}

const uint64_t StructWithContainers::_reflection_id;
void StructWithContainers::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_18101585657679500556(schema);
}

StructWithContainers::StructWithContainers(const StructWithContainers& src19) {
  if (src19.list_ref)
    list_ref.reset(new std::vector<int32_t> (*src19.list_ref));
  if (src19.set_ref)
    set_ref.reset(new std::set<int32_t> (*src19.set_ref));
  if (src19.map_ref)
    map_ref.reset(new std::map<int32_t, int32_t> (*src19.map_ref));
  if (src19.list_ref_unique)
    list_ref_unique.reset(new std::vector<int32_t> (*src19.list_ref_unique));
  set_ref_shared = src19.set_ref_shared;
  map_ref_custom = src19.map_ref_custom;
  list_ref_shared_const = src19.list_ref_shared_const;
  if (src19.set_custom_ref)
    set_custom_ref.reset(new std::set<int32_t> (*src19.set_custom_ref));
}
bool StructWithContainers::operator == (const StructWithContainers & rhs) const {
  if (bool(list_ref) != bool(rhs.list_ref))
    return false;
  else if (bool(list_ref) && !(*list_ref == *rhs.list_ref))
    return false;
  if (bool(set_ref) != bool(rhs.set_ref))
    return false;
  else if (bool(set_ref) && !(*set_ref == *rhs.set_ref))
    return false;
  if (bool(map_ref) != bool(rhs.map_ref))
    return false;
  else if (bool(map_ref) && !(*map_ref == *rhs.map_ref))
    return false;
  if (bool(list_ref_unique) != bool(rhs.list_ref_unique))
    return false;
  else if (bool(list_ref_unique) && !(*list_ref_unique == *rhs.list_ref_unique))
    return false;
  if (bool(set_ref_shared) != bool(rhs.set_ref_shared))
    return false;
  else if (bool(set_ref_shared) && !(*set_ref_shared == *rhs.set_ref_shared))
    return false;
  if (bool(map_ref_custom) != bool(rhs.map_ref_custom))
    return false;
  else if (bool(map_ref_custom) && !(*map_ref_custom == *rhs.map_ref_custom))
    return false;
  if (bool(list_ref_shared_const) != bool(rhs.list_ref_shared_const))
    return false;
  else if (bool(list_ref_shared_const) && !(*list_ref_shared_const == *rhs.list_ref_shared_const))
    return false;
  if (bool(set_custom_ref) != bool(rhs.set_custom_ref))
    return false;
  else if (bool(set_custom_ref) && !(*set_custom_ref == *rhs.set_custom_ref))
    return false;
  return true;
}

uint32_t StructWithContainers::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_18101585657679500556(*schema);
    iprot->setNextStructType(StructWithContainers::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype26(new element_type());
            auto& _rtype27 = *_ptype26;
            _rtype27.clear();
            uint32_t _size21;
            bool _sizeUnknown22;
            apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size21, _sizeUnknown22);
            if (!_sizeUnknown22) {
              _rtype27.resize(_size21);
              uint32_t _i28;
              for (_i28 = 0; _i28 < _size21; ++_i28)
              {
                xfer += iprot->readI32(_rtype27[_i28]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem29;
                xfer += iprot->readI32(_elem29);
                _rtype27.push_back(_elem29);
              }
            }
            this->list_ref =  std::move(_ptype26);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->set_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype35(new element_type());
            auto& _rtype36 = *_ptype35;
            _rtype36.clear();
            uint32_t _size30;
            bool _sizeUnknown31;
            apache::thrift::protocol::TType _etype34;
            xfer += iprot->readSetBegin(_etype34, _size30, _sizeUnknown31);
            if (!_sizeUnknown31) {
              uint32_t _i37;
              for (_i37 = 0; _i37 < _size30; ++_i37)
              {
                int32_t _elem38;
                xfer += iprot->readI32(_elem38);
                _rtype36.insert(_elem38);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem39;
                xfer += iprot->readI32(_elem39);
                _rtype36.insert(_elem39);
              }
            }
            this->set_ref =  std::move(_ptype35);
            xfer += iprot->readSetEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->map_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype45(new element_type());
            auto& _rtype46 = *_ptype45;
            _rtype46.clear();
            uint32_t _size40;
            bool _sizeUnknown41;
            apache::thrift::protocol::TType _ktype42;
            apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size40, _sizeUnknown41);
            if (!_sizeUnknown41) {
              uint32_t _i47;
              for (_i47 = 0; _i47 < _size40; ++_i47)
              {
                int32_t _key48;
                xfer += iprot->readI32(_key48);
                int32_t& _val49 = _rtype46[_key48];
                xfer += iprot->readI32(_val49);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key50;
                xfer += iprot->readI32(_key50);
                int32_t& _val51 = _rtype46[_key50];
                xfer += iprot->readI32(_val51);
              }
            }
            this->map_ref =  std::move(_ptype45);
            xfer += iprot->readMapEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref_unique)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype57(new element_type());
            auto& _rtype58 = *_ptype57;
            _rtype58.clear();
            uint32_t _size52;
            bool _sizeUnknown53;
            apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size52, _sizeUnknown53);
            if (!_sizeUnknown53) {
              _rtype58.resize(_size52);
              uint32_t _i59;
              for (_i59 = 0; _i59 < _size52; ++_i59)
              {
                xfer += iprot->readI32(_rtype58[_i59]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem60;
                xfer += iprot->readI32(_elem60);
                _rtype58.push_back(_elem60);
              }
            }
            this->list_ref_unique =  std::move(_ptype57);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->set_ref_shared)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype66(new element_type());
            auto& _rtype67 = *_ptype66;
            _rtype67.clear();
            uint32_t _size61;
            bool _sizeUnknown62;
            apache::thrift::protocol::TType _etype65;
            xfer += iprot->readSetBegin(_etype65, _size61, _sizeUnknown62);
            if (!_sizeUnknown62) {
              uint32_t _i68;
              for (_i68 = 0; _i68 < _size61; ++_i68)
              {
                int32_t _elem69;
                xfer += iprot->readI32(_elem69);
                _rtype67.insert(_elem69);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem70;
                xfer += iprot->readI32(_elem70);
                _rtype67.insert(_elem70);
              }
            }
            this->set_ref_shared =  std::move(_ptype66);
            xfer += iprot->readSetEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->map_ref_custom)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype76(new element_type());
            auto& _rtype77 = *_ptype76;
            _rtype77.clear();
            uint32_t _size71;
            bool _sizeUnknown72;
            apache::thrift::protocol::TType _ktype73;
            apache::thrift::protocol::TType _vtype74;
            xfer += iprot->readMapBegin(_ktype73, _vtype74, _size71, _sizeUnknown72);
            if (!_sizeUnknown72) {
              uint32_t _i78;
              for (_i78 = 0; _i78 < _size71; ++_i78)
              {
                int32_t _key79;
                xfer += iprot->readI32(_key79);
                int32_t& _val80 = _rtype77[_key79];
                xfer += iprot->readI32(_val80);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key81;
                xfer += iprot->readI32(_key81);
                int32_t& _val82 = _rtype77[_key81];
                xfer += iprot->readI32(_val82);
              }
            }
            this->map_ref_custom =  std::move(_ptype76);
            xfer += iprot->readMapEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->list_ref_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype88(new element_type());
            auto& _rtype89 = *_ptype88;
            _rtype89.clear();
            uint32_t _size83;
            bool _sizeUnknown84;
            apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size83, _sizeUnknown84);
            if (!_sizeUnknown84) {
              _rtype89.resize(_size83);
              uint32_t _i90;
              for (_i90 = 0; _i90 < _size83; ++_i90)
              {
                xfer += iprot->readI32(_rtype89[_i90]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem91;
                xfer += iprot->readI32(_elem91);
                _rtype89.push_back(_elem91);
              }
            }
            this->list_ref_shared_const =  std::move(_ptype88);
            xfer += iprot->readListEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->set_custom_ref)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype97(new element_type());
            auto& _rtype98 = *_ptype97;
            _rtype98.clear();
            uint32_t _size92;
            bool _sizeUnknown93;
            apache::thrift::protocol::TType _etype96;
            xfer += iprot->readSetBegin(_etype96, _size92, _sizeUnknown93);
            if (!_sizeUnknown93) {
              uint32_t _i99;
              for (_i99 = 0; _i99 < _size92; ++_i99)
              {
                int32_t _elem100;
                xfer += iprot->readI32(_elem100);
                _rtype98.insert(_elem100);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem101;
                xfer += iprot->readI32(_elem101);
                _rtype98.insert(_elem101);
              }
            }
            this->set_custom_ref =  std::move(_ptype97);
            xfer += iprot->readSetEnd();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void StructWithContainers::__clear() {
  list_ref.reset(new typename decltype(list_ref)::element_type());
  set_ref.reset(new typename decltype(set_ref)::element_type());
  map_ref.reset(new typename decltype(map_ref)::element_type());
  list_ref_unique.reset(new typename decltype(list_ref_unique)::element_type());
  set_ref_shared.reset(new typename decltype(set_ref_shared)::element_type());
  map_ref_custom.reset(new typename decltype(map_ref_custom)::element_type());
  list_ref_shared_const.reset(new typename decltype(list_ref_shared_const)::element_type());
  set_custom_ref.reset(new typename decltype(set_custom_ref)::element_type());
  __isset.__clear();
}
uint32_t StructWithContainers::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithContainers");
  if (this->list_ref) {
    xfer += oprot->writeFieldBegin("list_ref", apache::thrift::protocol::T_LIST, 1);
    {
      if (this->list_ref) {
        const auto& _rtype102 = *this->list_ref;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype102.size());
        std::vector<int32_t> ::const_iterator _iter103;
        for (_iter103 = _rtype102.begin(); _iter103 != _rtype102.end(); ++_iter103)
        {
          xfer += oprot->writeI32((*_iter103));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->set_ref) {
    xfer += oprot->writeFieldBegin("set_ref", apache::thrift::protocol::T_SET, 2);
    {
      if (this->set_ref) {
        const auto& _rtype104 = *this->set_ref;
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, _rtype104.size());
        std::set<int32_t> ::const_iterator _iter105;
        for (_iter105 = _rtype104.begin(); _iter105 != _rtype104.end(); ++_iter105)
        {
          xfer += oprot->writeI32((*_iter105));
        }
        xfer += oprot->writeSetEnd();
      } else {
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->map_ref) {
    xfer += oprot->writeFieldBegin("map_ref", apache::thrift::protocol::T_MAP, 3);
    {
      if (this->map_ref) {
        const auto& _rtype106 = *this->map_ref;
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, _rtype106.size());
        std::map<int32_t, int32_t> ::const_iterator _iter107;
        for (_iter107 = _rtype106.begin(); _iter107 != _rtype106.end(); ++_iter107)
        {
          xfer += oprot->writeI32(_iter107->first);
          xfer += oprot->writeI32(_iter107->second);
        }
        xfer += oprot->writeMapEnd();
      } else {
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->list_ref_unique) {
    xfer += oprot->writeFieldBegin("list_ref_unique", apache::thrift::protocol::T_LIST, 4);
    {
      if (this->list_ref_unique) {
        const auto& _rtype108 = *this->list_ref_unique;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype108.size());
        std::vector<int32_t> ::const_iterator _iter109;
        for (_iter109 = _rtype108.begin(); _iter109 != _rtype108.end(); ++_iter109)
        {
          xfer += oprot->writeI32((*_iter109));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->set_ref_shared) {
    xfer += oprot->writeFieldBegin("set_ref_shared", apache::thrift::protocol::T_SET, 5);
    {
      if (this->set_ref_shared) {
        const auto& _rtype110 = *this->set_ref_shared;
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, _rtype110.size());
        std::set<int32_t> ::const_iterator _iter111;
        for (_iter111 = _rtype110.begin(); _iter111 != _rtype110.end(); ++_iter111)
        {
          xfer += oprot->writeI32((*_iter111));
        }
        xfer += oprot->writeSetEnd();
      } else {
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->map_ref_custom) {
    xfer += oprot->writeFieldBegin("map_ref_custom", apache::thrift::protocol::T_MAP, 6);
    {
      if (this->map_ref_custom) {
        const auto& _rtype112 = *this->map_ref_custom;
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, _rtype112.size());
        const std::map<int32_t, int32_t>::const_iterator _iter113;
        for (_iter113 = _rtype112.begin(); _iter113 != _rtype112.end(); ++_iter113)
        {
          xfer += oprot->writeI32(_iter113->first);
          xfer += oprot->writeI32(_iter113->second);
        }
        xfer += oprot->writeMapEnd();
      } else {
        xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->list_ref_shared_const) {
    xfer += oprot->writeFieldBegin("list_ref_shared_const", apache::thrift::protocol::T_LIST, 7);
    {
      if (this->list_ref_shared_const) {
        const auto& _rtype114 = *this->list_ref_shared_const;
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, _rtype114.size());
        std::vector<int32_t> ::const_iterator _iter115;
        for (_iter115 = _rtype114.begin(); _iter115 != _rtype114.end(); ++_iter115)
        {
          xfer += oprot->writeI32((*_iter115));
        }
        xfer += oprot->writeListEnd();
      } else {
        xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->set_custom_ref) {
    xfer += oprot->writeFieldBegin("set_custom_ref", apache::thrift::protocol::T_SET, 8);
    {
      if (this->set_custom_ref) {
        const auto& _rtype116 = *this->set_custom_ref;
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, _rtype116.size());
        std::set<int32_t> ::const_iterator _iter117;
        for (_iter117 = _rtype116.begin(); _iter117 != _rtype116.end(); ++_iter117)
        {
          xfer += oprot->writeI32((*_iter117));
        }
        xfer += oprot->writeSetEnd();
      } else {
        xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, 0);
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithContainers &a, StructWithContainers &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.list_ref, b.list_ref);
  swap(a.set_ref, b.set_ref);
  swap(a.map_ref, b.map_ref);
  swap(a.list_ref_unique, b.list_ref_unique);
  swap(a.set_ref_shared, b.set_ref_shared);
  swap(a.map_ref_custom, b.map_ref_custom);
  swap(a.list_ref_shared_const, b.list_ref_shared_const);
  swap(a.set_custom_ref, b.set_custom_ref);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithContainers& from, StructWithContainers& to) {
  using apache::thrift::merge;
  merge(from.list_ref, to.list_ref);
  merge(from.set_ref, to.set_ref);
  merge(from.map_ref, to.map_ref);
  merge(from.list_ref_unique, to.list_ref_unique);
  merge(from.set_ref_shared, to.set_ref_shared);
  merge(from.map_ref_custom, to.map_ref_custom);
  merge(from.list_ref_shared_const, to.list_ref_shared_const);
  merge(from.set_custom_ref, to.set_custom_ref);
}

void merge(StructWithContainers&& from, StructWithContainers& to) {
  using apache::thrift::merge;
  merge(std::move(from.list_ref), to.list_ref);
  merge(std::move(from.set_ref), to.set_ref);
  merge(std::move(from.map_ref), to.map_ref);
  merge(std::move(from.list_ref_unique), to.list_ref_unique);
  merge(std::move(from.set_ref_shared), to.set_ref_shared);
  merge(std::move(from.map_ref_custom), to.map_ref_custom);
  merge(std::move(from.list_ref_shared_const), to.list_ref_shared_const);
  merge(std::move(from.set_custom_ref), to.set_custom_ref);
}

const uint64_t StructWithSharedConst::_reflection_id;
void StructWithSharedConst::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_17232433652683371404(schema);
}

bool StructWithSharedConst::operator == (const StructWithSharedConst & rhs) const {
  if (bool(opt_shared_const) != bool(rhs.opt_shared_const))
    return false;
  else if (bool(opt_shared_const) && !(*opt_shared_const == *rhs.opt_shared_const))
    return false;
  if (bool(shared_const) != bool(rhs.shared_const))
    return false;
  else if (bool(shared_const) && !(*shared_const == *rhs.shared_const))
    return false;
  if (bool(req_shared_const) != bool(rhs.req_shared_const))
    return false;
  else if (bool(req_shared_const) && !(*req_shared_const == *rhs.req_shared_const))
    return false;
  return true;
}

uint32_t StructWithSharedConst::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_17232433652683371404(*schema);
    iprot->setNextStructType(StructWithSharedConst::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;

  bool isset_req_shared_const = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->opt_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype119(new element_type());
            xfer += _ptype119->read(iprot);
            this->opt_shared_const = std::move(_ptype119);
            if (false) {
            } else if (this->opt_shared_const->__isset.opt_value) {
            } else if (this->opt_shared_const->__isset.value) {
            } else { this->opt_shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype120(new element_type());
            xfer += _ptype120->read(iprot);
            this->shared_const = std::move(_ptype120);
            if (false) {
            } else if (this->shared_const->__isset.opt_value) {
            } else if (this->shared_const->__isset.value) {
            } else { this->shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            using element_type = typename std::remove_const<typename std::remove_reference<decltype(this->req_shared_const)>::type::element_type>::type;
            std::unique_ptr<element_type> _ptype121(new element_type());
            xfer += _ptype121->read(iprot);
            this->req_shared_const = std::move(_ptype121);
            if (false) {
            } else if (this->req_shared_const->__isset.opt_value) {
            } else if (this->req_shared_const->__isset.value) {
            } else { this->req_shared_const = nullptr; }
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          isset_req_shared_const = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  if (!isset_req_shared_const)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'req_shared_const' was not found in serialized data! Struct: StructWithSharedConst");
  return xfer;
}

void StructWithSharedConst::__clear() {
  opt_shared_const.reset();
  shared_const.reset();
  req_shared_const.reset();
  __isset.__clear();
}
uint32_t StructWithSharedConst::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StructWithSharedConst");
  if (this->opt_shared_const) {
    xfer += oprot->writeFieldBegin("opt_shared_const", apache::thrift::protocol::T_STRUCT, 1);
    if (this->opt_shared_const) {xfer += this->opt_shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->shared_const) {
    xfer += oprot->writeFieldBegin("shared_const", apache::thrift::protocol::T_STRUCT, 2);
    if (this->shared_const) {xfer += this->shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  if (this->req_shared_const) {
    xfer += oprot->writeFieldBegin("req_shared_const", apache::thrift::protocol::T_STRUCT, 3);
    if (this->req_shared_const) {xfer += this->req_shared_const->write(oprot); 
} else {oprot->writeStructBegin("MyField"); oprot->writeStructEnd(); oprot->writeFieldStop();}
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StructWithSharedConst &a, StructWithSharedConst &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.opt_shared_const, b.opt_shared_const);
  swap(a.shared_const, b.shared_const);
  swap(a.req_shared_const, b.req_shared_const);
  swap(a.__isset, b.__isset);
}

void merge(const StructWithSharedConst& from, StructWithSharedConst& to) {
  using apache::thrift::merge;
  merge(from.opt_shared_const, to.opt_shared_const);
  merge(from.shared_const, to.shared_const);
  merge(from.req_shared_const, to.req_shared_const);
}

void merge(StructWithSharedConst&& from, StructWithSharedConst& to) {
  using apache::thrift::merge;
  merge(std::move(from.opt_shared_const), to.opt_shared_const);
  merge(std::move(from.shared_const), to.shared_const);
  merge(std::move(from.req_shared_const), to.req_shared_const);
}


