/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef  _MyService_H
#define  _MyService_H

#include <functional>
#include <thrift/lib/cpp/transport/TBufferTransports.h>
namespace apache { namespace thrift { namespace async {
class TAsyncChannel;
}}}
#include <thrift/lib/cpp/TDispatchProcessor.h>
#include <folly/ExceptionWrapper.h>
#include <thrift/lib/cpp/async/TAsyncDispatchProcessor.h>
#include "thrift/compiler/test/fixtures/basic-cpp-async/gen-cpp/module_types.h"



class MyServiceIf {
 public:
  virtual ~MyServiceIf() {}
  virtual void ping() = 0;
  virtual void getRandomData(std::string& _return) = 0;
  virtual bool hasDataById(int64_t id) = 0;
  virtual void getDataById(std::string& _return, int64_t id) = 0;
  virtual void putDataById(int64_t id, const std::string& data) = 0;
  virtual void lobDataById(int64_t id, const std::string& data) = 0;
  virtual void putStructById(int64_t id, const MyStruct& data) = 0;
};

class MyServiceIfFactory {
 public:
  typedef MyServiceIf Handler;

  virtual ~MyServiceIfFactory() {}

  virtual MyServiceIf* getHandler(::apache::thrift::server::TConnectionContext* ctx) = 0;
  virtual void releaseHandler(MyServiceIf* /*handler*/) = 0;
};

class MyServiceIfSingletonFactory : virtual public MyServiceIfFactory {
 public:
  MyServiceIfSingletonFactory(const std::shared_ptr<MyServiceIf>& iface) : iface_(iface) {}
  virtual ~MyServiceIfSingletonFactory() {}

  virtual MyServiceIf* getHandler(::apache::thrift::server::TConnectionContext*) {
    return iface_.get();
  }
  virtual void releaseHandler(MyServiceIf* /*handler*/) {}

 protected:
  std::shared_ptr<MyServiceIf> iface_;
};

class MyServiceNull : virtual public MyServiceIf {
 public:
  virtual ~MyServiceNull() {}
  void ping() {
    return;
  }
  void getRandomData(std::string& /* _return */) {
    return;
  }
  bool hasDataById(int64_t /* id */) {
    bool _return = false;
    return _return;
  }
  void getDataById(std::string& /* _return */, int64_t /* id */) {
    return;
  }
  void putDataById(int64_t /* id */, const std::string& /* data */) {
    return;
  }
  void lobDataById(int64_t /* id */, const std::string& /* data */) {
    return;
  }
  void putStructById(int64_t /* id */, const MyStruct& /* data */) {
    return;
  }
};

class MyService_ping_args : public apache::thrift::TStructType<MyService_ping_args> {
 public:

  static const uint64_t _reflection_id = 16917139520594253004U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_ping_args() {
  }

  MyService_ping_args(const MyService_ping_args&) = default;
  MyService_ping_args& operator=(const MyService_ping_args& src)= default;
  MyService_ping_args(MyService_ping_args&&) = default;
  MyService_ping_args& operator=(MyService_ping_args&&) = default;

  void __clear();

  virtual ~MyService_ping_args() noexcept {}


  bool operator == (const MyService_ping_args &) const;
  bool operator != (const MyService_ping_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_ping_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_ping_args;
void merge(const MyService_ping_args& from, MyService_ping_args& to);
void merge(MyService_ping_args&& from, MyService_ping_args& to);
class MyService_ping_pargs : public apache::thrift::TStructType<MyService_ping_pargs> {
 public:

  static const uint64_t _reflection_id = 16815395149953092012U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_ping_pargs() = default;

  virtual ~MyService_ping_pargs() noexcept {}


  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_ping_pargs;
void merge(const MyService_ping_pargs& from, MyService_ping_pargs& to);
void merge(MyService_ping_pargs&& from, MyService_ping_pargs& to);
class MyService_ping_presult : public apache::thrift::TStructType<MyService_ping_presult> {
 public:

  static const uint64_t _reflection_id = 7454426369090387564U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_ping_presult() = default;

  virtual ~MyService_ping_presult() noexcept {}


  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_ping_presult;
void merge(const MyService_ping_presult& from, MyService_ping_presult& to);
void merge(MyService_ping_presult&& from, MyService_ping_presult& to);
class MyService_getRandomData_args : public apache::thrift::TStructType<MyService_getRandomData_args> {
 public:

  static const uint64_t _reflection_id = 15719605412501798860U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getRandomData_args() {
  }

  MyService_getRandomData_args(const MyService_getRandomData_args&) = default;
  MyService_getRandomData_args& operator=(const MyService_getRandomData_args& src)= default;
  MyService_getRandomData_args(MyService_getRandomData_args&&) = default;
  MyService_getRandomData_args& operator=(MyService_getRandomData_args&&) = default;

  void __clear();

  virtual ~MyService_getRandomData_args() noexcept {}


  bool operator == (const MyService_getRandomData_args &) const;
  bool operator != (const MyService_getRandomData_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_getRandomData_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getRandomData_args;
void merge(const MyService_getRandomData_args& from, MyService_getRandomData_args& to);
void merge(MyService_getRandomData_args&& from, MyService_getRandomData_args& to);
class MyService_getRandomData_pargs : public apache::thrift::TStructType<MyService_getRandomData_pargs> {
 public:

  static const uint64_t _reflection_id = 7557343870547663148U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getRandomData_pargs() = default;

  virtual ~MyService_getRandomData_pargs() noexcept {}


  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getRandomData_pargs;
void merge(const MyService_getRandomData_pargs& from, MyService_getRandomData_pargs& to);
void merge(MyService_getRandomData_pargs&& from, MyService_getRandomData_pargs& to);
class MyService_getRandomData_presult : public apache::thrift::TStructType<MyService_getRandomData_presult> {
 public:

  static const uint64_t _reflection_id = 11335342061983591980U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getRandomData_presult() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_getRandomData_presult(
    ::apache::thrift::detail::argument_wrapper<0, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_getRandomData_presult(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    success = arg.move();
    __isset.success = true;
  }

  virtual ~MyService_getRandomData_presult() noexcept {}

  std::string* success;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      success = false;
    }
    bool success;
  } __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getRandomData_presult;
void merge(const MyService_getRandomData_presult& from, MyService_getRandomData_presult& to);
void merge(MyService_getRandomData_presult&& from, MyService_getRandomData_presult& to);
class MyService_hasDataById_args : public apache::thrift::TStructType<MyService_hasDataById_args> {
 public:

  static const uint64_t _reflection_id = 12544043904188382700U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_hasDataById_args() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_hasDataById_args(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_hasDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }

  MyService_hasDataById_args(const MyService_hasDataById_args&) = default;
  MyService_hasDataById_args& operator=(const MyService_hasDataById_args& src)= default;
  MyService_hasDataById_args(MyService_hasDataById_args&&) = default;
  MyService_hasDataById_args& operator=(MyService_hasDataById_args&&) = default;

  void __clear();

  virtual ~MyService_hasDataById_args() noexcept {}

  int64_t id;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id = false;
    }
    bool id;
  } __isset;

  bool operator == (const MyService_hasDataById_args &) const;
  bool operator != (const MyService_hasDataById_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_hasDataById_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_hasDataById_args;
void merge(const MyService_hasDataById_args& from, MyService_hasDataById_args& to);
void merge(MyService_hasDataById_args&& from, MyService_hasDataById_args& to);
class MyService_hasDataById_pargs : public apache::thrift::TStructType<MyService_hasDataById_pargs> {
 public:

  static const uint64_t _reflection_id = 11103477756651294252U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_hasDataById_pargs() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_hasDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_hasDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
  }

  virtual ~MyService_hasDataById_pargs() noexcept {}

  const int64_t* id;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_hasDataById_pargs;
void merge(const MyService_hasDataById_pargs& from, MyService_hasDataById_pargs& to);
void merge(MyService_hasDataById_pargs&& from, MyService_hasDataById_pargs& to);
class MyService_hasDataById_presult : public apache::thrift::TStructType<MyService_hasDataById_presult> {
 public:

  static const uint64_t _reflection_id = 7676580259158416684U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_hasDataById_presult() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_hasDataById_presult(
    ::apache::thrift::detail::argument_wrapper<0, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_hasDataById_presult(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    success = arg.move();
    __isset.success = true;
  }

  virtual ~MyService_hasDataById_presult() noexcept {}

  bool* success;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      success = false;
    }
    bool success;
  } __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_hasDataById_presult;
void merge(const MyService_hasDataById_presult& from, MyService_hasDataById_presult& to);
void merge(MyService_hasDataById_presult&& from, MyService_hasDataById_presult& to);
class MyService_getDataById_args : public apache::thrift::TStructType<MyService_getDataById_args> {
 public:

  static const uint64_t _reflection_id = 6402583257721468108U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getDataById_args() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_getDataById_args(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_getDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }

  MyService_getDataById_args(const MyService_getDataById_args&) = default;
  MyService_getDataById_args& operator=(const MyService_getDataById_args& src)= default;
  MyService_getDataById_args(MyService_getDataById_args&&) = default;
  MyService_getDataById_args& operator=(MyService_getDataById_args&&) = default;

  void __clear();

  virtual ~MyService_getDataById_args() noexcept {}

  int64_t id;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id = false;
    }
    bool id;
  } __isset;

  bool operator == (const MyService_getDataById_args &) const;
  bool operator != (const MyService_getDataById_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_getDataById_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getDataById_args;
void merge(const MyService_getDataById_args& from, MyService_getDataById_args& to);
void merge(MyService_getDataById_args&& from, MyService_getDataById_args& to);
class MyService_getDataById_pargs : public apache::thrift::TStructType<MyService_getDataById_pargs> {
 public:

  static const uint64_t _reflection_id = 10310703131271109740U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getDataById_pargs() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_getDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_getDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
  }

  virtual ~MyService_getDataById_pargs() noexcept {}

  const int64_t* id;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getDataById_pargs;
void merge(const MyService_getDataById_pargs& from, MyService_getDataById_pargs& to);
void merge(MyService_getDataById_pargs&& from, MyService_getDataById_pargs& to);
class MyService_getDataById_presult : public apache::thrift::TStructType<MyService_getDataById_presult> {
 public:

  static const uint64_t _reflection_id = 8469747470745394316U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_getDataById_presult() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_getDataById_presult(
    ::apache::thrift::detail::argument_wrapper<0, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_getDataById_presult(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    success = arg.move();
    __isset.success = true;
  }

  virtual ~MyService_getDataById_presult() noexcept {}

  std::string* success;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      success = false;
    }
    bool success;
  } __isset;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_getDataById_presult;
void merge(const MyService_getDataById_presult& from, MyService_getDataById_presult& to);
void merge(MyService_getDataById_presult&& from, MyService_getDataById_presult& to);
class MyService_putDataById_args : public apache::thrift::TStructType<MyService_putDataById_args> {
 public:

  static const uint64_t _reflection_id = 546042509371991564U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putDataById_args() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putDataById_args(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putDataById_args(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
    __isset.data = true;
  }

  MyService_putDataById_args(const MyService_putDataById_args&) = default;
  MyService_putDataById_args& operator=(const MyService_putDataById_args& src)= default;
  MyService_putDataById_args(MyService_putDataById_args&&) = default;
  MyService_putDataById_args& operator=(MyService_putDataById_args&&) = default;

  void __clear();

  virtual ~MyService_putDataById_args() noexcept {}

  int64_t id;
  std::string data;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id = false;
      data = false;
    }
    bool id;
    bool data;
  } __isset;

  bool operator == (const MyService_putDataById_args &) const;
  bool operator != (const MyService_putDataById_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_putDataById_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putDataById_args;
void merge(const MyService_putDataById_args& from, MyService_putDataById_args& to);
void merge(MyService_putDataById_args&& from, MyService_putDataById_args& to);
class MyService_putDataById_pargs : public apache::thrift::TStructType<MyService_putDataById_pargs> {
 public:

  static const uint64_t _reflection_id = 9284081343717630892U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putDataById_pargs() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
  }

  virtual ~MyService_putDataById_pargs() noexcept {}

  const int64_t* id;
  const std::string* data;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putDataById_pargs;
void merge(const MyService_putDataById_pargs& from, MyService_putDataById_pargs& to);
void merge(MyService_putDataById_pargs&& from, MyService_putDataById_pargs& to);
class MyService_putDataById_presult : public apache::thrift::TStructType<MyService_putDataById_presult> {
 public:

  static const uint64_t _reflection_id = 9940143875439151532U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putDataById_presult() = default;

  virtual ~MyService_putDataById_presult() noexcept {}


  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putDataById_presult;
void merge(const MyService_putDataById_presult& from, MyService_putDataById_presult& to);
void merge(MyService_putDataById_presult&& from, MyService_putDataById_presult& to);
class MyService_lobDataById_args : public apache::thrift::TStructType<MyService_lobDataById_args> {
 public:

  static const uint64_t _reflection_id = 15564732069918360876U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_lobDataById_args() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_lobDataById_args(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_lobDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_lobDataById_args(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_lobDataById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
    __isset.data = true;
  }

  MyService_lobDataById_args(const MyService_lobDataById_args&) = default;
  MyService_lobDataById_args& operator=(const MyService_lobDataById_args& src)= default;
  MyService_lobDataById_args(MyService_lobDataById_args&&) = default;
  MyService_lobDataById_args& operator=(MyService_lobDataById_args&&) = default;

  void __clear();

  virtual ~MyService_lobDataById_args() noexcept {}

  int64_t id;
  std::string data;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id = false;
      data = false;
    }
    bool id;
    bool data;
  } __isset;

  bool operator == (const MyService_lobDataById_args &) const;
  bool operator != (const MyService_lobDataById_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_lobDataById_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_lobDataById_args;
void merge(const MyService_lobDataById_args& from, MyService_lobDataById_args& to);
void merge(MyService_lobDataById_args&& from, MyService_lobDataById_args& to);
class MyService_lobDataById_pargs : public apache::thrift::TStructType<MyService_lobDataById_pargs> {
 public:

  static const uint64_t _reflection_id = 11737864613387025900U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_lobDataById_pargs() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_lobDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_lobDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_lobDataById_pargs(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_lobDataById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
  }

  virtual ~MyService_lobDataById_pargs() noexcept {}

  const int64_t* id;
  const std::string* data;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_lobDataById_pargs;
void merge(const MyService_lobDataById_pargs& from, MyService_lobDataById_pargs& to);
void merge(MyService_lobDataById_pargs&& from, MyService_lobDataById_pargs& to);
class MyService_putStructById_args : public apache::thrift::TStructType<MyService_putStructById_args> {
 public:

  static const uint64_t _reflection_id = 15712934915173236044U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putStructById_args() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putStructById_args(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putStructById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putStructById_args(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putStructById_args(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
    __isset.data = true;
  }

  MyService_putStructById_args(const MyService_putStructById_args&) = default;
  MyService_putStructById_args& operator=(const MyService_putStructById_args& src)= default;
  MyService_putStructById_args(MyService_putStructById_args&&) = default;
  MyService_putStructById_args& operator=(MyService_putStructById_args&&) = default;

  void __clear();

  virtual ~MyService_putStructById_args() noexcept {}

  int64_t id;
  MyStruct data;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id = false;
      data = false;
    }
    bool id;
    bool data;
  } __isset;

  bool operator == (const MyService_putStructById_args &) const;
  bool operator != (const MyService_putStructById_args& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyService_putStructById_args & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putStructById_args;
void merge(const MyService_putStructById_args& from, MyService_putStructById_args& to);
void merge(MyService_putStructById_args&& from, MyService_putStructById_args& to);
class MyService_putStructById_pargs : public apache::thrift::TStructType<MyService_putStructById_pargs> {
 public:

  static const uint64_t _reflection_id = 1575852537323546924U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putStructById_pargs() = default;
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putStructById_pargs(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putStructById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyService_putStructById_pargs(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyService_putStructById_pargs(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    data = arg.move();
  }

  virtual ~MyService_putStructById_pargs() noexcept {}

  const int64_t* id;
  const MyStruct* data;

  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putStructById_pargs;
void merge(const MyService_putStructById_pargs& from, MyService_putStructById_pargs& to);
void merge(MyService_putStructById_pargs&& from, MyService_putStructById_pargs& to);
class MyService_putStructById_presult : public apache::thrift::TStructType<MyService_putStructById_presult> {
 public:

  static const uint64_t _reflection_id = 4967378470319252300U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyService_putStructById_presult() = default;

  virtual ~MyService_putStructById_presult() noexcept {}


  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyService_putStructById_presult;
void merge(const MyService_putStructById_presult& from, MyService_putStructById_presult& to);
void merge(MyService_putStructById_presult&& from, MyService_putStructById_presult& to);
template <class Protocol_>
class MyServiceClientT : virtual public MyServiceIf, virtual public apache::thrift::TClientBase {
 public:
  MyServiceClientT(std::shared_ptr<Protocol_> prot) :
    checkSeqid_(true),
    nextSendSequenceId_(1),
    nextRecvSequenceId_(1),
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
    connectionContext_ = std::shared_ptr<TClientBase::ConnContext>(
      new TClientBase::ConnContext(piprot_, poprot_));
  }
  MyServiceClientT(std::shared_ptr<Protocol_> iprot, std::shared_ptr<Protocol_> oprot) :
    checkSeqid_(true),
    nextSendSequenceId_(1),
    nextRecvSequenceId_(1),
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
    connectionContext_ = std::shared_ptr<TClientBase::ConnContext>(
      new TClientBase::ConnContext(piprot_, poprot_));
  }
  std::shared_ptr<apache::thrift::protocol::TProtocol> getInputProtocol() {
    return this->piprot_;
  }
  std::shared_ptr<apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return this->poprot_;
  }
  virtual ~MyServiceClientT() {}
  void ping();
  virtual void send_ping();
  virtual void recv_ping();
  virtual folly::exception_wrapper recv_wrapped_ping();
  void getRandomData(std::string& _return);
  virtual void send_getRandomData();
  virtual void recv_getRandomData(std::string& _return);
  virtual folly::exception_wrapper recv_wrapped_getRandomData(std::string& _return);
  bool hasDataById(int64_t id);
  virtual void send_hasDataById(int64_t id);
  virtual bool recv_hasDataById();
  virtual folly::exception_wrapper recv_wrapped_hasDataById(bool& _return);
  void getDataById(std::string& _return, int64_t id);
  virtual void send_getDataById(int64_t id);
  virtual void recv_getDataById(std::string& _return);
  virtual folly::exception_wrapper recv_wrapped_getDataById(std::string& _return);
  void putDataById(int64_t id, const std::string& data);
  virtual void send_putDataById(int64_t id, const std::string& data);
  virtual void recv_putDataById();
  virtual folly::exception_wrapper recv_wrapped_putDataById();
  void lobDataById(int64_t id, const std::string& data);
  virtual void send_lobDataById(int64_t id, const std::string& data);
  void putStructById(int64_t id, const MyStruct& data);
  virtual void send_putStructById(int64_t id, const MyStruct& data);
  virtual void recv_putStructById();
  virtual folly::exception_wrapper recv_wrapped_putStructById();
  apache::thrift::server::TConnectionContext* getConnectionContext() {
    return connectionContext_.get();
  }

  /**
   * Disable checking the seqid field in server responses.
   *
   * This should only be used with broken servers that return incorrect seqid values.
   */
  void _disableSequenceIdChecks() {
    checkSeqid_ = false;
  }

 protected:
  bool checkSeqid_;
  int32_t nextSendSequenceId_;
  int32_t nextRecvSequenceId_;
  int32_t getNextSendSequenceId();
  int32_t getNextRecvSequenceId();
  std::shared_ptr<Protocol_> piprot_;
  std::shared_ptr<Protocol_> poprot_;
  Protocol_* iprot_;
  Protocol_* oprot_;
  std::shared_ptr<apache::thrift::server::TConnectionContext> connectionContext_;
  virtual const char* getServiceName();
};

typedef MyServiceClientT<apache::thrift::protocol::TProtocol> MyServiceClient;

template <class Protocol_>
class MyServiceProcessorT : public ::apache::thrift::TDispatchProcessorT<Protocol_> {
 public:
  virtual const char* getServiceName() {
    return "MyService";
  }
 protected:
  std::shared_ptr<MyServiceIf> iface_;
  virtual bool dispatchCall(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext);
  virtual bool dispatchCallTemplated(Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext);
 private:
  typedef  void (MyServiceProcessorT::*ProcessFunction)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, apache::thrift::server::TConnectionContext*);
  typedef void (MyServiceProcessorT::*SpecializedProcessFunction)(int32_t, Protocol_*, Protocol_*, apache::thrift::server::TConnectionContext*);
  struct ProcessFunctions {
    ProcessFunction generic;
    SpecializedProcessFunction specialized;
    ProcessFunctions(ProcessFunction g, SpecializedProcessFunction s) :
      generic(g),
      specialized(s) {}
    ProcessFunctions() : generic(NULL), specialized(NULL) {}
  };
  typedef std::map<std::string, ProcessFunctions> ProcessMap;
  ProcessMap processMap_;
  void process_ping(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_ping(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getRandomData(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getRandomData(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_hasDataById(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_hasDataById(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getDataById(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getDataById(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putDataById(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putDataById(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_lobDataById(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_lobDataById(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putStructById(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putStructById(int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
 public:
  MyServiceProcessorT(std::shared_ptr<MyServiceIf> iface) :
    iface_(iface) {
    processMap_["ping"] = ProcessFunctions(
      &MyServiceProcessorT::process_ping,
      &MyServiceProcessorT::process_ping);
    processMap_["getRandomData"] = ProcessFunctions(
      &MyServiceProcessorT::process_getRandomData,
      &MyServiceProcessorT::process_getRandomData);
    processMap_["hasDataById"] = ProcessFunctions(
      &MyServiceProcessorT::process_hasDataById,
      &MyServiceProcessorT::process_hasDataById);
    processMap_["getDataById"] = ProcessFunctions(
      &MyServiceProcessorT::process_getDataById,
      &MyServiceProcessorT::process_getDataById);
    processMap_["putDataById"] = ProcessFunctions(
      &MyServiceProcessorT::process_putDataById,
      &MyServiceProcessorT::process_putDataById);
    processMap_["lobDataById"] = ProcessFunctions(
      &MyServiceProcessorT::process_lobDataById,
      &MyServiceProcessorT::process_lobDataById);
    processMap_["putStructById"] = ProcessFunctions(
      &MyServiceProcessorT::process_putStructById,
      &MyServiceProcessorT::process_putStructById);
  }

  virtual ~MyServiceProcessorT() {}

  std::shared_ptr<std::set<std::string> > getProcessFunctions() { 
    std::shared_ptr<std::set<std::string> > rSet(new std::set<std::string>());
    rSet->insert("MyService.ping");
    rSet->insert("MyService.getRandomData");
    rSet->insert("MyService.hasDataById");
    rSet->insert("MyService.getDataById");
    rSet->insert("MyService.putDataById");
    rSet->insert("MyService.lobDataById");
    rSet->insert("MyService.putStructById");
    return rSet;
  }
};

typedef MyServiceProcessorT<apache::thrift::protocol::TDummyProtocol> MyServiceProcessor;

template <class Protocol_>
class MyServiceProcessorFactoryT : public ::apache::thrift::TProcessorFactory {
 public:
  MyServiceProcessorFactoryT(const ::std::shared_ptr< MyServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(::apache::thrift::server::TConnectionContext* ctx);

 protected:
  ::std::shared_ptr< MyServiceIfFactory > handlerFactory_;
};

typedef MyServiceProcessorFactoryT< ::apache::thrift::protocol::TDummyProtocol > MyServiceProcessorFactory;

class MyServiceMultiface : virtual public MyServiceIf {
 public:
  MyServiceMultiface(std::vector<std::shared_ptr<MyServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~MyServiceMultiface() {}
 protected:
  std::vector<std::shared_ptr<MyServiceIf> > ifaces_;
  MyServiceMultiface() {}
  void add(std::shared_ptr<MyServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void ping() {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->ping();
    }
  }

  void getRandomData(std::string& _return) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->getRandomData(_return);
    }
  }

  bool hasDataById(int64_t id) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_ - 1; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->hasDataById(id);
    }
    return ifaces_[thrift_multifaces_index_tmp_]->hasDataById(id);
  }

  void getDataById(std::string& _return, int64_t id) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->getDataById(_return, id);
    }
  }

  void putDataById(int64_t id, const std::string& data) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->putDataById(id, data);
    }
  }

  void lobDataById(int64_t id, const std::string& data) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->lobDataById(id, data);
    }
  }

  void putStructById(int64_t id, const MyStruct& data) {
    uint32_t thrift_multifaces_index_tmp_;
    uint32_t thrift_multifaces_size_tmp_ = ifaces_.size();
    for (thrift_multifaces_index_tmp_ = 0; thrift_multifaces_index_tmp_ < thrift_multifaces_size_tmp_; ++thrift_multifaces_index_tmp_) {
      ifaces_[thrift_multifaces_index_tmp_]->putStructById(id, data);
    }
  }

};

template <class Protocol_>
class MyServiceCobClientT;

template <class Protocol_>
class MyServiceCobClIfT {
 public:
  virtual ~MyServiceCobClIfT() {}
  virtual void ping(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob) = 0;
  virtual void getRandomData(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob) = 0;
  virtual void hasDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id) = 0;
  virtual void getDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id) = 0;
  virtual void putDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const std::string& data) = 0;
  virtual void lobDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const std::string& data) = 0;
  virtual void putStructById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const MyStruct& data) = 0;
};

typedef MyServiceCobClIfT<apache::thrift::protocol::TProtocol> MyServiceCobClIf;

class MyServiceCobSvIf {
 public:
  virtual ~MyServiceCobSvIf() {}
  virtual void ping(std::function<void()> cob) = 0;
  virtual void getRandomData(std::function<void(std::string const& _return)> cob) = 0;
  virtual void hasDataById(std::function<void(bool const& _return)> cob, int64_t id) = 0;
  virtual void getDataById(std::function<void(std::string const& _return)> cob, int64_t id) = 0;
  virtual void putDataById(std::function<void()> cob, int64_t id, const std::string& data) = 0;
  virtual void lobDataById(std::function<void()> cob, int64_t id, const std::string& data) = 0;
  virtual void putStructById(std::function<void()> cob, int64_t id, const MyStruct& data) = 0;
};

class MyServiceCobSvIfFactory {
 public:
  typedef MyServiceCobSvIf Handler;

  virtual ~MyServiceCobSvIfFactory() {}

  virtual MyServiceCobSvIf* getHandler(::apache::thrift::server::TConnectionContext* ctx) = 0;
  virtual void releaseHandler(MyServiceCobSvIf* /*handler*/) = 0;
};

class MyServiceCobSvIfSingletonFactory : virtual public MyServiceCobSvIfFactory {
 public:
  MyServiceCobSvIfSingletonFactory(const std::shared_ptr<MyServiceCobSvIf>& iface) : iface_(iface) {}
  virtual ~MyServiceCobSvIfSingletonFactory() {}

  virtual MyServiceCobSvIf* getHandler(::apache::thrift::server::TConnectionContext*) {
    return iface_.get();
  }
  virtual void releaseHandler(MyServiceCobSvIf* /*handler*/) {}

 protected:
  std::shared_ptr<MyServiceCobSvIf> iface_;
};

class MyServiceCobSvNull : virtual public MyServiceCobSvIf {
 public:
  virtual ~MyServiceCobSvNull() {}
  void ping(std::function<void()> cob) {
    return cob();
  }
  void getRandomData(std::function<void(std::string const& _return)> cob) {
    std::string _return;
    return cob(_return);
  }
  void hasDataById(std::function<void(bool const& _return)> cob, int64_t /* id */) {
    bool _return = false;
    return cob(_return);
  }
  void getDataById(std::function<void(std::string const& _return)> cob, int64_t /* id */) {
    std::string _return;
    return cob(_return);
  }
  void putDataById(std::function<void()> cob, int64_t /* id */, const std::string& /* data */) {
    return cob();
  }
  void lobDataById(std::function<void()> cob, int64_t /* id */, const std::string& /* data */) {
    return cob();
  }
  void putStructById(std::function<void()> cob, int64_t /* id */, const MyStruct& /* data */) {
    return cob();
  }
};

template <class Protocol_>
class MyServiceCobClientT : virtual public MyServiceCobClIfT<Protocol_>, virtual public apache::thrift::TClientBase {
 public:
  MyServiceCobClientT(std::shared_ptr<apache::thrift::async::TAsyncChannel> channel, apache::thrift::protocol::TProtocolFactory* protocolFactory) :
    channel_(channel),
    itrans_(new apache::thrift::transport::TMemoryBuffer()),
    otrans_(new apache::thrift::transport::TMemoryBuffer()),
    checkSeqid_(true),
    nextSendSequenceId_(1),
    nextRecvSequenceId_(1),
    piprot_(std::dynamic_pointer_cast<Protocol_>(protocolFactory->getProtocol(itrans_))),
    poprot_(std::dynamic_pointer_cast<Protocol_>(protocolFactory->getProtocol(otrans_))) {
    if (!piprot_ || !poprot_) {
      throw apache::thrift::TLibraryException("TProtocolFactory returned unexpected protocol type in MyServiceCobClientT constructor");
    }
    iprot_ = piprot_.get();
    oprot_ = poprot_.get();
    connectionContext_ = std::shared_ptr<TClientBase::ConnContext>(
      new TClientBase::ConnContext(channel, piprot_, poprot_));
  }
  MyServiceCobClientT(std::shared_ptr<apache::thrift::async::TAsyncChannel> channel, apache::thrift::protocol::TDuplexProtocolFactory* protocolFactory) :
    channel_(channel),
    itrans_(new apache::thrift::transport::TMemoryBuffer()),
    otrans_(new apache::thrift::transport::TMemoryBuffer()),
    checkSeqid_(true),
    nextSendSequenceId_(1),
    nextRecvSequenceId_(1) {
    apache::thrift::transport::TTransportPair tpair = std::make_pair(itrans_, otrans_);
    apache::thrift::protocol::TProtocolPair ppair = protocolFactory->getProtocol(tpair);
    piprot_ = std::dynamic_pointer_cast<Protocol_>(ppair.first);
    poprot_ = std::dynamic_pointer_cast<Protocol_>(ppair.second);
    if (!piprot_ || !poprot_) {
      throw apache::thrift::TLibraryException("TDuplexProtocolFactory returned unexpected protocol type in MyServiceCobClientT constructor");
    }
    iprot_ = piprot_.get();
    oprot_ = poprot_.get();
    connectionContext_ = std::shared_ptr<TClientBase::ConnContext>(
      new TClientBase::ConnContext(channel, piprot_, poprot_));
  }
  std::shared_ptr<apache::thrift::async::TAsyncChannel> getChannel() {
    return this->channel_;
  }
  virtual void completed__(bool /*success*/) {}
  virtual ~MyServiceCobClientT() {}
  void ping(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob);
  virtual void send_ping();
  virtual void recv_ping();
  virtual folly::exception_wrapper recv_wrapped_ping();
  void getRandomData(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob);
  virtual void send_getRandomData();
  virtual void recv_getRandomData(std::string& _return);
  virtual folly::exception_wrapper recv_wrapped_getRandomData(std::string& _return);
  void hasDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id);
  virtual void send_hasDataById(int64_t id);
  virtual bool recv_hasDataById();
  virtual folly::exception_wrapper recv_wrapped_hasDataById(bool& _return);
  void getDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id);
  virtual void send_getDataById(int64_t id);
  virtual void recv_getDataById(std::string& _return);
  virtual folly::exception_wrapper recv_wrapped_getDataById(std::string& _return);
  void putDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const std::string& data);
  virtual void send_putDataById(int64_t id, const std::string& data);
  virtual void recv_putDataById();
  virtual folly::exception_wrapper recv_wrapped_putDataById();
  void lobDataById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const std::string& data);
  virtual void send_lobDataById(int64_t id, const std::string& data);
  void putStructById(std::function<void(MyServiceCobClientT<Protocol_>* client)> cob, int64_t id, const MyStruct& data);
  virtual void send_putStructById(int64_t id, const MyStruct& data);
  virtual void recv_putStructById();
  virtual folly::exception_wrapper recv_wrapped_putStructById();
  apache::thrift::server::TConnectionContext* getConnectionContext() {
    return connectionContext_.get();
  }

  /**
   * Disable checking the seqid field in server responses.
   *
   * This should only be used with broken servers that return incorrect seqid values.
   */
  void _disableSequenceIdChecks() {
    checkSeqid_ = false;
  }


  /**
   * Increase the send buffer size.  Use this if you plan to have more than one message outstanding.
   */
  void _resizeSendBuffer(uint32_t size) {
    otrans_->getWritePtr(size);
  }

 protected:
  std::shared_ptr<apache::thrift::async::TAsyncChannel> channel_;
  std::shared_ptr<apache::thrift::transport::TMemoryBuffer> itrans_;
  std::shared_ptr<apache::thrift::transport::TMemoryBuffer> otrans_;
  bool checkSeqid_;
  int32_t nextSendSequenceId_;
  int32_t nextRecvSequenceId_;
  int32_t getNextSendSequenceId();
  int32_t getNextRecvSequenceId();
  std::shared_ptr<Protocol_> piprot_;
  std::shared_ptr<Protocol_> poprot_;
  Protocol_* iprot_;
  Protocol_* oprot_;
  std::shared_ptr<apache::thrift::server::TConnectionContext> connectionContext_;
  virtual const char* getServiceName();
};

typedef MyServiceCobClientT<apache::thrift::protocol::TProtocol> MyServiceCobClient;

template <class Protocol_>
class MyServiceAsyncProcessorT : public ::apache::thrift::async::TAsyncDispatchProcessorT<Protocol_> {
 public:
  virtual const char* getServiceName() {
    return "MyService";
  }
 protected:
  std::shared_ptr<MyServiceCobSvIf> iface_;
  virtual void dispatchCall(std::function<void(bool ok)> cob, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext);
  virtual void dispatchCallTemplated(std::function<void(bool ok)> cob, Protocol_* iprot, Protocol_* oprot, const std::string& fname, int32_t seqid, apache::thrift::server::TConnectionContext* connectionContext);
 private:
  typedef  void (MyServiceAsyncProcessorT::*ProcessFunction)(std::function<void(bool ok)>, int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, apache::thrift::server::TConnectionContext*);
  typedef void (MyServiceAsyncProcessorT::*SpecializedProcessFunction)(std::function<void(bool ok)>, int32_t, Protocol_*, Protocol_*, apache::thrift::server::TConnectionContext*);
  struct ProcessFunctions {
    ProcessFunction generic;
    SpecializedProcessFunction specialized;
    ProcessFunctions(ProcessFunction g, SpecializedProcessFunction s) :
      generic(g),
      specialized(s) {}
    ProcessFunctions() : generic(NULL), specialized(NULL) {}
  };
  typedef std::map<std::string, ProcessFunctions> ProcessMap;
  ProcessMap processMap_;
  void process_ping(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_ping(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_ping(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx);
  void return_ping(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx);
  void throw_ping(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_ping(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::string& _return);
  void return_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::string& _return);
  void throw_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_getRandomData(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const bool& _return);
  void return_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const bool& _return);
  void throw_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_hasDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_getDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_getDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_getDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::string& _return);
  void return_getDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::string& _return);
  void throw_getDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_getDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_putDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_putDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx);
  void return_putDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx);
  void throw_putDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_putDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx);
  void return_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx);
  void throw_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_lobDataById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void process_putStructById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void process_putStructById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* iprot, Protocol_* oprot, apache::thrift::server::TConnectionContext* connectionContext);
  void return_putStructById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx);
  void return_putStructById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx);
  void throw_putStructById(std::function<void(bool ok)> cob, int32_t seqid, apache::thrift::protocol::TProtocol* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
  void throw_putStructById(std::function<void(bool ok)> cob, int32_t seqid, Protocol_* oprot, apache::thrift::ContextStack* ctx, const std::exception& ex);
 public:
  MyServiceAsyncProcessorT(std::shared_ptr<MyServiceCobSvIf> iface) :
    iface_(iface) {
    processMap_["ping"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_ping,
      &MyServiceAsyncProcessorT::process_ping);
    processMap_["getRandomData"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_getRandomData,
      &MyServiceAsyncProcessorT::process_getRandomData);
    processMap_["hasDataById"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_hasDataById,
      &MyServiceAsyncProcessorT::process_hasDataById);
    processMap_["getDataById"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_getDataById,
      &MyServiceAsyncProcessorT::process_getDataById);
    processMap_["putDataById"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_putDataById,
      &MyServiceAsyncProcessorT::process_putDataById);
    processMap_["lobDataById"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_lobDataById,
      &MyServiceAsyncProcessorT::process_lobDataById);
    processMap_["putStructById"] = ProcessFunctions(
      &MyServiceAsyncProcessorT::process_putStructById,
      &MyServiceAsyncProcessorT::process_putStructById);
  }

  virtual ~MyServiceAsyncProcessorT() {}

  std::shared_ptr<std::set<std::string> > getProcessFunctions() { 
    std::shared_ptr<std::set<std::string> > rSet(new std::set<std::string>());
    rSet->insert("MyService.ping");
    rSet->insert("MyService.getRandomData");
    rSet->insert("MyService.hasDataById");
    rSet->insert("MyService.getDataById");
    rSet->insert("MyService.putDataById");
    rSet->insert("MyService.lobDataById");
    rSet->insert("MyService.putStructById");
    return rSet;
  }
};

typedef MyServiceAsyncProcessorT<apache::thrift::protocol::TDummyProtocol> MyServiceAsyncProcessor;

template <class Protocol_>
class MyServiceAsyncProcessorFactoryT : public ::apache::thrift::async::TAsyncProcessorFactory {
 public:
  MyServiceAsyncProcessorFactoryT(const ::std::shared_ptr< MyServiceCobSvIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TAsyncProcessor > getProcessor(::apache::thrift::server::TConnectionContext* ctx);

 protected:
  ::std::shared_ptr< MyServiceCobSvIfFactory > handlerFactory_;
};

typedef MyServiceAsyncProcessorFactoryT< ::apache::thrift::protocol::TDummyProtocol > MyServiceAsyncProcessorFactory;



#include "thrift/compiler/test/fixtures/basic-cpp-async/gen-cpp/MyService.tcc"
#include "thrift/compiler/test/fixtures/basic-cpp-async/gen-cpp/module_types.tcc"

#endif
