#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from cython.operator cimport dereference as deref, preincrement as inc
from thrift.lib.py3.thrift_server cimport TException
cimport std_libcpp

from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class AnEnum(Enum):
    ONE = <int> (AnEnum__ONE)
    TWO = <int> (AnEnum__TWO)
    THREE = <int> (AnEnum__THREE)
    FOUR = <int> (AnEnum__FOUR)

cdef cAnEnum AnEnum_to_cpp(value):
    if value == AnEnum.ONE:
        return AnEnum__ONE
    elif value == AnEnum.TWO:
        return AnEnum__TWO
    elif value == AnEnum.THREE:
        return AnEnum__THREE
    elif value == AnEnum.FOUR:
        return AnEnum__FOUR


cdef class SimpleException(TException):
    def __init__(
        SimpleException self,
        err_code
    ):
        self.c_SimpleException = make_shared[cSimpleException]()
        deref(self.c_SimpleException).err_code = err_code
        
    @staticmethod
    cdef create(shared_ptr[cSimpleException] c_SimpleException):
        inst = <SimpleException>SimpleException.__new__(SimpleException)
        inst.c_SimpleException = c_SimpleException
        return inst

    @property
    def err_code(self):
        return self.c_SimpleException.get().err_code


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleException) and
                isinstance(other, SimpleException)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleException cself = deref((<SimpleException>self).c_SimpleException)
        cdef cSimpleException cother = deref((<SimpleException>other).c_SimpleException)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(SimpleException self):
        return hash((
          self.err_code,
        ))



cdef class SimpleStruct:
    def __init__(
        SimpleStruct self,
        is_on,
        tiny_int,
        small_int,
        nice_sized_int,
        big_int,
        real
    ):
        self.c_SimpleStruct = make_shared[cSimpleStruct]()
        deref(self.c_SimpleStruct).is_on = is_on
        deref(self.c_SimpleStruct).tiny_int = tiny_int
        deref(self.c_SimpleStruct).small_int = small_int
        deref(self.c_SimpleStruct).nice_sized_int = nice_sized_int
        deref(self.c_SimpleStruct).big_int = big_int
        deref(self.c_SimpleStruct).real = real
        
    @staticmethod
    cdef create(shared_ptr[cSimpleStruct] c_SimpleStruct):
        inst = <SimpleStruct>SimpleStruct.__new__(SimpleStruct)
        inst.c_SimpleStruct = c_SimpleStruct
        return inst

    @property
    def is_on(self):
        return <pbool> self.c_SimpleStruct.get().is_on

    @property
    def tiny_int(self):
        return self.c_SimpleStruct.get().tiny_int

    @property
    def small_int(self):
        return self.c_SimpleStruct.get().small_int

    @property
    def nice_sized_int(self):
        return self.c_SimpleStruct.get().nice_sized_int

    @property
    def big_int(self):
        return self.c_SimpleStruct.get().big_int

    @property
    def real(self):
        return self.c_SimpleStruct.get().real


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, SimpleStruct) and
                isinstance(other, SimpleStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cSimpleStruct cself = deref((<SimpleStruct>self).c_SimpleStruct)
        cdef cSimpleStruct cother = deref((<SimpleStruct>other).c_SimpleStruct)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(SimpleStruct self):
        return hash((
          self.is_on,
          self.tiny_int,
          self.small_int,
          self.nice_sized_int,
          self.big_int,
          self.real,
        ))



cdef class ComplexStruct:
    def __init__(
        ComplexStruct self,
        structOne,
        structTwo,
        an_integer,
        name,
        an_enum
    ):
        self.c_ComplexStruct = make_shared[cComplexStruct]()
        cdef shared_ptr[cSimpleStruct] __structOne = (
            <SimpleStruct?> structOne).c_SimpleStruct
        deref(self.c_ComplexStruct).structOne = deref(__structOne.get())
        cdef shared_ptr[cSimpleStruct] __structTwo = (
            <SimpleStruct?> structTwo).c_SimpleStruct
        deref(self.c_ComplexStruct).structTwo = deref(__structTwo.get())
        deref(self.c_ComplexStruct).an_integer = an_integer
        if name is not None:
            deref(self.c_ComplexStruct).name = name.encode('UTF-8')
        deref(self.c_ComplexStruct).an_enum = AnEnum_to_cpp(an_enum)
        
        
    @staticmethod
    cdef create(shared_ptr[cComplexStruct] c_ComplexStruct):
        inst = <ComplexStruct>ComplexStruct.__new__(ComplexStruct)
        inst.c_ComplexStruct = c_ComplexStruct
        return inst

    @property
    def structOne(self):
        cdef shared_ptr[cSimpleStruct] item
        if self.__structOne is None:
            item = make_shared[cSimpleStruct](
                deref(self.c_ComplexStruct).structOne)
            self.__structOne = SimpleStruct.create(item)
        return self.__structOne
        

    @property
    def structTwo(self):
        cdef shared_ptr[cSimpleStruct] item
        if self.__structTwo is None:
            item = make_shared[cSimpleStruct](
                deref(self.c_ComplexStruct).structTwo)
            self.__structTwo = SimpleStruct.create(item)
        return self.__structTwo
        

    @property
    def an_integer(self):
        return self.c_ComplexStruct.get().an_integer

    @property
    def name(self):
        return self.c_ComplexStruct.get().name.decode()

    @property
    def an_enum(self):
        cdef int value = <int> deref(self.c_ComplexStruct).an_enum
        return AnEnum(value)
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ComplexStruct) and
                isinstance(other, ComplexStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cComplexStruct cself = deref((<ComplexStruct>self).c_ComplexStruct)
        cdef cComplexStruct cother = deref((<ComplexStruct>other).c_ComplexStruct)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(ComplexStruct self):
        return hash((
          self.structOne,
          self.structTwo,
          self.an_integer,
          self.name,
          self.an_enum,
        ))



cdef class List__i16:
    def __init__(self, items=None):
        if isinstance(items, List__i16):
            self._vector = (<List__i16> items)._vector
        else:
          self._vector = make_shared[vector[int16_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int16_t]] c_items):
        inst = <List__i16>List__i16.__new__(List__i16)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef int16_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef int16_t citem
        for citem in deref(self._vector):
            yield citem

    def __reversed__(self):
        cdef int16_t citem
        cdef vector[int16_t] vec = deref(
            self._vector.get())
        cdef vector[int16_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._vector.get())
        cdef vector[int16_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef int16_t citem = item
        cdef vector[int16_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i16)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._vector = (<List__i32> items)._vector
        else:
          self._vector = make_shared[vector[int32_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef int32_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef int32_t citem
        for citem in deref(self._vector):
            yield citem

    def __reversed__(self):
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class List__i64:
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._vector = (<List__i64> items)._vector
        else:
          self._vector = make_shared[vector[int64_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef int64_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef int64_t citem
        for citem in deref(self._vector):
            yield citem

    def __reversed__(self):
        cdef int64_t citem
        cdef vector[int64_t] vec = deref(
            self._vector.get())
        cdef vector[int64_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._vector.get())
        cdef vector[int64_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef int64_t citem = item
        cdef vector[int64_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i64)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._vector = (<List__string> items)._vector
        else:
          self._vector = make_shared[vector[string]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item.encode('UTF-8'))

    @staticmethod
    cdef create(
            shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef string citem = (
            deref(self._vector.get())[index])
        return bytes(citem).decode()

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef string citem
        for citem in deref(self._vector):
            yield bytes(citem).decode()

    def __reversed__(self):
        cdef string citem
        cdef vector[string] vec = deref(
            self._vector.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode()
            inc(loc)

    def index(self, item):
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, List__SimpleStruct):
            self._vector = (<List__SimpleStruct> items)._vector
        else:
          self._vector = make_shared[vector[cSimpleStruct]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref((<SimpleStruct> item).c_SimpleStruct))

    @staticmethod
    cdef create(
            shared_ptr[vector[cSimpleStruct]] c_items):
        inst = <List__SimpleStruct>List__SimpleStruct.__new__(List__SimpleStruct)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef cSimpleStruct citem = (
            deref(self._vector.get())[index])
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef cSimpleStruct citem
        for citem in deref(self._vector):
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __reversed__(self):
        cdef cSimpleStruct citem
        cdef vector[cSimpleStruct] vec = deref(
            self._vector.get())
        cdef vector[cSimpleStruct].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))
            inc(loc)

    def index(self, item):
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(self._vector.get())
        cdef vector[cSimpleStruct].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef cSimpleStruct citem = deref((<SimpleStruct> item).c_SimpleStruct)
        cdef vector[cSimpleStruct] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__SimpleStruct)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._set = (<Set__i32> items)._set
        else:
          self._set = make_shared[cset[int32_t]]()
          if items:
              for item in items:
                  deref(self._set).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        return pbool(deref(self._set).count(item))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        for citem in deref(self._set):
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._set)
            cother = deref((<Set__i32> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        return hash(tuple(self))

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
            if deref((<Set__i32> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other



Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._set = (<Set__string> items)._set
        else:
          self._set = make_shared[cset[string]]()
          if items:
              for item in items:
                  deref(self._set).insert(item.encode('UTF-8'))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        return pbool(deref(self._set).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        for citem in deref(self._set):
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._set)
            cother = deref((<Set__string> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        return hash(tuple(self))

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
            if deref((<Set__string> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other



Set.register(Set__string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._map = (<Map__string_string> items)._map
        else:
          self._map = make_shared[cmap[string,string]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,string](
                          key.encode('UTF-8'),
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef string citem = deref(iter).second
        return bytes(citem).decode()

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode()

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.second
            yield bytes(citem).decode()

    def items(self):
        cdef string ckey
        cdef string citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), bytes(citem).decode())



Mapping.register(Map__string_string)

cdef class Map__string_SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_SimpleStruct):
            self._map = (<Map__string_SimpleStruct> items)._map
        else:
          self._map = make_shared[cmap[string,cSimpleStruct]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,cSimpleStruct](
                          key.encode('UTF-8'),
                          deref((<SimpleStruct> item).c_SimpleStruct)))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cSimpleStruct]] c_items):
        inst = <Map__string_SimpleStruct>Map__string_SimpleStruct.__new__(Map__string_SimpleStruct)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cSimpleStruct].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef cSimpleStruct citem = deref(iter).second
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cSimpleStruct].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef cSimpleStruct citem = deref(iter).second
        return SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef cSimpleStruct citem
        for pair in deref(self._map):
            citem = pair.second
            yield SimpleStruct.create(make_shared[cSimpleStruct](citem))

    def items(self):
        cdef string ckey
        cdef cSimpleStruct citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), SimpleStruct.create(make_shared[cSimpleStruct](citem)))



Mapping.register(Map__string_SimpleStruct)

cdef class Map__string_i16:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i16):
            self._map = (<Map__string_i16> items)._map
        else:
          self._map = make_shared[cmap[string,int16_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,int16_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int16_t]] c_items):
        inst = <Map__string_i16>Map__string_i16.__new__(Map__string_i16)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int16_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef int16_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int16_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int16_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef int16_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        cdef string ckey
        cdef int16_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), citem)



Mapping.register(Map__string_i16)

cdef class List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._vector = (<List__List__i32> items)._vector
        else:
          self._vector = make_shared[vector[vector[int32_t]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref(List__i32(item)._vector.get()))

    @staticmethod
    cdef create(
            shared_ptr[vector[vector[int32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef vector[int32_t] citem = (
            deref(self._vector.get())[index])
        return List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef vector[int32_t] citem
        for citem in deref(self._vector):
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))

    def __reversed__(self):
        cdef vector[int32_t] citem
        cdef vector[vector[int32_t]] vec = deref(
            self._vector.get())
        cdef vector[vector[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__i32.create(
    make_shared[vector[int32_t]](citem))
            inc(loc)

    def index(self, item):
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(self._vector.get())
        cdef vector[vector[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef vector[int32_t] citem = deref(List__i32(item)._vector.get())
        cdef vector[vector[int32_t]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._map = (<Map__string_i32> items)._map
        else:
          self._map = make_shared[cmap[string,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,int32_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), citem)



Mapping.register(Map__string_i32)

cdef class Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._map = (<Map__string_Map__string_i32> items)._map
        else:
          self._map = make_shared[cmap[string,cmap[string,int32_t]]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,cmap[string,int32_t]](
                          key.encode('UTF-8'),
                          cmap[string,int32_t](deref(Map__string_i32(item)._map.get()))))

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,int32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,cmap[string,int32_t]].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef cmap[string,int32_t] citem = deref(iter).second
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef cmap[string,int32_t] citem
        for pair in deref(self._map):
            citem = pair.second
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def items(self):
        cdef string ckey
        cdef cmap[string,int32_t] citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem)))



Mapping.register(Map__string_Map__string_i32)

cdef class List__Set__string:
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._vector = (<List__Set__string> items)._vector
        else:
          self._vector = make_shared[vector[cset[string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cset[string](deref(Set__string(item)._set.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef cset[string] citem = (
            deref(self._vector.get())[index])
        return Set__string.create(
    make_shared[cset[string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef cset[string] citem
        for citem in deref(self._vector):
            yield Set__string.create(
    make_shared[cset[string]](citem))

    def __reversed__(self):
        cdef cset[string] citem
        cdef vector[cset[string]] vec = deref(
            self._vector.get())
        cdef vector[cset[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__string.create(
    make_shared[cset[string]](citem))
            inc(loc)

    def index(self, item):
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(self._vector.get())
        cdef vector[cset[string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef cset[string] citem = cset[string](deref(Set__string(item)._set.get()))
        cdef vector[cset[string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__string)

cdef class Map__string_List__SimpleStruct:
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__SimpleStruct):
            self._map = (<Map__string_List__SimpleStruct> items)._map
        else:
          self._map = make_shared[cmap[string,vector[cSimpleStruct]]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,vector[cSimpleStruct]](
                          key.encode('UTF-8'),
                          deref(List__SimpleStruct(item)._vector.get())))

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cSimpleStruct]]] c_items):
        inst = <Map__string_List__SimpleStruct>Map__string_List__SimpleStruct.__new__(Map__string_List__SimpleStruct)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef vector[cSimpleStruct] citem = deref(iter).second
        return List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,vector[cSimpleStruct]].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef vector[cSimpleStruct] citem = deref(iter).second
        return List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._map):
            citem = pair.second
            yield List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem))

    def items(self):
        cdef string ckey
        cdef vector[cSimpleStruct] citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode(), List__SimpleStruct.create(
    make_shared[vector[cSimpleStruct]](citem)))



Mapping.register(Map__string_List__SimpleStruct)

cdef class List__List__string:
    def __init__(self, items=None):
        if isinstance(items, List__List__string):
            self._vector = (<List__List__string> items)._vector
        else:
          self._vector = make_shared[vector[vector[string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref(List__string(item)._vector.get()))

    @staticmethod
    cdef create(
            shared_ptr[vector[vector[string]]] c_items):
        inst = <List__List__string>List__List__string.__new__(List__List__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef vector[string] citem = (
            deref(self._vector.get())[index])
        return List__string.create(
    make_shared[vector[string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef vector[string] citem
        for citem in deref(self._vector):
            yield List__string.create(
    make_shared[vector[string]](citem))

    def __reversed__(self):
        cdef vector[string] citem
        cdef vector[vector[string]] vec = deref(
            self._vector.get())
        cdef vector[vector[string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield List__string.create(
    make_shared[vector[string]](citem))
            inc(loc)

    def index(self, item):
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(self._vector.get())
        cdef vector[vector[string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef vector[string] citem = deref(List__string(item)._vector.get())
        cdef vector[vector[string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__List__string)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._vector = (<List__Set__i32> items)._vector
        else:
          self._vector = make_shared[vector[cset[int32_t]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cset[int32_t](deref(Set__i32(item)._set.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef cset[int32_t] citem = (
            deref(self._vector.get())[index])
        return Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef cset[int32_t] citem
        for citem in deref(self._vector):
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))

    def __reversed__(self):
        cdef cset[int32_t] citem
        cdef vector[cset[int32_t]] vec = deref(
            self._vector.get())
        cdef vector[cset[int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Set__i32.create(
    make_shared[cset[int32_t]](citem))
            inc(loc)

    def index(self, item):
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(self._vector.get())
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef cset[int32_t] citem = cset[int32_t](deref(Set__i32(item)._set.get()))
        cdef vector[cset[int32_t]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Set__i32)

cdef class List__Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_string):
            self._vector = (<List__Map__string_string> items)._vector
        else:
          self._vector = make_shared[vector[cmap[string,string]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cmap[string,string](deref(Map__string_string(item)._map.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[string,string]]] c_items):
        inst = <List__Map__string_string>List__Map__string_string.__new__(List__Map__string_string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef cmap[string,string] citem = (
            deref(self._vector.get())[index])
        return Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef cmap[string,string] citem
        for citem in deref(self._vector):
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))

    def __reversed__(self):
        cdef cmap[string,string] citem
        cdef vector[cmap[string,string]] vec = deref(
            self._vector.get())
        cdef vector[cmap[string,string]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_string.create(
    make_shared[cmap[string,string]](citem))
            inc(loc)

    def index(self, item):
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(self._vector.get())
        cdef vector[cmap[string,string]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef cmap[string,string] citem = cmap[string,string](deref(Map__string_string(item)._map.get()))
        cdef vector[cmap[string,string]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_string)

cdef class Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_double):
            self._map = (<Map__i32_double> items)._map
        else:
          self._map = make_shared[cmap[int32_t,double]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[int32_t,double](
                          key,
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,double]] c_items):
        inst = <Map__i32_double>Map__i32_double.__new__(Map__i32_double)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef int32_t ckey = key
        cdef cmap[int32_t,double].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef int32_t ckey = key
        cdef cmap[int32_t,double].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef double citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef double citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        cdef int32_t ckey
        cdef double citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_double)

cdef class List__Map__i32_double:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i32_double):
            self._vector = (<List__Map__i32_double> items)._vector
        else:
          self._vector = make_shared[vector[cmap[int32_t,double]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cmap[int32_t,double](deref(Map__i32_double(item)._map.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[int32_t,double]]] c_items):
        inst = <List__Map__i32_double>List__Map__i32_double.__new__(List__Map__i32_double)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef cmap[int32_t,double] citem = (
            deref(self._vector.get())[index])
        return Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef cmap[int32_t,double] citem
        for citem in deref(self._vector):
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))

    def __reversed__(self):
        cdef cmap[int32_t,double] citem
        cdef vector[cmap[int32_t,double]] vec = deref(
            self._vector.get())
        cdef vector[cmap[int32_t,double]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__i32_double.create(
    make_shared[cmap[int32_t,double]](citem))
            inc(loc)

    def index(self, item):
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._vector.get())
        cdef vector[cmap[int32_t,double]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef cmap[int32_t,double] citem = cmap[int32_t,double](deref(Map__i32_double(item)._map.get()))
        cdef vector[cmap[int32_t,double]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__i32_double)


A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.140000
A_FAKE_NUMBER = 3.0
A_WORD = cA_WORD().decode('UTF-8')
A_STRUCT = SimpleStruct.create(
    make_shared[cSimpleStruct](cA_STRUCT()))
WORD_LIST = List__string.create(make_shared[vector[string]](cWORD_LIST()))
SOME_MAP = List__Map__i32_double.create(make_shared[vector[cmap[int32_t,double]]](cSOME_MAP()))
DIGITS = Set__i32.create(make_shared[cset[int32_t]](cDIGITS()))
A_CONST_MAP = Map__string_SimpleStruct.create(make_shared[cmap[string,cSimpleStruct]](cA_CONST_MAP()))
