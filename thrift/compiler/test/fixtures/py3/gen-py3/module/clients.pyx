#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libcpp.vector cimport vector as vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper
from thrift.py3.exceptions cimport try_make_shared_exception, raise_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
import thrift.py3.client
cimport thrift.py3.client
from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport cython

import asyncio
import sys
import traceback

cimport module.types
import module.types

from module.clients_wrapper cimport cSimpleServiceAsyncClient, cSimpleServiceClientWrapper
from module.clients_wrapper cimport cDerivedServiceAsyncClient, cDerivedServiceClientWrapper
from module.clients_wrapper cimport cRederivedServiceAsyncClient, cRederivedServiceClientWrapper


cdef void SimpleService_get_five_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_add_five_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_do_nothing_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void SimpleService_concat_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void SimpleService_get_value_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_negate_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void SimpleService_tiny_callback(
    cFollyTry[int8_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_small_callback(
    cFollyTry[int16_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_big_callback(
    cFollyTry[int64_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_two_callback(
    cFollyTry[double]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_expected_exception_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException[module.types.cSimpleException]():
        pyfuture.set_exception(module.types.SimpleException.create(try_make_shared_exception[module.types.cSimpleException](result.exception())))
    elif result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void SimpleService_unexpected_exception_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_sum_i16_list_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_sum_i32_list_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_sum_i64_list_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_concat_many_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void SimpleService_count_structs_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_sum_set_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_contains_word_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void SimpleService_get_map_value_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void SimpleService_map_length_callback(
    cFollyTry[int16_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_sum_map_values_callback(
    cFollyTry[int16_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_complex_sum_i32_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_repeat_name_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void SimpleService_get_struct_callback(
    cFollyTry[module.types.cSimpleStruct]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.SimpleStruct.create(make_shared[module.types.cSimpleStruct](result.value())))

cdef void SimpleService_fib_callback(
    cFollyTry[vector[int32_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__i32.create(make_shared[vector[int32_t]](result.value())))

cdef void SimpleService_unique_words_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__string.create(make_shared[cset[string]](result.value())))

cdef void SimpleService_words_count_callback(
    cFollyTry[cmap[string,int16_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Map__string_i16.create(make_shared[cmap[string,int16_t]](result.value())))

cdef void SimpleService_set_enum_callback(
    cFollyTry[module.types.cAnEnum]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.AnEnum(<int> result.value()))

cdef void SimpleService_list_of_lists_callback(
    cFollyTry[vector[vector[int32_t]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__List__i32.create(make_shared[vector[vector[int32_t]]](result.value())))

cdef void SimpleService_word_character_frequency_callback(
    cFollyTry[cmap[string,cmap[string,int32_t]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Map__string_Map__string_i32.create(make_shared[cmap[string,cmap[string,int32_t]]](result.value())))

cdef void SimpleService_list_of_sets_callback(
    cFollyTry[vector[cset[string]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__Set__string.create(make_shared[vector[cset[string]]](result.value())))

cdef void SimpleService_nested_map_argument_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_make_sentence_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void SimpleService_get_union_callback(
    cFollyTry[cset[int32_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__i32.create(make_shared[cset[int32_t]](result.value())))

cdef void SimpleService_get_keys_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__string.create(make_shared[cset[string]](result.value())))

cdef void SimpleService_lookup_double_callback(
    cFollyTry[double]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_retrieve_binary_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void SimpleService_contain_binary_callback(
    cFollyTry[cset[string]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__binary.create(make_shared[cset[string]](result.value())))

cdef void SimpleService_contain_enum_callback(
    cFollyTry[vector[module.types.cAnEnum]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__AnEnum.create(make_shared[vector[module.types.cAnEnum]](result.value())))

cdef void DerivedService_get_six_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void RederivedService_get_seven_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())


cdef class SimpleService(thrift.py3.client.Client):

    def __cinit__(SimpleService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(SimpleService self):
        return &typeid(cSimpleServiceAsyncClient)

    @staticmethod
    cdef _module_SimpleService_set_client(SimpleService inst, shared_ptr[cSimpleServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_SimpleService_client = c_obj

    cdef _module_SimpleService_reset_client(SimpleService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_SimpleService_client.reset()

    def __dealloc__(SimpleService self):
        if self._cRequestChannel or self._module_SimpleService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(SimpleService self):
        await self._connect_future
        if self._cRequestChannel:
            SimpleService._module_SimpleService_set_client(
                self,
                makeClientWrapper[cSimpleServiceAsyncClient, cSimpleServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(SimpleService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_SimpleService_client).disconnect(),
            closed_SimpleService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_SimpleService_reset_client()

    def set_persistent_header(SimpleService self, str key, str value):
        if not self._module_SimpleService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_SimpleService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    async def get_five(
            SimpleService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).get_five(
            ),
            SimpleService_get_five_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def add_five(
            SimpleService self,
            int num):
        if num is None:
            raise TypeError('num can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).add_five(
                num,
            ),
            SimpleService_add_five_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def do_nothing(
            SimpleService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_SimpleService_client).do_nothing(
            ),
            SimpleService_do_nothing_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def concat(
            SimpleService self,
            str first,
            str second):
        if first is None:
            raise TypeError('first can not be None')
        if second is None:
            raise TypeError('second can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).concat(
                first.encode('UTF-8'),
                second.encode('UTF-8'),
            ),
            SimpleService_concat_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def get_value(
            SimpleService self,
            module.types.SimpleStruct simple_struct):
        if simple_struct is None:
            raise TypeError('simple_struct can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).get_value(
                deref((<module.types.SimpleStruct>simple_struct)._cpp_obj),
            ),
            SimpleService_get_value_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def negate(
            SimpleService self,
            pbool input):
        if input is None:
            raise TypeError('input can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_SimpleService_client).negate(
                input,
            ),
            SimpleService_negate_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def tiny(
            SimpleService self,
            int input):
        if input is None:
            raise TypeError('input can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int8_t](
            self._executor,
            deref(self._module_SimpleService_client).tiny(
                input,
            ),
            SimpleService_tiny_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def small(
            SimpleService self,
            int input):
        if input is None:
            raise TypeError('input can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int16_t](
            self._executor,
            deref(self._module_SimpleService_client).small(
                input,
            ),
            SimpleService_small_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def big(
            SimpleService self,
            int input):
        if input is None:
            raise TypeError('input can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_SimpleService_client).big(
                input,
            ),
            SimpleService_big_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def two(
            SimpleService self,
            float input):
        if input is None:
            raise TypeError('input can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_SimpleService_client).two(
                input,
            ),
            SimpleService_two_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def expected_exception(
            SimpleService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_SimpleService_client).expected_exception(
            ),
            SimpleService_expected_exception_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def unexpected_exception(
            SimpleService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).unexpected_exception(
            ),
            SimpleService_unexpected_exception_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def sum_i16_list(
            SimpleService self,
            numbers):
        if numbers is None:
            raise TypeError('numbers can not be None')
        if not isinstance(numbers, module.types.List__i16):
            numbers = module.types.List__i16(numbers)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).sum_i16_list(
                vector[int16_t](deref(module.types.List__i16(numbers)._cpp_obj.get())),
            ),
            SimpleService_sum_i16_list_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def sum_i32_list(
            SimpleService self,
            numbers):
        if numbers is None:
            raise TypeError('numbers can not be None')
        if not isinstance(numbers, module.types.List__i32):
            numbers = module.types.List__i32(numbers)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).sum_i32_list(
                vector[int32_t](deref(module.types.List__i32(numbers)._cpp_obj.get())),
            ),
            SimpleService_sum_i32_list_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def sum_i64_list(
            SimpleService self,
            numbers):
        if numbers is None:
            raise TypeError('numbers can not be None')
        if not isinstance(numbers, module.types.List__i64):
            numbers = module.types.List__i64(numbers)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).sum_i64_list(
                vector[int64_t](deref(module.types.List__i64(numbers)._cpp_obj.get())),
            ),
            SimpleService_sum_i64_list_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def concat_many(
            SimpleService self,
            words):
        if words is None:
            raise TypeError('words can not be None')
        if not isinstance(words, module.types.List__string):
            words = module.types.List__string(words)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).concat_many(
                vector[string](deref(module.types.List__string(words)._cpp_obj.get())),
            ),
            SimpleService_concat_many_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def count_structs(
            SimpleService self,
            items):
        if items is None:
            raise TypeError('items can not be None')
        if not isinstance(items, module.types.List__SimpleStruct):
            items = module.types.List__SimpleStruct(items)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).count_structs(
                vector[module.types.cSimpleStruct](deref(module.types.List__SimpleStruct(items)._cpp_obj.get())),
            ),
            SimpleService_count_structs_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def sum_set(
            SimpleService self,
            numbers):
        if numbers is None:
            raise TypeError('numbers can not be None')
        if not isinstance(numbers, module.types.Set__i32):
            numbers = module.types.Set__i32(numbers)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).sum_set(
                cset[int32_t](deref(module.types.Set__i32(numbers)._cpp_obj.get())),
            ),
            SimpleService_sum_set_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def contains_word(
            SimpleService self,
            words,
            str word):
        if words is None:
            raise TypeError('words can not be None')
        if not isinstance(words, module.types.Set__string):
            words = module.types.Set__string(words)
        if word is None:
            raise TypeError('word can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_SimpleService_client).contains_word(
                cset[string](deref(module.types.Set__string(words)._cpp_obj.get())),
                word.encode('UTF-8'),
            ),
            SimpleService_contains_word_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def get_map_value(
            SimpleService self,
            words,
            str key):
        if words is None:
            raise TypeError('words can not be None')
        if not isinstance(words, module.types.Map__string_string):
            words = module.types.Map__string_string(words)
        if key is None:
            raise TypeError('key can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).get_map_value(
                cmap[string,string](deref(module.types.Map__string_string(words)._cpp_obj.get())),
                key.encode('UTF-8'),
            ),
            SimpleService_get_map_value_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def map_length(
            SimpleService self,
            items):
        if items is None:
            raise TypeError('items can not be None')
        if not isinstance(items, module.types.Map__string_SimpleStruct):
            items = module.types.Map__string_SimpleStruct(items)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int16_t](
            self._executor,
            deref(self._module_SimpleService_client).map_length(
                cmap[string,module.types.cSimpleStruct](deref(module.types.Map__string_SimpleStruct(items)._cpp_obj.get())),
            ),
            SimpleService_map_length_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def sum_map_values(
            SimpleService self,
            items):
        if items is None:
            raise TypeError('items can not be None')
        if not isinstance(items, module.types.Map__string_i16):
            items = module.types.Map__string_i16(items)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int16_t](
            self._executor,
            deref(self._module_SimpleService_client).sum_map_values(
                cmap[string,int16_t](deref(module.types.Map__string_i16(items)._cpp_obj.get())),
            ),
            SimpleService_sum_map_values_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def complex_sum_i32(
            SimpleService self,
            module.types.ComplexStruct counter):
        if counter is None:
            raise TypeError('counter can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).complex_sum_i32(
                deref((<module.types.ComplexStruct>counter)._cpp_obj),
            ),
            SimpleService_complex_sum_i32_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def repeat_name(
            SimpleService self,
            module.types.ComplexStruct counter):
        if counter is None:
            raise TypeError('counter can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).repeat_name(
                deref((<module.types.ComplexStruct>counter)._cpp_obj),
            ),
            SimpleService_repeat_name_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def get_struct(
            SimpleService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cSimpleStruct](
            self._executor,
            deref(self._module_SimpleService_client).get_struct(
            ),
            SimpleService_get_struct_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def fib(
            SimpleService self,
            int n):
        if n is None:
            raise TypeError('n can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[int32_t]](
            self._executor,
            deref(self._module_SimpleService_client).fib(
                n,
            ),
            SimpleService_fib_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def unique_words(
            SimpleService self,
            words):
        if words is None:
            raise TypeError('words can not be None')
        if not isinstance(words, module.types.List__string):
            words = module.types.List__string(words)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[string]](
            self._executor,
            deref(self._module_SimpleService_client).unique_words(
                vector[string](deref(module.types.List__string(words)._cpp_obj.get())),
            ),
            SimpleService_unique_words_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def words_count(
            SimpleService self,
            words):
        if words is None:
            raise TypeError('words can not be None')
        if not isinstance(words, module.types.List__string):
            words = module.types.List__string(words)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cmap[string,int16_t]](
            self._executor,
            deref(self._module_SimpleService_client).words_count(
                vector[string](deref(module.types.List__string(words)._cpp_obj.get())),
            ),
            SimpleService_words_count_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def set_enum(
            SimpleService self,
            in_enum):
        if in_enum is None:
            raise TypeError('in_enum can not be None')
        if not isinstance(in_enum, module.types.AnEnum):
            raise ValueError('in_enum is not of the enum type { module.types.AnEnum }.')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cAnEnum](
            self._executor,
            deref(self._module_SimpleService_client).set_enum(
                module.types.AnEnum_to_cpp(in_enum),
            ),
            SimpleService_set_enum_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_of_lists(
            SimpleService self,
            int num_lists,
            int num_items):
        if num_lists is None:
            raise TypeError('num_lists can not be None')
        if num_items is None:
            raise TypeError('num_items can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[vector[int32_t]]](
            self._executor,
            deref(self._module_SimpleService_client).list_of_lists(
                num_lists,
                num_items,
            ),
            SimpleService_list_of_lists_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def word_character_frequency(
            SimpleService self,
            str sentence):
        if sentence is None:
            raise TypeError('sentence can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cmap[string,cmap[string,int32_t]]](
            self._executor,
            deref(self._module_SimpleService_client).word_character_frequency(
                sentence.encode('UTF-8'),
            ),
            SimpleService_word_character_frequency_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_of_sets(
            SimpleService self,
            str some_words):
        if some_words is None:
            raise TypeError('some_words can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[cset[string]]](
            self._executor,
            deref(self._module_SimpleService_client).list_of_sets(
                some_words.encode('UTF-8'),
            ),
            SimpleService_list_of_sets_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def nested_map_argument(
            SimpleService self,
            struct_map):
        if struct_map is None:
            raise TypeError('struct_map can not be None')
        if not isinstance(struct_map, module.types.Map__string_List__SimpleStruct):
            struct_map = module.types.Map__string_List__SimpleStruct(struct_map)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_SimpleService_client).nested_map_argument(
                cmap[string,vector[module.types.cSimpleStruct]](deref(module.types.Map__string_List__SimpleStruct(struct_map)._cpp_obj.get())),
            ),
            SimpleService_nested_map_argument_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def make_sentence(
            SimpleService self,
            word_chars):
        if word_chars is None:
            raise TypeError('word_chars can not be None')
        if not isinstance(word_chars, module.types.List__List__string):
            word_chars = module.types.List__List__string(word_chars)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).make_sentence(
                vector[vector[string]](deref(module.types.List__List__string(word_chars)._cpp_obj.get())),
            ),
            SimpleService_make_sentence_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def get_union(
            SimpleService self,
            sets):
        if sets is None:
            raise TypeError('sets can not be None')
        if not isinstance(sets, module.types.List__Set__i32):
            sets = module.types.List__Set__i32(sets)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[int32_t]](
            self._executor,
            deref(self._module_SimpleService_client).get_union(
                vector[cset[int32_t]](deref(module.types.List__Set__i32(sets)._cpp_obj.get())),
            ),
            SimpleService_get_union_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def get_keys(
            SimpleService self,
            string_map):
        if string_map is None:
            raise TypeError('string_map can not be None')
        if not isinstance(string_map, module.types.List__Map__string_string):
            string_map = module.types.List__Map__string_string(string_map)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[string]](
            self._executor,
            deref(self._module_SimpleService_client).get_keys(
                vector[cmap[string,string]](deref(module.types.List__Map__string_string(string_map)._cpp_obj.get())),
            ),
            SimpleService_get_keys_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def lookup_double(
            SimpleService self,
            int key):
        if key is None:
            raise TypeError('key can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_SimpleService_client).lookup_double(
                key,
            ),
            SimpleService_lookup_double_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def retrieve_binary(
            SimpleService self,
            bytes something):
        if something is None:
            raise TypeError('something can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_SimpleService_client).retrieve_binary(
                something,
            ),
            SimpleService_retrieve_binary_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def contain_binary(
            SimpleService self,
            binaries):
        if binaries is None:
            raise TypeError('binaries can not be None')
        if not isinstance(binaries, module.types.List__binary):
            binaries = module.types.List__binary(binaries)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[string]](
            self._executor,
            deref(self._module_SimpleService_client).contain_binary(
                vector[string](deref(module.types.List__binary(binaries)._cpp_obj.get())),
            ),
            SimpleService_contain_binary_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def contain_enum(
            SimpleService self,
            the_enum):
        if the_enum is None:
            raise TypeError('the_enum can not be None')
        if not isinstance(the_enum, module.types.List__AnEnum):
            the_enum = module.types.List__AnEnum(the_enum)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[module.types.cAnEnum]](
            self._executor,
            deref(self._module_SimpleService_client).contain_enum(
                vector[module.types.cAnEnum](deref(module.types.List__AnEnum(the_enum)._cpp_obj.get())),
            ),
            SimpleService_contain_enum_callback,
            <PyObject *> __future
        )
        return await __future



cdef void closed_SimpleService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
cdef class DerivedService(SimpleService):

    def __cinit__(DerivedService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(DerivedService self):
        return &typeid(cDerivedServiceAsyncClient)

    @staticmethod
    cdef _module_DerivedService_set_client(DerivedService inst, shared_ptr[cDerivedServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_DerivedService_client = c_obj
        SimpleService._module_SimpleService_set_client(inst, <shared_ptr[cSimpleServiceClientWrapper]>c_obj)

    cdef _module_DerivedService_reset_client(DerivedService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_DerivedService_client.reset()
        SimpleService._module_SimpleService_reset_client(self)

    def __dealloc__(DerivedService self):
        if self._cRequestChannel or self._module_DerivedService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(DerivedService self):
        await self._connect_future
        if self._cRequestChannel:
            DerivedService._module_DerivedService_set_client(
                self,
                makeClientWrapper[cDerivedServiceAsyncClient, cDerivedServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(DerivedService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_DerivedService_client).disconnect(),
            closed_DerivedService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_DerivedService_reset_client()

    def set_persistent_header(DerivedService self, str key, str value):
        if not self._module_DerivedService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_DerivedService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    async def get_six(
            DerivedService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_DerivedService_client).get_six(
            ),
            DerivedService_get_six_callback,
            <PyObject *> __future
        )
        return await __future



cdef void closed_DerivedService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
cdef class RederivedService(DerivedService):

    def __cinit__(RederivedService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(RederivedService self):
        return &typeid(cRederivedServiceAsyncClient)

    @staticmethod
    cdef _module_RederivedService_set_client(RederivedService inst, shared_ptr[cRederivedServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_RederivedService_client = c_obj
        DerivedService._module_DerivedService_set_client(inst, <shared_ptr[cDerivedServiceClientWrapper]>c_obj)

    cdef _module_RederivedService_reset_client(RederivedService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_RederivedService_client.reset()
        DerivedService._module_DerivedService_reset_client(self)

    def __dealloc__(RederivedService self):
        if self._cRequestChannel or self._module_RederivedService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(RederivedService self):
        await self._connect_future
        if self._cRequestChannel:
            RederivedService._module_RederivedService_set_client(
                self,
                makeClientWrapper[cRederivedServiceAsyncClient, cRederivedServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(RederivedService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_RederivedService_client).disconnect(),
            closed_RederivedService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_RederivedService_reset_client()

    def set_persistent_header(RederivedService self, str key, str value):
        if not self._module_RederivedService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_RederivedService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    async def get_seven(
            RederivedService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_RederivedService_client).get_seven(
            ),
            RederivedService_get_seven_callback,
            <PyObject *> __future
        )
        return await __future



cdef void closed_RederivedService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
