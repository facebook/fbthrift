#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

cimport cython
from typing import AsyncIterator
from cpython.version cimport PY_VERSION_HEX
from libc.stdint cimport (
    int8_t as cint8_t,
    int16_t as cint16_t,
    int32_t as cint32_t,
    int64_t as cint64_t,
)
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from libcpp.utility cimport move as cmove
from libcpp.pair cimport pair
from cython.operator cimport dereference as deref
from cpython.ref cimport PyObject
from thrift.py3.exceptions cimport (
    cTApplicationException,
    ApplicationError as __ApplicationError,
    cTApplicationExceptionType__UNKNOWN)
from thrift.py3.server cimport ServiceInterface, RequestContext, Cpp2RequestContext
from thrift.py3.server import RequestContext, pass_context
from folly cimport (
  cFollyPromise,
  cFollyUnit,
  c_unit,
)
from thrift.py3.common cimport (
    cThriftServiceContext as __fbthrift_cThriftServiceContext,
    cThriftMetadata as __fbthrift_cThriftMetadata,
    ServiceMetadata,
    extractMetadataFromServiceContext,
    MetadataBox as __MetadataBox,
)

if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
    from thrift.py3.server cimport THRIFT_REQUEST_CONTEXT as __THRIFT_REQUEST_CONTEXT

cimport folly.futures
from folly.executor cimport get_executor
cimport folly.iobuf as _fbthrift_iobuf
import folly.iobuf as _fbthrift_iobuf
from folly.iobuf cimport move as move_iobuf
from folly.memory cimport to_shared_ptr as __to_shared_ptr

cimport module.types as _module_types
import module.types as _module_types

cimport module.services_reflection as _services_reflection

import asyncio
import functools
import sys
import traceback
import types as _py_types

from module.services_wrapper cimport cSimpleServiceInterface
from module.services_wrapper cimport cDerivedServiceInterface
from module.services_wrapper cimport cRederivedServiceInterface



@cython.auto_pickle(False)
cdef class Promise__module_types_cAnEnum:
    cdef cFollyPromise[_module_types.cAnEnum] cPromise

    @staticmethod
    cdef create(cFollyPromise[_module_types.cAnEnum] cPromise):
        cdef Promise__module_types_cAnEnum inst = Promise__module_types_cAnEnum.__new__(Promise__module_types_cAnEnum)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise__module_types_cBinaryUnionStruct:
    cdef cFollyPromise[unique_ptr[_module_types.cBinaryUnionStruct]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[_module_types.cBinaryUnionStruct]] cPromise):
        cdef Promise__module_types_cBinaryUnionStruct inst = Promise__module_types_cBinaryUnionStruct.__new__(Promise__module_types_cBinaryUnionStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector___module_types_cAnEnum:
    cdef cFollyPromise[unique_ptr[vector[_module_types.cAnEnum]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[_module_types.cAnEnum]]] cPromise):
        cdef Promise_vector___module_types_cAnEnum inst = Promise_vector___module_types_cAnEnum.__new__(Promise_vector___module_types_cAnEnum)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__vector__cint32_t:
    cdef cFollyPromise[unique_ptr[vector[vector[cint32_t]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[vector[cint32_t]]]] cPromise):
        cdef Promise_vector__vector__cint32_t inst = Promise_vector__vector__cint32_t.__new__(Promise_vector__vector__cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__cset__string:
    cdef cFollyPromise[unique_ptr[vector[cset[string]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[cset[string]]]] cPromise):
        cdef Promise_vector__cset__string inst = Promise_vector__cset__string.__new__(Promise_vector__cset__string)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__cint32_t:
    cdef cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise):
        cdef Promise_vector__cint32_t inst = Promise_vector__cint32_t.__new__(Promise_vector__cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cmap__string_cmap__string_cint32_t:
    cdef cFollyPromise[unique_ptr[cmap[string,cmap[string,cint32_t]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cmap[string,cmap[string,cint32_t]]]] cPromise):
        cdef Promise_cmap__string_cmap__string_cint32_t inst = Promise_cmap__string_cmap__string_cint32_t.__new__(Promise_cmap__string_cmap__string_cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cmap__string_cint16_t:
    cdef cFollyPromise[unique_ptr[cmap[string,cint16_t]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cmap[string,cint16_t]]] cPromise):
        cdef Promise_cmap__string_cint16_t inst = Promise_cmap__string_cint16_t.__new__(Promise_cmap__string_cint16_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cset__binary:
    cdef cFollyPromise[unique_ptr[cset[string]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cset[string]]] cPromise):
        cdef Promise_cset__binary inst = Promise_cset__binary.__new__(Promise_cset__binary)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cset__cint32_t:
    cdef cFollyPromise[unique_ptr[cset[cint32_t]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cset[cint32_t]]] cPromise):
        cdef Promise_cset__cint32_t inst = Promise_cset__cint32_t.__new__(Promise_cset__cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cset__string:
    cdef cFollyPromise[unique_ptr[cset[string]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cset[string]]] cPromise):
        cdef Promise_cset__string inst = Promise_cset__string.__new__(Promise_cset__string)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise__module_types_cSimpleStruct:
    cdef cFollyPromise[unique_ptr[_module_types.cSimpleStruct]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[_module_types.cSimpleStruct]] cPromise):
        cdef Promise__module_types_cSimpleStruct inst = Promise__module_types_cSimpleStruct.__new__(Promise__module_types_cSimpleStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_binary:
    cdef cFollyPromise[unique_ptr[string]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[string]] cPromise):
        cdef Promise_binary inst = Promise_binary.__new__(Promise_binary)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cbool:
    cdef cFollyPromise[cbool] cPromise

    @staticmethod
    cdef create(cFollyPromise[cbool] cPromise):
        cdef Promise_cbool inst = Promise_cbool.__new__(Promise_cbool)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint8_t:
    cdef cFollyPromise[cint8_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint8_t] cPromise):
        cdef Promise_cint8_t inst = Promise_cint8_t.__new__(Promise_cint8_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_double:
    cdef cFollyPromise[double] cPromise

    @staticmethod
    cdef create(cFollyPromise[double] cPromise):
        cdef Promise_double inst = Promise_double.__new__(Promise_double)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint16_t:
    cdef cFollyPromise[cint16_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint16_t] cPromise):
        cdef Promise_cint16_t inst = Promise_cint16_t.__new__(Promise_cint16_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint32_t:
    cdef cFollyPromise[cint32_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint32_t] cPromise):
        cdef Promise_cint32_t inst = Promise_cint32_t.__new__(Promise_cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint64_t:
    cdef cFollyPromise[cint64_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint64_t] cPromise):
        cdef Promise_cint64_t inst = Promise_cint64_t.__new__(Promise_cint64_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_string:
    cdef cFollyPromise[unique_ptr[string]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[string]] cPromise):
        cdef Promise_string inst = Promise_string.__new__(Promise_string)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cFollyUnit:
    cdef cFollyPromise[cFollyUnit] cPromise

    @staticmethod
    cdef create(cFollyPromise[cFollyUnit] cPromise):
        cdef Promise_cFollyUnit inst = Promise_cFollyUnit.__new__(Promise_cFollyUnit)
        inst.cPromise = cmove(cPromise)
        return inst

cdef object _SimpleService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class SimpleServiceInterface(
    ServiceInterface
):
    annotations = _SimpleService_annotations

    def __cinit__(self):
        self._cpp_obj = cSimpleServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @staticmethod
    def pass_context_get_five(fn):
        return pass_context(fn)

    async def get_five(
            self):
        raise NotImplementedError("async def get_five is not implemented")

    @staticmethod
    def pass_context_add_five(fn):
        return pass_context(fn)

    async def add_five(
            self,
            num):
        raise NotImplementedError("async def add_five is not implemented")

    @staticmethod
    def pass_context_do_nothing(fn):
        return pass_context(fn)

    async def do_nothing(
            self):
        raise NotImplementedError("async def do_nothing is not implemented")

    @staticmethod
    def pass_context_concat(fn):
        return pass_context(fn)

    async def concat(
            self,
            first,
            second):
        raise NotImplementedError("async def concat is not implemented")

    @staticmethod
    def pass_context_get_value(fn):
        return pass_context(fn)

    async def get_value(
            self,
            simple_struct):
        raise NotImplementedError("async def get_value is not implemented")

    @staticmethod
    def pass_context_negate(fn):
        return pass_context(fn)

    async def negate(
            self,
            input):
        raise NotImplementedError("async def negate is not implemented")

    @staticmethod
    def pass_context_tiny(fn):
        return pass_context(fn)

    async def tiny(
            self,
            input):
        raise NotImplementedError("async def tiny is not implemented")

    @staticmethod
    def pass_context_small(fn):
        return pass_context(fn)

    async def small(
            self,
            input):
        raise NotImplementedError("async def small is not implemented")

    @staticmethod
    def pass_context_big(fn):
        return pass_context(fn)

    async def big(
            self,
            input):
        raise NotImplementedError("async def big is not implemented")

    @staticmethod
    def pass_context_two(fn):
        return pass_context(fn)

    async def two(
            self,
            input):
        raise NotImplementedError("async def two is not implemented")

    @staticmethod
    def pass_context_expected_exception(fn):
        return pass_context(fn)

    async def expected_exception(
            self):
        raise NotImplementedError("async def expected_exception is not implemented")

    @staticmethod
    def pass_context_unexpected_exception(fn):
        return pass_context(fn)

    async def unexpected_exception(
            self):
        raise NotImplementedError("async def unexpected_exception is not implemented")

    @staticmethod
    def pass_context_sum_i16_list(fn):
        return pass_context(fn)

    async def sum_i16_list(
            self,
            numbers):
        raise NotImplementedError("async def sum_i16_list is not implemented")

    @staticmethod
    def pass_context_sum_i32_list(fn):
        return pass_context(fn)

    async def sum_i32_list(
            self,
            numbers):
        raise NotImplementedError("async def sum_i32_list is not implemented")

    @staticmethod
    def pass_context_sum_i64_list(fn):
        return pass_context(fn)

    async def sum_i64_list(
            self,
            numbers):
        raise NotImplementedError("async def sum_i64_list is not implemented")

    @staticmethod
    def pass_context_concat_many(fn):
        return pass_context(fn)

    async def concat_many(
            self,
            words):
        raise NotImplementedError("async def concat_many is not implemented")

    @staticmethod
    def pass_context_count_structs(fn):
        return pass_context(fn)

    async def count_structs(
            self,
            items):
        raise NotImplementedError("async def count_structs is not implemented")

    @staticmethod
    def pass_context_sum_set(fn):
        return pass_context(fn)

    async def sum_set(
            self,
            numbers):
        raise NotImplementedError("async def sum_set is not implemented")

    @staticmethod
    def pass_context_contains_word(fn):
        return pass_context(fn)

    async def contains_word(
            self,
            words,
            word):
        raise NotImplementedError("async def contains_word is not implemented")

    @staticmethod
    def pass_context_get_map_value(fn):
        return pass_context(fn)

    async def get_map_value(
            self,
            words,
            key):
        raise NotImplementedError("async def get_map_value is not implemented")

    @staticmethod
    def pass_context_map_length(fn):
        return pass_context(fn)

    async def map_length(
            self,
            items):
        raise NotImplementedError("async def map_length is not implemented")

    @staticmethod
    def pass_context_sum_map_values(fn):
        return pass_context(fn)

    async def sum_map_values(
            self,
            items):
        raise NotImplementedError("async def sum_map_values is not implemented")

    @staticmethod
    def pass_context_complex_sum_i32(fn):
        return pass_context(fn)

    async def complex_sum_i32(
            self,
            counter):
        raise NotImplementedError("async def complex_sum_i32 is not implemented")

    @staticmethod
    def pass_context_repeat_name(fn):
        return pass_context(fn)

    async def repeat_name(
            self,
            counter):
        raise NotImplementedError("async def repeat_name is not implemented")

    @staticmethod
    def pass_context_get_struct(fn):
        return pass_context(fn)

    async def get_struct(
            self):
        raise NotImplementedError("async def get_struct is not implemented")

    @staticmethod
    def pass_context_fib(fn):
        return pass_context(fn)

    async def fib(
            self,
            n):
        raise NotImplementedError("async def fib is not implemented")

    @staticmethod
    def pass_context_unique_words(fn):
        return pass_context(fn)

    async def unique_words(
            self,
            words):
        raise NotImplementedError("async def unique_words is not implemented")

    @staticmethod
    def pass_context_words_count(fn):
        return pass_context(fn)

    async def words_count(
            self,
            words):
        raise NotImplementedError("async def words_count is not implemented")

    @staticmethod
    def pass_context_set_enum(fn):
        return pass_context(fn)

    async def set_enum(
            self,
            in_enum):
        raise NotImplementedError("async def set_enum is not implemented")

    @staticmethod
    def pass_context_list_of_lists(fn):
        return pass_context(fn)

    async def list_of_lists(
            self,
            num_lists,
            num_items):
        raise NotImplementedError("async def list_of_lists is not implemented")

    @staticmethod
    def pass_context_word_character_frequency(fn):
        return pass_context(fn)

    async def word_character_frequency(
            self,
            sentence):
        raise NotImplementedError("async def word_character_frequency is not implemented")

    @staticmethod
    def pass_context_list_of_sets(fn):
        return pass_context(fn)

    async def list_of_sets(
            self,
            some_words):
        raise NotImplementedError("async def list_of_sets is not implemented")

    @staticmethod
    def pass_context_nested_map_argument(fn):
        return pass_context(fn)

    async def nested_map_argument(
            self,
            struct_map):
        raise NotImplementedError("async def nested_map_argument is not implemented")

    @staticmethod
    def pass_context_make_sentence(fn):
        return pass_context(fn)

    async def make_sentence(
            self,
            word_chars):
        raise NotImplementedError("async def make_sentence is not implemented")

    @staticmethod
    def pass_context_get_union(fn):
        return pass_context(fn)

    async def get_union(
            self,
            sets):
        raise NotImplementedError("async def get_union is not implemented")

    @staticmethod
    def pass_context_get_keys(fn):
        return pass_context(fn)

    async def get_keys(
            self,
            string_map):
        raise NotImplementedError("async def get_keys is not implemented")

    @staticmethod
    def pass_context_lookup_double(fn):
        return pass_context(fn)

    async def lookup_double(
            self,
            key):
        raise NotImplementedError("async def lookup_double is not implemented")

    @staticmethod
    def pass_context_retrieve_binary(fn):
        return pass_context(fn)

    async def retrieve_binary(
            self,
            something):
        raise NotImplementedError("async def retrieve_binary is not implemented")

    @staticmethod
    def pass_context_contain_binary(fn):
        return pass_context(fn)

    async def contain_binary(
            self,
            binaries):
        raise NotImplementedError("async def contain_binary is not implemented")

    @staticmethod
    def pass_context_contain_enum(fn):
        return pass_context(fn)

    async def contain_enum(
            self,
            the_enum):
        raise NotImplementedError("async def contain_enum is not implemented")

    @staticmethod
    def pass_context_get_binary_union_struct(fn):
        return pass_context(fn)

    async def get_binary_union_struct(
            self,
            u):
        raise NotImplementedError("async def get_binary_union_struct is not implemented")

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__SimpleService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cSimpleServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.SimpleService"

cdef object _DerivedService_annotations = _py_types.MappingProxyType({
    """bar""": """1""",    """foo""": """\"\"\"""",
})


@cython.auto_pickle(False)
cdef class DerivedServiceInterface(
SimpleServiceInterface
):
    annotations = _DerivedService_annotations

    def __cinit__(self):
        self._cpp_obj = cDerivedServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @staticmethod
    def pass_context_get_six(fn):
        return pass_context(fn)

    async def get_six(
            self):
        raise NotImplementedError("async def get_six is not implemented")

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__DerivedService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cDerivedServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.DerivedService"

cdef object _RederivedService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class RederivedServiceInterface(
DerivedServiceInterface
):
    annotations = _RederivedService_annotations

    def __cinit__(self):
        self._cpp_obj = cRederivedServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @staticmethod
    def pass_context_get_seven(fn):
        return pass_context(fn)

    async def get_seven(
            self):
        raise NotImplementedError("async def get_seven is not implemented")

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__RederivedService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cRederivedServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.RederivedService"



cdef api void call_cy_SimpleService_get_five(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_five_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_five_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.get_five, "pass_context", False):
            result = await self.get_five(ctx,)
        else:
            result = await self.get_five()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_five:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_add_five(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    cint32_t num
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_num = num
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_add_five_coro(
            self,
            __context,
            __promise,
            arg_num
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_add_five_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    num
):
    try:
        if ctx and getattr(self.add_five, "pass_context", False):
            result = await self.add_five(ctx,
                      num)
        else:
            result = await self.add_five(
                      num)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler add_five:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_do_nothing(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_do_nothing_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_do_nothing_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise
):
    try:
        if ctx and getattr(self.do_nothing, "pass_context", False):
            result = await self.do_nothing(ctx,)
        else:
            result = await self.do_nothing()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler do_nothing:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_SimpleService_concat(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[string] first,
    unique_ptr[string] second
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_first = (deref(first)).data().decode('UTF-8')
    arg_second = (deref(second)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_concat_coro(
            self,
            __context,
            __promise,
            arg_first,
            arg_second
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_concat_coro(
    object self,
    object ctx,
    Promise_string promise,
    first,
    second
):
    try:
        if ctx and getattr(self.concat, "pass_context", False):
            result = await self.concat(ctx,
                      first,
                      second)
        else:
            result = await self.concat(
                      first,
                      second)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler concat:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_SimpleService_get_value(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[_module_types.cSimpleStruct] simple_struct
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_simple_struct = _module_types.SimpleStruct.create(shared_ptr[_module_types.cSimpleStruct](simple_struct.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_value_coro(
            self,
            __context,
            __promise,
            arg_simple_struct
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_value_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    simple_struct
):
    try:
        if ctx and getattr(self.get_value, "pass_context", False):
            result = await self.get_value(ctx,
                      simple_struct)
        else:
            result = await self.get_value(
                      simple_struct)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_value:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_negate(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise,
    cbool input
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    arg_input = input
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_negate_coro(
            self,
            __context,
            __promise,
            arg_input
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_negate_coro(
    object self,
    object ctx,
    Promise_cbool promise,
    input
):
    try:
        if ctx and getattr(self.negate, "pass_context", False):
            result = await self.negate(ctx,
                      input)
        else:
            result = await self.negate(
                      input)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler negate:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_SimpleService_tiny(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint8_t] cPromise,
    cint8_t input
):
    cdef Promise_cint8_t __promise = Promise_cint8_t.create(cmove(cPromise))
    arg_input = input
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_tiny_coro(
            self,
            __context,
            __promise,
            arg_input
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_tiny_coro(
    object self,
    object ctx,
    Promise_cint8_t promise,
    input
):
    try:
        if ctx and getattr(self.tiny, "pass_context", False):
            result = await self.tiny(ctx,
                      input)
        else:
            result = await self.tiny(
                      input)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler tiny:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint8_t> result)

cdef api void call_cy_SimpleService_small(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint16_t] cPromise,
    cint16_t input
):
    cdef Promise_cint16_t __promise = Promise_cint16_t.create(cmove(cPromise))
    arg_input = input
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_small_coro(
            self,
            __context,
            __promise,
            arg_input
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_small_coro(
    object self,
    object ctx,
    Promise_cint16_t promise,
    input
):
    try:
        if ctx and getattr(self.small, "pass_context", False):
            result = await self.small(ctx,
                      input)
        else:
            result = await self.small(
                      input)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler small:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint16_t> result)

cdef api void call_cy_SimpleService_big(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint64_t] cPromise,
    cint64_t input
):
    cdef Promise_cint64_t __promise = Promise_cint64_t.create(cmove(cPromise))
    arg_input = input
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_big_coro(
            self,
            __context,
            __promise,
            arg_input
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_big_coro(
    object self,
    object ctx,
    Promise_cint64_t promise,
    input
):
    try:
        if ctx and getattr(self.big, "pass_context", False):
            result = await self.big(ctx,
                      input)
        else:
            result = await self.big(
                      input)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler big:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint64_t> result)

cdef api void call_cy_SimpleService_two(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[double] cPromise,
    double input
):
    cdef Promise_double __promise = Promise_double.create(cmove(cPromise))
    arg_input = input
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_two_coro(
            self,
            __context,
            __promise,
            arg_input
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_two_coro(
    object self,
    object ctx,
    Promise_double promise,
    input
):
    try:
        if ctx and getattr(self.two, "pass_context", False):
            result = await self.two(ctx,
                      input)
        else:
            result = await self.two(
                      input)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler two:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<double> result)

cdef api void call_cy_SimpleService_expected_exception(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_expected_exception_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_expected_exception_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise
):
    try:
        if ctx and getattr(self.expected_exception, "pass_context", False):
            result = await self.expected_exception(ctx,)
        else:
            result = await self.expected_exception()
    except _module_types.SimpleException as ex:
        promise.cPromise.setException(deref((<_module_types.SimpleException> ex)._cpp_obj))
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler expected_exception:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_SimpleService_unexpected_exception(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_unexpected_exception_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_unexpected_exception_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.unexpected_exception, "pass_context", False):
            result = await self.unexpected_exception(ctx,)
        else:
            result = await self.unexpected_exception()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler unexpected_exception:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_sum_i16_list(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[vector[cint16_t]] numbers
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_numbers = _module_types.List__i16.create(__to_shared_ptr(cmove(numbers)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_sum_i16_list_coro(
            self,
            __context,
            __promise,
            arg_numbers
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_sum_i16_list_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    numbers
):
    try:
        if ctx and getattr(self.sum_i16_list, "pass_context", False):
            result = await self.sum_i16_list(ctx,
                      numbers)
        else:
            result = await self.sum_i16_list(
                      numbers)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler sum_i16_list:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_sum_i32_list(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[vector[cint32_t]] numbers
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_numbers = _module_types.List__i32.create(__to_shared_ptr(cmove(numbers)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_sum_i32_list_coro(
            self,
            __context,
            __promise,
            arg_numbers
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_sum_i32_list_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    numbers
):
    try:
        if ctx and getattr(self.sum_i32_list, "pass_context", False):
            result = await self.sum_i32_list(ctx,
                      numbers)
        else:
            result = await self.sum_i32_list(
                      numbers)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler sum_i32_list:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_sum_i64_list(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[vector[cint64_t]] numbers
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_numbers = _module_types.List__i64.create(__to_shared_ptr(cmove(numbers)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_sum_i64_list_coro(
            self,
            __context,
            __promise,
            arg_numbers
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_sum_i64_list_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    numbers
):
    try:
        if ctx and getattr(self.sum_i64_list, "pass_context", False):
            result = await self.sum_i64_list(ctx,
                      numbers)
        else:
            result = await self.sum_i64_list(
                      numbers)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler sum_i64_list:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_concat_many(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[vector[string]] words
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_words = _module_types.List__string.create(__to_shared_ptr(cmove(words)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_concat_many_coro(
            self,
            __context,
            __promise,
            arg_words
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_concat_many_coro(
    object self,
    object ctx,
    Promise_string promise,
    words
):
    try:
        if ctx and getattr(self.concat_many, "pass_context", False):
            result = await self.concat_many(ctx,
                      words)
        else:
            result = await self.concat_many(
                      words)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler concat_many:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_SimpleService_count_structs(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[vector[_module_types.cSimpleStruct]] items
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_items = _module_types.List__SimpleStruct.create(__to_shared_ptr(cmove(items)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_count_structs_coro(
            self,
            __context,
            __promise,
            arg_items
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_count_structs_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    items
):
    try:
        if ctx and getattr(self.count_structs, "pass_context", False):
            result = await self.count_structs(ctx,
                      items)
        else:
            result = await self.count_structs(
                      items)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler count_structs:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_sum_set(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[cset[cint32_t]] numbers
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_numbers = _module_types.Set__i32.create(__to_shared_ptr(cmove(numbers)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_sum_set_coro(
            self,
            __context,
            __promise,
            arg_numbers
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_sum_set_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    numbers
):
    try:
        if ctx and getattr(self.sum_set, "pass_context", False):
            result = await self.sum_set(ctx,
                      numbers)
        else:
            result = await self.sum_set(
                      numbers)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler sum_set:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_contains_word(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise,
    unique_ptr[cset[string]] words,
    unique_ptr[string] word
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    arg_words = _module_types.Set__string.create(__to_shared_ptr(cmove(words)))
    arg_word = (deref(word)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_contains_word_coro(
            self,
            __context,
            __promise,
            arg_words,
            arg_word
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_contains_word_coro(
    object self,
    object ctx,
    Promise_cbool promise,
    words,
    word
):
    try:
        if ctx and getattr(self.contains_word, "pass_context", False):
            result = await self.contains_word(ctx,
                      words,
                      word)
        else:
            result = await self.contains_word(
                      words,
                      word)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler contains_word:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_SimpleService_get_map_value(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[cmap[string,string]] words,
    unique_ptr[string] key
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_words = _module_types.Map__string_string.create(__to_shared_ptr(cmove(words)))
    arg_key = (deref(key)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_map_value_coro(
            self,
            __context,
            __promise,
            arg_words,
            arg_key
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_map_value_coro(
    object self,
    object ctx,
    Promise_string promise,
    words,
    key
):
    try:
        if ctx and getattr(self.get_map_value, "pass_context", False):
            result = await self.get_map_value(ctx,
                      words,
                      key)
        else:
            result = await self.get_map_value(
                      words,
                      key)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_map_value:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_SimpleService_map_length(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint16_t] cPromise,
    unique_ptr[cmap[string,_module_types.cSimpleStruct]] items
):
    cdef Promise_cint16_t __promise = Promise_cint16_t.create(cmove(cPromise))
    arg_items = _module_types.Map__string_SimpleStruct.create(__to_shared_ptr(cmove(items)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_map_length_coro(
            self,
            __context,
            __promise,
            arg_items
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_map_length_coro(
    object self,
    object ctx,
    Promise_cint16_t promise,
    items
):
    try:
        if ctx and getattr(self.map_length, "pass_context", False):
            result = await self.map_length(ctx,
                      items)
        else:
            result = await self.map_length(
                      items)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler map_length:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint16_t> result)

cdef api void call_cy_SimpleService_sum_map_values(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint16_t] cPromise,
    unique_ptr[cmap[string,cint16_t]] items
):
    cdef Promise_cint16_t __promise = Promise_cint16_t.create(cmove(cPromise))
    arg_items = _module_types.Map__string_i16.create(__to_shared_ptr(cmove(items)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_sum_map_values_coro(
            self,
            __context,
            __promise,
            arg_items
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_sum_map_values_coro(
    object self,
    object ctx,
    Promise_cint16_t promise,
    items
):
    try:
        if ctx and getattr(self.sum_map_values, "pass_context", False):
            result = await self.sum_map_values(ctx,
                      items)
        else:
            result = await self.sum_map_values(
                      items)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler sum_map_values:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint16_t> result)

cdef api void call_cy_SimpleService_complex_sum_i32(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[_module_types.cComplexStruct] counter
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_counter = _module_types.ComplexStruct.create(shared_ptr[_module_types.cComplexStruct](counter.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_complex_sum_i32_coro(
            self,
            __context,
            __promise,
            arg_counter
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_complex_sum_i32_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    counter
):
    try:
        if ctx and getattr(self.complex_sum_i32, "pass_context", False):
            result = await self.complex_sum_i32(ctx,
                      counter)
        else:
            result = await self.complex_sum_i32(
                      counter)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler complex_sum_i32:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_repeat_name(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[_module_types.cComplexStruct] counter
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_counter = _module_types.ComplexStruct.create(shared_ptr[_module_types.cComplexStruct](counter.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_repeat_name_coro(
            self,
            __context,
            __promise,
            arg_counter
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_repeat_name_coro(
    object self,
    object ctx,
    Promise_string promise,
    counter
):
    try:
        if ctx and getattr(self.repeat_name, "pass_context", False):
            result = await self.repeat_name(ctx,
                      counter)
        else:
            result = await self.repeat_name(
                      counter)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler repeat_name:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_SimpleService_get_struct(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cSimpleStruct]] cPromise
):
    cdef Promise__module_types_cSimpleStruct __promise = Promise__module_types_cSimpleStruct.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_struct_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_struct_coro(
    object self,
    object ctx,
    Promise__module_types_cSimpleStruct promise
):
    try:
        if ctx and getattr(self.get_struct, "pass_context", False):
            result = await self.get_struct(ctx,)
        else:
            result = await self.get_struct()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_struct:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cSimpleStruct](deref((<_module_types.SimpleStruct?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_fib(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise,
    cint16_t n
):
    cdef Promise_vector__cint32_t __promise = Promise_vector__cint32_t.create(cmove(cPromise))
    arg_n = n
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_fib_coro(
            self,
            __context,
            __promise,
            arg_n
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_fib_coro(
    object self,
    object ctx,
    Promise_vector__cint32_t promise,
    n
):
    try:
        if ctx and getattr(self.fib, "pass_context", False):
            result = await self.fib(ctx,
                      n)
        else:
            result = await self.fib(
                      n)
        result = _module_types.List__i32(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler fib:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[cint32_t]](deref((<_module_types.List__i32?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_unique_words(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[string]]] cPromise,
    unique_ptr[vector[string]] words
):
    cdef Promise_cset__string __promise = Promise_cset__string.create(cmove(cPromise))
    arg_words = _module_types.List__string.create(__to_shared_ptr(cmove(words)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_unique_words_coro(
            self,
            __context,
            __promise,
            arg_words
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_unique_words_coro(
    object self,
    object ctx,
    Promise_cset__string promise,
    words
):
    try:
        if ctx and getattr(self.unique_words, "pass_context", False):
            result = await self.unique_words(ctx,
                      words)
        else:
            result = await self.unique_words(
                      words)
        result = _module_types.Set__string(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler unique_words:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[string]](deref((<_module_types.Set__string?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_words_count(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cmap[string,cint16_t]]] cPromise,
    unique_ptr[vector[string]] words
):
    cdef Promise_cmap__string_cint16_t __promise = Promise_cmap__string_cint16_t.create(cmove(cPromise))
    arg_words = _module_types.List__string.create(__to_shared_ptr(cmove(words)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_words_count_coro(
            self,
            __context,
            __promise,
            arg_words
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_words_count_coro(
    object self,
    object ctx,
    Promise_cmap__string_cint16_t promise,
    words
):
    try:
        if ctx and getattr(self.words_count, "pass_context", False):
            result = await self.words_count(ctx,
                      words)
        else:
            result = await self.words_count(
                      words)
        result = _module_types.Map__string_i16(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler words_count:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cmap[string,cint16_t]](deref((<_module_types.Map__string_i16?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_set_enum(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[_module_types.cAnEnum] cPromise,
    _module_types.cAnEnum in_enum
):
    cdef Promise__module_types_cAnEnum __promise = Promise__module_types_cAnEnum.create(cmove(cPromise))
    arg_in_enum = _module_types.AnEnum(<int> in_enum)
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_set_enum_coro(
            self,
            __context,
            __promise,
            arg_in_enum
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_set_enum_coro(
    object self,
    object ctx,
    Promise__module_types_cAnEnum promise,
    in_enum
):
    try:
        if ctx and getattr(self.set_enum, "pass_context", False):
            result = await self.set_enum(ctx,
                      in_enum)
        else:
            result = await self.set_enum(
                      in_enum)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler set_enum:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<_module_types.cAnEnum><int>result)

cdef api void call_cy_SimpleService_list_of_lists(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[vector[cint32_t]]]] cPromise,
    cint16_t num_lists,
    cint16_t num_items
):
    cdef Promise_vector__vector__cint32_t __promise = Promise_vector__vector__cint32_t.create(cmove(cPromise))
    arg_num_lists = num_lists
    arg_num_items = num_items
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_list_of_lists_coro(
            self,
            __context,
            __promise,
            arg_num_lists,
            arg_num_items
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_list_of_lists_coro(
    object self,
    object ctx,
    Promise_vector__vector__cint32_t promise,
    num_lists,
    num_items
):
    try:
        if ctx and getattr(self.list_of_lists, "pass_context", False):
            result = await self.list_of_lists(ctx,
                      num_lists,
                      num_items)
        else:
            result = await self.list_of_lists(
                      num_lists,
                      num_items)
        result = _module_types.List__List__i32(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_of_lists:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[vector[cint32_t]]](deref((<_module_types.List__List__i32?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_word_character_frequency(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cmap[string,cmap[string,cint32_t]]]] cPromise,
    unique_ptr[string] sentence
):
    cdef Promise_cmap__string_cmap__string_cint32_t __promise = Promise_cmap__string_cmap__string_cint32_t.create(cmove(cPromise))
    arg_sentence = (deref(sentence)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_word_character_frequency_coro(
            self,
            __context,
            __promise,
            arg_sentence
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_word_character_frequency_coro(
    object self,
    object ctx,
    Promise_cmap__string_cmap__string_cint32_t promise,
    sentence
):
    try:
        if ctx and getattr(self.word_character_frequency, "pass_context", False):
            result = await self.word_character_frequency(ctx,
                      sentence)
        else:
            result = await self.word_character_frequency(
                      sentence)
        result = _module_types.Map__string_Map__string_i32(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler word_character_frequency:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cmap[string,cmap[string,cint32_t]]](deref((<_module_types.Map__string_Map__string_i32?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_list_of_sets(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[cset[string]]]] cPromise,
    unique_ptr[string] some_words
):
    cdef Promise_vector__cset__string __promise = Promise_vector__cset__string.create(cmove(cPromise))
    arg_some_words = (deref(some_words)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_list_of_sets_coro(
            self,
            __context,
            __promise,
            arg_some_words
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_list_of_sets_coro(
    object self,
    object ctx,
    Promise_vector__cset__string promise,
    some_words
):
    try:
        if ctx and getattr(self.list_of_sets, "pass_context", False):
            result = await self.list_of_sets(ctx,
                      some_words)
        else:
            result = await self.list_of_sets(
                      some_words)
        result = _module_types.List__Set__string(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_of_sets:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[cset[string]]](deref((<_module_types.List__Set__string?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_nested_map_argument(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    unique_ptr[cmap[string,vector[_module_types.cSimpleStruct]]] struct_map
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_struct_map = _module_types.Map__string_List__SimpleStruct.create(__to_shared_ptr(cmove(struct_map)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_nested_map_argument_coro(
            self,
            __context,
            __promise,
            arg_struct_map
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_nested_map_argument_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    struct_map
):
    try:
        if ctx and getattr(self.nested_map_argument, "pass_context", False):
            result = await self.nested_map_argument(ctx,
                      struct_map)
        else:
            result = await self.nested_map_argument(
                      struct_map)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler nested_map_argument:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_SimpleService_make_sentence(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[vector[vector[string]]] word_chars
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_word_chars = _module_types.List__List__string.create(__to_shared_ptr(cmove(word_chars)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_make_sentence_coro(
            self,
            __context,
            __promise,
            arg_word_chars
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_make_sentence_coro(
    object self,
    object ctx,
    Promise_string promise,
    word_chars
):
    try:
        if ctx and getattr(self.make_sentence, "pass_context", False):
            result = await self.make_sentence(ctx,
                      word_chars)
        else:
            result = await self.make_sentence(
                      word_chars)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler make_sentence:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_SimpleService_get_union(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[cint32_t]]] cPromise,
    unique_ptr[vector[cset[cint32_t]]] sets
):
    cdef Promise_cset__cint32_t __promise = Promise_cset__cint32_t.create(cmove(cPromise))
    arg_sets = _module_types.List__Set__i32.create(__to_shared_ptr(cmove(sets)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_union_coro(
            self,
            __context,
            __promise,
            arg_sets
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_union_coro(
    object self,
    object ctx,
    Promise_cset__cint32_t promise,
    sets
):
    try:
        if ctx and getattr(self.get_union, "pass_context", False):
            result = await self.get_union(ctx,
                      sets)
        else:
            result = await self.get_union(
                      sets)
        result = _module_types.Set__i32(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_union:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[cint32_t]](deref((<_module_types.Set__i32?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_get_keys(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[string]]] cPromise,
    unique_ptr[vector[cmap[string,string]]] string_map
):
    cdef Promise_cset__string __promise = Promise_cset__string.create(cmove(cPromise))
    arg_string_map = _module_types.List__Map__string_string.create(__to_shared_ptr(cmove(string_map)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_keys_coro(
            self,
            __context,
            __promise,
            arg_string_map
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_keys_coro(
    object self,
    object ctx,
    Promise_cset__string promise,
    string_map
):
    try:
        if ctx and getattr(self.get_keys, "pass_context", False):
            result = await self.get_keys(ctx,
                      string_map)
        else:
            result = await self.get_keys(
                      string_map)
        result = _module_types.Set__string(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_keys:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[string]](deref((<_module_types.Set__string?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_lookup_double(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[double] cPromise,
    cint32_t key
):
    cdef Promise_double __promise = Promise_double.create(cmove(cPromise))
    arg_key = key
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_lookup_double_coro(
            self,
            __context,
            __promise,
            arg_key
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_lookup_double_coro(
    object self,
    object ctx,
    Promise_double promise,
    key
):
    try:
        if ctx and getattr(self.lookup_double, "pass_context", False):
            result = await self.lookup_double(ctx,
                      key)
        else:
            result = await self.lookup_double(
                      key)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler lookup_double:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<double> result)

cdef api void call_cy_SimpleService_retrieve_binary(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[string] something
):
    cdef Promise_binary __promise = Promise_binary.create(cmove(cPromise))
    arg_something = (deref(something))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_retrieve_binary_coro(
            self,
            __context,
            __promise,
            arg_something
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_retrieve_binary_coro(
    object self,
    object ctx,
    Promise_binary promise,
    something
):
    try:
        if ctx and getattr(self.retrieve_binary, "pass_context", False):
            result = await self.retrieve_binary(ctx,
                      something)
        else:
            result = await self.retrieve_binary(
                      something)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler retrieve_binary:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result))

cdef api void call_cy_SimpleService_contain_binary(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[string]]] cPromise,
    unique_ptr[vector[string]] binaries
):
    cdef Promise_cset__binary __promise = Promise_cset__binary.create(cmove(cPromise))
    arg_binaries = _module_types.List__binary.create(__to_shared_ptr(cmove(binaries)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_contain_binary_coro(
            self,
            __context,
            __promise,
            arg_binaries
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_contain_binary_coro(
    object self,
    object ctx,
    Promise_cset__binary promise,
    binaries
):
    try:
        if ctx and getattr(self.contain_binary, "pass_context", False):
            result = await self.contain_binary(ctx,
                      binaries)
        else:
            result = await self.contain_binary(
                      binaries)
        result = _module_types.Set__binary(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler contain_binary:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[string]](deref((<_module_types.Set__binary?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_contain_enum(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[_module_types.cAnEnum]]] cPromise,
    unique_ptr[vector[_module_types.cAnEnum]] the_enum
):
    cdef Promise_vector___module_types_cAnEnum __promise = Promise_vector___module_types_cAnEnum.create(cmove(cPromise))
    arg_the_enum = _module_types.List__AnEnum.create(__to_shared_ptr(cmove(the_enum)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_contain_enum_coro(
            self,
            __context,
            __promise,
            arg_the_enum
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_contain_enum_coro(
    object self,
    object ctx,
    Promise_vector___module_types_cAnEnum promise,
    the_enum
):
    try:
        if ctx and getattr(self.contain_enum, "pass_context", False):
            result = await self.contain_enum(ctx,
                      the_enum)
        else:
            result = await self.contain_enum(
                      the_enum)
        result = _module_types.List__AnEnum(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler contain_enum:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[_module_types.cAnEnum]](deref((<_module_types.List__AnEnum?> result)._cpp_obj)))

cdef api void call_cy_SimpleService_get_binary_union_struct(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cBinaryUnionStruct]] cPromise,
    unique_ptr[_module_types.cBinaryUnion] u
):
    cdef Promise__module_types_cBinaryUnionStruct __promise = Promise__module_types_cBinaryUnionStruct.create(cmove(cPromise))
    arg_u = _module_types.BinaryUnion.create(shared_ptr[_module_types.cBinaryUnion](u.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        SimpleService_get_binary_union_struct_coro(
            self,
            __context,
            __promise,
            arg_u
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def SimpleService_get_binary_union_struct_coro(
    object self,
    object ctx,
    Promise__module_types_cBinaryUnionStruct promise,
    u
):
    try:
        if ctx and getattr(self.get_binary_union_struct, "pass_context", False):
            result = await self.get_binary_union_struct(ctx,
                      u)
        else:
            result = await self.get_binary_union_struct(
                      u)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_binary_union_struct:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cBinaryUnionStruct](deref((<_module_types.BinaryUnionStruct?> result)._cpp_obj)))

cdef api void call_cy_DerivedService_get_six(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        DerivedService_get_six_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def DerivedService_get_six_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.get_six, "pass_context", False):
            result = await self.get_six(ctx,)
        else:
            result = await self.get_six()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_six:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_RederivedService_get_seven(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        RederivedService_get_seven_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def RederivedService_get_seven_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.get_seven, "pass_context", False):
            result = await self.get_seven(ctx,)
        else:
            result = await self.get_seven()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler get_seven:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

