/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/module_types.h"
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::AnEnum>::size;
folly::Range<::py3::simple::AnEnum const*> const TEnumTraits<::py3::simple::AnEnum>::values = folly::range(TEnumDataStorage<::py3::simple::AnEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::AnEnum>::names = folly::range(TEnumDataStorage<::py3::simple::AnEnum>::names);

char const* TEnumTraits<::py3::simple::AnEnum>::findName(type value) {
  using factory = ::py3::simple::_AnEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::AnEnum>::findValue(char const* name, type* out) {
  using factory = ::py3::simple::_AnEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace py3 { namespace simple {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _AnEnum_EnumMapFactory::ValuesToNamesMapType _AnEnum_VALUES_TO_NAMES = _AnEnum_EnumMapFactory::makeValuesToNamesMap();
const _AnEnum_EnumMapFactory::NamesToValuesMapType _AnEnum_NAMES_TO_VALUES = _AnEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // py3::simple

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::Flags>::size;
folly::Range<::py3::simple::Flags const*> const TEnumTraits<::py3::simple::Flags>::values = folly::range(TEnumDataStorage<::py3::simple::Flags>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::Flags>::names = folly::range(TEnumDataStorage<::py3::simple::Flags>::names);

char const* TEnumTraits<::py3::simple::Flags>::findName(type value) {
  using factory = ::py3::simple::_Flags_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::Flags>::findValue(char const* name, type* out) {
  using factory = ::py3::simple::_Flags_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace py3 { namespace simple {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _Flags_EnumMapFactory::ValuesToNamesMapType _Flags_VALUES_TO_NAMES = _Flags_EnumMapFactory::makeValuesToNamesMap();
const _Flags_EnumMapFactory::NamesToValuesMapType _Flags_NAMES_TO_VALUES = _Flags_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::SimpleException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::SimpleException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

SimpleException::SimpleException(const SimpleException&) = default;
SimpleException& SimpleException::operator=(const SimpleException&) = default;
SimpleException::SimpleException() :
      err_code() {
}


SimpleException::~SimpleException() {}

SimpleException::SimpleException(SimpleException&& other) noexcept  :
    err_code(std::move(other.err_code)),
    __isset(other.__isset) {
}

SimpleException& SimpleException::operator=(FOLLY_MAYBE_UNUSED SimpleException&& other) noexcept {
    this->err_code = std::move(other.err_code);
    __isset = other.__isset;
    return *this;
}


SimpleException::SimpleException(apache::thrift::FragileConstructor, ::std::int16_t err_code__arg) :
    err_code(std::move(err_code__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void SimpleException::__clear() {
  // clear all fields
  this->err_code = ::std::int16_t();
  __isset = {};
}

bool SimpleException::operator==(const SimpleException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.err_code_ref() == rhs.err_code_ref())) {
    return false;
  }
  return true;
}

bool SimpleException::operator<(const SimpleException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.err_code_ref() == rhs.err_code_ref())) {
    return lhs.err_code_ref() < rhs.err_code_ref();
  }
  return false;
}


void swap(SimpleException& a, SimpleException& b) {
  using ::std::swap;
  swap(a.err_code_ref().value(), b.err_code_ref().value());
  swap(a.__isset, b.__isset);
}

template void SimpleException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SimpleException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SimpleException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SimpleException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SimpleException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SimpleException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SimpleException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SimpleException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::OptionalRefStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::OptionalRefStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

OptionalRefStruct::OptionalRefStruct(const OptionalRefStruct& srcObj) {
  optional_blob = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::binary>(srcObj.optional_blob);
  __isset.set(0,srcObj.__isset.get(0));
}

OptionalRefStruct& OptionalRefStruct::operator=(const OptionalRefStruct& src) {
  OptionalRefStruct tmp(src);
  swap(*this, tmp);
  return *this;
}

OptionalRefStruct::OptionalRefStruct(OptionalRefStruct&& other) noexcept  :
    optional_blob(std::move(other.optional_blob)),
    __isset(other.__isset) {
}

OptionalRefStruct& OptionalRefStruct::operator=(FOLLY_MAYBE_UNUSED OptionalRefStruct&& other) noexcept {
    this->optional_blob = std::move(other.optional_blob);
    __isset = other.__isset;
    return *this;
}


OptionalRefStruct::OptionalRefStruct(apache::thrift::FragileConstructor, ::py3::simple::IOBufPtr optional_blob__arg) :
    optional_blob(std::move(optional_blob__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void OptionalRefStruct::__clear() {
  // clear all fields
  this->optional_blob = apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::fromStringLiteral("");
  __isset = {};
}

bool OptionalRefStruct::operator==(const OptionalRefStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.optional_blob_ref().has_value() != rhs.optional_blob_ref().has_value() || (lhs.optional_blob_ref().has_value() && !apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(lhs.optional_blob, rhs.optional_blob))) {
    return false;
  }
  return true;
}

bool OptionalRefStruct::operator<(const OptionalRefStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.optional_blob_ref().has_value() != rhs.optional_blob_ref().has_value() || (lhs.optional_blob_ref().has_value() && !apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(lhs.optional_blob, rhs.optional_blob))) {
    return !lhs.optional_blob_ref().has_value() || (rhs.optional_blob_ref().has_value() && apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isLess(lhs.optional_blob, rhs.optional_blob));
  }
  return false;
}


void swap(OptionalRefStruct& a, OptionalRefStruct& b) {
  using ::std::swap;
  swap(a.optional_blob_ref().value_unchecked(), b.optional_blob_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void OptionalRefStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t OptionalRefStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t OptionalRefStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t OptionalRefStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void OptionalRefStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t OptionalRefStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t OptionalRefStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t OptionalRefStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::SimpleStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::SimpleStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

SimpleStruct::SimpleStruct(const SimpleStruct&) = default;
SimpleStruct& SimpleStruct::operator=(const SimpleStruct&) = default;
SimpleStruct::SimpleStruct(SimpleStruct&& other) noexcept  :
    __fbthrift_field_is_on(std::move(other.__fbthrift_field_is_on)),
    __fbthrift_field_tiny_int(std::move(other.__fbthrift_field_tiny_int)),
    __fbthrift_field_small_int(std::move(other.__fbthrift_field_small_int)),
    __fbthrift_field_nice_sized_int(std::move(other.__fbthrift_field_nice_sized_int)),
    __fbthrift_field_big_int(std::move(other.__fbthrift_field_big_int)),
    __fbthrift_field_real(std::move(other.__fbthrift_field_real)),
    __fbthrift_field_smaller_real(std::move(other.__fbthrift_field_smaller_real)),
    __fbthrift_field_hidden_field(std::move(other.__fbthrift_field_hidden_field)),
    __isset(other.__isset) {
}

SimpleStruct& SimpleStruct::operator=(FOLLY_MAYBE_UNUSED SimpleStruct&& other) noexcept {
    this->__fbthrift_field_is_on = std::move(other.__fbthrift_field_is_on);
    this->__fbthrift_field_tiny_int = std::move(other.__fbthrift_field_tiny_int);
    this->__fbthrift_field_small_int = std::move(other.__fbthrift_field_small_int);
    this->__fbthrift_field_nice_sized_int = std::move(other.__fbthrift_field_nice_sized_int);
    this->__fbthrift_field_big_int = std::move(other.__fbthrift_field_big_int);
    this->__fbthrift_field_real = std::move(other.__fbthrift_field_real);
    this->__fbthrift_field_smaller_real = std::move(other.__fbthrift_field_smaller_real);
    this->__fbthrift_field_hidden_field = std::move(other.__fbthrift_field_hidden_field);
    __isset = other.__isset;
    return *this;
}


SimpleStruct::SimpleStruct(apache::thrift::FragileConstructor, bool is_on__arg, ::std::int8_t tiny_int__arg, ::std::int16_t small_int__arg, ::std::int32_t nice_sized_int__arg, ::std::int64_t big_int__arg, double real__arg, float smaller_real__arg, ::std::int16_t hidden_field__arg) :
    __fbthrift_field_is_on(std::move(is_on__arg)),
    __fbthrift_field_tiny_int(std::move(tiny_int__arg)),
    __fbthrift_field_small_int(std::move(small_int__arg)),
    __fbthrift_field_nice_sized_int(std::move(nice_sized_int__arg)),
    __fbthrift_field_big_int(std::move(big_int__arg)),
    __fbthrift_field_real(std::move(real__arg)),
    __fbthrift_field_smaller_real(std::move(smaller_real__arg)),
    __fbthrift_field_hidden_field(std::move(hidden_field__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
}


void SimpleStruct::__clear() {
  // clear all fields
  this->__fbthrift_field_is_on = bool();
  this->__fbthrift_field_tiny_int = ::std::int8_t();
  this->__fbthrift_field_small_int = ::std::int16_t();
  this->__fbthrift_field_nice_sized_int = ::std::int32_t();
  this->__fbthrift_field_big_int = ::std::int64_t();
  this->__fbthrift_field_real = double();
  this->__fbthrift_field_smaller_real = float();
  this->__fbthrift_field_hidden_field = ::std::int16_t();
  __isset = {};
}

bool SimpleStruct::operator==(const SimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_on_ref() == rhs.is_on_ref())) {
    return false;
  }
  if (!(lhs.tiny_int_ref() == rhs.tiny_int_ref())) {
    return false;
  }
  if (!(lhs.small_int_ref() == rhs.small_int_ref())) {
    return false;
  }
  if (!(lhs.nice_sized_int_ref() == rhs.nice_sized_int_ref())) {
    return false;
  }
  if (!(lhs.big_int_ref() == rhs.big_int_ref())) {
    return false;
  }
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return false;
  }
  if (!(lhs.smaller_real_ref() == rhs.smaller_real_ref())) {
    return false;
  }
  if (!(lhs.hidden_field_ref() == rhs.hidden_field_ref())) {
    return false;
  }
  return true;
}

bool SimpleStruct::operator<(const SimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_on_ref() == rhs.is_on_ref())) {
    return lhs.is_on_ref() < rhs.is_on_ref();
  }
  if (!(lhs.tiny_int_ref() == rhs.tiny_int_ref())) {
    return lhs.tiny_int_ref() < rhs.tiny_int_ref();
  }
  if (!(lhs.small_int_ref() == rhs.small_int_ref())) {
    return lhs.small_int_ref() < rhs.small_int_ref();
  }
  if (!(lhs.nice_sized_int_ref() == rhs.nice_sized_int_ref())) {
    return lhs.nice_sized_int_ref() < rhs.nice_sized_int_ref();
  }
  if (!(lhs.big_int_ref() == rhs.big_int_ref())) {
    return lhs.big_int_ref() < rhs.big_int_ref();
  }
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return lhs.real_ref() < rhs.real_ref();
  }
  if (!(lhs.smaller_real_ref() == rhs.smaller_real_ref())) {
    return lhs.smaller_real_ref() < rhs.smaller_real_ref();
  }
  if (!(lhs.hidden_field_ref() == rhs.hidden_field_ref())) {
    return lhs.hidden_field_ref() < rhs.hidden_field_ref();
  }
  return false;
}


void swap(SimpleStruct& a, SimpleStruct& b) {
  using ::std::swap;
  swap(a.is_on_ref().value(), b.is_on_ref().value());
  swap(a.tiny_int_ref().value(), b.tiny_int_ref().value());
  swap(a.small_int_ref().value(), b.small_int_ref().value());
  swap(a.nice_sized_int_ref().value(), b.nice_sized_int_ref().value());
  swap(a.big_int_ref().value(), b.big_int_ref().value());
  swap(a.real_ref().value(), b.real_ref().value());
  swap(a.smaller_real_ref().value(), b.smaller_real_ref().value());
  swap(a.hidden_field_ref().value(), b.hidden_field_ref().value());
  swap(a.__isset, b.__isset);
}

template void SimpleStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SimpleStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SimpleStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SimpleStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SimpleStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SimpleStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SimpleStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SimpleStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::ComplexStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::ComplexStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

ComplexStruct::ComplexStruct(const ComplexStruct&) = default;
ComplexStruct& ComplexStruct::operator=(const ComplexStruct&) = default;
ComplexStruct::ComplexStruct() :
      __fbthrift_field_an_integer(),
      __fbthrift_field_an_enum() {
}


ComplexStruct::~ComplexStruct() {}

ComplexStruct::ComplexStruct(ComplexStruct&& other) noexcept  :
    __fbthrift_field_structOne(std::move(other.__fbthrift_field_structOne)),
    __fbthrift_field_structTwo(std::move(other.__fbthrift_field_structTwo)),
    __fbthrift_field_an_integer(std::move(other.__fbthrift_field_an_integer)),
    __fbthrift_field_name(std::move(other.__fbthrift_field_name)),
    __fbthrift_field_an_enum(std::move(other.__fbthrift_field_an_enum)),
    __fbthrift_field_some_bytes(std::move(other.__fbthrift_field_some_bytes)),
    __fbthrift_field_from(std::move(other.__fbthrift_field_from)),
    __fbthrift_field_cdef(std::move(other.__fbthrift_field_cdef)),
    __fbthrift_field_bytes_with_cpp_type(std::move(other.__fbthrift_field_bytes_with_cpp_type)),
    __isset(other.__isset) {
}

ComplexStruct& ComplexStruct::operator=(FOLLY_MAYBE_UNUSED ComplexStruct&& other) noexcept {
    this->__fbthrift_field_structOne = std::move(other.__fbthrift_field_structOne);
    this->__fbthrift_field_structTwo = std::move(other.__fbthrift_field_structTwo);
    this->__fbthrift_field_an_integer = std::move(other.__fbthrift_field_an_integer);
    this->__fbthrift_field_name = std::move(other.__fbthrift_field_name);
    this->__fbthrift_field_an_enum = std::move(other.__fbthrift_field_an_enum);
    this->__fbthrift_field_some_bytes = std::move(other.__fbthrift_field_some_bytes);
    this->__fbthrift_field_from = std::move(other.__fbthrift_field_from);
    this->__fbthrift_field_cdef = std::move(other.__fbthrift_field_cdef);
    this->__fbthrift_field_bytes_with_cpp_type = std::move(other.__fbthrift_field_bytes_with_cpp_type);
    __isset = other.__isset;
    return *this;
}


ComplexStruct::ComplexStruct(apache::thrift::FragileConstructor, ::py3::simple::SimpleStruct structOne__arg, ::py3::simple::SimpleStruct structTwo__arg, ::std::int32_t an_integer__arg, ::std::string name__arg, ::py3::simple::AnEnum an_enum__arg, ::std::string some_bytes__arg, ::std::string from__arg, ::std::string cdef__arg, ::py3::simple::foo_bar bytes_with_cpp_type__arg) :
    __fbthrift_field_structOne(std::move(structOne__arg)),
    __fbthrift_field_structTwo(std::move(structTwo__arg)),
    __fbthrift_field_an_integer(std::move(an_integer__arg)),
    __fbthrift_field_name(std::move(name__arg)),
    __fbthrift_field_an_enum(std::move(an_enum__arg)),
    __fbthrift_field_some_bytes(std::move(some_bytes__arg)),
    __fbthrift_field_from(std::move(from__arg)),
    __fbthrift_field_cdef(std::move(cdef__arg)),
    __fbthrift_field_bytes_with_cpp_type(std::move(bytes_with_cpp_type__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
}


void ComplexStruct::__clear() {
  // clear all fields
  this->__fbthrift_field_structOne.__clear();
  this->__fbthrift_field_structTwo.__clear();
  this->__fbthrift_field_an_integer = ::std::int32_t();
  this->__fbthrift_field_name = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_an_enum = ::py3::simple::AnEnum();
  this->__fbthrift_field_some_bytes = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_from = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_cdef = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_bytes_with_cpp_type = apache::thrift::StringTraits<foo::Bar>::fromStringLiteral("");
  __isset = {};
}

bool ComplexStruct::operator==(const ComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.structOne_ref() == rhs.structOne_ref())) {
    return false;
  }
  if (!(lhs.structTwo_ref() == rhs.structTwo_ref())) {
    return false;
  }
  if (!(lhs.an_integer_ref() == rhs.an_integer_ref())) {
    return false;
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return false;
  }
  if (!(lhs.an_enum_ref() == rhs.an_enum_ref())) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_some_bytes, rhs.__fbthrift_field_some_bytes)) {
    return false;
  }
  if (!(lhs.from_ref() == rhs.from_ref())) {
    return false;
  }
  if (!(lhs.cdef_ref() == rhs.cdef_ref())) {
    return false;
  }
  if (!apache::thrift::StringTraits<foo::Bar>::isEqual(lhs.__fbthrift_field_bytes_with_cpp_type, rhs.__fbthrift_field_bytes_with_cpp_type)) {
    return false;
  }
  return true;
}

bool ComplexStruct::operator<(const ComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.structOne_ref() == rhs.structOne_ref())) {
    return lhs.structOne_ref() < rhs.structOne_ref();
  }
  if (!(lhs.structTwo_ref() == rhs.structTwo_ref())) {
    return lhs.structTwo_ref() < rhs.structTwo_ref();
  }
  if (!(lhs.an_integer_ref() == rhs.an_integer_ref())) {
    return lhs.an_integer_ref() < rhs.an_integer_ref();
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return lhs.name_ref() < rhs.name_ref();
  }
  if (!(lhs.an_enum_ref() == rhs.an_enum_ref())) {
    return lhs.an_enum_ref() < rhs.an_enum_ref();
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_some_bytes, rhs.__fbthrift_field_some_bytes)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.__fbthrift_field_some_bytes, rhs.__fbthrift_field_some_bytes);
  }
  if (!(lhs.from_ref() == rhs.from_ref())) {
    return lhs.from_ref() < rhs.from_ref();
  }
  if (!(lhs.cdef_ref() == rhs.cdef_ref())) {
    return lhs.cdef_ref() < rhs.cdef_ref();
  }
  if (!apache::thrift::StringTraits<foo::Bar>::isEqual(lhs.__fbthrift_field_bytes_with_cpp_type, rhs.__fbthrift_field_bytes_with_cpp_type)) {
    return apache::thrift::StringTraits<foo::Bar>::isLess(lhs.__fbthrift_field_bytes_with_cpp_type, rhs.__fbthrift_field_bytes_with_cpp_type);
  }
  return false;
}

const ::py3::simple::SimpleStruct& ComplexStruct::get_structOne() const& {
  return __fbthrift_field_structOne;
}

::py3::simple::SimpleStruct ComplexStruct::get_structOne() && {
  return std::move(__fbthrift_field_structOne);
}

const ::py3::simple::SimpleStruct& ComplexStruct::get_structTwo() const& {
  return __fbthrift_field_structTwo;
}

::py3::simple::SimpleStruct ComplexStruct::get_structTwo() && {
  return std::move(__fbthrift_field_structTwo);
}


void swap(ComplexStruct& a, ComplexStruct& b) {
  using ::std::swap;
  swap(a.structOne_ref().value(), b.structOne_ref().value());
  swap(a.structTwo_ref().value(), b.structTwo_ref().value());
  swap(a.an_integer_ref().value(), b.an_integer_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.an_enum_ref().value(), b.an_enum_ref().value());
  swap(a.some_bytes_ref().value(), b.some_bytes_ref().value());
  swap(a.from_ref().value(), b.from_ref().value());
  swap(a.cdef_ref().value(), b.cdef_ref().value());
  swap(a.bytes_with_cpp_type_ref().value(), b.bytes_with_cpp_type_ref().value());
  swap(a.__isset, b.__isset);
}

template void ComplexStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of nimble option");

}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::BinaryUnion>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::BinaryUnion>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::BinaryUnion::Type>::size;
folly::Range<::py3::simple::BinaryUnion::Type const*> const TEnumTraits<::py3::simple::BinaryUnion::Type>::values = folly::range(TEnumDataStorage<::py3::simple::BinaryUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::BinaryUnion::Type>::names = folly::range(TEnumDataStorage<::py3::simple::BinaryUnion::Type>::names);

char const* TEnumTraits<::py3::simple::BinaryUnion::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::py3::simple::BinaryUnion::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::BinaryUnion::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::py3::simple::BinaryUnion::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace py3 { namespace simple {

void BinaryUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::iobuf_val:
      destruct(value_.iobuf_val);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}


void swap(BinaryUnion& a, BinaryUnion& b) {
  BinaryUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void BinaryUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BinaryUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BinaryUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BinaryUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BinaryUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BinaryUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BinaryUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BinaryUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::BinaryUnionStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::BinaryUnionStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

BinaryUnionStruct::BinaryUnionStruct(const BinaryUnionStruct&) = default;
BinaryUnionStruct& BinaryUnionStruct::operator=(const BinaryUnionStruct&) = default;
BinaryUnionStruct::BinaryUnionStruct(BinaryUnionStruct&& other) noexcept  :
    __fbthrift_field_u(std::move(other.__fbthrift_field_u)),
    __isset(other.__isset) {
}

BinaryUnionStruct& BinaryUnionStruct::operator=(FOLLY_MAYBE_UNUSED BinaryUnionStruct&& other) noexcept {
    this->__fbthrift_field_u = std::move(other.__fbthrift_field_u);
    __isset = other.__isset;
    return *this;
}


BinaryUnionStruct::BinaryUnionStruct(apache::thrift::FragileConstructor, ::py3::simple::BinaryUnion u__arg) :
    __fbthrift_field_u(std::move(u__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void BinaryUnionStruct::__clear() {
  // clear all fields
  this->__fbthrift_field_u.__clear();
  __isset = {};
}



const ::py3::simple::BinaryUnion& BinaryUnionStruct::get_u() const& {
  return __fbthrift_field_u;
}

::py3::simple::BinaryUnion BinaryUnionStruct::get_u() && {
  return std::move(__fbthrift_field_u);
}


void swap(BinaryUnionStruct& a, BinaryUnionStruct& b) {
  using ::std::swap;
  swap(a.u_ref().value(), b.u_ref().value());
  swap(a.__isset, b.__isset);
}

template void BinaryUnionStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BinaryUnionStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BinaryUnionStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BinaryUnionStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BinaryUnionStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BinaryUnionStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BinaryUnionStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BinaryUnionStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BinaryUnionStruct,
        ::apache::thrift::type_class::variant,
        ::py3::simple::BinaryUnion>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BinaryUnionStruct,
        ::apache::thrift::type_class::variant,
        ::py3::simple::BinaryUnion>,
    "inconsistent use of nimble option");

}} // py3::simple

namespace py3 { namespace simple { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}} // py3::simple
