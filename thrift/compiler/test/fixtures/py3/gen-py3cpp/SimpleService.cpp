/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/SimpleService.h"
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/SimpleService.tcc"
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

namespace py3 { namespace simple {
std::unique_ptr<apache::thrift::AsyncProcessor> SimpleServiceSvIf::getProcessor() {
  return std::make_unique<SimpleServiceAsyncProcessor>(this);
}

SimpleServiceSvIf::CreateMethodMetadataResult SimpleServiceSvIf::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<SimpleServiceAsyncProcessor>();
}


::std::int32_t SimpleServiceSvIf::get_five() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_five");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_get_five() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return get_five();
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_get_five() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_five(), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_five(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_five.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_five();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_five();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(get_five());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::add_five(::std::int32_t /*num*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("add_five");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_add_five(::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return add_five(p_num);
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_add_five(::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_add_five(p_num), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_add_five(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, ::std::int32_t p_num) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_add_five.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_add_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_add_five(p_num);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_add_five(p_num);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(add_five(p_num));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::do_nothing() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("do_nothing");
}

folly::SemiFuture<folly::Unit> SimpleServiceSvIf::semifuture_do_nothing() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  do_nothing();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> SimpleServiceSvIf::future_do_nothing() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_do_nothing(), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_do_nothing(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_do_nothing.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_do_nothing.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_do_nothing();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_do_nothing();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        do_nothing();
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::concat(::std::string& /*_return*/, std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("concat");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_concat(std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  concat(*ret, std::move(p_first), std::move(p_second));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_concat(std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_concat(std::move(p_first), std::move(p_second)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_concat(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_concat.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_concat.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_concat(std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_concat(std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        concat(_return, std::move(p_first), std::move(p_second));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::get_value(std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_value");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return get_value(std::move(p_simple_struct));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_value(std::move(p_simple_struct)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_value(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_value.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_value(std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_value(std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(get_value(std::move(p_simple_struct)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool SimpleServiceSvIf::negate(bool /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("negate");
}

folly::SemiFuture<bool> SimpleServiceSvIf::semifuture_negate(bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return negate(p_input);
}

folly::Future<bool> SimpleServiceSvIf::future_negate(bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_negate(p_input), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_negate(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, bool p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_negate.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_negate.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_negate(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_negate(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(negate(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int8_t SimpleServiceSvIf::tiny(::std::int8_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("tiny");
}

folly::SemiFuture<::std::int8_t> SimpleServiceSvIf::semifuture_tiny(::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return tiny(p_input);
}

folly::Future<::std::int8_t> SimpleServiceSvIf::future_tiny(::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_tiny(p_input), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_tiny(std::unique_ptr<apache::thrift::HandlerCallback<::std::int8_t>> callback, ::std::int8_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_tiny.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_tiny.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_tiny(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_tiny(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(tiny(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t SimpleServiceSvIf::small(::std::int16_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("small");
}

folly::SemiFuture<::std::int16_t> SimpleServiceSvIf::semifuture_small(::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return small(p_input);
}

folly::Future<::std::int16_t> SimpleServiceSvIf::future_small(::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_small(p_input), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_small(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, ::std::int16_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_small.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_small.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_small(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_small(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(small(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int64_t SimpleServiceSvIf::big(::std::int64_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("big");
}

folly::SemiFuture<::std::int64_t> SimpleServiceSvIf::semifuture_big(::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return big(p_input);
}

folly::Future<::std::int64_t> SimpleServiceSvIf::future_big(::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_big(p_input), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_big(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback, ::std::int64_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_big.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_big.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_big(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_big(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(big(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

double SimpleServiceSvIf::two(double /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("two");
}

folly::SemiFuture<double> SimpleServiceSvIf::semifuture_two(double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return two(p_input);
}

folly::Future<double> SimpleServiceSvIf::future_two(double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_two(p_input), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_two(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback, double p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_two.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_two.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_two(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_two(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(two(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::expected_exception() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("expected_exception");
}

folly::SemiFuture<folly::Unit> SimpleServiceSvIf::semifuture_expected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  expected_exception();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> SimpleServiceSvIf::future_expected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_expected_exception(), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_expected_exception(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_expected_exception.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_expected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_expected_exception();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_expected_exception();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        expected_exception();
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::unexpected_exception() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("unexpected_exception");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_unexpected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return unexpected_exception();
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_unexpected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_unexpected_exception(), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_unexpected_exception(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_unexpected_exception.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_unexpected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_unexpected_exception();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_unexpected_exception();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(unexpected_exception());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i16_list");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sum_i16_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i16_list(std::move(p_numbers)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_sum_i16_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_sum_i16_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_sum_i16_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i16_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i16_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sum_i16_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i32_list");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sum_i32_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i32_list(std::move(p_numbers)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_sum_i32_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_sum_i32_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_sum_i32_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i32_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i32_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sum_i32_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i64_list");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sum_i64_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i64_list(std::move(p_numbers)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_sum_i64_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_sum_i64_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_sum_i64_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i64_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i64_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sum_i64_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::concat_many(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("concat_many");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_concat_many(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  concat_many(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_concat_many(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_concat_many(std::move(p_words)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_concat_many(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_concat_many.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_concat_many.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_concat_many(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_concat_many(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        concat_many(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("count_structs");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return count_structs(std::move(p_items));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_count_structs(std::move(p_items)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_count_structs(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_count_structs.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_count_structs.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_count_structs(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_count_structs(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(count_structs(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::sum_set(std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_set");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sum_set(std::move(p_numbers));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_set(std::move(p_numbers)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_sum_set(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_sum_set.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_sum_set.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_set(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_set(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sum_set(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool SimpleServiceSvIf::contains_word(std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contains_word");
}

folly::SemiFuture<bool> SimpleServiceSvIf::semifuture_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return contains_word(std::move(p_words), std::move(p_word));
}

folly::Future<bool> SimpleServiceSvIf::future_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contains_word(std::move(p_words), std::move(p_word)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_contains_word(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_contains_word.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_contains_word.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contains_word(std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contains_word(std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(contains_word(std::move(p_words), std::move(p_word)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::get_map_value(::std::string& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_map_value");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_get_map_value(std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  get_map_value(*ret, std::move(p_words), std::move(p_key));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_get_map_value(std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_map_value(std::move(p_words), std::move(p_key)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_map_value(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_map_value.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_map_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_map_value(std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_map_value(std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        get_map_value(_return, std::move(p_words), std::move(p_key));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t SimpleServiceSvIf::map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("map_length");
}

folly::SemiFuture<::std::int16_t> SimpleServiceSvIf::semifuture_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return map_length(std::move(p_items));
}

folly::Future<::std::int16_t> SimpleServiceSvIf::future_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_map_length(std::move(p_items)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_map_length(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_map_length.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_map_length.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_map_length(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_map_length(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(map_length(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t SimpleServiceSvIf::sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_map_values");
}

folly::SemiFuture<::std::int16_t> SimpleServiceSvIf::semifuture_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sum_map_values(std::move(p_items));
}

folly::Future<::std::int16_t> SimpleServiceSvIf::future_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_map_values(std::move(p_items)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_sum_map_values(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_sum_map_values.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_sum_map_values.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_map_values(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_map_values(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sum_map_values(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("complex_sum_i32");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return complex_sum_i32(std::move(p_counter));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_complex_sum_i32(std::move(p_counter)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_complex_sum_i32(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_complex_sum_i32.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_complex_sum_i32(std::move(p_counter));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_complex_sum_i32(std::move(p_counter));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(complex_sum_i32(std::move(p_counter)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::repeat_name(::std::string& /*_return*/, std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("repeat_name");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_repeat_name(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  repeat_name(*ret, std::move(p_counter));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_repeat_name(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_repeat_name(std::move(p_counter)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_repeat_name(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_repeat_name.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_repeat_name.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_repeat_name(std::move(p_counter));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_repeat_name(std::move(p_counter));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        repeat_name(_return, std::move(p_counter));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::get_struct(::py3::simple::SimpleStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_struct");
}

folly::SemiFuture<std::unique_ptr<::py3::simple::SimpleStruct>> SimpleServiceSvIf::semifuture_get_struct() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::py3::simple::SimpleStruct>();
  get_struct(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::py3::simple::SimpleStruct>> SimpleServiceSvIf::future_get_struct() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_struct(), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_struct(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::SimpleStruct>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_struct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_struct();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_struct();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::py3::simple::SimpleStruct _return;
        get_struct(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::fib(::std::vector<::std::int32_t>& /*_return*/, ::std::int16_t /*n*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("fib");
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::int32_t>>> SimpleServiceSvIf::semifuture_fib(::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::int32_t>>();
  fib(*ret, p_n);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::int32_t>>> SimpleServiceSvIf::future_fib(::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_fib(p_n), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_fib(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::int32_t>>>> callback, ::std::int16_t p_n) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_fib.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_fib.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_fib(p_n);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_fib(p_n);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::int32_t> _return;
        fib(_return, p_n);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::unique_words(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("unique_words");
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::semifuture_unique_words(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  unique_words(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::future_unique_words(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_unique_words(std::move(p_words)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_unique_words(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_unique_words.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_unique_words.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_unique_words(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_unique_words(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        unique_words(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::words_count(::std::map<::std::string, ::std::int16_t>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("words_count");
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> SimpleServiceSvIf::semifuture_words_count(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::int16_t>>();
  words_count(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> SimpleServiceSvIf::future_words_count(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_words_count(std::move(p_words)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_words_count(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_words_count.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_words_count.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_words_count(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_words_count(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::int16_t> _return;
        words_count(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::py3::simple::AnEnum SimpleServiceSvIf::set_enum(::py3::simple::AnEnum /*in_enum*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("set_enum");
}

folly::SemiFuture<::py3::simple::AnEnum> SimpleServiceSvIf::semifuture_set_enum(::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return set_enum(p_in_enum);
}

folly::Future<::py3::simple::AnEnum> SimpleServiceSvIf::future_set_enum(::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_set_enum(p_in_enum), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_set_enum(std::unique_ptr<apache::thrift::HandlerCallback<::py3::simple::AnEnum>> callback, ::py3::simple::AnEnum p_in_enum) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_set_enum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_set_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_set_enum(p_in_enum);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_set_enum(p_in_enum);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(set_enum(p_in_enum));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::list_of_lists(::std::vector<::std::vector<::std::int32_t>>& /*_return*/, ::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_of_lists");
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> SimpleServiceSvIf::semifuture_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::vector<::std::int32_t>>>();
  list_of_lists(*ret, p_num_lists, p_num_items);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> SimpleServiceSvIf::future_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_of_lists(p_num_lists, p_num_items), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_list_of_lists(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>>> callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_list_of_lists.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_list_of_lists.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_of_lists(p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_of_lists(p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::vector<::std::int32_t>> _return;
        list_of_lists(_return, p_num_lists, p_num_items);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& /*_return*/, std::unique_ptr<::std::string> /*sentence*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("word_character_frequency");
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> SimpleServiceSvIf::semifuture_word_character_frequency(std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>();
  word_character_frequency(*ret, std::move(p_sentence));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> SimpleServiceSvIf::future_word_character_frequency(std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_word_character_frequency(std::move(p_sentence)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_word_character_frequency(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>> callback, std::unique_ptr<::std::string> p_sentence) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_word_character_frequency.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_word_character_frequency.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_word_character_frequency(std::move(p_sentence));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_word_character_frequency(std::move(p_sentence));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>> _return;
        word_character_frequency(_return, std::move(p_sentence));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::list_of_sets(::std::vector<::std::set<::std::string>>& /*_return*/, std::unique_ptr<::std::string> /*some_words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_of_sets");
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::set<::std::string>>>> SimpleServiceSvIf::semifuture_list_of_sets(std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::set<::std::string>>>();
  list_of_sets(*ret, std::move(p_some_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::set<::std::string>>>> SimpleServiceSvIf::future_list_of_sets(std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_of_sets(std::move(p_some_words)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_list_of_sets(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::set<::std::string>>>>> callback, std::unique_ptr<::std::string> p_some_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_list_of_sets.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_list_of_sets.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_of_sets(std::move(p_some_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_of_sets(std::move(p_some_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::set<::std::string>> _return;
        list_of_sets(_return, std::move(p_some_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvIf::nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("nested_map_argument");
}

folly::SemiFuture<::std::int32_t> SimpleServiceSvIf::semifuture_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return nested_map_argument(std::move(p_struct_map));
}

folly::Future<::std::int32_t> SimpleServiceSvIf::future_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_nested_map_argument(std::move(p_struct_map)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_nested_map_argument(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_nested_map_argument.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_nested_map_argument.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_nested_map_argument(std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_nested_map_argument(std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(nested_map_argument(std::move(p_struct_map)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::make_sentence(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("make_sentence");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_make_sentence(std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  make_sentence(*ret, std::move(p_word_chars));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_make_sentence(std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_make_sentence(std::move(p_word_chars)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_make_sentence(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_make_sentence.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_make_sentence.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_make_sentence(std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_make_sentence(std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        make_sentence(_return, std::move(p_word_chars));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::get_union(::std::set<::std::int32_t>& /*_return*/, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_union");
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::int32_t>>> SimpleServiceSvIf::semifuture_get_union(std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::int32_t>>();
  get_union(*ret, std::move(p_sets));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::int32_t>>> SimpleServiceSvIf::future_get_union(std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_union(std::move(p_sets)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_union(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::int32_t>>>> callback, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_union.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_union.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_union(std::move(p_sets));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_union(std::move(p_sets));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::int32_t> _return;
        get_union(_return, std::move(p_sets));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::get_keys(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_keys");
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::semifuture_get_keys(std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  get_keys(*ret, std::move(p_string_map));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::future_get_keys(std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_keys(std::move(p_string_map)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_keys(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_keys.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_keys.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_keys(std::move(p_string_map));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_keys(std::move(p_string_map));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        get_keys(_return, std::move(p_string_map));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

double SimpleServiceSvIf::lookup_double(::std::int32_t /*key*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("lookup_double");
}

folly::SemiFuture<double> SimpleServiceSvIf::semifuture_lookup_double(::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return lookup_double(p_key);
}

folly::Future<double> SimpleServiceSvIf::future_lookup_double(::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_lookup_double(p_key), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_lookup_double(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback, ::std::int32_t p_key) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_lookup_double.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_lookup_double.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_lookup_double(p_key);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_lookup_double(p_key);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(lookup_double(p_key));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::retrieve_binary(::std::string& /*_return*/, std::unique_ptr<::std::string> /*something*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("retrieve_binary");
}

folly::SemiFuture<std::unique_ptr<::std::string>> SimpleServiceSvIf::semifuture_retrieve_binary(std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  retrieve_binary(*ret, std::move(p_something));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> SimpleServiceSvIf::future_retrieve_binary(std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_retrieve_binary(std::move(p_something)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_retrieve_binary(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_something) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_retrieve_binary.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_retrieve_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_retrieve_binary(std::move(p_something));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_retrieve_binary(std::move(p_something));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        retrieve_binary(_return, std::move(p_something));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::contain_binary(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*binaries*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contain_binary");
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::semifuture_contain_binary(std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  contain_binary(*ret, std::move(p_binaries));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> SimpleServiceSvIf::future_contain_binary(std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contain_binary(std::move(p_binaries)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_contain_binary(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_contain_binary.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_contain_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contain_binary(std::move(p_binaries));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contain_binary(std::move(p_binaries));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        contain_binary(_return, std::move(p_binaries));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::contain_enum(::std::vector<::py3::simple::AnEnum>& /*_return*/, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contain_enum");
}

folly::SemiFuture<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> SimpleServiceSvIf::semifuture_contain_enum(std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::py3::simple::AnEnum>>();
  contain_enum(*ret, std::move(p_the_enum));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> SimpleServiceSvIf::future_contain_enum(std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contain_enum(std::move(p_the_enum)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_contain_enum(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>>> callback, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_contain_enum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_contain_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contain_enum(std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contain_enum(std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::py3::simple::AnEnum> _return;
        contain_enum(_return, std::move(p_the_enum));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void SimpleServiceSvIf::get_binary_union_struct(::py3::simple::BinaryUnionStruct& /*_return*/, std::unique_ptr<::py3::simple::BinaryUnion> /*u*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_binary_union_struct");
}

folly::SemiFuture<std::unique_ptr<::py3::simple::BinaryUnionStruct>> SimpleServiceSvIf::semifuture_get_binary_union_struct(std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::py3::simple::BinaryUnionStruct>();
  get_binary_union_struct(*ret, std::move(p_u));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::py3::simple::BinaryUnionStruct>> SimpleServiceSvIf::future_get_binary_union_struct(std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_binary_union_struct(std::move(p_u)), getInternalKeepAlive());
}

void SimpleServiceSvIf::async_tm_get_binary_union_struct(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::BinaryUnionStruct>>> callback, std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
  auto invocationType = __fbthrift_invocation_get_binary_union_struct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
        __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_binary_union_struct(std::move(p_u));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_binary_union_struct(std::move(p_u));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::py3::simple::BinaryUnionStruct _return;
        get_binary_union_struct(_return, std::move(p_u));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t SimpleServiceSvNull::get_five() {
  return 0;
}

::std::int32_t SimpleServiceSvNull::add_five(::std::int32_t /*num*/) {
  return 0;
}

void SimpleServiceSvNull::do_nothing() {
  return;
}

void SimpleServiceSvNull::concat(::std::string& /*_return*/, std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/) {}

::std::int32_t SimpleServiceSvNull::get_value(std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/) {
  return 0;
}

bool SimpleServiceSvNull::negate(bool /*input*/) {
  return 0;
}

::std::int8_t SimpleServiceSvNull::tiny(::std::int8_t /*input*/) {
  return 0;
}

::std::int16_t SimpleServiceSvNull::small(::std::int16_t /*input*/) {
  return 0;
}

::std::int64_t SimpleServiceSvNull::big(::std::int64_t /*input*/) {
  return 0;
}

double SimpleServiceSvNull::two(double /*input*/) {
  return 0;
}

void SimpleServiceSvNull::expected_exception() {
  return;
}

::std::int32_t SimpleServiceSvNull::unexpected_exception() {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/) {
  return 0;
}

void SimpleServiceSvNull::concat_many(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

::std::int32_t SimpleServiceSvNull::count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_set(std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/) {
  return 0;
}

bool SimpleServiceSvNull::contains_word(std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/) {
  return 0;
}

void SimpleServiceSvNull::get_map_value(::std::string& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/) {}

::std::int16_t SimpleServiceSvNull::map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/) {
  return 0;
}

::std::int16_t SimpleServiceSvNull::sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  return 0;
}

void SimpleServiceSvNull::repeat_name(::std::string& /*_return*/, std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {}

void SimpleServiceSvNull::get_struct(::py3::simple::SimpleStruct& /*_return*/) {}

void SimpleServiceSvNull::fib(::std::vector<::std::int32_t>& /*_return*/, ::std::int16_t /*n*/) {}

void SimpleServiceSvNull::unique_words(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

void SimpleServiceSvNull::words_count(::std::map<::std::string, ::std::int16_t>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

::py3::simple::AnEnum SimpleServiceSvNull::set_enum(::py3::simple::AnEnum /*in_enum*/) {
  return (::py3::simple::AnEnum)0;
}

void SimpleServiceSvNull::list_of_lists(::std::vector<::std::vector<::std::int32_t>>& /*_return*/, ::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/) {}

void SimpleServiceSvNull::word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& /*_return*/, std::unique_ptr<::std::string> /*sentence*/) {}

void SimpleServiceSvNull::list_of_sets(::std::vector<::std::set<::std::string>>& /*_return*/, std::unique_ptr<::std::string> /*some_words*/) {}

::std::int32_t SimpleServiceSvNull::nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/) {
  return 0;
}

void SimpleServiceSvNull::make_sentence(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/) {}

void SimpleServiceSvNull::get_union(::std::set<::std::int32_t>& /*_return*/, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/) {}

void SimpleServiceSvNull::get_keys(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/) {}

double SimpleServiceSvNull::lookup_double(::std::int32_t /*key*/) {
  return 0;
}

void SimpleServiceSvNull::retrieve_binary(::std::string& /*_return*/, std::unique_ptr<::std::string> /*something*/) {}

void SimpleServiceSvNull::contain_binary(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*binaries*/) {}

void SimpleServiceSvNull::contain_enum(::std::vector<::py3::simple::AnEnum>& /*_return*/, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/) {}

void SimpleServiceSvNull::get_binary_union_struct(::py3::simple::BinaryUnionStruct& /*_return*/, std::unique_ptr<::py3::simple::BinaryUnion> /*u*/) {}



const char* SimpleServiceAsyncProcessor::getServiceName() {
  return "SimpleService";
}

void SimpleServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<SimpleServiceSvIf>::gen(response);
}

void SimpleServiceAsyncProcessor::processSerializedCompressedRequest(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, std::move(req), std::move(serializedRequest), protType, context, eb, tm);
}

void SimpleServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

const SimpleServiceAsyncProcessor::ProcessMap& SimpleServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const SimpleServiceAsyncProcessor::ProcessMap SimpleServiceAsyncProcessor::kOwnProcessMap_ {
  {"get_five", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"add_five", {&SimpleServiceAsyncProcessor::setUpAndProcess_add_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_add_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"do_nothing", {&SimpleServiceAsyncProcessor::setUpAndProcess_do_nothing<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_do_nothing<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"concat", {&SimpleServiceAsyncProcessor::setUpAndProcess_concat<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_concat<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_value", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"negate", {&SimpleServiceAsyncProcessor::setUpAndProcess_negate<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_negate<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"tiny", {&SimpleServiceAsyncProcessor::setUpAndProcess_tiny<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_tiny<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"small", {&SimpleServiceAsyncProcessor::setUpAndProcess_small<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_small<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"big", {&SimpleServiceAsyncProcessor::setUpAndProcess_big<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_big<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"two", {&SimpleServiceAsyncProcessor::setUpAndProcess_two<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_two<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"expected_exception", {&SimpleServiceAsyncProcessor::setUpAndProcess_expected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_expected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"unexpected_exception", {&SimpleServiceAsyncProcessor::setUpAndProcess_unexpected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_unexpected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i16_list", {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i16_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i16_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i32_list", {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i32_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i32_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i64_list", {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i64_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i64_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"concat_many", {&SimpleServiceAsyncProcessor::setUpAndProcess_concat_many<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_concat_many<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"count_structs", {&SimpleServiceAsyncProcessor::setUpAndProcess_count_structs<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_count_structs<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_set", {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_set<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_sum_set<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contains_word", {&SimpleServiceAsyncProcessor::setUpAndProcess_contains_word<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_contains_word<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_map_value", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_map_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_map_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"map_length", {&SimpleServiceAsyncProcessor::setUpAndProcess_map_length<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_map_length<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_map_values", {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_map_values<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_sum_map_values<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"complex_sum_i32", {&SimpleServiceAsyncProcessor::setUpAndProcess_complex_sum_i32<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_complex_sum_i32<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"repeat_name", {&SimpleServiceAsyncProcessor::setUpAndProcess_repeat_name<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_repeat_name<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_struct", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"fib", {&SimpleServiceAsyncProcessor::setUpAndProcess_fib<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_fib<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"unique_words", {&SimpleServiceAsyncProcessor::setUpAndProcess_unique_words<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_unique_words<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"words_count", {&SimpleServiceAsyncProcessor::setUpAndProcess_words_count<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_words_count<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"set_enum", {&SimpleServiceAsyncProcessor::setUpAndProcess_set_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_set_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_of_lists", {&SimpleServiceAsyncProcessor::setUpAndProcess_list_of_lists<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_list_of_lists<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"word_character_frequency", {&SimpleServiceAsyncProcessor::setUpAndProcess_word_character_frequency<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_word_character_frequency<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_of_sets", {&SimpleServiceAsyncProcessor::setUpAndProcess_list_of_sets<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_list_of_sets<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"nested_map_argument", {&SimpleServiceAsyncProcessor::setUpAndProcess_nested_map_argument<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_nested_map_argument<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"make_sentence", {&SimpleServiceAsyncProcessor::setUpAndProcess_make_sentence<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_make_sentence<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_union", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_union<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_union<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_keys", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_keys<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_keys<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"lookup_double", {&SimpleServiceAsyncProcessor::setUpAndProcess_lookup_double<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_lookup_double<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"retrieve_binary", {&SimpleServiceAsyncProcessor::setUpAndProcess_retrieve_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_retrieve_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contain_binary", {&SimpleServiceAsyncProcessor::setUpAndProcess_contain_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_contain_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contain_enum", {&SimpleServiceAsyncProcessor::setUpAndProcess_contain_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_contain_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_binary_union_struct", {&SimpleServiceAsyncProcessor::setUpAndProcess_get_binary_union_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>, &SimpleServiceAsyncProcessor::setUpAndProcess_get_binary_union_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

}} // py3::simple
