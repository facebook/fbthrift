/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/py3/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/py3/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/py3/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::AnEnum>::size;
folly::Range<::py3::simple::AnEnum const*> const TEnumTraits<::py3::simple::AnEnum>::values = folly::range(TEnumDataStorage<::py3::simple::AnEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::AnEnum>::names = folly::range(TEnumDataStorage<::py3::simple::AnEnum>::names);

char const* TEnumTraits<::py3::simple::AnEnum>::findName(type value) {
  using factory = ::py3::simple::_AnEnum_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::AnEnum>::findValue(char const* name, type* out) {
  using factory = ::py3::simple::_AnEnum_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace py3 { namespace simple {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _AnEnum_EnumMapFactory::ValuesToNamesMapType _AnEnum_VALUES_TO_NAMES = _AnEnum_EnumMapFactory::makeValuesToNamesMap();
const _AnEnum_EnumMapFactory::NamesToValuesMapType _AnEnum_NAMES_TO_VALUES = _AnEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // py3::simple

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::Flags>::size;
folly::Range<::py3::simple::Flags const*> const TEnumTraits<::py3::simple::Flags>::values = folly::range(TEnumDataStorage<::py3::simple::Flags>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::Flags>::names = folly::range(TEnumDataStorage<::py3::simple::Flags>::names);

char const* TEnumTraits<::py3::simple::Flags>::findName(type value) {
  using factory = ::py3::simple::_Flags_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::Flags>::findValue(char const* name, type* out) {
  using factory = ::py3::simple::_Flags_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace py3 { namespace simple {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _Flags_EnumMapFactory::ValuesToNamesMapType _Flags_VALUES_TO_NAMES = _Flags_EnumMapFactory::makeValuesToNamesMap();
const _Flags_EnumMapFactory::NamesToValuesMapType _Flags_NAMES_TO_VALUES = _Flags_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::SimpleException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::SimpleException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleException::SimpleException(const SimpleException&) = default;
SimpleException& SimpleException::operator=(const SimpleException&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleException::SimpleException(SimpleException&& other) noexcept  :
    err_code(std::move(other.err_code)),
    __isset(other.__isset) {}
SimpleException& SimpleException::operator=(FOLLY_MAYBE_UNUSED SimpleException&& other) noexcept {
    this->err_code = std::move(other.err_code);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleException::SimpleException(apache::thrift::FragileConstructor, ::std::int16_t err_code__arg) :
    err_code(std::move(err_code__arg)) {
  __isset.err_code = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SimpleException::__clear() {
  // clear all fields
  this->err_code = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SimpleException::operator==(const SimpleException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.err_code == rhs.err_code)) {
    return false;
  }
  return true;
}

bool SimpleException::operator<(const SimpleException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.err_code == rhs.err_code)) {
    return lhs.err_code < rhs.err_code;
  }
  return false;
}


void swap(SimpleException& a, SimpleException& b) {
  using ::std::swap;
  swap(a.err_code_ref().value(), b.err_code_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SimpleException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SimpleException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SimpleException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SimpleException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SimpleException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SimpleException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SimpleException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SimpleException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::OptionalRefStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::OptionalRefStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

OptionalRefStruct::OptionalRefStruct(const OptionalRefStruct& srcObj) {
  optional_blob = ::apache::thrift::detail::st::copy_unique<
        ::apache::thrift::type_class::binary>(srcObj.optional_blob);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.optional_blob = srcObj.__isset.optional_blob;
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

OptionalRefStruct& OptionalRefStruct::operator=(const OptionalRefStruct& src) {
  OptionalRefStruct tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
OptionalRefStruct::OptionalRefStruct(OptionalRefStruct&& other) noexcept  :
    optional_blob(std::move(other.optional_blob)),
    __isset(other.__isset) {}
OptionalRefStruct& OptionalRefStruct::operator=(FOLLY_MAYBE_UNUSED OptionalRefStruct&& other) noexcept {
    this->optional_blob = std::move(other.optional_blob);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
OptionalRefStruct::OptionalRefStruct(apache::thrift::FragileConstructor, ::py3::simple::IOBufPtr optional_blob__arg) :
    optional_blob(std::move(optional_blob__arg)) {
  __isset.optional_blob = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void OptionalRefStruct::__clear() {
  // clear all fields
  this->optional_blob = apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool OptionalRefStruct::operator==(const OptionalRefStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.optional_blob_ref().has_value() != rhs.optional_blob_ref().has_value()) {
    return false;
  }
  if (lhs.optional_blob_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(lhs.optional_blob, rhs.optional_blob)) {
      return false;
    }
  }
  return true;
}

bool OptionalRefStruct::operator<(const OptionalRefStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.optional_blob_ref().has_value() != rhs.optional_blob_ref().has_value()) {
    return lhs.optional_blob_ref().has_value() < rhs.optional_blob_ref().has_value();
  }
  if (lhs.optional_blob_ref().has_value()) {
    if (!apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(lhs.optional_blob, rhs.optional_blob)) {
      return apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isLess(lhs.optional_blob, rhs.optional_blob);
    }
  }
  return false;
}


void swap(OptionalRefStruct& a, OptionalRefStruct& b) {
  using ::std::swap;
  swap(a.optional_blob_ref().value_unchecked(), b.optional_blob_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void OptionalRefStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t OptionalRefStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t OptionalRefStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t OptionalRefStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void OptionalRefStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t OptionalRefStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t OptionalRefStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t OptionalRefStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::SimpleStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::SimpleStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleStruct::SimpleStruct(const SimpleStruct&) = default;
SimpleStruct& SimpleStruct::operator=(const SimpleStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleStruct::SimpleStruct(SimpleStruct&& other) noexcept  :
    is_on(std::move(other.is_on)),
    tiny_int(std::move(other.tiny_int)),
    small_int(std::move(other.small_int)),
    nice_sized_int(std::move(other.nice_sized_int)),
    big_int(std::move(other.big_int)),
    real(std::move(other.real)),
    smaller_real(std::move(other.smaller_real)),
    hidden_field(std::move(other.hidden_field)),
    __isset(other.__isset) {}
SimpleStruct& SimpleStruct::operator=(FOLLY_MAYBE_UNUSED SimpleStruct&& other) noexcept {
    this->is_on = std::move(other.is_on);
    this->tiny_int = std::move(other.tiny_int);
    this->small_int = std::move(other.small_int);
    this->nice_sized_int = std::move(other.nice_sized_int);
    this->big_int = std::move(other.big_int);
    this->real = std::move(other.real);
    this->smaller_real = std::move(other.smaller_real);
    this->hidden_field = std::move(other.hidden_field);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SimpleStruct::SimpleStruct(apache::thrift::FragileConstructor, bool is_on__arg, ::std::int8_t tiny_int__arg, ::std::int16_t small_int__arg, ::std::int32_t nice_sized_int__arg, ::std::int64_t big_int__arg, double real__arg, float smaller_real__arg, ::std::int16_t hidden_field__arg) :
    is_on(std::move(is_on__arg)),
    tiny_int(std::move(tiny_int__arg)),
    small_int(std::move(small_int__arg)),
    nice_sized_int(std::move(nice_sized_int__arg)),
    big_int(std::move(big_int__arg)),
    real(std::move(real__arg)),
    smaller_real(std::move(smaller_real__arg)),
    hidden_field(std::move(hidden_field__arg)) {
  __isset.is_on = true;
  __isset.tiny_int = true;
  __isset.small_int = true;
  __isset.nice_sized_int = true;
  __isset.big_int = true;
  __isset.real = true;
  __isset.smaller_real = true;
  __isset.hidden_field = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SimpleStruct::__clear() {
  // clear all fields
  this->is_on = 0;
  this->tiny_int = 0;
  this->small_int = 0;
  this->nice_sized_int = 0;
  this->big_int = 0;
  this->real = 0;
  this->smaller_real = 0;
  this->hidden_field = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SimpleStruct::operator==(const SimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_on == rhs.is_on)) {
    return false;
  }
  if (!(lhs.tiny_int == rhs.tiny_int)) {
    return false;
  }
  if (!(lhs.small_int == rhs.small_int)) {
    return false;
  }
  if (!(lhs.nice_sized_int == rhs.nice_sized_int)) {
    return false;
  }
  if (!(lhs.big_int == rhs.big_int)) {
    return false;
  }
  if (!(lhs.real == rhs.real)) {
    return false;
  }
  if (!(lhs.smaller_real == rhs.smaller_real)) {
    return false;
  }
  if (!(lhs.hidden_field == rhs.hidden_field)) {
    return false;
  }
  return true;
}

bool SimpleStruct::operator<(const SimpleStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.is_on == rhs.is_on)) {
    return lhs.is_on < rhs.is_on;
  }
  if (!(lhs.tiny_int == rhs.tiny_int)) {
    return lhs.tiny_int < rhs.tiny_int;
  }
  if (!(lhs.small_int == rhs.small_int)) {
    return lhs.small_int < rhs.small_int;
  }
  if (!(lhs.nice_sized_int == rhs.nice_sized_int)) {
    return lhs.nice_sized_int < rhs.nice_sized_int;
  }
  if (!(lhs.big_int == rhs.big_int)) {
    return lhs.big_int < rhs.big_int;
  }
  if (!(lhs.real == rhs.real)) {
    return lhs.real < rhs.real;
  }
  if (!(lhs.smaller_real == rhs.smaller_real)) {
    return lhs.smaller_real < rhs.smaller_real;
  }
  if (!(lhs.hidden_field == rhs.hidden_field)) {
    return lhs.hidden_field < rhs.hidden_field;
  }
  return false;
}


void swap(SimpleStruct& a, SimpleStruct& b) {
  using ::std::swap;
  swap(a.is_on_ref().value(), b.is_on_ref().value());
  swap(a.tiny_int_ref().value(), b.tiny_int_ref().value());
  swap(a.small_int_ref().value(), b.small_int_ref().value());
  swap(a.nice_sized_int_ref().value(), b.nice_sized_int_ref().value());
  swap(a.big_int_ref().value(), b.big_int_ref().value());
  swap(a.real_ref().value(), b.real_ref().value());
  swap(a.smaller_real_ref().value(), b.smaller_real_ref().value());
  swap(a.hidden_field_ref().value(), b.hidden_field_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SimpleStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SimpleStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SimpleStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SimpleStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SimpleStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SimpleStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SimpleStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SimpleStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::ComplexStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::ComplexStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexStruct::ComplexStruct(const ComplexStruct&) = default;
ComplexStruct& ComplexStruct::operator=(const ComplexStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexStruct::ComplexStruct() :
      an_integer(0),
      an_enum( ::py3::simple::AnEnum::None) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

ComplexStruct::~ComplexStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexStruct::ComplexStruct(ComplexStruct&& other) noexcept  :
    structOne(std::move(other.structOne)),
    structTwo(std::move(other.structTwo)),
    an_integer(std::move(other.an_integer)),
    name(std::move(other.name)),
    an_enum(std::move(other.an_enum)),
    some_bytes(std::move(other.some_bytes)),
    from(std::move(other.from)),
    cdef(std::move(other.cdef)),
    bytes_with_cpp_type(std::move(other.bytes_with_cpp_type)),
    __isset(other.__isset) {}
ComplexStruct& ComplexStruct::operator=(FOLLY_MAYBE_UNUSED ComplexStruct&& other) noexcept {
    this->structOne = std::move(other.structOne);
    this->structTwo = std::move(other.structTwo);
    this->an_integer = std::move(other.an_integer);
    this->name = std::move(other.name);
    this->an_enum = std::move(other.an_enum);
    this->some_bytes = std::move(other.some_bytes);
    this->from = std::move(other.from);
    this->cdef = std::move(other.cdef);
    this->bytes_with_cpp_type = std::move(other.bytes_with_cpp_type);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ComplexStruct::ComplexStruct(apache::thrift::FragileConstructor, ::py3::simple::SimpleStruct structOne__arg, ::py3::simple::SimpleStruct structTwo__arg, ::std::int32_t an_integer__arg, ::std::string name__arg, ::py3::simple::AnEnum an_enum__arg, ::std::string some_bytes__arg, ::std::string from__arg, ::std::string cdef__arg, ::py3::simple::foo_bar bytes_with_cpp_type__arg) :
    structOne(std::move(structOne__arg)),
    structTwo(std::move(structTwo__arg)),
    an_integer(std::move(an_integer__arg)),
    name(std::move(name__arg)),
    an_enum(std::move(an_enum__arg)),
    some_bytes(std::move(some_bytes__arg)),
    from(std::move(from__arg)),
    cdef(std::move(cdef__arg)),
    bytes_with_cpp_type(std::move(bytes_with_cpp_type__arg)) {
  __isset.structOne = true;
  __isset.structTwo = true;
  __isset.an_integer = true;
  __isset.name = true;
  __isset.an_enum = true;
  __isset.some_bytes = true;
  __isset.from = true;
  __isset.cdef = true;
  __isset.bytes_with_cpp_type = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ComplexStruct::__clear() {
  // clear all fields
  this->structOne.__clear();
  this->structTwo.__clear();
  this->an_integer = 0;
  this->name = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->an_enum =  ::py3::simple::AnEnum::None;
  this->some_bytes = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->from = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->cdef = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->bytes_with_cpp_type = apache::thrift::StringTraits<foo::Bar>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ComplexStruct::operator==(const ComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.structOne == rhs.structOne)) {
    return false;
  }
  if (!(lhs.structTwo == rhs.structTwo)) {
    return false;
  }
  if (!(lhs.an_integer == rhs.an_integer)) {
    return false;
  }
  if (!(lhs.name == rhs.name)) {
    return false;
  }
  if (!(lhs.an_enum == rhs.an_enum)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.some_bytes, rhs.some_bytes)) {
    return false;
  }
  if (!(lhs.from == rhs.from)) {
    return false;
  }
  if (!(lhs.cdef == rhs.cdef)) {
    return false;
  }
  if (!apache::thrift::StringTraits<foo::Bar>::isEqual(lhs.bytes_with_cpp_type, rhs.bytes_with_cpp_type)) {
    return false;
  }
  return true;
}

bool ComplexStruct::operator<(const ComplexStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.structOne == rhs.structOne)) {
    return lhs.structOne < rhs.structOne;
  }
  if (!(lhs.structTwo == rhs.structTwo)) {
    return lhs.structTwo < rhs.structTwo;
  }
  if (!(lhs.an_integer == rhs.an_integer)) {
    return lhs.an_integer < rhs.an_integer;
  }
  if (!(lhs.name == rhs.name)) {
    return lhs.name < rhs.name;
  }
  if (!(lhs.an_enum == rhs.an_enum)) {
    return lhs.an_enum < rhs.an_enum;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.some_bytes, rhs.some_bytes)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.some_bytes, rhs.some_bytes);
  }
  if (!(lhs.from == rhs.from)) {
    return lhs.from < rhs.from;
  }
  if (!(lhs.cdef == rhs.cdef)) {
    return lhs.cdef < rhs.cdef;
  }
  if (!apache::thrift::StringTraits<foo::Bar>::isEqual(lhs.bytes_with_cpp_type, rhs.bytes_with_cpp_type)) {
    return apache::thrift::StringTraits<foo::Bar>::isLess(lhs.bytes_with_cpp_type, rhs.bytes_with_cpp_type);
  }
  return false;
}

const ::py3::simple::SimpleStruct& ComplexStruct::get_structOne() const& {
  return structOne;
}

::py3::simple::SimpleStruct ComplexStruct::get_structOne() && {
  return std::move(structOne);
}

const ::py3::simple::SimpleStruct& ComplexStruct::get_structTwo() const& {
  return structTwo;
}

::py3::simple::SimpleStruct ComplexStruct::get_structTwo() && {
  return std::move(structTwo);
}


void swap(ComplexStruct& a, ComplexStruct& b) {
  using ::std::swap;
  swap(a.structOne_ref().value(), b.structOne_ref().value());
  swap(a.structTwo_ref().value(), b.structTwo_ref().value());
  swap(a.an_integer_ref().value(), b.an_integer_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.an_enum_ref().value(), b.an_enum_ref().value());
  swap(a.some_bytes_ref().value(), b.some_bytes_ref().value());
  swap(a.from_ref().value(), b.from_ref().value());
  swap(a.cdef_ref().value(), b.cdef_ref().value());
  swap(a.bytes_with_cpp_type_ref().value(), b.bytes_with_cpp_type_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ComplexStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ComplexStruct,
        ::apache::thrift::type_class::structure,
        ::py3::simple::SimpleStruct>,
    "inconsistent use of nimble option");

}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::BinaryUnion>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::BinaryUnion>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::py3::simple::BinaryUnion::Type>::size;
folly::Range<::py3::simple::BinaryUnion::Type const*> const TEnumTraits<::py3::simple::BinaryUnion::Type>::values = folly::range(TEnumDataStorage<::py3::simple::BinaryUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::py3::simple::BinaryUnion::Type>::names = folly::range(TEnumDataStorage<::py3::simple::BinaryUnion::Type>::names);

char const* TEnumTraits<::py3::simple::BinaryUnion::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::py3::simple::BinaryUnion::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::py3::simple::BinaryUnion::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::py3::simple::BinaryUnion::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace py3 { namespace simple {

void BinaryUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::iobuf_val:
      destruct(value_.iobuf_val);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}


void swap(BinaryUnion& a, BinaryUnion& b) {
  BinaryUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void BinaryUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BinaryUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BinaryUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BinaryUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BinaryUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BinaryUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BinaryUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BinaryUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // py3::simple

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::py3::simple::BinaryUnionStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::py3::simple::BinaryUnionStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace py3 { namespace simple {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BinaryUnionStruct::BinaryUnionStruct(const BinaryUnionStruct&) = default;
BinaryUnionStruct& BinaryUnionStruct::operator=(const BinaryUnionStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BinaryUnionStruct::BinaryUnionStruct(BinaryUnionStruct&& other) noexcept  :
    u(std::move(other.u)),
    __isset(other.__isset) {}
BinaryUnionStruct& BinaryUnionStruct::operator=(FOLLY_MAYBE_UNUSED BinaryUnionStruct&& other) noexcept {
    this->u = std::move(other.u);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BinaryUnionStruct::BinaryUnionStruct(apache::thrift::FragileConstructor, ::py3::simple::BinaryUnion u__arg) :
    u(std::move(u__arg)) {
  __isset.u = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BinaryUnionStruct::__clear() {
  // clear all fields
  this->u.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}



const ::py3::simple::BinaryUnion& BinaryUnionStruct::get_u() const& {
  return u;
}

::py3::simple::BinaryUnion BinaryUnionStruct::get_u() && {
  return std::move(u);
}


void swap(BinaryUnionStruct& a, BinaryUnionStruct& b) {
  using ::std::swap;
  swap(a.u_ref().value(), b.u_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BinaryUnionStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BinaryUnionStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BinaryUnionStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BinaryUnionStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BinaryUnionStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BinaryUnionStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BinaryUnionStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BinaryUnionStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BinaryUnionStruct,
        ::apache::thrift::type_class::variant,
        ::py3::simple::BinaryUnion>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BinaryUnionStruct,
        ::apache::thrift::type_class::variant,
        ::py3::simple::BinaryUnion>,
    "inconsistent use of nimble option");

}} // py3::simple
