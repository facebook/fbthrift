/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct err_code;
struct optional_blob;
struct is_on;
struct tiny_int;
struct small_int;
struct nice_sized_int;
struct big_int;
struct real;
struct smaller_real;
struct hidden_field;
struct structOne;
struct structTwo;
struct an_integer;
struct name;
struct an_enum;
struct some_bytes;
struct from;
struct cdef;
struct bytes_with_cpp_type;
struct iobuf_val;
struct u;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_err_code
#define APACHE_THRIFT_ACCESSOR_err_code
APACHE_THRIFT_DEFINE_ACCESSOR(err_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optional_blob
#define APACHE_THRIFT_ACCESSOR_optional_blob
APACHE_THRIFT_DEFINE_ACCESSOR(optional_blob);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_on
#define APACHE_THRIFT_ACCESSOR_is_on
APACHE_THRIFT_DEFINE_ACCESSOR(is_on);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tiny_int
#define APACHE_THRIFT_ACCESSOR_tiny_int
APACHE_THRIFT_DEFINE_ACCESSOR(tiny_int);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_small_int
#define APACHE_THRIFT_ACCESSOR_small_int
APACHE_THRIFT_DEFINE_ACCESSOR(small_int);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_nice_sized_int
#define APACHE_THRIFT_ACCESSOR_nice_sized_int
APACHE_THRIFT_DEFINE_ACCESSOR(nice_sized_int);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_big_int
#define APACHE_THRIFT_ACCESSOR_big_int
APACHE_THRIFT_DEFINE_ACCESSOR(big_int);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_real
#define APACHE_THRIFT_ACCESSOR_real
APACHE_THRIFT_DEFINE_ACCESSOR(real);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_smaller_real
#define APACHE_THRIFT_ACCESSOR_smaller_real
APACHE_THRIFT_DEFINE_ACCESSOR(smaller_real);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hidden_field
#define APACHE_THRIFT_ACCESSOR_hidden_field
APACHE_THRIFT_DEFINE_ACCESSOR(hidden_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structOne
#define APACHE_THRIFT_ACCESSOR_structOne
APACHE_THRIFT_DEFINE_ACCESSOR(structOne);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structTwo
#define APACHE_THRIFT_ACCESSOR_structTwo
APACHE_THRIFT_DEFINE_ACCESSOR(structTwo);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_an_integer
#define APACHE_THRIFT_ACCESSOR_an_integer
APACHE_THRIFT_DEFINE_ACCESSOR(an_integer);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_an_enum
#define APACHE_THRIFT_ACCESSOR_an_enum
APACHE_THRIFT_DEFINE_ACCESSOR(an_enum);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_some_bytes
#define APACHE_THRIFT_ACCESSOR_some_bytes
APACHE_THRIFT_DEFINE_ACCESSOR(some_bytes);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_from
#define APACHE_THRIFT_ACCESSOR_from
APACHE_THRIFT_DEFINE_ACCESSOR(from);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cdef
#define APACHE_THRIFT_ACCESSOR_cdef
APACHE_THRIFT_DEFINE_ACCESSOR(cdef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_bytes_with_cpp_type
#define APACHE_THRIFT_ACCESSOR_bytes_with_cpp_type
APACHE_THRIFT_DEFINE_ACCESSOR(bytes_with_cpp_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_val
#define APACHE_THRIFT_ACCESSOR_iobuf_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_u
#define APACHE_THRIFT_ACCESSOR_u
APACHE_THRIFT_DEFINE_ACCESSOR(u);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace py3 { namespace simple {

enum class AnEnum {
  None = 0,
  ONE = 1,
  TWO = 2,
  THREE = 3,
  FOUR = 4,
};




enum class Flags {
  flag_A = 1,
  flag_B = 2,
  flag_C = 4,
  flag_D = 8,
};




}} // py3::simple

namespace std {
template<> struct hash<::py3::simple::AnEnum> :
  ::apache::thrift::detail::enum_hash<::py3::simple::AnEnum> {};
template<> struct hash<::py3::simple::Flags> :
  ::apache::thrift::detail::enum_hash<::py3::simple::Flags> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::py3::simple::AnEnum>;

template <> struct TEnumTraits<::py3::simple::AnEnum> {
  using type = ::py3::simple::AnEnum;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::None; }
  static constexpr type max() { return type::FOUR; }
};


template <> struct TEnumDataStorage<::py3::simple::Flags>;

template <> struct TEnumTraits<::py3::simple::Flags> {
  using type = ::py3::simple::Flags;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::flag_A; }
  static constexpr type max() { return type::flag_D; }
};


}} // apache::thrift

namespace py3 { namespace simple {

using _AnEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnEnum>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AnEnum_EnumMapFactory::ValuesToNamesMapType _AnEnum_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AnEnum_EnumMapFactory::NamesToValuesMapType _AnEnum_NAMES_TO_VALUES;

using _Flags_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<Flags>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _Flags_EnumMapFactory::ValuesToNamesMapType _Flags_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _Flags_EnumMapFactory::NamesToValuesMapType _Flags_NAMES_TO_VALUES;

}} // py3::simple

// END declare_enums
// BEGIN forward_declare
namespace py3 { namespace simple {
class SimpleException;
class OptionalRefStruct;
class SimpleStruct;
class ComplexStruct;
class BinaryUnion;
class BinaryUnionStruct;
}} // py3::simple
// END forward_declare
// BEGIN typedefs
namespace py3 { namespace simple {
typedef std::unique_ptr<folly::IOBuf> IOBufPtr;
typedef folly::IOBuf IOBuf;
typedef foo::Bar foo_bar;

}} // py3::simple
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FOLLY_EXPORT SimpleException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = SimpleException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SimpleException();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SimpleException(apache::thrift::FragileConstructor, ::std::int16_t err_code__arg);

  SimpleException(SimpleException&&) noexcept;

  SimpleException(const SimpleException& src);


  SimpleException& operator=(SimpleException&&) noexcept;
  SimpleException& operator=(const SimpleException& src);
  void __clear();

  ~SimpleException() override;

 private:
  ::std::int16_t err_code;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool err_code;
  } __isset = {};

 public:

  bool operator==(const SimpleException&) const;
  bool operator<(const SimpleException&) const;

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> err_code_ref() const& {
    return {this->err_code, __isset.err_code};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> err_code_ref() const&& {
    return {std::move(this->err_code), __isset.err_code};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> err_code_ref() & {
    return {this->err_code, __isset.err_code};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> err_code_ref() && {
    return {std::move(this->err_code), __isset.err_code};
  }

  ::std::int16_t get_err_code() const {
    return err_code;
  }

  [[deprecated("Use `FOO.err_code_ref() = BAR;` instead of `FOO.set_err_code(BAR);`")]]
  ::std::int16_t& set_err_code(::std::int16_t err_code_) {
    err_code = err_code_;
    __isset.err_code = true;
    return err_code;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::py3::simple::SimpleException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SimpleException>;
  friend void swap(SimpleException& a, SimpleException& b);
};

template <class Protocol_>
uint32_t SimpleException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class OptionalRefStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = OptionalRefStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  OptionalRefStruct() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  OptionalRefStruct(apache::thrift::FragileConstructor, ::py3::simple::IOBufPtr optional_blob__arg);

  OptionalRefStruct(OptionalRefStruct&&) noexcept;
  OptionalRefStruct(const OptionalRefStruct& src);


  OptionalRefStruct& operator=(OptionalRefStruct&&) noexcept;
  OptionalRefStruct& operator=(const OptionalRefStruct& src);
  void __clear();
 public:
  ::py3::simple::IOBufPtr optional_blob;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool optional_blob;
  } __isset = {};

 public:

  bool operator==(const OptionalRefStruct&) const;
  bool operator<(const OptionalRefStruct&) const;

  template <typename..., typename T = ::py3::simple::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optional_blob_ref() const& {
    return {this->optional_blob, __isset.optional_blob};
  }

  template <typename..., typename T = ::py3::simple::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optional_blob_ref() const&& {
    return {std::move(this->optional_blob), __isset.optional_blob};
  }

  template <typename..., typename T = ::py3::simple::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optional_blob_ref() & {
    return {this->optional_blob, __isset.optional_blob};
  }

  template <typename..., typename T = ::py3::simple::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optional_blob_ref() && {
    return {std::move(this->optional_blob), __isset.optional_blob};
  }

  const ::py3::simple::IOBufPtr* get_optional_blob() const& {
    return optional_blob_ref() ? std::addressof(optional_blob) : nullptr;
  }

  ::py3::simple::IOBufPtr* get_optional_blob() & {
    return optional_blob_ref() ? std::addressof(optional_blob) : nullptr;
  }
  ::py3::simple::IOBufPtr* get_optional_blob() && = delete;

  template <typename T_OptionalRefStruct_optional_blob_struct_setter = ::py3::simple::IOBufPtr>
  [[deprecated("Use `FOO.optional_blob_ref() = BAR;` instead of `FOO.set_optional_blob(BAR);`")]]
  ::py3::simple::IOBufPtr& set_optional_blob(T_OptionalRefStruct_optional_blob_struct_setter&& optional_blob_) {
    optional_blob = std::forward<T_OptionalRefStruct_optional_blob_struct_setter>(optional_blob_);
    __isset.optional_blob = true;
    return optional_blob;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<OptionalRefStruct>;
  friend void swap(OptionalRefStruct& a, OptionalRefStruct& b);
};

template <class Protocol_>
uint32_t OptionalRefStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class SimpleStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SimpleStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SimpleStruct() :
      is_on(0),
      tiny_int(0),
      small_int(0),
      nice_sized_int(0),
      big_int(0),
      real(0),
      smaller_real(0),
      hidden_field(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SimpleStruct(apache::thrift::FragileConstructor, bool is_on__arg, ::std::int8_t tiny_int__arg, ::std::int16_t small_int__arg, ::std::int32_t nice_sized_int__arg, ::std::int64_t big_int__arg, double real__arg, float smaller_real__arg, ::std::int16_t hidden_field__arg);

  SimpleStruct(SimpleStruct&&) noexcept;

  SimpleStruct(const SimpleStruct& src);


  SimpleStruct& operator=(SimpleStruct&&) noexcept;
  SimpleStruct& operator=(const SimpleStruct& src);
  void __clear();
 private:
  bool is_on;
 private:
  ::std::int8_t tiny_int;
 private:
  ::std::int16_t small_int;
 private:
  ::std::int32_t nice_sized_int;
 private:
  ::std::int64_t big_int;
 private:
  double real;
 private:
  float smaller_real;
 private:
  ::std::int16_t hidden_field;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool is_on;
    bool tiny_int;
    bool small_int;
    bool nice_sized_int;
    bool big_int;
    bool real;
    bool smaller_real;
    bool hidden_field;
  } __isset = {};

 public:

  bool operator==(const SimpleStruct&) const;
  bool operator<(const SimpleStruct&) const;

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_on_ref() const& {
    return {this->is_on, __isset.is_on};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_on_ref() const&& {
    return {std::move(this->is_on), __isset.is_on};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_on_ref() & {
    return {this->is_on, __isset.is_on};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_on_ref() && {
    return {std::move(this->is_on), __isset.is_on};
  }

  template <typename..., typename T = ::std::int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tiny_int_ref() const& {
    return {this->tiny_int, __isset.tiny_int};
  }

  template <typename..., typename T = ::std::int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tiny_int_ref() const&& {
    return {std::move(this->tiny_int), __isset.tiny_int};
  }

  template <typename..., typename T = ::std::int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tiny_int_ref() & {
    return {this->tiny_int, __isset.tiny_int};
  }

  template <typename..., typename T = ::std::int8_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tiny_int_ref() && {
    return {std::move(this->tiny_int), __isset.tiny_int};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> small_int_ref() const& {
    return {this->small_int, __isset.small_int};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> small_int_ref() const&& {
    return {std::move(this->small_int), __isset.small_int};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> small_int_ref() & {
    return {this->small_int, __isset.small_int};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> small_int_ref() && {
    return {std::move(this->small_int), __isset.small_int};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> nice_sized_int_ref() const& {
    return {this->nice_sized_int, __isset.nice_sized_int};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> nice_sized_int_ref() const&& {
    return {std::move(this->nice_sized_int), __isset.nice_sized_int};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> nice_sized_int_ref() & {
    return {this->nice_sized_int, __isset.nice_sized_int};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> nice_sized_int_ref() && {
    return {std::move(this->nice_sized_int), __isset.nice_sized_int};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> big_int_ref() const& {
    return {this->big_int, __isset.big_int};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> big_int_ref() const&& {
    return {std::move(this->big_int), __isset.big_int};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> big_int_ref() & {
    return {this->big_int, __isset.big_int};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> big_int_ref() && {
    return {std::move(this->big_int), __isset.big_int};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> real_ref() const& {
    return {this->real, __isset.real};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> real_ref() const&& {
    return {std::move(this->real), __isset.real};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> real_ref() & {
    return {this->real, __isset.real};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> real_ref() && {
    return {std::move(this->real), __isset.real};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> smaller_real_ref() const& {
    return {this->smaller_real, __isset.smaller_real};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> smaller_real_ref() const&& {
    return {std::move(this->smaller_real), __isset.smaller_real};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> smaller_real_ref() & {
    return {this->smaller_real, __isset.smaller_real};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> smaller_real_ref() && {
    return {std::move(this->smaller_real), __isset.smaller_real};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> hidden_field_ref() const& {
    return {this->hidden_field, __isset.hidden_field};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> hidden_field_ref() const&& {
    return {std::move(this->hidden_field), __isset.hidden_field};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> hidden_field_ref() & {
    return {this->hidden_field, __isset.hidden_field};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> hidden_field_ref() && {
    return {std::move(this->hidden_field), __isset.hidden_field};
  }

  bool get_is_on() const {
    return is_on;
  }

  [[deprecated("Use `FOO.is_on_ref() = BAR;` instead of `FOO.set_is_on(BAR);`")]]
  bool& set_is_on(bool is_on_) {
    is_on = is_on_;
    __isset.is_on = true;
    return is_on;
  }

  ::std::int8_t get_tiny_int() const {
    return tiny_int;
  }

  [[deprecated("Use `FOO.tiny_int_ref() = BAR;` instead of `FOO.set_tiny_int(BAR);`")]]
  ::std::int8_t& set_tiny_int(::std::int8_t tiny_int_) {
    tiny_int = tiny_int_;
    __isset.tiny_int = true;
    return tiny_int;
  }

  ::std::int16_t get_small_int() const {
    return small_int;
  }

  [[deprecated("Use `FOO.small_int_ref() = BAR;` instead of `FOO.set_small_int(BAR);`")]]
  ::std::int16_t& set_small_int(::std::int16_t small_int_) {
    small_int = small_int_;
    __isset.small_int = true;
    return small_int;
  }

  ::std::int32_t get_nice_sized_int() const {
    return nice_sized_int;
  }

  [[deprecated("Use `FOO.nice_sized_int_ref() = BAR;` instead of `FOO.set_nice_sized_int(BAR);`")]]
  ::std::int32_t& set_nice_sized_int(::std::int32_t nice_sized_int_) {
    nice_sized_int = nice_sized_int_;
    __isset.nice_sized_int = true;
    return nice_sized_int;
  }

  ::std::int64_t get_big_int() const {
    return big_int;
  }

  [[deprecated("Use `FOO.big_int_ref() = BAR;` instead of `FOO.set_big_int(BAR);`")]]
  ::std::int64_t& set_big_int(::std::int64_t big_int_) {
    big_int = big_int_;
    __isset.big_int = true;
    return big_int;
  }

  double get_real() const {
    return real;
  }

  [[deprecated("Use `FOO.real_ref() = BAR;` instead of `FOO.set_real(BAR);`")]]
  double& set_real(double real_) {
    real = real_;
    __isset.real = true;
    return real;
  }

  float get_smaller_real() const {
    return smaller_real;
  }

  [[deprecated("Use `FOO.smaller_real_ref() = BAR;` instead of `FOO.set_smaller_real(BAR);`")]]
  float& set_smaller_real(float smaller_real_) {
    smaller_real = smaller_real_;
    __isset.smaller_real = true;
    return smaller_real;
  }

  ::std::int16_t get_hidden_field() const {
    return hidden_field;
  }

  [[deprecated("Use `FOO.hidden_field_ref() = BAR;` instead of `FOO.set_hidden_field(BAR);`")]]
  ::std::int16_t& set_hidden_field(::std::int16_t hidden_field_) {
    hidden_field = hidden_field_;
    __isset.hidden_field = true;
    return hidden_field;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SimpleStruct>;
  friend void swap(SimpleStruct& a, SimpleStruct& b);
};

template <class Protocol_>
uint32_t SimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class ComplexStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ComplexStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ComplexStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexStruct(apache::thrift::FragileConstructor, ::py3::simple::SimpleStruct structOne__arg, ::py3::simple::SimpleStruct structTwo__arg, ::std::int32_t an_integer__arg, ::std::string name__arg, ::py3::simple::AnEnum an_enum__arg, ::std::string some_bytes__arg, ::std::string from__arg, ::std::string cdef__arg, ::py3::simple::foo_bar bytes_with_cpp_type__arg);

  ComplexStruct(ComplexStruct&&) noexcept;

  ComplexStruct(const ComplexStruct& src);


  ComplexStruct& operator=(ComplexStruct&&) noexcept;
  ComplexStruct& operator=(const ComplexStruct& src);
  void __clear();

  ~ComplexStruct();

 private:
  ::py3::simple::SimpleStruct structOne;
 private:
  ::py3::simple::SimpleStruct structTwo;
 private:
  ::std::int32_t an_integer;
 private:
  ::std::string name;
 private:
  ::py3::simple::AnEnum an_enum;
 private:
  ::std::string some_bytes;
 private:
  ::std::string from;
 private:
  ::std::string cdef;
 private:
  ::py3::simple::foo_bar bytes_with_cpp_type;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool structOne;
    bool structTwo;
    bool an_integer;
    bool name;
    bool an_enum;
    bool some_bytes;
    bool from;
    bool cdef;
    bool bytes_with_cpp_type;
  } __isset = {};

 public:

  bool operator==(const ComplexStruct&) const;
  bool operator<(const ComplexStruct&) const;

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structOne_ref() const& {
    return {this->structOne, __isset.structOne};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structOne_ref() const&& {
    return {std::move(this->structOne), __isset.structOne};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structOne_ref() & {
    return {this->structOne, __isset.structOne};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structOne_ref() && {
    return {std::move(this->structOne), __isset.structOne};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structTwo_ref() const& {
    return {this->structTwo, __isset.structTwo};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structTwo_ref() const&& {
    return {std::move(this->structTwo), __isset.structTwo};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structTwo_ref() & {
    return {this->structTwo, __isset.structTwo};
  }

  template <typename..., typename T = ::py3::simple::SimpleStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structTwo_ref() && {
    return {std::move(this->structTwo), __isset.structTwo};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> an_integer_ref() const& {
    return {this->an_integer, __isset.an_integer};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> an_integer_ref() const&& {
    return {std::move(this->an_integer), __isset.an_integer};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> an_integer_ref() & {
    return {this->an_integer, __isset.an_integer};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> an_integer_ref() && {
    return {std::move(this->an_integer), __isset.an_integer};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::py3::simple::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> an_enum_ref() const& {
    return {this->an_enum, __isset.an_enum};
  }

  template <typename..., typename T = ::py3::simple::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> an_enum_ref() const&& {
    return {std::move(this->an_enum), __isset.an_enum};
  }

  template <typename..., typename T = ::py3::simple::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> an_enum_ref() & {
    return {this->an_enum, __isset.an_enum};
  }

  template <typename..., typename T = ::py3::simple::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> an_enum_ref() && {
    return {std::move(this->an_enum), __isset.an_enum};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> some_bytes_ref() const& {
    return {this->some_bytes, __isset.some_bytes};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> some_bytes_ref() const&& {
    return {std::move(this->some_bytes), __isset.some_bytes};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> some_bytes_ref() & {
    return {this->some_bytes, __isset.some_bytes};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> some_bytes_ref() && {
    return {std::move(this->some_bytes), __isset.some_bytes};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> from_ref() const& {
    return {this->from, __isset.from};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> from_ref() const&& {
    return {std::move(this->from), __isset.from};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> from_ref() & {
    return {this->from, __isset.from};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> from_ref() && {
    return {std::move(this->from), __isset.from};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> cdef_ref() const& {
    return {this->cdef, __isset.cdef};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> cdef_ref() const&& {
    return {std::move(this->cdef), __isset.cdef};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> cdef_ref() & {
    return {this->cdef, __isset.cdef};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> cdef_ref() && {
    return {std::move(this->cdef), __isset.cdef};
  }

  template <typename..., typename T = ::py3::simple::foo_bar>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> bytes_with_cpp_type_ref() const& {
    return {this->bytes_with_cpp_type, __isset.bytes_with_cpp_type};
  }

  template <typename..., typename T = ::py3::simple::foo_bar>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> bytes_with_cpp_type_ref() const&& {
    return {std::move(this->bytes_with_cpp_type), __isset.bytes_with_cpp_type};
  }

  template <typename..., typename T = ::py3::simple::foo_bar>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> bytes_with_cpp_type_ref() & {
    return {this->bytes_with_cpp_type, __isset.bytes_with_cpp_type};
  }

  template <typename..., typename T = ::py3::simple::foo_bar>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> bytes_with_cpp_type_ref() && {
    return {std::move(this->bytes_with_cpp_type), __isset.bytes_with_cpp_type};
  }
  const ::py3::simple::SimpleStruct& get_structOne() const&;
  ::py3::simple::SimpleStruct get_structOne() &&;

  template <typename T_ComplexStruct_structOne_struct_setter = ::py3::simple::SimpleStruct>
  [[deprecated("Use `FOO.structOne_ref() = BAR;` instead of `FOO.set_structOne(BAR);`")]]
  ::py3::simple::SimpleStruct& set_structOne(T_ComplexStruct_structOne_struct_setter&& structOne_) {
    structOne = std::forward<T_ComplexStruct_structOne_struct_setter>(structOne_);
    __isset.structOne = true;
    return structOne;
  }
  const ::py3::simple::SimpleStruct& get_structTwo() const&;
  ::py3::simple::SimpleStruct get_structTwo() &&;

  template <typename T_ComplexStruct_structTwo_struct_setter = ::py3::simple::SimpleStruct>
  [[deprecated("Use `FOO.structTwo_ref() = BAR;` instead of `FOO.set_structTwo(BAR);`")]]
  ::py3::simple::SimpleStruct& set_structTwo(T_ComplexStruct_structTwo_struct_setter&& structTwo_) {
    structTwo = std::forward<T_ComplexStruct_structTwo_struct_setter>(structTwo_);
    __isset.structTwo = true;
    return structTwo;
  }

  ::std::int32_t get_an_integer() const {
    return an_integer;
  }

  [[deprecated("Use `FOO.an_integer_ref() = BAR;` instead of `FOO.set_an_integer(BAR);`")]]
  ::std::int32_t& set_an_integer(::std::int32_t an_integer_) {
    an_integer = an_integer_;
    __isset.an_integer = true;
    return an_integer;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ComplexStruct_name_struct_setter = ::std::string>
  [[deprecated("Use `FOO.name_ref() = BAR;` instead of `FOO.set_name(BAR);`")]]
  ::std::string& set_name(T_ComplexStruct_name_struct_setter&& name_) {
    name = std::forward<T_ComplexStruct_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  ::py3::simple::AnEnum get_an_enum() const {
    return an_enum;
  }

  [[deprecated("Use `FOO.an_enum_ref() = BAR;` instead of `FOO.set_an_enum(BAR);`")]]
  ::py3::simple::AnEnum& set_an_enum(::py3::simple::AnEnum an_enum_) {
    an_enum = an_enum_;
    __isset.an_enum = true;
    return an_enum;
  }

  const ::std::string& get_some_bytes() const& {
    return some_bytes;
  }

  ::std::string get_some_bytes() && {
    return std::move(some_bytes);
  }

  template <typename T_ComplexStruct_some_bytes_struct_setter = ::std::string>
  [[deprecated("Use `FOO.some_bytes_ref() = BAR;` instead of `FOO.set_some_bytes(BAR);`")]]
  ::std::string& set_some_bytes(T_ComplexStruct_some_bytes_struct_setter&& some_bytes_) {
    some_bytes = std::forward<T_ComplexStruct_some_bytes_struct_setter>(some_bytes_);
    __isset.some_bytes = true;
    return some_bytes;
  }

  const ::std::string& get_from() const& {
    return from;
  }

  ::std::string get_from() && {
    return std::move(from);
  }

  template <typename T_ComplexStruct_from_struct_setter = ::std::string>
  [[deprecated("Use `FOO.from_ref() = BAR;` instead of `FOO.set_from(BAR);`")]]
  ::std::string& set_from(T_ComplexStruct_from_struct_setter&& from_) {
    from = std::forward<T_ComplexStruct_from_struct_setter>(from_);
    __isset.from = true;
    return from;
  }

  const ::std::string& get_cdef() const& {
    return cdef;
  }

  ::std::string get_cdef() && {
    return std::move(cdef);
  }

  template <typename T_ComplexStruct_cdef_struct_setter = ::std::string>
  [[deprecated("Use `FOO.cdef_ref() = BAR;` instead of `FOO.set_cdef(BAR);`")]]
  ::std::string& set_cdef(T_ComplexStruct_cdef_struct_setter&& cdef_) {
    cdef = std::forward<T_ComplexStruct_cdef_struct_setter>(cdef_);
    __isset.cdef = true;
    return cdef;
  }

  const ::py3::simple::foo_bar& get_bytes_with_cpp_type() const& {
    return bytes_with_cpp_type;
  }

  ::py3::simple::foo_bar get_bytes_with_cpp_type() && {
    return std::move(bytes_with_cpp_type);
  }

  template <typename T_ComplexStruct_bytes_with_cpp_type_struct_setter = ::py3::simple::foo_bar>
  [[deprecated("Use `FOO.bytes_with_cpp_type_ref() = BAR;` instead of `FOO.set_bytes_with_cpp_type(BAR);`")]]
  ::py3::simple::foo_bar& set_bytes_with_cpp_type(T_ComplexStruct_bytes_with_cpp_type_struct_setter&& bytes_with_cpp_type_) {
    bytes_with_cpp_type = std::forward<T_ComplexStruct_bytes_with_cpp_type_struct_setter>(bytes_with_cpp_type_);
    __isset.bytes_with_cpp_type = true;
    return bytes_with_cpp_type;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexStruct>;
  friend void swap(ComplexStruct& a, ComplexStruct& b);
};

template <class Protocol_>
uint32_t ComplexStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class BinaryUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BinaryUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    iobuf_val = 1,
  } ;

  BinaryUnion()
      : type_(Type::__EMPTY__) {}

  BinaryUnion(BinaryUnion&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::iobuf_val:
      {
        set_iobuf_val(std::move(rhs.value_.iobuf_val));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  BinaryUnion(const BinaryUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::iobuf_val:
      {
        set_iobuf_val(rhs.value_.iobuf_val);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  BinaryUnion& operator=(BinaryUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::iobuf_val:
      {
        set_iobuf_val(std::move(rhs.value_.iobuf_val));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  BinaryUnion& operator=(const BinaryUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::iobuf_val:
      {
        set_iobuf_val(rhs.value_.iobuf_val);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~BinaryUnion() {
    __clear();
  }
  union storage_type {
    ::py3::simple::IOBuf iobuf_val;

    storage_type() {}
    ~storage_type() {}
  } ;

  ::py3::simple::IOBuf& set_iobuf_val(::py3::simple::IOBuf const &t) {
    __clear();
    type_ = Type::iobuf_val;
    ::new (std::addressof(value_.iobuf_val)) ::py3::simple::IOBuf(t);
    return value_.iobuf_val;
  }

  ::py3::simple::IOBuf& set_iobuf_val(::py3::simple::IOBuf&& t) {
    __clear();
    type_ = Type::iobuf_val;
    ::new (std::addressof(value_.iobuf_val)) ::py3::simple::IOBuf(std::move(t));
    return value_.iobuf_val;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::py3::simple::IOBuf, T...>> ::py3::simple::IOBuf& set_iobuf_val(T&&... t) {
    __clear();
    type_ = Type::iobuf_val;
    ::new (std::addressof(value_.iobuf_val)) ::py3::simple::IOBuf(std::forward<T>(t)...);
    return value_.iobuf_val;
  }

  ::py3::simple::IOBuf const& get_iobuf_val() const {
    if (type_ != Type::iobuf_val) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.iobuf_val;
  }

  ::py3::simple::IOBuf& mutable_iobuf_val() {
    assert(type_ == Type::iobuf_val);
    return value_.iobuf_val;
  }

  ::py3::simple::IOBuf move_iobuf_val() {
    assert(type_ == Type::iobuf_val);
    return std::move(value_.iobuf_val);
  }

  template <typename..., typename T = ::py3::simple::IOBuf>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> iobuf_val_ref() const& {
    return {value_.iobuf_val, type_, iobuf_val, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::py3::simple::IOBuf>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> iobuf_val_ref() const&& {
    return {std::move(value_.iobuf_val), type_, iobuf_val, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::py3::simple::IOBuf>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> iobuf_val_ref() & {
    return {value_.iobuf_val, type_, iobuf_val, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::py3::simple::IOBuf>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> iobuf_val_ref() && {
    return {std::move(value_.iobuf_val), type_, iobuf_val, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<BinaryUnion>;
  friend void swap(BinaryUnion& a, BinaryUnion& b);
};

template <class Protocol_>
uint32_t BinaryUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
namespace py3 { namespace simple {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class BinaryUnionStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BinaryUnionStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  BinaryUnionStruct() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  BinaryUnionStruct(apache::thrift::FragileConstructor, ::py3::simple::BinaryUnion u__arg);

  BinaryUnionStruct(BinaryUnionStruct&&) noexcept;

  BinaryUnionStruct(const BinaryUnionStruct& src);


  BinaryUnionStruct& operator=(BinaryUnionStruct&&) noexcept;
  BinaryUnionStruct& operator=(const BinaryUnionStruct& src);
  void __clear();
 private:
  ::py3::simple::BinaryUnion u;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool u;
  } __isset = {};

 public:

  template <typename..., typename T = ::py3::simple::BinaryUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> u_ref() const& {
    return {this->u, __isset.u};
  }

  template <typename..., typename T = ::py3::simple::BinaryUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> u_ref() const&& {
    return {std::move(this->u), __isset.u};
  }

  template <typename..., typename T = ::py3::simple::BinaryUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> u_ref() & {
    return {this->u, __isset.u};
  }

  template <typename..., typename T = ::py3::simple::BinaryUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> u_ref() && {
    return {std::move(this->u), __isset.u};
  }
  const ::py3::simple::BinaryUnion& get_u() const&;
  ::py3::simple::BinaryUnion get_u() &&;

  template <typename T_BinaryUnionStruct_u_struct_setter = ::py3::simple::BinaryUnion>
  [[deprecated("Use `FOO.u_ref() = BAR;` instead of `FOO.set_u(BAR);`")]]
  ::py3::simple::BinaryUnion& set_u(T_BinaryUnionStruct_u_struct_setter&& u_) {
    u = std::forward<T_BinaryUnionStruct_u_struct_setter>(u_);
    __isset.u = true;
    return u;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<BinaryUnionStruct>;
  friend void swap(BinaryUnionStruct& a, BinaryUnionStruct& b);
};

template <class Protocol_>
uint32_t BinaryUnionStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // py3::simple
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::py3::simple::BinaryUnion::Type>;

template <> struct TEnumTraits<::py3::simple::BinaryUnion::Type> {
  using type = ::py3::simple::BinaryUnion::Type;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
