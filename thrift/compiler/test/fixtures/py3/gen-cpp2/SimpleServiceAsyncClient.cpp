/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "thrift/compiler/test/fixtures/py3/gen-cpp2/SimpleServiceAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace py3 { namespace simple {
typedef apache::thrift::ThriftPresult<false> SimpleService_get_five_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_get_five_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_add_five_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_add_five_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_do_nothing_pargs;
typedef apache::thrift::ThriftPresult<true> SimpleService_do_nothing_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::SimpleStruct*>> SimpleService_get_value_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_get_value_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, bool*>> SimpleService_negate_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, bool*>> SimpleService_negate_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int8_t*>> SimpleService_tiny_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int8_t*>> SimpleService_tiny_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_small_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_small_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int64_t*>> SimpleService_big_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int64_t*>> SimpleService_big_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::floating_point, double*>> SimpleService_two_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::floating_point, double*>> SimpleService_two_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_expected_exception_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::SimpleException>> SimpleService_expected_exception_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_unexpected_exception_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_unexpected_exception_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int16_t>*>> SimpleService_sum_i16_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i16_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int32_t>*>> SimpleService_sum_i32_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i32_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int64_t>*>> SimpleService_sum_i64_list_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_i64_list_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_concat_many_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_concat_many_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<::py3::simple::SimpleStruct>*>> SimpleService_count_structs_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_count_structs_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::set<::apache::thrift::type_class::integral>, ::std::set<::std::int32_t>*>> SimpleService_sum_set_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_sum_set_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_contains_word_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, bool*>> SimpleService_contains_word_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::string>, ::std::map<::std::string, ::std::string>*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_get_map_value_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_get_map_value_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>, ::std::map<::std::string, ::py3::simple::SimpleStruct>*>> SimpleService_map_length_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_map_length_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, ::std::int16_t>*>> SimpleService_sum_map_values_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_sum_map_values_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::ComplexStruct*>> SimpleService_complex_sum_i32_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_complex_sum_i32_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::py3::simple::ComplexStruct*>> SimpleService_repeat_name_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_repeat_name_presult;
typedef apache::thrift::ThriftPresult<false> SimpleService_get_struct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::py3::simple::SimpleStruct*>> SimpleService_get_struct_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_fib_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::std::vector<::std::int32_t>*>> SimpleService_fib_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_unique_words_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>> SimpleService_unique_words_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::string>, ::std::vector<::std::string>*>> SimpleService_words_count_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>, ::std::map<::std::string, ::std::int16_t>*>> SimpleService_words_count_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::enumeration, ::py3::simple::AnEnum*>> SimpleService_set_enum_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::enumeration, ::py3::simple::AnEnum*>> SimpleService_set_enum_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int16_t*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::integral, ::std::int16_t*>> SimpleService_list_of_lists_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, ::std::vector<::std::vector<::std::int32_t>>*>> SimpleService_list_of_lists_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_word_character_frequency_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::integral>>, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>*>> SimpleService_word_character_frequency_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_list_of_sets_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::set<::apache::thrift::type_class::string>>, ::std::vector<::std::set<::std::string>>*>> SimpleService_list_of_sets_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>*>> SimpleService_nested_map_argument_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_nested_map_argument_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::string>>, ::std::vector<::std::vector<::std::string>>*>> SimpleService_make_sentence_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::string, ::std::string*>> SimpleService_make_sentence_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::set<::apache::thrift::type_class::integral>>, ::std::vector<::std::set<::std::int32_t>>*>> SimpleService_get_union_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::integral>, ::std::set<::std::int32_t>*>> SimpleService_get_union_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::string>>, ::std::vector<::std::map<::std::string, ::std::string>>*>> SimpleService_get_keys_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::string>, ::std::set<::std::string>*>> SimpleService_get_keys_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> SimpleService_lookup_double_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::floating_point, double*>> SimpleService_lookup_double_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::binary, ::std::string*>> SimpleService_retrieve_binary_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::binary, ::std::string*>> SimpleService_retrieve_binary_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::binary>, ::std::vector<::std::string>*>> SimpleService_contain_binary_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::set<::apache::thrift::type_class::binary>, ::std::set<::std::string>*>> SimpleService_contain_binary_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::enumeration>, ::std::vector<::py3::simple::AnEnum>*>> SimpleService_contain_enum_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::enumeration>, ::std::vector<::py3::simple::AnEnum>*>> SimpleService_contain_enum_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::variant, ::py3::simple::BinaryUnion*>> SimpleService_get_binary_union_struct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::py3::simple::BinaryUnionStruct*>> SimpleService_get_binary_union_struct_presult;

template <typename Protocol_>
void SimpleServiceAsyncClient::get_fiveT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {

  SimpleService_get_five_pargs args;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_five",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::add_fiveT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int32_t p_num) {

  SimpleService_add_five_pargs args;
  args.get<0>().value = &p_num;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "add_five",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::do_nothingT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {

  SimpleService_do_nothing_pargs args;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "do_nothing",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::concatT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_first, const ::std::string& p_second) {

  SimpleService_concat_pargs args;
  args.get<0>().value = const_cast<::std::string*>(&p_first);
  args.get<1>().value = const_cast<::std::string*>(&p_second);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "concat",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_valueT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::SimpleStruct& p_simple_struct) {

  SimpleService_get_value_pargs args;
  args.get<0>().value = const_cast<::py3::simple::SimpleStruct*>(&p_simple_struct);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_value",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::negateT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, bool p_input) {

  SimpleService_negate_pargs args;
  args.get<0>().value = &p_input;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "negate",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::tinyT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int8_t p_input) {

  SimpleService_tiny_pargs args;
  args.get<0>().value = &p_input;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "tiny",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::smallT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_input) {

  SimpleService_small_pargs args;
  args.get<0>().value = &p_input;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "small",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::bigT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int64_t p_input) {

  SimpleService_big_pargs args;
  args.get<0>().value = &p_input;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "big",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::twoT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, double p_input) {

  SimpleService_two_pargs args;
  args.get<0>().value = &p_input;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "two",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::expected_exceptionT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {

  SimpleService_expected_exception_pargs args;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "expected_exception",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::unexpected_exceptionT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {

  SimpleService_unexpected_exception_pargs args;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "unexpected_exception",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::sum_i16_listT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int16_t>& p_numbers) {

  SimpleService_sum_i16_list_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::int16_t>*>(&p_numbers);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "sum_i16_list",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::sum_i32_listT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int32_t>& p_numbers) {

  SimpleService_sum_i32_list_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::int32_t>*>(&p_numbers);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "sum_i32_list",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::sum_i64_listT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int64_t>& p_numbers) {

  SimpleService_sum_i64_list_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::int64_t>*>(&p_numbers);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "sum_i64_list",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::concat_manyT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {

  SimpleService_concat_many_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::string>*>(&p_words);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "concat_many",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::count_structsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {

  SimpleService_count_structs_pargs args;
  args.get<0>().value = const_cast<::std::vector<::py3::simple::SimpleStruct>*>(&p_items);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "count_structs",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::sum_setT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::set<::std::int32_t>& p_numbers) {

  SimpleService_sum_set_pargs args;
  args.get<0>().value = const_cast<::std::set<::std::int32_t>*>(&p_numbers);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "sum_set",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::contains_wordT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {

  SimpleService_contains_word_pargs args;
  args.get<0>().value = const_cast<::std::set<::std::string>*>(&p_words);
  args.get<1>().value = const_cast<::std::string*>(&p_word);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "contains_word",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_map_valueT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {

  SimpleService_get_map_value_pargs args;
  args.get<0>().value = const_cast<::std::map<::std::string, ::std::string>*>(&p_words);
  args.get<1>().value = const_cast<::std::string*>(&p_key);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_map_value",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::map_lengthT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {

  SimpleService_map_length_pargs args;
  args.get<0>().value = const_cast<::std::map<::std::string, ::py3::simple::SimpleStruct>*>(&p_items);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "map_length",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::sum_map_valuesT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::int16_t>& p_items) {

  SimpleService_sum_map_values_pargs args;
  args.get<0>().value = const_cast<::std::map<::std::string, ::std::int16_t>*>(&p_items);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "sum_map_values",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::complex_sum_i32T(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::ComplexStruct& p_counter) {

  SimpleService_complex_sum_i32_pargs args;
  args.get<0>().value = const_cast<::py3::simple::ComplexStruct*>(&p_counter);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "complex_sum_i32",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::repeat_nameT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::ComplexStruct& p_counter) {

  SimpleService_repeat_name_pargs args;
  args.get<0>().value = const_cast<::py3::simple::ComplexStruct*>(&p_counter);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "repeat_name",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_structT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {

  SimpleService_get_struct_pargs args;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_struct",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::fibT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_n) {

  SimpleService_fib_pargs args;
  args.get<0>().value = &p_n;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "fib",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::unique_wordsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {

  SimpleService_unique_words_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::string>*>(&p_words);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "unique_words",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::words_countT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {

  SimpleService_words_count_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::string>*>(&p_words);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "words_count",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::set_enumT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::py3::simple::AnEnum p_in_enum) {

  SimpleService_set_enum_pargs args;
  args.get<0>().value = &p_in_enum;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "set_enum",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::list_of_listsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {

  SimpleService_list_of_lists_pargs args;
  args.get<0>().value = &p_num_lists;
  args.get<1>().value = &p_num_items;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "list_of_lists",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::word_character_frequencyT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_sentence) {

  SimpleService_word_character_frequency_pargs args;
  args.get<0>().value = const_cast<::std::string*>(&p_sentence);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "word_character_frequency",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::list_of_setsT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_some_words) {

  SimpleService_list_of_sets_pargs args;
  args.get<0>().value = const_cast<::std::string*>(&p_some_words);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "list_of_sets",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::nested_map_argumentT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {

  SimpleService_nested_map_argument_pargs args;
  args.get<0>().value = const_cast<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>*>(&p_struct_map);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "nested_map_argument",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::make_sentenceT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {

  SimpleService_make_sentence_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::vector<::std::string>>*>(&p_word_chars);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "make_sentence",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_unionT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {

  SimpleService_get_union_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::set<::std::int32_t>>*>(&p_sets);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_union",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_keysT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {

  SimpleService_get_keys_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::map<::std::string, ::std::string>>*>(&p_string_map);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_keys",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::lookup_doubleT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int32_t p_key) {

  SimpleService_lookup_double_pargs args;
  args.get<0>().value = &p_key;
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "lookup_double",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::retrieve_binaryT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_something) {

  SimpleService_retrieve_binary_pargs args;
  args.get<0>().value = const_cast<::std::string*>(&p_something);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "retrieve_binary",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::contain_binaryT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_binaries) {

  SimpleService_contain_binary_pargs args;
  args.get<0>().value = const_cast<::std::vector<::std::string>*>(&p_binaries);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "contain_binary",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::contain_enumT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {

  SimpleService_contain_enum_pargs args;
  args.get<0>().value = const_cast<::std::vector<::py3::simple::AnEnum>*>(&p_the_enum);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "contain_enum",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}

template <typename Protocol_>
void SimpleServiceAsyncClient::get_binary_union_structT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::BinaryUnion& p_u) {

  SimpleService_get_binary_union_struct_pargs args;
  args.get<0>().value = const_cast<::py3::simple::BinaryUnion*>(&p_u);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };

  static ::apache::thrift::MethodMetadata::Data* methodMetadata =
        new ::apache::thrift::MethodMetadata::Data(
                "get_binary_union_struct",
                ::apache::thrift::FunctionQualifier::Unspecified);
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(prot, rpcOptions, std::move(callback), contextStack, std::move(header), channel_.get(), ::apache::thrift::MethodMetadata::from_static(methodMetadata), writer, sizer);

}



void SimpleServiceAsyncClient::get_five(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_five(rpcOptions, std::move(callback));
}

void SimpleServiceAsyncClient::get_five(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  auto [ctx, header] = get_fiveCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_fiveImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback));
}

void SimpleServiceAsyncClient::get_fiveImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_fiveT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_fiveT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_fiveCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_five",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_get_five() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_get_five(rpcOptions);
}

::std::int32_t SimpleServiceAsyncClient::sync_get_five(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_fiveCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_fiveImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback));
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_get_five(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_get_five() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_five(rpcOptions);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_get_five() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_five(rpcOptions);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_get_five(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_get_five, channel_);
  get_five(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_get_five(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_five, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_five(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_five(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_get_five, channel_);
  get_five(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_five(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_five, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_five(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_five(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  get_five(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_five(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_five_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_get_five(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_get_five(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_get_five(::apache::thrift::ClientReceiveState& state) {
  return recv_get_five(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_five(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_five(_return, state);
}

void SimpleServiceAsyncClient::add_five(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int32_t p_num) {
  ::apache::thrift::RpcOptions rpcOptions;
  add_five(rpcOptions, std::move(callback), p_num);
}

void SimpleServiceAsyncClient::add_five(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int32_t p_num) {
  auto [ctx, header] = add_fiveCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  add_fiveImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_num);
}

void SimpleServiceAsyncClient::add_fiveImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int32_t p_num) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      add_fiveT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_num);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      add_fiveT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_num);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::add_fiveCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.add_five",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_add_five(::std::int32_t p_num) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_add_five(rpcOptions, p_num);
}

::std::int32_t SimpleServiceAsyncClient::sync_add_five(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_num) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = add_fiveCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      add_fiveImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_num);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_add_five(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_add_five(::std::int32_t p_num) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_add_five(rpcOptions, p_num);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_add_five(::std::int32_t p_num) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_add_five(rpcOptions, p_num);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_add_five(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_num) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_add_five, channel_);
  add_five(rpcOptions, std::move(callback), p_num);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_add_five(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_num) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_add_five, channel_);
  auto callback = std::move(callbackAndFuture.first);
  add_five(rpcOptions, std::move(callback), p_num);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_add_five(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_num) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_add_five, channel_);
  add_five(rpcOptions, std::move(callback), p_num);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_add_five(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_num) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_add_five, channel_);
  auto callback = std::move(callbackAndFuture.first);
  add_five(rpcOptions, std::move(callback), p_num);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::add_five(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int32_t p_num) {
  add_five(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_num);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_add_five(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_add_five_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_add_five(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_add_five(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_add_five(::apache::thrift::ClientReceiveState& state) {
  return recv_add_five(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_add_five(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_add_five(_return, state);
}

void SimpleServiceAsyncClient::do_nothing(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  do_nothing(rpcOptions, std::move(callback));
}

void SimpleServiceAsyncClient::do_nothing(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  auto [ctx, header] = do_nothingCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  do_nothingImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback));
}

void SimpleServiceAsyncClient::do_nothingImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      do_nothingT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      do_nothingT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::do_nothingCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.do_nothing",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_do_nothing() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_do_nothing(rpcOptions);
}

void SimpleServiceAsyncClient::sync_do_nothing(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = do_nothingCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      do_nothingImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback));
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_do_nothing(returnState);
  });
}


folly::Future<folly::Unit> SimpleServiceAsyncClient::future_do_nothing() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_do_nothing(rpcOptions);
}

folly::SemiFuture<folly::Unit> SimpleServiceAsyncClient::semifuture_do_nothing() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_do_nothing(rpcOptions);
}

folly::Future<folly::Unit> SimpleServiceAsyncClient::future_do_nothing(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(promise), recv_wrapped_do_nothing, channel_);
  do_nothing(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<folly::Unit> SimpleServiceAsyncClient::semifuture_do_nothing(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_do_nothing, channel_);
  auto callback = std::move(callbackAndFuture.first);
  do_nothing(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_do_nothing(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(promise), recv_wrapped_do_nothing, channel_);
  do_nothing(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_do_nothing(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_do_nothing, channel_);
  auto callback = std::move(callbackAndFuture.first);
  do_nothing(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::do_nothing(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  do_nothing(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_do_nothing(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_do_nothing_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_do_nothing(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_do_nothing(state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_do_nothing(::apache::thrift::ClientReceiveState& state) {
  recv_do_nothing(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_do_nothing(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_do_nothing(state);
}

void SimpleServiceAsyncClient::concat(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_first, const ::std::string& p_second) {
  ::apache::thrift::RpcOptions rpcOptions;
  concat(rpcOptions, std::move(callback), p_first, p_second);
}

void SimpleServiceAsyncClient::concat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_first, const ::std::string& p_second) {
  auto [ctx, header] = concatCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  concatImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_first, p_second);
}

void SimpleServiceAsyncClient::concatImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_first, const ::std::string& p_second) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      concatT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_first, p_second);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      concatT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_first, p_second);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::concatCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.concat",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_concat(::std::string& _return, const ::std::string& p_first, const ::std::string& p_second) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_concat(rpcOptions, _return, p_first, p_second);
}

void SimpleServiceAsyncClient::sync_concat(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::std::string& p_first, const ::std::string& p_second) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = concatCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      concatImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_first, p_second);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_concat(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_concat(const ::std::string& p_first, const ::std::string& p_second) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_concat(rpcOptions, p_first, p_second);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_concat(const ::std::string& p_first, const ::std::string& p_second) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_concat(rpcOptions, p_first, p_second);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_concat(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_first, const ::std::string& p_second) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_concat, channel_);
  concat(rpcOptions, std::move(callback), p_first, p_second);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_concat(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_first, const ::std::string& p_second) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_concat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  concat(rpcOptions, std::move(callback), p_first, p_second);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_concat(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_first, const ::std::string& p_second) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_concat, channel_);
  concat(rpcOptions, std::move(callback), p_first, p_second);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_concat(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_first, const ::std::string& p_second) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_concat, channel_);
  auto callback = std::move(callbackAndFuture.first);
  concat(rpcOptions, std::move(callback), p_first, p_second);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::concat(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::string& p_first, const ::std::string& p_second) {
  concat(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_first, p_second);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_concat(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_concat_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_concat(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_concat(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_concat(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_concat(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_concat(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_concat(_return, state);
}

void SimpleServiceAsyncClient::get_value(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::SimpleStruct& p_simple_struct) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_value(rpcOptions, std::move(callback), p_simple_struct);
}

void SimpleServiceAsyncClient::get_value(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::SimpleStruct& p_simple_struct) {
  auto [ctx, header] = get_valueCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_valueImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_simple_struct);
}

void SimpleServiceAsyncClient::get_valueImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::SimpleStruct& p_simple_struct) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_valueT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_simple_struct);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_valueT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_simple_struct);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_valueCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_value",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_get_value(const ::py3::simple::SimpleStruct& p_simple_struct) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_get_value(rpcOptions, p_simple_struct);
}

::std::int32_t SimpleServiceAsyncClient::sync_get_value(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::SimpleStruct& p_simple_struct) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_valueCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_valueImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_simple_struct);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_get_value(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_get_value(const ::py3::simple::SimpleStruct& p_simple_struct) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_value(rpcOptions, p_simple_struct);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_get_value(const ::py3::simple::SimpleStruct& p_simple_struct) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_value(rpcOptions, p_simple_struct);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_get_value(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::SimpleStruct& p_simple_struct) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_get_value, channel_);
  get_value(rpcOptions, std::move(callback), p_simple_struct);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_get_value(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::SimpleStruct& p_simple_struct) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_value, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_value(rpcOptions, std::move(callback), p_simple_struct);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_value(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::SimpleStruct& p_simple_struct) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_get_value, channel_);
  get_value(rpcOptions, std::move(callback), p_simple_struct);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_value(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::SimpleStruct& p_simple_struct) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_value, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_value(rpcOptions, std::move(callback), p_simple_struct);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_value(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::py3::simple::SimpleStruct& p_simple_struct) {
  get_value(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_simple_struct);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_value(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_value_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_get_value(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_get_value(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_get_value(::apache::thrift::ClientReceiveState& state) {
  return recv_get_value(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_value(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_value(_return, state);
}

void SimpleServiceAsyncClient::negate(std::unique_ptr<apache::thrift::RequestCallback> callback, bool p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  negate(rpcOptions, std::move(callback), p_input);
}

void SimpleServiceAsyncClient::negate(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, bool p_input) {
  auto [ctx, header] = negateCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  negateImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_input);
}

void SimpleServiceAsyncClient::negateImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, bool p_input) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      negateT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      negateT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::negateCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.negate",
      *header);

  return {std::move(ctx), std::move(header)};
}

bool SimpleServiceAsyncClient::sync_negate(bool p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_negate(rpcOptions, p_input);
}

bool SimpleServiceAsyncClient::sync_negate(apache::thrift::RpcOptions& rpcOptions, bool p_input) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = negateCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      negateImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_input);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_negate(returnState);
  });
}


folly::Future<bool> SimpleServiceAsyncClient::future_negate(bool p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_negate(rpcOptions, p_input);
}

folly::SemiFuture<bool> SimpleServiceAsyncClient::semifuture_negate(bool p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_negate(rpcOptions, p_input);
}

folly::Future<bool> SimpleServiceAsyncClient::future_negate(apache::thrift::RpcOptions& rpcOptions, bool p_input) {
  folly::Promise<bool> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(promise), recv_wrapped_negate, channel_);
  negate(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<bool> SimpleServiceAsyncClient::semifuture_negate(apache::thrift::RpcOptions& rpcOptions, bool p_input) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_negate, channel_);
  auto callback = std::move(callbackAndFuture.first);
  negate(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_negate(apache::thrift::RpcOptions& rpcOptions, bool p_input) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(promise), recv_wrapped_negate, channel_);
  negate(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_negate(apache::thrift::RpcOptions& rpcOptions, bool p_input) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_negate, channel_);
  auto callback = std::move(callbackAndFuture.first);
  negate(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::negate(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, bool p_input) {
  negate(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_input);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_negate(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_negate_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool SimpleServiceAsyncClient::recv_negate(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_negate(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool SimpleServiceAsyncClient::recv_instance_negate(::apache::thrift::ClientReceiveState& state) {
  return recv_negate(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_negate(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_negate(_return, state);
}

void SimpleServiceAsyncClient::tiny(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int8_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  tiny(rpcOptions, std::move(callback), p_input);
}

void SimpleServiceAsyncClient::tiny(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int8_t p_input) {
  auto [ctx, header] = tinyCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  tinyImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_input);
}

void SimpleServiceAsyncClient::tinyImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int8_t p_input) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      tinyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      tinyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::tinyCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.tiny",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int8_t SimpleServiceAsyncClient::sync_tiny(::std::int8_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_tiny(rpcOptions, p_input);
}

::std::int8_t SimpleServiceAsyncClient::sync_tiny(apache::thrift::RpcOptions& rpcOptions, ::std::int8_t p_input) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = tinyCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      tinyImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_input);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_tiny(returnState);
  });
}


folly::Future<::std::int8_t> SimpleServiceAsyncClient::future_tiny(::std::int8_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_tiny(rpcOptions, p_input);
}

folly::SemiFuture<::std::int8_t> SimpleServiceAsyncClient::semifuture_tiny(::std::int8_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_tiny(rpcOptions, p_input);
}

folly::Future<::std::int8_t> SimpleServiceAsyncClient::future_tiny(apache::thrift::RpcOptions& rpcOptions, ::std::int8_t p_input) {
  folly::Promise<::std::int8_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int8_t>>(std::move(promise), recv_wrapped_tiny, channel_);
  tiny(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<::std::int8_t> SimpleServiceAsyncClient::semifuture_tiny(apache::thrift::RpcOptions& rpcOptions, ::std::int8_t p_input) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_tiny, channel_);
  auto callback = std::move(callbackAndFuture.first);
  tiny(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int8_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_tiny(apache::thrift::RpcOptions& rpcOptions, ::std::int8_t p_input) {
  folly::Promise<std::pair<::std::int8_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int8_t>>(std::move(promise), recv_wrapped_tiny, channel_);
  tiny(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<std::pair<::std::int8_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_tiny(apache::thrift::RpcOptions& rpcOptions, ::std::int8_t p_input) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_tiny, channel_);
  auto callback = std::move(callbackAndFuture.first);
  tiny(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::tiny(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int8_t p_input) {
  tiny(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_input);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_tiny(::std::int8_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_tiny_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int8_t SimpleServiceAsyncClient::recv_tiny(::apache::thrift::ClientReceiveState& state) {
  ::std::int8_t _return;
  auto ew = recv_wrapped_tiny(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int8_t SimpleServiceAsyncClient::recv_instance_tiny(::apache::thrift::ClientReceiveState& state) {
  return recv_tiny(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_tiny(::std::int8_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_tiny(_return, state);
}

void SimpleServiceAsyncClient::small(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  small(rpcOptions, std::move(callback), p_input);
}

void SimpleServiceAsyncClient::small(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_input) {
  auto [ctx, header] = smallCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  smallImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_input);
}

void SimpleServiceAsyncClient::smallImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_input) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      smallT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      smallT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::smallCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.small",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int16_t SimpleServiceAsyncClient::sync_small(::std::int16_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_small(rpcOptions, p_input);
}

::std::int16_t SimpleServiceAsyncClient::sync_small(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_input) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = smallCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      smallImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_input);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_small(returnState);
  });
}


folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_small(::std::int16_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_small(rpcOptions, p_input);
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_small(::std::int16_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_small(rpcOptions, p_input);
}

folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_small(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_input) {
  folly::Promise<::std::int16_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_small, channel_);
  small(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_small(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_input) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_small, channel_);
  auto callback = std::move(callbackAndFuture.first);
  small(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_small(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_input) {
  folly::Promise<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_small, channel_);
  small(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_small(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_input) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_small, channel_);
  auto callback = std::move(callbackAndFuture.first);
  small(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::small(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int16_t p_input) {
  small(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_input);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_small(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_small_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int16_t SimpleServiceAsyncClient::recv_small(::apache::thrift::ClientReceiveState& state) {
  ::std::int16_t _return;
  auto ew = recv_wrapped_small(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int16_t SimpleServiceAsyncClient::recv_instance_small(::apache::thrift::ClientReceiveState& state) {
  return recv_small(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_small(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_small(_return, state);
}

void SimpleServiceAsyncClient::big(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int64_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  big(rpcOptions, std::move(callback), p_input);
}

void SimpleServiceAsyncClient::big(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int64_t p_input) {
  auto [ctx, header] = bigCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  bigImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_input);
}

void SimpleServiceAsyncClient::bigImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int64_t p_input) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      bigT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      bigT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::bigCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.big",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int64_t SimpleServiceAsyncClient::sync_big(::std::int64_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_big(rpcOptions, p_input);
}

::std::int64_t SimpleServiceAsyncClient::sync_big(apache::thrift::RpcOptions& rpcOptions, ::std::int64_t p_input) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = bigCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      bigImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_input);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_big(returnState);
  });
}


folly::Future<::std::int64_t> SimpleServiceAsyncClient::future_big(::std::int64_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_big(rpcOptions, p_input);
}

folly::SemiFuture<::std::int64_t> SimpleServiceAsyncClient::semifuture_big(::std::int64_t p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_big(rpcOptions, p_input);
}

folly::Future<::std::int64_t> SimpleServiceAsyncClient::future_big(apache::thrift::RpcOptions& rpcOptions, ::std::int64_t p_input) {
  folly::Promise<::std::int64_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int64_t>>(std::move(promise), recv_wrapped_big, channel_);
  big(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<::std::int64_t> SimpleServiceAsyncClient::semifuture_big(apache::thrift::RpcOptions& rpcOptions, ::std::int64_t p_input) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_big, channel_);
  auto callback = std::move(callbackAndFuture.first);
  big(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int64_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_big(apache::thrift::RpcOptions& rpcOptions, ::std::int64_t p_input) {
  folly::Promise<std::pair<::std::int64_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int64_t>>(std::move(promise), recv_wrapped_big, channel_);
  big(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<std::pair<::std::int64_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_big(apache::thrift::RpcOptions& rpcOptions, ::std::int64_t p_input) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_big, channel_);
  auto callback = std::move(callbackAndFuture.first);
  big(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::big(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int64_t p_input) {
  big(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_input);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_big(::std::int64_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_big_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int64_t SimpleServiceAsyncClient::recv_big(::apache::thrift::ClientReceiveState& state) {
  ::std::int64_t _return;
  auto ew = recv_wrapped_big(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int64_t SimpleServiceAsyncClient::recv_instance_big(::apache::thrift::ClientReceiveState& state) {
  return recv_big(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_big(::std::int64_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_big(_return, state);
}

void SimpleServiceAsyncClient::two(std::unique_ptr<apache::thrift::RequestCallback> callback, double p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  two(rpcOptions, std::move(callback), p_input);
}

void SimpleServiceAsyncClient::two(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, double p_input) {
  auto [ctx, header] = twoCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  twoImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_input);
}

void SimpleServiceAsyncClient::twoImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, double p_input) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      twoT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      twoT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_input);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::twoCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.two",
      *header);

  return {std::move(ctx), std::move(header)};
}

double SimpleServiceAsyncClient::sync_two(double p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_two(rpcOptions, p_input);
}

double SimpleServiceAsyncClient::sync_two(apache::thrift::RpcOptions& rpcOptions, double p_input) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = twoCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      twoImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_input);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_two(returnState);
  });
}


folly::Future<double> SimpleServiceAsyncClient::future_two(double p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_two(rpcOptions, p_input);
}

folly::SemiFuture<double> SimpleServiceAsyncClient::semifuture_two(double p_input) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_two(rpcOptions, p_input);
}

folly::Future<double> SimpleServiceAsyncClient::future_two(apache::thrift::RpcOptions& rpcOptions, double p_input) {
  folly::Promise<double> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<double>>(std::move(promise), recv_wrapped_two, channel_);
  two(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<double> SimpleServiceAsyncClient::semifuture_two(apache::thrift::RpcOptions& rpcOptions, double p_input) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_two, channel_);
  auto callback = std::move(callbackAndFuture.first);
  two(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_two(apache::thrift::RpcOptions& rpcOptions, double p_input) {
  folly::Promise<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<double>>(std::move(promise), recv_wrapped_two, channel_);
  two(rpcOptions, std::move(callback), p_input);
  return future;
}

folly::SemiFuture<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_two(apache::thrift::RpcOptions& rpcOptions, double p_input) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_two, channel_);
  auto callback = std::move(callbackAndFuture.first);
  two(rpcOptions, std::move(callback), p_input);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::two(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, double p_input) {
  two(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_input);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_two(double& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_two_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

double SimpleServiceAsyncClient::recv_two(::apache::thrift::ClientReceiveState& state) {
  double _return;
  auto ew = recv_wrapped_two(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

double SimpleServiceAsyncClient::recv_instance_two(::apache::thrift::ClientReceiveState& state) {
  return recv_two(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_two(double& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_two(_return, state);
}

void SimpleServiceAsyncClient::expected_exception(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  expected_exception(rpcOptions, std::move(callback));
}

void SimpleServiceAsyncClient::expected_exception(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  auto [ctx, header] = expected_exceptionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  expected_exceptionImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback));
}

void SimpleServiceAsyncClient::expected_exceptionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      expected_exceptionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      expected_exceptionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::expected_exceptionCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.expected_exception",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_expected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_expected_exception(rpcOptions);
}

void SimpleServiceAsyncClient::sync_expected_exception(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = expected_exceptionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      expected_exceptionImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback));
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_expected_exception(returnState);
  });
}


folly::Future<folly::Unit> SimpleServiceAsyncClient::future_expected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_expected_exception(rpcOptions);
}

folly::SemiFuture<folly::Unit> SimpleServiceAsyncClient::semifuture_expected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_expected_exception(rpcOptions);
}

folly::Future<folly::Unit> SimpleServiceAsyncClient::future_expected_exception(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(promise), recv_wrapped_expected_exception, channel_);
  expected_exception(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<folly::Unit> SimpleServiceAsyncClient::semifuture_expected_exception(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_expected_exception, channel_);
  auto callback = std::move(callbackAndFuture.first);
  expected_exception(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_expected_exception(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(promise), recv_wrapped_expected_exception, channel_);
  expected_exception(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_expected_exception(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_expected_exception, channel_);
  auto callback = std::move(callbackAndFuture.first);
  expected_exception(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::expected_exception(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  expected_exception(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_expected_exception(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_expected_exception_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_expected_exception(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_expected_exception(state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_expected_exception(::apache::thrift::ClientReceiveState& state) {
  recv_expected_exception(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_expected_exception(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_expected_exception(state);
}

void SimpleServiceAsyncClient::unexpected_exception(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  unexpected_exception(rpcOptions, std::move(callback));
}

void SimpleServiceAsyncClient::unexpected_exception(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  auto [ctx, header] = unexpected_exceptionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  unexpected_exceptionImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback));
}

void SimpleServiceAsyncClient::unexpected_exceptionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      unexpected_exceptionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      unexpected_exceptionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::unexpected_exceptionCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.unexpected_exception",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_unexpected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_unexpected_exception(rpcOptions);
}

::std::int32_t SimpleServiceAsyncClient::sync_unexpected_exception(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = unexpected_exceptionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      unexpected_exceptionImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback));
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_unexpected_exception(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_unexpected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_unexpected_exception(rpcOptions);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_unexpected_exception() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_unexpected_exception(rpcOptions);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_unexpected_exception(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_unexpected_exception, channel_);
  unexpected_exception(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_unexpected_exception(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_unexpected_exception, channel_);
  auto callback = std::move(callbackAndFuture.first);
  unexpected_exception(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_unexpected_exception(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_unexpected_exception, channel_);
  unexpected_exception(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_unexpected_exception(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_unexpected_exception, channel_);
  auto callback = std::move(callbackAndFuture.first);
  unexpected_exception(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::unexpected_exception(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  unexpected_exception(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_unexpected_exception(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_unexpected_exception_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_unexpected_exception(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_unexpected_exception(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_unexpected_exception(::apache::thrift::ClientReceiveState& state) {
  return recv_unexpected_exception(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_unexpected_exception(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_unexpected_exception(_return, state);
}

void SimpleServiceAsyncClient::sum_i16_list(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int16_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  sum_i16_list(rpcOptions, std::move(callback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i16_list(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int16_t>& p_numbers) {
  auto [ctx, header] = sum_i16_listCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  sum_i16_listImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i16_listImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int16_t>& p_numbers) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      sum_i16_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      sum_i16_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::sum_i16_listCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.sum_i16_list",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i16_list(const ::std::vector<::std::int16_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sum_i16_list(rpcOptions, p_numbers);
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i16_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int16_t>& p_numbers) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = sum_i16_listCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      sum_i16_listImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_numbers);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_sum_i16_list(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i16_list(const ::std::vector<::std::int16_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sum_i16_list(rpcOptions, p_numbers);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i16_list(const ::std::vector<::std::int16_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_sum_i16_list(rpcOptions, p_numbers);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i16_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int16_t>& p_numbers) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i16_list, channel_);
  sum_i16_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i16_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int16_t>& p_numbers) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_sum_i16_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i16_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_sum_i16_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int16_t>& p_numbers) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i16_list, channel_);
  sum_i16_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_sum_i16_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int16_t>& p_numbers) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_sum_i16_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i16_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::sum_i16_list(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::int16_t>& p_numbers) {
  sum_i16_list(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_numbers);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_sum_i16_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_sum_i16_list_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_sum_i16_list(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_sum_i16_list(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_sum_i16_list(::apache::thrift::ClientReceiveState& state) {
  return recv_sum_i16_list(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_sum_i16_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sum_i16_list(_return, state);
}

void SimpleServiceAsyncClient::sum_i32_list(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  sum_i32_list(rpcOptions, std::move(callback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i32_list(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int32_t>& p_numbers) {
  auto [ctx, header] = sum_i32_listCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  sum_i32_listImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i32_listImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int32_t>& p_numbers) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      sum_i32_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      sum_i32_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::sum_i32_listCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.sum_i32_list",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i32_list(const ::std::vector<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sum_i32_list(rpcOptions, p_numbers);
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i32_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int32_t>& p_numbers) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = sum_i32_listCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      sum_i32_listImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_numbers);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_sum_i32_list(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i32_list(const ::std::vector<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sum_i32_list(rpcOptions, p_numbers);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i32_list(const ::std::vector<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_sum_i32_list(rpcOptions, p_numbers);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i32_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int32_t>& p_numbers) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i32_list, channel_);
  sum_i32_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i32_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int32_t>& p_numbers) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_sum_i32_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i32_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_sum_i32_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int32_t>& p_numbers) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i32_list, channel_);
  sum_i32_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_sum_i32_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int32_t>& p_numbers) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_sum_i32_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i32_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::sum_i32_list(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::int32_t>& p_numbers) {
  sum_i32_list(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_numbers);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_sum_i32_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_sum_i32_list_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_sum_i32_list(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_sum_i32_list(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_sum_i32_list(::apache::thrift::ClientReceiveState& state) {
  return recv_sum_i32_list(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_sum_i32_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sum_i32_list(_return, state);
}

void SimpleServiceAsyncClient::sum_i64_list(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int64_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  sum_i64_list(rpcOptions, std::move(callback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i64_list(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::int64_t>& p_numbers) {
  auto [ctx, header] = sum_i64_listCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  sum_i64_listImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_numbers);
}

void SimpleServiceAsyncClient::sum_i64_listImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::int64_t>& p_numbers) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      sum_i64_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      sum_i64_listT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::sum_i64_listCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.sum_i64_list",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i64_list(const ::std::vector<::std::int64_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sum_i64_list(rpcOptions, p_numbers);
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_i64_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int64_t>& p_numbers) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = sum_i64_listCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      sum_i64_listImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_numbers);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_sum_i64_list(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i64_list(const ::std::vector<::std::int64_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sum_i64_list(rpcOptions, p_numbers);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i64_list(const ::std::vector<::std::int64_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_sum_i64_list(rpcOptions, p_numbers);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_i64_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int64_t>& p_numbers) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i64_list, channel_);
  sum_i64_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_i64_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int64_t>& p_numbers) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_sum_i64_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i64_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_sum_i64_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int64_t>& p_numbers) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_i64_list, channel_);
  sum_i64_list(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_sum_i64_list(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::int64_t>& p_numbers) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_sum_i64_list, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_i64_list(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::sum_i64_list(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::int64_t>& p_numbers) {
  sum_i64_list(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_numbers);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_sum_i64_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_sum_i64_list_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_sum_i64_list(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_sum_i64_list(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_sum_i64_list(::apache::thrift::ClientReceiveState& state) {
  return recv_sum_i64_list(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_sum_i64_list(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sum_i64_list(_return, state);
}

void SimpleServiceAsyncClient::concat_many(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  concat_many(rpcOptions, std::move(callback), p_words);
}

void SimpleServiceAsyncClient::concat_many(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  auto [ctx, header] = concat_manyCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  concat_manyImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_words);
}

void SimpleServiceAsyncClient::concat_manyImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      concat_manyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      concat_manyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::concat_manyCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.concat_many",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_concat_many(::std::string& _return, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_concat_many(rpcOptions, _return, p_words);
}

void SimpleServiceAsyncClient::sync_concat_many(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::std::vector<::std::string>& p_words) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = concat_manyCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      concat_manyImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_words);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_concat_many(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_concat_many(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_concat_many(rpcOptions, p_words);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_concat_many(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_concat_many(rpcOptions, p_words);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_concat_many(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_concat_many, channel_);
  concat_many(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_concat_many(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_concat_many, channel_);
  auto callback = std::move(callbackAndFuture.first);
  concat_many(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_concat_many(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_concat_many, channel_);
  concat_many(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_concat_many(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_concat_many, channel_);
  auto callback = std::move(callbackAndFuture.first);
  concat_many(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::concat_many(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::string>& p_words) {
  concat_many(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_words);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_concat_many(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_concat_many_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_concat_many(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_concat_many(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_concat_many(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_concat_many(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_concat_many(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_concat_many(_return, state);
}

void SimpleServiceAsyncClient::count_structs(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  count_structs(rpcOptions, std::move(callback), p_items);
}

void SimpleServiceAsyncClient::count_structs(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  auto [ctx, header] = count_structsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  count_structsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_items);
}

void SimpleServiceAsyncClient::count_structsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      count_structsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      count_structsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::count_structsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.count_structs",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_count_structs(const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_count_structs(rpcOptions, p_items);
}

::std::int32_t SimpleServiceAsyncClient::sync_count_structs(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = count_structsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      count_structsImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_items);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_count_structs(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_count_structs(const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_count_structs(rpcOptions, p_items);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_count_structs(const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_count_structs(rpcOptions, p_items);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_count_structs(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_count_structs, channel_);
  count_structs(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_count_structs(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_count_structs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  count_structs(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_count_structs(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_count_structs, channel_);
  count_structs(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_count_structs(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_count_structs, channel_);
  auto callback = std::move(callbackAndFuture.first);
  count_structs(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::count_structs(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::py3::simple::SimpleStruct>& p_items) {
  count_structs(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_items);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_count_structs(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_count_structs_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_count_structs(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_count_structs(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_count_structs(::apache::thrift::ClientReceiveState& state) {
  return recv_count_structs(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_count_structs(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_count_structs(_return, state);
}

void SimpleServiceAsyncClient::sum_set(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::set<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  sum_set(rpcOptions, std::move(callback), p_numbers);
}

void SimpleServiceAsyncClient::sum_set(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::set<::std::int32_t>& p_numbers) {
  auto [ctx, header] = sum_setCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  sum_setImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_numbers);
}

void SimpleServiceAsyncClient::sum_setImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::set<::std::int32_t>& p_numbers) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      sum_setT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      sum_setT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_numbers);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::sum_setCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.sum_set",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_set(const ::std::set<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sum_set(rpcOptions, p_numbers);
}

::std::int32_t SimpleServiceAsyncClient::sync_sum_set(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::int32_t>& p_numbers) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = sum_setCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      sum_setImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_numbers);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_sum_set(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_set(const ::std::set<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sum_set(rpcOptions, p_numbers);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_set(const ::std::set<::std::int32_t>& p_numbers) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_sum_set(rpcOptions, p_numbers);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_sum_set(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::int32_t>& p_numbers) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_set, channel_);
  sum_set(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_sum_set(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::int32_t>& p_numbers) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_sum_set, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_set(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_sum_set(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::int32_t>& p_numbers) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_sum_set, channel_);
  sum_set(rpcOptions, std::move(callback), p_numbers);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_sum_set(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::int32_t>& p_numbers) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_sum_set, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_set(rpcOptions, std::move(callback), p_numbers);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::sum_set(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::set<::std::int32_t>& p_numbers) {
  sum_set(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_numbers);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_sum_set(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_sum_set_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_sum_set(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_sum_set(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_sum_set(::apache::thrift::ClientReceiveState& state) {
  return recv_sum_set(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_sum_set(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sum_set(_return, state);
}

void SimpleServiceAsyncClient::contains_word(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  ::apache::thrift::RpcOptions rpcOptions;
  contains_word(rpcOptions, std::move(callback), p_words, p_word);
}

void SimpleServiceAsyncClient::contains_word(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  auto [ctx, header] = contains_wordCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  contains_wordImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_words, p_word);
}

void SimpleServiceAsyncClient::contains_wordImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      contains_wordT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words, p_word);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      contains_wordT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words, p_word);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::contains_wordCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.contains_word",
      *header);

  return {std::move(ctx), std::move(header)};
}

bool SimpleServiceAsyncClient::sync_contains_word(const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_contains_word(rpcOptions, p_words, p_word);
}

bool SimpleServiceAsyncClient::sync_contains_word(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = contains_wordCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      contains_wordImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_words, p_word);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_contains_word(returnState);
  });
}


folly::Future<bool> SimpleServiceAsyncClient::future_contains_word(const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_contains_word(rpcOptions, p_words, p_word);
}

folly::SemiFuture<bool> SimpleServiceAsyncClient::semifuture_contains_word(const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_contains_word(rpcOptions, p_words, p_word);
}

folly::Future<bool> SimpleServiceAsyncClient::future_contains_word(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  folly::Promise<bool> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<bool>>(std::move(promise), recv_wrapped_contains_word, channel_);
  contains_word(rpcOptions, std::move(callback), p_words, p_word);
  return future;
}

folly::SemiFuture<bool> SimpleServiceAsyncClient::semifuture_contains_word(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_contains_word, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contains_word(rpcOptions, std::move(callback), p_words, p_word);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_contains_word(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(promise), recv_wrapped_contains_word, channel_);
  contains_word(rpcOptions, std::move(callback), p_words, p_word);
  return future;
}

folly::SemiFuture<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_contains_word(apache::thrift::RpcOptions& rpcOptions, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_contains_word, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contains_word(rpcOptions, std::move(callback), p_words, p_word);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::contains_word(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::set<::std::string>& p_words, const ::std::string& p_word) {
  contains_word(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_words, p_word);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_contains_word(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_contains_word_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool SimpleServiceAsyncClient::recv_contains_word(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_contains_word(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

bool SimpleServiceAsyncClient::recv_instance_contains_word(::apache::thrift::ClientReceiveState& state) {
  return recv_contains_word(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_contains_word(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_contains_word(_return, state);
}

void SimpleServiceAsyncClient::get_map_value(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_map_value(rpcOptions, std::move(callback), p_words, p_key);
}

void SimpleServiceAsyncClient::get_map_value(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  auto [ctx, header] = get_map_valueCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_map_valueImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_words, p_key);
}

void SimpleServiceAsyncClient::get_map_valueImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_map_valueT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words, p_key);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_map_valueT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words, p_key);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_map_valueCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_map_value",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_get_map_value(::std::string& _return, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get_map_value(rpcOptions, _return, p_words, p_key);
}

void SimpleServiceAsyncClient::sync_get_map_value(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_map_valueCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_map_valueImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_words, p_key);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get_map_value(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_get_map_value(const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_map_value(rpcOptions, p_words, p_key);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_get_map_value(const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_map_value(rpcOptions, p_words, p_key);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_get_map_value(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_get_map_value, channel_);
  get_map_value(rpcOptions, std::move(callback), p_words, p_key);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_get_map_value(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_map_value, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_map_value(rpcOptions, std::move(callback), p_words, p_key);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_map_value(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_get_map_value, channel_);
  get_map_value(rpcOptions, std::move(callback), p_words, p_key);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_map_value(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_map_value, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_map_value(rpcOptions, std::move(callback), p_words, p_key);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_map_value(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::map<::std::string, ::std::string>& p_words, const ::std::string& p_key) {
  get_map_value(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_words, p_key);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_map_value(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_map_value_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_get_map_value(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get_map_value(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_get_map_value(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get_map_value(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_map_value(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_map_value(_return, state);
}

void SimpleServiceAsyncClient::map_length(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  map_length(rpcOptions, std::move(callback), p_items);
}

void SimpleServiceAsyncClient::map_length(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  auto [ctx, header] = map_lengthCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  map_lengthImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_items);
}

void SimpleServiceAsyncClient::map_lengthImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      map_lengthT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      map_lengthT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::map_lengthCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.map_length",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int16_t SimpleServiceAsyncClient::sync_map_length(const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_map_length(rpcOptions, p_items);
}

::std::int16_t SimpleServiceAsyncClient::sync_map_length(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = map_lengthCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      map_lengthImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_items);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_map_length(returnState);
  });
}


folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_map_length(const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_map_length(rpcOptions, p_items);
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_map_length(const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_map_length(rpcOptions, p_items);
}

folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_map_length(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  folly::Promise<::std::int16_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_map_length, channel_);
  map_length(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_map_length(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_map_length, channel_);
  auto callback = std::move(callbackAndFuture.first);
  map_length(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_map_length(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  folly::Promise<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_map_length, channel_);
  map_length(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_map_length(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_map_length, channel_);
  auto callback = std::move(callbackAndFuture.first);
  map_length(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::map_length(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::map<::std::string, ::py3::simple::SimpleStruct>& p_items) {
  map_length(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_items);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_map_length(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_map_length_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int16_t SimpleServiceAsyncClient::recv_map_length(::apache::thrift::ClientReceiveState& state) {
  ::std::int16_t _return;
  auto ew = recv_wrapped_map_length(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int16_t SimpleServiceAsyncClient::recv_instance_map_length(::apache::thrift::ClientReceiveState& state) {
  return recv_map_length(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_map_length(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_map_length(_return, state);
}

void SimpleServiceAsyncClient::sum_map_values(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  sum_map_values(rpcOptions, std::move(callback), p_items);
}

void SimpleServiceAsyncClient::sum_map_values(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  auto [ctx, header] = sum_map_valuesCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  sum_map_valuesImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_items);
}

void SimpleServiceAsyncClient::sum_map_valuesImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      sum_map_valuesT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      sum_map_valuesT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_items);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::sum_map_valuesCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.sum_map_values",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int16_t SimpleServiceAsyncClient::sync_sum_map_values(const ::std::map<::std::string, ::std::int16_t>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sum_map_values(rpcOptions, p_items);
}

::std::int16_t SimpleServiceAsyncClient::sync_sum_map_values(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = sum_map_valuesCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      sum_map_valuesImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_items);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_sum_map_values(returnState);
  });
}


folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_sum_map_values(const ::std::map<::std::string, ::std::int16_t>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sum_map_values(rpcOptions, p_items);
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_sum_map_values(const ::std::map<::std::string, ::std::int16_t>& p_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_sum_map_values(rpcOptions, p_items);
}

folly::Future<::std::int16_t> SimpleServiceAsyncClient::future_sum_map_values(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  folly::Promise<::std::int16_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_sum_map_values, channel_);
  sum_map_values(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<::std::int16_t> SimpleServiceAsyncClient::semifuture_sum_map_values(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_sum_map_values, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_map_values(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_sum_map_values(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  folly::Promise<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int16_t>>(std::move(promise), recv_wrapped_sum_map_values, channel_);
  sum_map_values(rpcOptions, std::move(callback), p_items);
  return future;
}

folly::SemiFuture<std::pair<::std::int16_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_sum_map_values(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_sum_map_values, channel_);
  auto callback = std::move(callbackAndFuture.first);
  sum_map_values(rpcOptions, std::move(callback), p_items);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::sum_map_values(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::map<::std::string, ::std::int16_t>& p_items) {
  sum_map_values(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_items);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_sum_map_values(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_sum_map_values_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int16_t SimpleServiceAsyncClient::recv_sum_map_values(::apache::thrift::ClientReceiveState& state) {
  ::std::int16_t _return;
  auto ew = recv_wrapped_sum_map_values(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int16_t SimpleServiceAsyncClient::recv_instance_sum_map_values(::apache::thrift::ClientReceiveState& state) {
  return recv_sum_map_values(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_sum_map_values(::std::int16_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sum_map_values(_return, state);
}

void SimpleServiceAsyncClient::complex_sum_i32(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  complex_sum_i32(rpcOptions, std::move(callback), p_counter);
}

void SimpleServiceAsyncClient::complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::ComplexStruct& p_counter) {
  auto [ctx, header] = complex_sum_i32Ctx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  complex_sum_i32Impl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_counter);
}

void SimpleServiceAsyncClient::complex_sum_i32Impl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::ComplexStruct& p_counter) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      complex_sum_i32T(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_counter);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      complex_sum_i32T(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_counter);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::complex_sum_i32Ctx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.complex_sum_i32",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_complex_sum_i32(const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_complex_sum_i32(rpcOptions, p_counter);
}

::std::int32_t SimpleServiceAsyncClient::sync_complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = complex_sum_i32Ctx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      complex_sum_i32Impl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_counter);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_complex_sum_i32(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_complex_sum_i32(const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_complex_sum_i32(rpcOptions, p_counter);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_complex_sum_i32(const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_complex_sum_i32(rpcOptions, p_counter);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_complex_sum_i32, channel_);
  complex_sum_i32(rpcOptions, std::move(callback), p_counter);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_complex_sum_i32, channel_);
  auto callback = std::move(callbackAndFuture.first);
  complex_sum_i32(rpcOptions, std::move(callback), p_counter);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_complex_sum_i32, channel_);
  complex_sum_i32(rpcOptions, std::move(callback), p_counter);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_complex_sum_i32(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_complex_sum_i32, channel_);
  auto callback = std::move(callbackAndFuture.first);
  complex_sum_i32(rpcOptions, std::move(callback), p_counter);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::complex_sum_i32(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::py3::simple::ComplexStruct& p_counter) {
  complex_sum_i32(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_counter);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_complex_sum_i32(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_complex_sum_i32_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_complex_sum_i32(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_complex_sum_i32(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_complex_sum_i32(::apache::thrift::ClientReceiveState& state) {
  return recv_complex_sum_i32(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_complex_sum_i32(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_complex_sum_i32(_return, state);
}

void SimpleServiceAsyncClient::repeat_name(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  repeat_name(rpcOptions, std::move(callback), p_counter);
}

void SimpleServiceAsyncClient::repeat_name(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::ComplexStruct& p_counter) {
  auto [ctx, header] = repeat_nameCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  repeat_nameImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_counter);
}

void SimpleServiceAsyncClient::repeat_nameImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::ComplexStruct& p_counter) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      repeat_nameT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_counter);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      repeat_nameT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_counter);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::repeat_nameCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.repeat_name",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_repeat_name(::std::string& _return, const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_repeat_name(rpcOptions, _return, p_counter);
}

void SimpleServiceAsyncClient::sync_repeat_name(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::py3::simple::ComplexStruct& p_counter) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = repeat_nameCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      repeat_nameImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_counter);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_repeat_name(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_repeat_name(const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_repeat_name(rpcOptions, p_counter);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_repeat_name(const ::py3::simple::ComplexStruct& p_counter) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_repeat_name(rpcOptions, p_counter);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_repeat_name(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_repeat_name, channel_);
  repeat_name(rpcOptions, std::move(callback), p_counter);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_repeat_name(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_repeat_name, channel_);
  auto callback = std::move(callbackAndFuture.first);
  repeat_name(rpcOptions, std::move(callback), p_counter);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_repeat_name(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_repeat_name, channel_);
  repeat_name(rpcOptions, std::move(callback), p_counter);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_repeat_name(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::ComplexStruct& p_counter) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_repeat_name, channel_);
  auto callback = std::move(callbackAndFuture.first);
  repeat_name(rpcOptions, std::move(callback), p_counter);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::repeat_name(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::py3::simple::ComplexStruct& p_counter) {
  repeat_name(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_counter);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_repeat_name(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_repeat_name_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_repeat_name(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_repeat_name(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_repeat_name(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_repeat_name(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_repeat_name(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_repeat_name(_return, state);
}

void SimpleServiceAsyncClient::get_struct(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_struct(rpcOptions, std::move(callback));
}

void SimpleServiceAsyncClient::get_struct(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  auto [ctx, header] = get_structCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_structImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback));
}

void SimpleServiceAsyncClient::get_structImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_structT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_structT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_structCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_struct",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_get_struct(::py3::simple::SimpleStruct& _return) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get_struct(rpcOptions, _return);
}

void SimpleServiceAsyncClient::sync_get_struct(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::SimpleStruct& _return) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_structCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_structImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback));
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get_struct(_return, returnState);
  });
}


folly::Future<::py3::simple::SimpleStruct> SimpleServiceAsyncClient::future_get_struct() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_struct(rpcOptions);
}

folly::SemiFuture<::py3::simple::SimpleStruct> SimpleServiceAsyncClient::semifuture_get_struct() {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_struct(rpcOptions);
}

folly::Future<::py3::simple::SimpleStruct> SimpleServiceAsyncClient::future_get_struct(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<::py3::simple::SimpleStruct> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::py3::simple::SimpleStruct>>(std::move(promise), recv_wrapped_get_struct, channel_);
  get_struct(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<::py3::simple::SimpleStruct> SimpleServiceAsyncClient::semifuture_get_struct(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_struct, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_struct(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::py3::simple::SimpleStruct, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_struct(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<::py3::simple::SimpleStruct, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::py3::simple::SimpleStruct>>(std::move(promise), recv_wrapped_get_struct, channel_);
  get_struct(rpcOptions, std::move(callback));
  return future;
}

folly::SemiFuture<std::pair<::py3::simple::SimpleStruct, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_struct(apache::thrift::RpcOptions& rpcOptions) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_struct, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_struct(rpcOptions, std::move(callback));
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_struct(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  get_struct(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_struct(::py3::simple::SimpleStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_struct_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_get_struct(::py3::simple::SimpleStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get_struct(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_get_struct(::py3::simple::SimpleStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get_struct(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_struct(::py3::simple::SimpleStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_struct(_return, state);
}

void SimpleServiceAsyncClient::fib(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_n) {
  ::apache::thrift::RpcOptions rpcOptions;
  fib(rpcOptions, std::move(callback), p_n);
}

void SimpleServiceAsyncClient::fib(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_n) {
  auto [ctx, header] = fibCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  fibImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_n);
}

void SimpleServiceAsyncClient::fibImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_n) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      fibT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_n);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      fibT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_n);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::fibCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.fib",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_fib(::std::vector<::std::int32_t>& _return, ::std::int16_t p_n) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_fib(rpcOptions, _return, p_n);
}

void SimpleServiceAsyncClient::sync_fib(apache::thrift::RpcOptions& rpcOptions, ::std::vector<::std::int32_t>& _return, ::std::int16_t p_n) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = fibCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      fibImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_n);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_fib(_return, returnState);
  });
}


folly::Future<::std::vector<::std::int32_t>> SimpleServiceAsyncClient::future_fib(::std::int16_t p_n) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_fib(rpcOptions, p_n);
}

folly::SemiFuture<::std::vector<::std::int32_t>> SimpleServiceAsyncClient::semifuture_fib(::std::int16_t p_n) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_fib(rpcOptions, p_n);
}

folly::Future<::std::vector<::std::int32_t>> SimpleServiceAsyncClient::future_fib(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_n) {
  folly::Promise<::std::vector<::std::int32_t>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::vector<::std::int32_t>>>(std::move(promise), recv_wrapped_fib, channel_);
  fib(rpcOptions, std::move(callback), p_n);
  return future;
}

folly::SemiFuture<::std::vector<::std::int32_t>> SimpleServiceAsyncClient::semifuture_fib(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_n) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_fib, channel_);
  auto callback = std::move(callbackAndFuture.first);
  fib(rpcOptions, std::move(callback), p_n);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::vector<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_fib(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_n) {
  folly::Promise<std::pair<::std::vector<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::vector<::std::int32_t>>>(std::move(promise), recv_wrapped_fib, channel_);
  fib(rpcOptions, std::move(callback), p_n);
  return future;
}

folly::SemiFuture<std::pair<::std::vector<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_fib(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_n) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_fib, channel_);
  auto callback = std::move(callbackAndFuture.first);
  fib(rpcOptions, std::move(callback), p_n);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::fib(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int16_t p_n) {
  fib(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_n);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_fib(::std::vector<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_fib_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_fib(::std::vector<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_fib(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_fib(::std::vector<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_fib(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_fib(::std::vector<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_fib(_return, state);
}

void SimpleServiceAsyncClient::unique_words(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  unique_words(rpcOptions, std::move(callback), p_words);
}

void SimpleServiceAsyncClient::unique_words(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  auto [ctx, header] = unique_wordsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  unique_wordsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_words);
}

void SimpleServiceAsyncClient::unique_wordsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      unique_wordsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      unique_wordsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::unique_wordsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.unique_words",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_unique_words(::std::set<::std::string>& _return, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_unique_words(rpcOptions, _return, p_words);
}

void SimpleServiceAsyncClient::sync_unique_words(apache::thrift::RpcOptions& rpcOptions, ::std::set<::std::string>& _return, const ::std::vector<::std::string>& p_words) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = unique_wordsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      unique_wordsImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_words);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_unique_words(_return, returnState);
  });
}


folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_unique_words(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_unique_words(rpcOptions, p_words);
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_unique_words(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_unique_words(rpcOptions, p_words);
}

folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_unique_words(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<::std::set<::std::string>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_unique_words, channel_);
  unique_words(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_unique_words(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_unique_words, channel_);
  auto callback = std::move(callbackAndFuture.first);
  unique_words(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_unique_words(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_unique_words, channel_);
  unique_words(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_unique_words(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_unique_words, channel_);
  auto callback = std::move(callbackAndFuture.first);
  unique_words(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::unique_words(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::string>& p_words) {
  unique_words(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_words);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_unique_words(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_unique_words_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_unique_words(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_unique_words(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_unique_words(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_unique_words(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_unique_words(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_unique_words(_return, state);
}

void SimpleServiceAsyncClient::words_count(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  words_count(rpcOptions, std::move(callback), p_words);
}

void SimpleServiceAsyncClient::words_count(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_words) {
  auto [ctx, header] = words_countCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  words_countImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_words);
}

void SimpleServiceAsyncClient::words_countImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_words) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      words_countT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      words_countT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_words);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::words_countCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.words_count",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_words_count(::std::map<::std::string, ::std::int16_t>& _return, const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_words_count(rpcOptions, _return, p_words);
}

void SimpleServiceAsyncClient::sync_words_count(apache::thrift::RpcOptions& rpcOptions, ::std::map<::std::string, ::std::int16_t>& _return, const ::std::vector<::std::string>& p_words) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = words_countCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      words_countImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_words);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_words_count(_return, returnState);
  });
}


folly::Future<::std::map<::std::string, ::std::int16_t>> SimpleServiceAsyncClient::future_words_count(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_words_count(rpcOptions, p_words);
}

folly::SemiFuture<::std::map<::std::string, ::std::int16_t>> SimpleServiceAsyncClient::semifuture_words_count(const ::std::vector<::std::string>& p_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_words_count(rpcOptions, p_words);
}

folly::Future<::std::map<::std::string, ::std::int16_t>> SimpleServiceAsyncClient::future_words_count(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<::std::map<::std::string, ::std::int16_t>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::map<::std::string, ::std::int16_t>>>(std::move(promise), recv_wrapped_words_count, channel_);
  words_count(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<::std::map<::std::string, ::std::int16_t>> SimpleServiceAsyncClient::semifuture_words_count(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_words_count, channel_);
  auto callback = std::move(callbackAndFuture.first);
  words_count(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::map<::std::string, ::std::int16_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_words_count(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  folly::Promise<std::pair<::std::map<::std::string, ::std::int16_t>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::map<::std::string, ::std::int16_t>>>(std::move(promise), recv_wrapped_words_count, channel_);
  words_count(rpcOptions, std::move(callback), p_words);
  return future;
}

folly::SemiFuture<std::pair<::std::map<::std::string, ::std::int16_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_words_count(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_words) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_words_count, channel_);
  auto callback = std::move(callbackAndFuture.first);
  words_count(rpcOptions, std::move(callback), p_words);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::words_count(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::string>& p_words) {
  words_count(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_words);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_words_count(::std::map<::std::string, ::std::int16_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_words_count_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_words_count(::std::map<::std::string, ::std::int16_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_words_count(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_words_count(::std::map<::std::string, ::std::int16_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_words_count(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_words_count(::std::map<::std::string, ::std::int16_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_words_count(_return, state);
}

void SimpleServiceAsyncClient::set_enum(std::unique_ptr<apache::thrift::RequestCallback> callback, ::py3::simple::AnEnum p_in_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  set_enum(rpcOptions, std::move(callback), p_in_enum);
}

void SimpleServiceAsyncClient::set_enum(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::py3::simple::AnEnum p_in_enum) {
  auto [ctx, header] = set_enumCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  set_enumImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_in_enum);
}

void SimpleServiceAsyncClient::set_enumImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::py3::simple::AnEnum p_in_enum) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      set_enumT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_in_enum);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      set_enumT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_in_enum);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::set_enumCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.set_enum",
      *header);

  return {std::move(ctx), std::move(header)};
}

::py3::simple::AnEnum SimpleServiceAsyncClient::sync_set_enum(::py3::simple::AnEnum p_in_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_set_enum(rpcOptions, p_in_enum);
}

::py3::simple::AnEnum SimpleServiceAsyncClient::sync_set_enum(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::AnEnum p_in_enum) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = set_enumCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      set_enumImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_in_enum);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_set_enum(returnState);
  });
}


folly::Future<::py3::simple::AnEnum> SimpleServiceAsyncClient::future_set_enum(::py3::simple::AnEnum p_in_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_set_enum(rpcOptions, p_in_enum);
}

folly::SemiFuture<::py3::simple::AnEnum> SimpleServiceAsyncClient::semifuture_set_enum(::py3::simple::AnEnum p_in_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_set_enum(rpcOptions, p_in_enum);
}

folly::Future<::py3::simple::AnEnum> SimpleServiceAsyncClient::future_set_enum(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::AnEnum p_in_enum) {
  folly::Promise<::py3::simple::AnEnum> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::py3::simple::AnEnum>>(std::move(promise), recv_wrapped_set_enum, channel_);
  set_enum(rpcOptions, std::move(callback), p_in_enum);
  return future;
}

folly::SemiFuture<::py3::simple::AnEnum> SimpleServiceAsyncClient::semifuture_set_enum(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::AnEnum p_in_enum) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_set_enum, channel_);
  auto callback = std::move(callbackAndFuture.first);
  set_enum(rpcOptions, std::move(callback), p_in_enum);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::py3::simple::AnEnum, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_set_enum(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::AnEnum p_in_enum) {
  folly::Promise<std::pair<::py3::simple::AnEnum, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::py3::simple::AnEnum>>(std::move(promise), recv_wrapped_set_enum, channel_);
  set_enum(rpcOptions, std::move(callback), p_in_enum);
  return future;
}

folly::SemiFuture<std::pair<::py3::simple::AnEnum, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_set_enum(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::AnEnum p_in_enum) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_set_enum, channel_);
  auto callback = std::move(callbackAndFuture.first);
  set_enum(rpcOptions, std::move(callback), p_in_enum);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::set_enum(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::py3::simple::AnEnum p_in_enum) {
  set_enum(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_in_enum);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_set_enum(::py3::simple::AnEnum& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_set_enum_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::py3::simple::AnEnum SimpleServiceAsyncClient::recv_set_enum(::apache::thrift::ClientReceiveState& state) {
  ::py3::simple::AnEnum _return;
  auto ew = recv_wrapped_set_enum(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::py3::simple::AnEnum SimpleServiceAsyncClient::recv_instance_set_enum(::apache::thrift::ClientReceiveState& state) {
  return recv_set_enum(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_set_enum(::py3::simple::AnEnum& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_set_enum(_return, state);
}

void SimpleServiceAsyncClient::list_of_lists(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  list_of_lists(rpcOptions, std::move(callback), p_num_lists, p_num_items);
}

void SimpleServiceAsyncClient::list_of_lists(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto [ctx, header] = list_of_listsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  list_of_listsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_num_lists, p_num_items);
}

void SimpleServiceAsyncClient::list_of_listsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      list_of_listsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_num_lists, p_num_items);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      list_of_listsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_num_lists, p_num_items);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::list_of_listsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.list_of_lists",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_list_of_lists(rpcOptions, _return, p_num_lists, p_num_items);
}

void SimpleServiceAsyncClient::sync_list_of_lists(apache::thrift::RpcOptions& rpcOptions, ::std::vector<::std::vector<::std::int32_t>>& _return, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = list_of_listsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      list_of_listsImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_num_lists, p_num_items);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_list_of_lists(_return, returnState);
  });
}


folly::Future<::std::vector<::std::vector<::std::int32_t>>> SimpleServiceAsyncClient::future_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_list_of_lists(rpcOptions, p_num_lists, p_num_items);
}

folly::SemiFuture<::std::vector<::std::vector<::std::int32_t>>> SimpleServiceAsyncClient::semifuture_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_list_of_lists(rpcOptions, p_num_lists, p_num_items);
}

folly::Future<::std::vector<::std::vector<::std::int32_t>>> SimpleServiceAsyncClient::future_list_of_lists(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  folly::Promise<::std::vector<::std::vector<::std::int32_t>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::vector<::std::vector<::std::int32_t>>>>(std::move(promise), recv_wrapped_list_of_lists, channel_);
  list_of_lists(rpcOptions, std::move(callback), p_num_lists, p_num_items);
  return future;
}

folly::SemiFuture<::std::vector<::std::vector<::std::int32_t>>> SimpleServiceAsyncClient::semifuture_list_of_lists(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_list_of_lists, channel_);
  auto callback = std::move(callbackAndFuture.first);
  list_of_lists(rpcOptions, std::move(callback), p_num_lists, p_num_items);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::vector<::std::vector<::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_list_of_lists(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  folly::Promise<std::pair<::std::vector<::std::vector<::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::vector<::std::vector<::std::int32_t>>>>(std::move(promise), recv_wrapped_list_of_lists, channel_);
  list_of_lists(rpcOptions, std::move(callback), p_num_lists, p_num_items);
  return future;
}

folly::SemiFuture<std::pair<::std::vector<::std::vector<::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_list_of_lists(apache::thrift::RpcOptions& rpcOptions, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_list_of_lists, channel_);
  auto callback = std::move(callbackAndFuture.first);
  list_of_lists(rpcOptions, std::move(callback), p_num_lists, p_num_items);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::list_of_lists(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  list_of_lists(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_num_lists, p_num_items);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_list_of_lists_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_list_of_lists(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_list_of_lists(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_list_of_lists(_return, state);
}

void SimpleServiceAsyncClient::word_character_frequency(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_sentence) {
  ::apache::thrift::RpcOptions rpcOptions;
  word_character_frequency(rpcOptions, std::move(callback), p_sentence);
}

void SimpleServiceAsyncClient::word_character_frequency(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_sentence) {
  auto [ctx, header] = word_character_frequencyCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  word_character_frequencyImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_sentence);
}

void SimpleServiceAsyncClient::word_character_frequencyImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_sentence) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      word_character_frequencyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_sentence);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      word_character_frequencyT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_sentence);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::word_character_frequencyCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.word_character_frequency",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, const ::std::string& p_sentence) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_word_character_frequency(rpcOptions, _return, p_sentence);
}

void SimpleServiceAsyncClient::sync_word_character_frequency(apache::thrift::RpcOptions& rpcOptions, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, const ::std::string& p_sentence) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = word_character_frequencyCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      word_character_frequencyImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_sentence);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_word_character_frequency(_return, returnState);
  });
}


folly::Future<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> SimpleServiceAsyncClient::future_word_character_frequency(const ::std::string& p_sentence) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_word_character_frequency(rpcOptions, p_sentence);
}

folly::SemiFuture<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> SimpleServiceAsyncClient::semifuture_word_character_frequency(const ::std::string& p_sentence) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_word_character_frequency(rpcOptions, p_sentence);
}

folly::Future<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> SimpleServiceAsyncClient::future_word_character_frequency(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_sentence) {
  folly::Promise<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>(std::move(promise), recv_wrapped_word_character_frequency, channel_);
  word_character_frequency(rpcOptions, std::move(callback), p_sentence);
  return future;
}

folly::SemiFuture<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> SimpleServiceAsyncClient::semifuture_word_character_frequency(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_sentence) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_word_character_frequency, channel_);
  auto callback = std::move(callbackAndFuture.first);
  word_character_frequency(rpcOptions, std::move(callback), p_sentence);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_word_character_frequency(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_sentence) {
  folly::Promise<std::pair<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>(std::move(promise), recv_wrapped_word_character_frequency, channel_);
  word_character_frequency(rpcOptions, std::move(callback), p_sentence);
  return future;
}

folly::SemiFuture<std::pair<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_word_character_frequency(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_sentence) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_word_character_frequency, channel_);
  auto callback = std::move(callbackAndFuture.first);
  word_character_frequency(rpcOptions, std::move(callback), p_sentence);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::word_character_frequency(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::string& p_sentence) {
  word_character_frequency(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_sentence);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_word_character_frequency_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_word_character_frequency(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_word_character_frequency(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_word_character_frequency(_return, state);
}

void SimpleServiceAsyncClient::list_of_sets(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_some_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  list_of_sets(rpcOptions, std::move(callback), p_some_words);
}

void SimpleServiceAsyncClient::list_of_sets(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_some_words) {
  auto [ctx, header] = list_of_setsCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  list_of_setsImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_some_words);
}

void SimpleServiceAsyncClient::list_of_setsImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_some_words) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      list_of_setsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_some_words);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      list_of_setsT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_some_words);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::list_of_setsCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.list_of_sets",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_list_of_sets(::std::vector<::std::set<::std::string>>& _return, const ::std::string& p_some_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_list_of_sets(rpcOptions, _return, p_some_words);
}

void SimpleServiceAsyncClient::sync_list_of_sets(apache::thrift::RpcOptions& rpcOptions, ::std::vector<::std::set<::std::string>>& _return, const ::std::string& p_some_words) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = list_of_setsCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      list_of_setsImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_some_words);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_list_of_sets(_return, returnState);
  });
}


folly::Future<::std::vector<::std::set<::std::string>>> SimpleServiceAsyncClient::future_list_of_sets(const ::std::string& p_some_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_list_of_sets(rpcOptions, p_some_words);
}

folly::SemiFuture<::std::vector<::std::set<::std::string>>> SimpleServiceAsyncClient::semifuture_list_of_sets(const ::std::string& p_some_words) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_list_of_sets(rpcOptions, p_some_words);
}

folly::Future<::std::vector<::std::set<::std::string>>> SimpleServiceAsyncClient::future_list_of_sets(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_some_words) {
  folly::Promise<::std::vector<::std::set<::std::string>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::vector<::std::set<::std::string>>>>(std::move(promise), recv_wrapped_list_of_sets, channel_);
  list_of_sets(rpcOptions, std::move(callback), p_some_words);
  return future;
}

folly::SemiFuture<::std::vector<::std::set<::std::string>>> SimpleServiceAsyncClient::semifuture_list_of_sets(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_some_words) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_list_of_sets, channel_);
  auto callback = std::move(callbackAndFuture.first);
  list_of_sets(rpcOptions, std::move(callback), p_some_words);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::vector<::std::set<::std::string>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_list_of_sets(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_some_words) {
  folly::Promise<std::pair<::std::vector<::std::set<::std::string>>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::vector<::std::set<::std::string>>>>(std::move(promise), recv_wrapped_list_of_sets, channel_);
  list_of_sets(rpcOptions, std::move(callback), p_some_words);
  return future;
}

folly::SemiFuture<std::pair<::std::vector<::std::set<::std::string>>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_list_of_sets(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_some_words) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_list_of_sets, channel_);
  auto callback = std::move(callbackAndFuture.first);
  list_of_sets(rpcOptions, std::move(callback), p_some_words);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::list_of_sets(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::string& p_some_words) {
  list_of_sets(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_some_words);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_list_of_sets(::std::vector<::std::set<::std::string>>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_list_of_sets_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_list_of_sets(::std::vector<::std::set<::std::string>>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_list_of_sets(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_list_of_sets(::std::vector<::std::set<::std::string>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_list_of_sets(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_list_of_sets(::std::vector<::std::set<::std::string>>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_list_of_sets(_return, state);
}

void SimpleServiceAsyncClient::nested_map_argument(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  nested_map_argument(rpcOptions, std::move(callback), p_struct_map);
}

void SimpleServiceAsyncClient::nested_map_argument(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  auto [ctx, header] = nested_map_argumentCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  nested_map_argumentImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_struct_map);
}

void SimpleServiceAsyncClient::nested_map_argumentImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      nested_map_argumentT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_struct_map);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      nested_map_argumentT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_struct_map);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::nested_map_argumentCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.nested_map_argument",
      *header);

  return {std::move(ctx), std::move(header)};
}

::std::int32_t SimpleServiceAsyncClient::sync_nested_map_argument(const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_nested_map_argument(rpcOptions, p_struct_map);
}

::std::int32_t SimpleServiceAsyncClient::sync_nested_map_argument(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = nested_map_argumentCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      nested_map_argumentImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_struct_map);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_nested_map_argument(returnState);
  });
}


folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_nested_map_argument(const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_nested_map_argument(rpcOptions, p_struct_map);
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_nested_map_argument(const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_nested_map_argument(rpcOptions, p_struct_map);
}

folly::Future<::std::int32_t> SimpleServiceAsyncClient::future_nested_map_argument(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  folly::Promise<::std::int32_t> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_nested_map_argument, channel_);
  nested_map_argument(rpcOptions, std::move(callback), p_struct_map);
  return future;
}

folly::SemiFuture<::std::int32_t> SimpleServiceAsyncClient::semifuture_nested_map_argument(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_nested_map_argument, channel_);
  auto callback = std::move(callbackAndFuture.first);
  nested_map_argument(rpcOptions, std::move(callback), p_struct_map);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_nested_map_argument(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  folly::Promise<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::int32_t>>(std::move(promise), recv_wrapped_nested_map_argument, channel_);
  nested_map_argument(rpcOptions, std::move(callback), p_struct_map);
  return future;
}

folly::SemiFuture<std::pair<::std::int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_nested_map_argument(apache::thrift::RpcOptions& rpcOptions, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_nested_map_argument, channel_);
  auto callback = std::move(callbackAndFuture.first);
  nested_map_argument(rpcOptions, std::move(callback), p_struct_map);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::nested_map_argument(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>& p_struct_map) {
  nested_map_argument(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_struct_map);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_nested_map_argument(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_nested_map_argument_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

::std::int32_t SimpleServiceAsyncClient::recv_nested_map_argument(::apache::thrift::ClientReceiveState& state) {
  ::std::int32_t _return;
  auto ew = recv_wrapped_nested_map_argument(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

::std::int32_t SimpleServiceAsyncClient::recv_instance_nested_map_argument(::apache::thrift::ClientReceiveState& state) {
  return recv_nested_map_argument(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_nested_map_argument(::std::int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_nested_map_argument(_return, state);
}

void SimpleServiceAsyncClient::make_sentence(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  ::apache::thrift::RpcOptions rpcOptions;
  make_sentence(rpcOptions, std::move(callback), p_word_chars);
}

void SimpleServiceAsyncClient::make_sentence(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  auto [ctx, header] = make_sentenceCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  make_sentenceImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_word_chars);
}

void SimpleServiceAsyncClient::make_sentenceImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      make_sentenceT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_word_chars);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      make_sentenceT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_word_chars);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::make_sentenceCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.make_sentence",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_make_sentence(::std::string& _return, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_make_sentence(rpcOptions, _return, p_word_chars);
}

void SimpleServiceAsyncClient::sync_make_sentence(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = make_sentenceCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      make_sentenceImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_word_chars);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_make_sentence(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_make_sentence(const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_make_sentence(rpcOptions, p_word_chars);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_make_sentence(const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_make_sentence(rpcOptions, p_word_chars);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_make_sentence(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_make_sentence, channel_);
  make_sentence(rpcOptions, std::move(callback), p_word_chars);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_make_sentence(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_make_sentence, channel_);
  auto callback = std::move(callbackAndFuture.first);
  make_sentence(rpcOptions, std::move(callback), p_word_chars);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_make_sentence(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_make_sentence, channel_);
  make_sentence(rpcOptions, std::move(callback), p_word_chars);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_make_sentence(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_make_sentence, channel_);
  auto callback = std::move(callbackAndFuture.first);
  make_sentence(rpcOptions, std::move(callback), p_word_chars);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::make_sentence(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::vector<::std::string>>& p_word_chars) {
  make_sentence(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_word_chars);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_make_sentence(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_make_sentence_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_make_sentence(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_make_sentence(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_make_sentence(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_make_sentence(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_make_sentence(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_make_sentence(_return, state);
}

void SimpleServiceAsyncClient::get_union(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_union(rpcOptions, std::move(callback), p_sets);
}

void SimpleServiceAsyncClient::get_union(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  auto [ctx, header] = get_unionCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_unionImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_sets);
}

void SimpleServiceAsyncClient::get_unionImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_unionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_sets);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_unionT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_sets);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_unionCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_union",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_get_union(::std::set<::std::int32_t>& _return, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get_union(rpcOptions, _return, p_sets);
}

void SimpleServiceAsyncClient::sync_get_union(apache::thrift::RpcOptions& rpcOptions, ::std::set<::std::int32_t>& _return, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_unionCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_unionImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_sets);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get_union(_return, returnState);
  });
}


folly::Future<::std::set<::std::int32_t>> SimpleServiceAsyncClient::future_get_union(const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_union(rpcOptions, p_sets);
}

folly::SemiFuture<::std::set<::std::int32_t>> SimpleServiceAsyncClient::semifuture_get_union(const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_union(rpcOptions, p_sets);
}

folly::Future<::std::set<::std::int32_t>> SimpleServiceAsyncClient::future_get_union(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  folly::Promise<::std::set<::std::int32_t>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::set<::std::int32_t>>>(std::move(promise), recv_wrapped_get_union, channel_);
  get_union(rpcOptions, std::move(callback), p_sets);
  return future;
}

folly::SemiFuture<::std::set<::std::int32_t>> SimpleServiceAsyncClient::semifuture_get_union(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_union, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_union(rpcOptions, std::move(callback), p_sets);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::set<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_union(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  folly::Promise<std::pair<::std::set<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::set<::std::int32_t>>>(std::move(promise), recv_wrapped_get_union, channel_);
  get_union(rpcOptions, std::move(callback), p_sets);
  return future;
}

folly::SemiFuture<std::pair<::std::set<::std::int32_t>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_union(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_union, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_union(rpcOptions, std::move(callback), p_sets);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_union(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::set<::std::int32_t>>& p_sets) {
  get_union(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_sets);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_union(::std::set<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_union_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_get_union(::std::set<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get_union(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_get_union(::std::set<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get_union(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_union(::std::set<::std::int32_t>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_union(_return, state);
}

void SimpleServiceAsyncClient::get_keys(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_keys(rpcOptions, std::move(callback), p_string_map);
}

void SimpleServiceAsyncClient::get_keys(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  auto [ctx, header] = get_keysCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_keysImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_string_map);
}

void SimpleServiceAsyncClient::get_keysImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_keysT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_string_map);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_keysT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_string_map);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_keysCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_keys",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_get_keys(::std::set<::std::string>& _return, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get_keys(rpcOptions, _return, p_string_map);
}

void SimpleServiceAsyncClient::sync_get_keys(apache::thrift::RpcOptions& rpcOptions, ::std::set<::std::string>& _return, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_keysCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_keysImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_string_map);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get_keys(_return, returnState);
  });
}


folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_get_keys(const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_keys(rpcOptions, p_string_map);
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_get_keys(const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_keys(rpcOptions, p_string_map);
}

folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_get_keys(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  folly::Promise<::std::set<::std::string>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_get_keys, channel_);
  get_keys(rpcOptions, std::move(callback), p_string_map);
  return future;
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_get_keys(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_keys, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_keys(rpcOptions, std::move(callback), p_string_map);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_keys(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  folly::Promise<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_get_keys, channel_);
  get_keys(rpcOptions, std::move(callback), p_string_map);
  return future;
}

folly::SemiFuture<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_keys(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_keys, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_keys(rpcOptions, std::move(callback), p_string_map);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_keys(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::map<::std::string, ::std::string>>& p_string_map) {
  get_keys(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_string_map);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_keys(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_keys_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_get_keys(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get_keys(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_get_keys(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get_keys(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_keys(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_keys(_return, state);
}

void SimpleServiceAsyncClient::lookup_double(std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int32_t p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  lookup_double(rpcOptions, std::move(callback), p_key);
}

void SimpleServiceAsyncClient::lookup_double(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, ::std::int32_t p_key) {
  auto [ctx, header] = lookup_doubleCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  lookup_doubleImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_key);
}

void SimpleServiceAsyncClient::lookup_doubleImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, ::std::int32_t p_key) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      lookup_doubleT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_key);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      lookup_doubleT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_key);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::lookup_doubleCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.lookup_double",
      *header);

  return {std::move(ctx), std::move(header)};
}

double SimpleServiceAsyncClient::sync_lookup_double(::std::int32_t p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_lookup_double(rpcOptions, p_key);
}

double SimpleServiceAsyncClient::sync_lookup_double(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_key) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = lookup_doubleCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      lookup_doubleImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_key);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      return recv_lookup_double(returnState);
  });
}


folly::Future<double> SimpleServiceAsyncClient::future_lookup_double(::std::int32_t p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_lookup_double(rpcOptions, p_key);
}

folly::SemiFuture<double> SimpleServiceAsyncClient::semifuture_lookup_double(::std::int32_t p_key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_lookup_double(rpcOptions, p_key);
}

folly::Future<double> SimpleServiceAsyncClient::future_lookup_double(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_key) {
  folly::Promise<double> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<double>>(std::move(promise), recv_wrapped_lookup_double, channel_);
  lookup_double(rpcOptions, std::move(callback), p_key);
  return future;
}

folly::SemiFuture<double> SimpleServiceAsyncClient::semifuture_lookup_double(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_key) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_lookup_double, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookup_double(rpcOptions, std::move(callback), p_key);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_lookup_double(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_key) {
  folly::Promise<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<double>>(std::move(promise), recv_wrapped_lookup_double, channel_);
  lookup_double(rpcOptions, std::move(callback), p_key);
  return future;
}

folly::SemiFuture<std::pair<double, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_lookup_double(apache::thrift::RpcOptions& rpcOptions, ::std::int32_t p_key) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_lookup_double, channel_);
  auto callback = std::move(callbackAndFuture.first);
  lookup_double(rpcOptions, std::move(callback), p_key);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::lookup_double(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, ::std::int32_t p_key) {
  lookup_double(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_key);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_lookup_double(double& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_lookup_double_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

double SimpleServiceAsyncClient::recv_lookup_double(::apache::thrift::ClientReceiveState& state) {
  double _return;
  auto ew = recv_wrapped_lookup_double(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

double SimpleServiceAsyncClient::recv_instance_lookup_double(::apache::thrift::ClientReceiveState& state) {
  return recv_lookup_double(state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_lookup_double(double& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_lookup_double(_return, state);
}

void SimpleServiceAsyncClient::retrieve_binary(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_something) {
  ::apache::thrift::RpcOptions rpcOptions;
  retrieve_binary(rpcOptions, std::move(callback), p_something);
}

void SimpleServiceAsyncClient::retrieve_binary(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::string& p_something) {
  auto [ctx, header] = retrieve_binaryCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  retrieve_binaryImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_something);
}

void SimpleServiceAsyncClient::retrieve_binaryImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::string& p_something) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      retrieve_binaryT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_something);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      retrieve_binaryT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_something);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::retrieve_binaryCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.retrieve_binary",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_retrieve_binary(::std::string& _return, const ::std::string& p_something) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_retrieve_binary(rpcOptions, _return, p_something);
}

void SimpleServiceAsyncClient::sync_retrieve_binary(apache::thrift::RpcOptions& rpcOptions, ::std::string& _return, const ::std::string& p_something) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = retrieve_binaryCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      retrieve_binaryImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_something);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_retrieve_binary(_return, returnState);
  });
}


folly::Future<::std::string> SimpleServiceAsyncClient::future_retrieve_binary(const ::std::string& p_something) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_retrieve_binary(rpcOptions, p_something);
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_retrieve_binary(const ::std::string& p_something) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_retrieve_binary(rpcOptions, p_something);
}

folly::Future<::std::string> SimpleServiceAsyncClient::future_retrieve_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_something) {
  folly::Promise<::std::string> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::string>>(std::move(promise), recv_wrapped_retrieve_binary, channel_);
  retrieve_binary(rpcOptions, std::move(callback), p_something);
  return future;
}

folly::SemiFuture<::std::string> SimpleServiceAsyncClient::semifuture_retrieve_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_something) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_retrieve_binary, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retrieve_binary(rpcOptions, std::move(callback), p_something);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_retrieve_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_something) {
  folly::Promise<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::string>>(std::move(promise), recv_wrapped_retrieve_binary, channel_);
  retrieve_binary(rpcOptions, std::move(callback), p_something);
  return future;
}

folly::SemiFuture<std::pair<::std::string, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_retrieve_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::string& p_something) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_retrieve_binary, channel_);
  auto callback = std::move(callbackAndFuture.first);
  retrieve_binary(rpcOptions, std::move(callback), p_something);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::retrieve_binary(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::string& p_something) {
  retrieve_binary(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_something);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_retrieve_binary(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_retrieve_binary_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_retrieve_binary(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_retrieve_binary(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_retrieve_binary(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_retrieve_binary(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_retrieve_binary(::std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_retrieve_binary(_return, state);
}

void SimpleServiceAsyncClient::contain_binary(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_binaries) {
  ::apache::thrift::RpcOptions rpcOptions;
  contain_binary(rpcOptions, std::move(callback), p_binaries);
}

void SimpleServiceAsyncClient::contain_binary(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::std::string>& p_binaries) {
  auto [ctx, header] = contain_binaryCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  contain_binaryImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_binaries);
}

void SimpleServiceAsyncClient::contain_binaryImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::std::string>& p_binaries) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      contain_binaryT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_binaries);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      contain_binaryT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_binaries);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::contain_binaryCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.contain_binary",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_contain_binary(::std::set<::std::string>& _return, const ::std::vector<::std::string>& p_binaries) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_contain_binary(rpcOptions, _return, p_binaries);
}

void SimpleServiceAsyncClient::sync_contain_binary(apache::thrift::RpcOptions& rpcOptions, ::std::set<::std::string>& _return, const ::std::vector<::std::string>& p_binaries) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = contain_binaryCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      contain_binaryImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_binaries);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_contain_binary(_return, returnState);
  });
}


folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_contain_binary(const ::std::vector<::std::string>& p_binaries) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_contain_binary(rpcOptions, p_binaries);
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_contain_binary(const ::std::vector<::std::string>& p_binaries) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_contain_binary(rpcOptions, p_binaries);
}

folly::Future<::std::set<::std::string>> SimpleServiceAsyncClient::future_contain_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_binaries) {
  folly::Promise<::std::set<::std::string>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_contain_binary, channel_);
  contain_binary(rpcOptions, std::move(callback), p_binaries);
  return future;
}

folly::SemiFuture<::std::set<::std::string>> SimpleServiceAsyncClient::semifuture_contain_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_binaries) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_contain_binary, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contain_binary(rpcOptions, std::move(callback), p_binaries);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_contain_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_binaries) {
  folly::Promise<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::set<::std::string>>>(std::move(promise), recv_wrapped_contain_binary, channel_);
  contain_binary(rpcOptions, std::move(callback), p_binaries);
  return future;
}

folly::SemiFuture<std::pair<::std::set<::std::string>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_contain_binary(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::std::string>& p_binaries) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_contain_binary, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contain_binary(rpcOptions, std::move(callback), p_binaries);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::contain_binary(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::std::string>& p_binaries) {
  contain_binary(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_binaries);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_contain_binary(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_contain_binary_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_contain_binary(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_contain_binary(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_contain_binary(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_contain_binary(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_contain_binary(::std::set<::std::string>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_contain_binary(_return, state);
}

void SimpleServiceAsyncClient::contain_enum(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  contain_enum(rpcOptions, std::move(callback), p_the_enum);
}

void SimpleServiceAsyncClient::contain_enum(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  auto [ctx, header] = contain_enumCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  contain_enumImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_the_enum);
}

void SimpleServiceAsyncClient::contain_enumImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      contain_enumT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_the_enum);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      contain_enumT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_the_enum);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::contain_enumCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.contain_enum",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_contain_enum(rpcOptions, _return, p_the_enum);
}

void SimpleServiceAsyncClient::sync_contain_enum(apache::thrift::RpcOptions& rpcOptions, ::std::vector<::py3::simple::AnEnum>& _return, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = contain_enumCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      contain_enumImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_the_enum);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_contain_enum(_return, returnState);
  });
}


folly::Future<::std::vector<::py3::simple::AnEnum>> SimpleServiceAsyncClient::future_contain_enum(const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_contain_enum(rpcOptions, p_the_enum);
}

folly::SemiFuture<::std::vector<::py3::simple::AnEnum>> SimpleServiceAsyncClient::semifuture_contain_enum(const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_contain_enum(rpcOptions, p_the_enum);
}

folly::Future<::std::vector<::py3::simple::AnEnum>> SimpleServiceAsyncClient::future_contain_enum(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  folly::Promise<::std::vector<::py3::simple::AnEnum>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::std::vector<::py3::simple::AnEnum>>>(std::move(promise), recv_wrapped_contain_enum, channel_);
  contain_enum(rpcOptions, std::move(callback), p_the_enum);
  return future;
}

folly::SemiFuture<::std::vector<::py3::simple::AnEnum>> SimpleServiceAsyncClient::semifuture_contain_enum(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_contain_enum, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contain_enum(rpcOptions, std::move(callback), p_the_enum);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::std::vector<::py3::simple::AnEnum>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_contain_enum(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  folly::Promise<std::pair<::std::vector<::py3::simple::AnEnum>, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::std::vector<::py3::simple::AnEnum>>>(std::move(promise), recv_wrapped_contain_enum, channel_);
  contain_enum(rpcOptions, std::move(callback), p_the_enum);
  return future;
}

folly::SemiFuture<std::pair<::std::vector<::py3::simple::AnEnum>, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_contain_enum(apache::thrift::RpcOptions& rpcOptions, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_contain_enum, channel_);
  auto callback = std::move(callbackAndFuture.first);
  contain_enum(rpcOptions, std::move(callback), p_the_enum);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::contain_enum(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::std::vector<::py3::simple::AnEnum>& p_the_enum) {
  contain_enum(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_the_enum);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_contain_enum_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_contain_enum(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_contain_enum(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_contain_enum(_return, state);
}

void SimpleServiceAsyncClient::get_binary_union_struct(std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::BinaryUnion& p_u) {
  ::apache::thrift::RpcOptions rpcOptions;
  get_binary_union_struct(rpcOptions, std::move(callback), p_u);
}

void SimpleServiceAsyncClient::get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const ::py3::simple::BinaryUnion& p_u) {
  auto [ctx, header] = get_binary_union_structCtx(&rpcOptions);
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId =
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto* contextStack = ctx.get();
  if (callback) {
    callbackContext.ctx = std::move(ctx);
  }
  auto wrappedCallback = apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  get_binary_union_structImpl(rpcOptions, std::move(header), contextStack, std::move(wrappedCallback), p_u);
}

void SimpleServiceAsyncClient::get_binary_union_structImpl(const apache::thrift::RpcOptions& rpcOptions, std::shared_ptr<apache::thrift::transport::THeader> header, apache::thrift::ContextStack* contextStack, apache::thrift::RequestClientCallback::Ptr callback, const ::py3::simple::BinaryUnion& p_u) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      get_binary_union_structT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_u);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      get_binary_union_structT(&writer, rpcOptions, std::move(header), contextStack, std::move(callback), p_u);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

std::pair<std::unique_ptr<::apache::thrift::ContextStack>, std::shared_ptr<::apache::thrift::transport::THeader>> SimpleServiceAsyncClient::get_binary_union_structCtx(apache::thrift::RpcOptions* rpcOptions) {
  auto header = std::make_shared<apache::thrift::transport::THeader>(
      apache::thrift::transport::THeader::ALLOW_BIG_FRAMES);
  header->setProtocolId(channel_->getProtocolId());
  if (rpcOptions) {
    header->setHeaders(rpcOptions->releaseWriteHeaders());
  }

  auto ctx = apache::thrift::ContextStack::createWithClientContext(
      handlers_,
      getServiceName(),
      "SimpleService.get_binary_union_struct",
      *header);

  return {std::move(ctx), std::move(header)};
}

void SimpleServiceAsyncClient::sync_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, const ::py3::simple::BinaryUnion& p_u) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_get_binary_union_struct(rpcOptions, _return, p_u);
}

void SimpleServiceAsyncClient::sync_get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, ::py3::simple::BinaryUnionStruct& _return, const ::py3::simple::BinaryUnion& p_u) {
  apache::thrift::ClientReceiveState returnState;
  apache::thrift::ClientSyncCallback<false> callback(&returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctxAndHeader = get_binary_union_structCtx(&rpcOptions);
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  callback.waitUntilDone(
    evb,
    [&] {
      get_binary_union_structImpl(rpcOptions, std::move(ctxAndHeader.second), ctxAndHeader.first.get(), std::move(wrappedCallback), p_u);
    });

  if (returnState.isException()) {
    returnState.exception().throw_exception();
  }
  returnState.resetProtocolId(protocolId);
  returnState.resetCtx(std::move(ctxAndHeader.first));
  SCOPE_EXIT {
    if (returnState.header() && !returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(returnState.header()->releaseHeaders());
    }
  };
  return folly::fibers::runInMainContext([&] {
      recv_get_binary_union_struct(_return, returnState);
  });
}


folly::Future<::py3::simple::BinaryUnionStruct> SimpleServiceAsyncClient::future_get_binary_union_struct(const ::py3::simple::BinaryUnion& p_u) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get_binary_union_struct(rpcOptions, p_u);
}

folly::SemiFuture<::py3::simple::BinaryUnionStruct> SimpleServiceAsyncClient::semifuture_get_binary_union_struct(const ::py3::simple::BinaryUnion& p_u) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_get_binary_union_struct(rpcOptions, p_u);
}

folly::Future<::py3::simple::BinaryUnionStruct> SimpleServiceAsyncClient::future_get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::BinaryUnion& p_u) {
  folly::Promise<::py3::simple::BinaryUnionStruct> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<::py3::simple::BinaryUnionStruct>>(std::move(promise), recv_wrapped_get_binary_union_struct, channel_);
  get_binary_union_struct(rpcOptions, std::move(callback), p_u);
  return future;
}

folly::SemiFuture<::py3::simple::BinaryUnionStruct> SimpleServiceAsyncClient::semifuture_get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::BinaryUnion& p_u) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_get_binary_union_struct, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_binary_union_struct(rpcOptions, std::move(callback), p_u);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::py3::simple::BinaryUnionStruct, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_future_get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::BinaryUnion& p_u) {
  folly::Promise<std::pair<::py3::simple::BinaryUnionStruct, std::unique_ptr<apache::thrift::transport::THeader>>> promise;
  auto future = promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<::py3::simple::BinaryUnionStruct>>(std::move(promise), recv_wrapped_get_binary_union_struct, channel_);
  get_binary_union_struct(rpcOptions, std::move(callback), p_u);
  return future;
}

folly::SemiFuture<std::pair<::py3::simple::BinaryUnionStruct, std::unique_ptr<apache::thrift::transport::THeader>>> SimpleServiceAsyncClient::header_semifuture_get_binary_union_struct(apache::thrift::RpcOptions& rpcOptions, const ::py3::simple::BinaryUnion& p_u) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_get_binary_union_struct, channel_);
  auto callback = std::move(callbackAndFuture.first);
  get_binary_union_struct(rpcOptions, std::move(callback), p_u);
  return std::move(callbackAndFuture.second);
}

void SimpleServiceAsyncClient::get_binary_union_struct(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const ::py3::simple::BinaryUnion& p_u) {
  get_binary_union_struct(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), p_u);
}

#if FOLLY_HAS_COROUTINES
#endif // FOLLY_HAS_COROUTINES
folly::exception_wrapper SimpleServiceAsyncClient::recv_wrapped_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.hasResponseBuffer()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }

  using result = SimpleService_get_binary_union_struct_presult;
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(
          &reader, state, _return);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void SimpleServiceAsyncClient::recv_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_get_binary_union_struct(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void SimpleServiceAsyncClient::recv_instance_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_get_binary_union_struct(_return, state);
}

folly::exception_wrapper SimpleServiceAsyncClient::recv_instance_wrapped_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get_binary_union_struct(_return, state);
}


}} // py3::simple
