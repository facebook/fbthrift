/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "module_fatal.h"

#include <fatal/type/enum.h>

#include <type_traits>

namespace test_cpp2 { namespace cpp_reflection {

namespace detail {

struct enum1_enum_traits {
  using type = ::test_cpp2::cpp_reflection::enum1;
  using name = ::fatal::constant_sequence<char, 'e', 'n', 'u', 'm', '1'>;

  struct str {
    using field0 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '0'>;
    using field1 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '1'>;
    using field2 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '2'>;
  };

  using name_to_value = ::fatal::type_map<
    ::fatal::type_pair<
      str::field0,
      std::integral_constant<type, type::field0>
    >,
    ::fatal::type_pair<
      str::field1,
      std::integral_constant<type, type::field1>
    >,
    ::fatal::type_pair<
      str::field2,
      std::integral_constant<type, type::field2>
    >
  >;

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::field0: return "field0";
      case type::field1: return "field1";
      case type::field2: return "field2";
      default: return fallback;
    }
  }
};

} // detail

FATAL_REGISTER_ENUM_TRAITS(::test_cpp2::cpp_reflection::detail::enum1_enum_traits, module_tags::metadata);
namespace detail {

struct enum2_enum_traits {
  using type = ::test_cpp2::cpp_reflection::enum2;
  using name = ::fatal::constant_sequence<char, 'e', 'n', 'u', 'm', '2'>;

  struct str {
    using field0_2 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '0', '_', '2'>;
    using field1_2 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '1', '_', '2'>;
    using field2_2 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '2', '_', '2'>;
  };

  using name_to_value = ::fatal::type_map<
    ::fatal::type_pair<
      str::field0_2,
      std::integral_constant<type, type::field0_2>
    >,
    ::fatal::type_pair<
      str::field1_2,
      std::integral_constant<type, type::field1_2>
    >,
    ::fatal::type_pair<
      str::field2_2,
      std::integral_constant<type, type::field2_2>
    >
  >;

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::field0_2: return "field0_2";
      case type::field1_2: return "field1_2";
      case type::field2_2: return "field2_2";
      default: return fallback;
    }
  }
};

} // detail

FATAL_REGISTER_ENUM_TRAITS(::test_cpp2::cpp_reflection::detail::enum2_enum_traits, module_tags::metadata);
namespace detail {

struct enum3_enum_traits {
  using type = ::test_cpp2::cpp_reflection::enum3;
  using name = ::fatal::constant_sequence<char, 'e', 'n', 'u', 'm', '3'>;

  struct str {
    using field0_3 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '0', '_', '3'>;
    using field1_3 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '1', '_', '3'>;
    using field2_3 = ::fatal::constant_sequence<char, 'f', 'i', 'e', 'l', 'd', '2', '_', '3'>;
  };

  using name_to_value = ::fatal::type_map<
    ::fatal::type_pair<
      str::field0_3,
      std::integral_constant<type, type::field0_3>
    >,
    ::fatal::type_pair<
      str::field1_3,
      std::integral_constant<type, type::field1_3>
    >,
    ::fatal::type_pair<
      str::field2_3,
      std::integral_constant<type, type::field2_3>
    >
  >;

  static char const *to_string(type e, char const *fallback) {
    switch (e) {
      case type::field0_3: return "field0_3";
      case type::field1_3: return "field1_3";
      case type::field2_3: return "field2_3";
      default: return fallback;
    }
  }
};

} // detail

FATAL_REGISTER_ENUM_TRAITS(::test_cpp2::cpp_reflection::detail::enum3_enum_traits, module_tags::metadata);

}} // test_cpp2::cpp_reflection