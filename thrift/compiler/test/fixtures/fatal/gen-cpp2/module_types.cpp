/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::size;
folly::Range<::test_cpp2::cpp_reflection::enum1 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = _enum1_EnumMapFactory::makeValuesToNamesMap();
const _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES = _enum1_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::size;
folly::Range<::test_cpp2::cpp_reflection::enum2 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = _enum2_EnumMapFactory::makeValuesToNamesMap();
const _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES = _enum2_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::size;
folly::Range<::test_cpp2::cpp_reflection::enum3 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = _enum3_EnumMapFactory::makeValuesToNamesMap();
const _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES = _enum3_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::size;
folly::Range<::test_cpp2::cpp_reflection::enum_with_special_names const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = _enum_with_special_names_EnumMapFactory::makeValuesToNamesMap();
const _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES = _enum_with_special_names_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union1>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "ui",
    "ud",
    "us",
    "ue",
  };
  static constexpr int16_t _ids[] = {
    1,
    3,
    5,
    7,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_DOUBLE,
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union1::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union1::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union1::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union1::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
    {
      destruct(value_.ui);
      break;
    }
    case Type::ud:
    {
      destruct(value_.ud);
      break;
    }
    case Type::us:
    {
      destruct(value_.us);
      break;
    }
    case Type::ue:
    {
      destruct(value_.ue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
    {
      return value_.ui == rhs.value_.ui;
    }
    case Type::ud:
    {
      return value_.ud == rhs.value_.ud;
    }
    case Type::us:
    {
      return value_.us == rhs.value_.us;
    }
    case Type::ue:
    {
      return value_.ue == rhs.value_.ue;
    }
    default:
    {
      return true;
    }
  }
}

bool union1::operator<(const union1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui:
      return lhs.value_.ui < rhs.value_.ui;
    case Type::ud:
      return lhs.value_.ud < rhs.value_.ud;
    case Type::us:
      return lhs.value_.us < rhs.value_.us;
    case Type::ue:
      return lhs.value_.ue < rhs.value_.ue;
    default:
      return false;
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union2>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "ui_2",
    "ud_2",
    "us_2",
    "ue_2",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_DOUBLE,
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union2::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union2::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union2::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union2::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
    {
      destruct(value_.ui_2);
      break;
    }
    case Type::ud_2:
    {
      destruct(value_.ud_2);
      break;
    }
    case Type::us_2:
    {
      destruct(value_.us_2);
      break;
    }
    case Type::ue_2:
    {
      destruct(value_.ue_2);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
    {
      return value_.ui_2 == rhs.value_.ui_2;
    }
    case Type::ud_2:
    {
      return value_.ud_2 == rhs.value_.ud_2;
    }
    case Type::us_2:
    {
      return value_.us_2 == rhs.value_.us_2;
    }
    case Type::ue_2:
    {
      return value_.ue_2 == rhs.value_.ue_2;
    }
    default:
    {
      return true;
    }
  }
}

bool union2::operator<(const union2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui_2:
      return lhs.value_.ui_2 < rhs.value_.ui_2;
    case Type::ud_2:
      return lhs.value_.ud_2 < rhs.value_.ud_2;
    case Type::us_2:
      return lhs.value_.us_2 < rhs.value_.us_2;
    case Type::ue_2:
      return lhs.value_.ue_2 < rhs.value_.ue_2;
    default:
      return false;
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union3>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "ui_3",
    "ud_3",
    "us_3",
    "ue_3",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_DOUBLE,
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union3::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union3::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union3::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union3::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
    {
      destruct(value_.ui_3);
      break;
    }
    case Type::ud_3:
    {
      destruct(value_.ud_3);
      break;
    }
    case Type::us_3:
    {
      destruct(value_.us_3);
      break;
    }
    case Type::ue_3:
    {
      destruct(value_.ue_3);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
    {
      return value_.ui_3 == rhs.value_.ui_3;
    }
    case Type::ud_3:
    {
      return value_.ud_3 == rhs.value_.ud_3;
    }
    case Type::us_3:
    {
      return value_.us_3 == rhs.value_.us_3;
    }
    case Type::ue_3:
    {
      return value_.ue_3 == rhs.value_.ue_3;
    }
    default:
    {
      return true;
    }
  }
}

bool union3::operator<(const union3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui_3:
      return lhs.value_.ui_3 < rhs.value_.ui_3;
    case Type::ud_3:
      return lhs.value_.ud_3 < rhs.value_.ud_3;
    case Type::us_3:
      return lhs.value_.us_3 < rhs.value_.us_3;
    case Type::ue_3:
      return lhs.value_.ue_3 < rhs.value_.ue_3;
    default:
      return false;
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structA>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "a",
    "b",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structA::structA(apache::thrift::FragileConstructor, int32_t a__arg, ::std::string b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)) {
  __isset.a = true;
  __isset.b = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void structA::__clear() {
  // clear all fields
  a = 0;
  b = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structA::operator==(const structA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  return true;
}

bool structA::operator<(const structA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  return false;
}


void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::unionA>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "i",
    "d",
    "s",
    "e",
    "a",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_DOUBLE,
    TType::T_STRING,
    TType::T_I32,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::unionA::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::unionA::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::unionA::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void unionA::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::i:
    {
      destruct(value_.i);
      break;
    }
    case Type::d:
    {
      destruct(value_.d);
      break;
    }
    case Type::s:
    {
      destruct(value_.s);
      break;
    }
    case Type::e:
    {
      destruct(value_.e);
      break;
    }
    case Type::a:
    {
      destruct(value_.a);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::i:
    {
      return value_.i == rhs.value_.i;
    }
    case Type::d:
    {
      return value_.d == rhs.value_.d;
    }
    case Type::s:
    {
      return value_.s == rhs.value_.s;
    }
    case Type::e:
    {
      return value_.e == rhs.value_.e;
    }
    case Type::a:
    {
      return value_.a == rhs.value_.a;
    }
    default:
    {
      return true;
    }
  }
}

bool unionA::operator<(const unionA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::i:
      return lhs.value_.i < rhs.value_.i;
    case Type::d:
      return lhs.value_.d < rhs.value_.d;
    case Type::s:
      return lhs.value_.s < rhs.value_.s;
    case Type::e:
      return lhs.value_.e < rhs.value_.e;
    case Type::a:
      return lhs.value_.a < rhs.value_.a;
    default:
      return false;
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void unionA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void unionA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        unionA,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        unionA,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structB>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "c",
    "d",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_DOUBLE,
    TType::T_BOOL,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structB::structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
    c(std::move(c__arg)),
    d(std::move(d__arg)) {
  __isset.c = true;
  __isset.d = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void structB::__clear() {
  // clear all fields
  c = 0;
  d = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structB::operator==(const structB& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.c == rhs.c)) {
    return false;
  }
  if (!(lhs.d == rhs.d)) {
    return false;
  }
  return true;
}

bool structB::operator<(const structB& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.c == rhs.c)) {
    return lhs.c < rhs.c;
  }
  if (!(lhs.d == rhs.d)) {
    return lhs.d < rhs.d;
  }
  return false;
}


void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.d_ref().value(), b.d_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structB::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structB::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structC>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 30;
  static constexpr folly::StringPiece _names[] = {
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "j1",
    "j2",
    "j3",
    "k",
    "k1",
    "k2",
    "k3",
    "l",
    "l1",
    "l2",
    "l3",
    "m1",
    "m2",
    "m3",
    "n1",
    "n2",
    "n3",
    "o1",
    "o2",
    "o3",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_DOUBLE,
    TType::T_BOOL,
    TType::T_I32,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC() :
      a(0),
      c(0),
      d(0),
      e( ::test_cpp2::cpp_reflection::enum1::field0),
      f( ::test_cpp2::cpp_reflection::enum2::field0_2) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


structC::~structC() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC(apache::thrift::FragileConstructor, int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg,  ::test_cpp2::cpp_reflection::enum1 e__arg,  ::test_cpp2::cpp_reflection::enum2 f__arg,  ::test_cpp2::cpp_reflection::union1 g__arg,  ::test_cpp2::cpp_reflection::unionA h__arg,  ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<int32_t> j__arg, ::std::vector<int32_t> j1__arg, ::std::vector< ::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector< ::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<int32_t> k__arg, ::std::set<int32_t> k1__arg, ::std::set< ::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set< ::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<int32_t, int32_t> l__arg, ::std::map<int32_t, int32_t> l1__arg, ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, int32_t> n1__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1__arg, ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    d(std::move(d__arg)),
    e(std::move(e__arg)),
    f(std::move(f__arg)),
    g(std::move(g__arg)),
    h(std::move(h__arg)),
    i(std::move(i__arg)),
    j(std::move(j__arg)),
    j1(std::move(j1__arg)),
    j2(std::move(j2__arg)),
    j3(std::move(j3__arg)),
    k(std::move(k__arg)),
    k1(std::move(k1__arg)),
    k2(std::move(k2__arg)),
    k3(std::move(k3__arg)),
    l(std::move(l__arg)),
    l1(std::move(l1__arg)),
    l2(std::move(l2__arg)),
    l3(std::move(l3__arg)),
    m1(std::move(m1__arg)),
    m2(std::move(m2__arg)),
    m3(std::move(m3__arg)),
    n1(std::move(n1__arg)),
    n2(std::move(n2__arg)),
    n3(std::move(n3__arg)),
    o1(std::move(o1__arg)),
    o2(std::move(o2__arg)),
    o3(std::move(o3__arg)) {
  __isset.a = true;
  __isset.b = true;
  __isset.c = true;
  __isset.d = true;
  __isset.e = true;
  __isset.f = true;
  __isset.g = true;
  __isset.h = true;
  __isset.i = true;
  __isset.j = true;
  __isset.j1 = true;
  __isset.j2 = true;
  __isset.j3 = true;
  __isset.k = true;
  __isset.k1 = true;
  __isset.k2 = true;
  __isset.k3 = true;
  __isset.l = true;
  __isset.l1 = true;
  __isset.l2 = true;
  __isset.l3 = true;
  __isset.m1 = true;
  __isset.m2 = true;
  __isset.m3 = true;
  __isset.n1 = true;
  __isset.n2 = true;
  __isset.n3 = true;
  __isset.o1 = true;
  __isset.o2 = true;
  __isset.o3 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void structC::__clear() {
  // clear all fields
  a = 0;
  b = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  c = 0;
  d = 0;
  e =  ::test_cpp2::cpp_reflection::enum1::field0;
  f =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&g);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&h);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&i);
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structC::operator==(const structC& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  if (!(lhs.c == rhs.c)) {
    return false;
  }
  if (!(lhs.d == rhs.d)) {
    return false;
  }
  if (!(lhs.e == rhs.e)) {
    return false;
  }
  if (!(lhs.f == rhs.f)) {
    return false;
  }
  if (!(lhs.g == rhs.g)) {
    return false;
  }
  if (!(lhs.h == rhs.h)) {
    return false;
  }
  if (!(lhs.i == rhs.i)) {
    return false;
  }
  if (!(lhs.j == rhs.j)) {
    return false;
  }
  if (!(lhs.j1 == rhs.j1)) {
    return false;
  }
  if (!(lhs.j2 == rhs.j2)) {
    return false;
  }
  if (!(lhs.j3 == rhs.j3)) {
    return false;
  }
  if (!(lhs.k == rhs.k)) {
    return false;
  }
  if (!(lhs.k1 == rhs.k1)) {
    return false;
  }
  if (!(lhs.k2 == rhs.k2)) {
    return false;
  }
  if (!(lhs.k3 == rhs.k3)) {
    return false;
  }
  if (!(lhs.l == rhs.l)) {
    return false;
  }
  if (!(lhs.l1 == rhs.l1)) {
    return false;
  }
  if (!(lhs.l2 == rhs.l2)) {
    return false;
  }
  if (!(lhs.l3 == rhs.l3)) {
    return false;
  }
  if (!(lhs.m1 == rhs.m1)) {
    return false;
  }
  if (!(lhs.m2 == rhs.m2)) {
    return false;
  }
  if (!(lhs.m3 == rhs.m3)) {
    return false;
  }
  if (!(lhs.n1 == rhs.n1)) {
    return false;
  }
  if (!(lhs.n2 == rhs.n2)) {
    return false;
  }
  if (!(lhs.n3 == rhs.n3)) {
    return false;
  }
  if (!(lhs.o1 == rhs.o1)) {
    return false;
  }
  if (!(lhs.o2 == rhs.o2)) {
    return false;
  }
  if (!(lhs.o3 == rhs.o3)) {
    return false;
  }
  return true;
}

bool structC::operator<(const structC& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  if (!(lhs.c == rhs.c)) {
    return lhs.c < rhs.c;
  }
  if (!(lhs.d == rhs.d)) {
    return lhs.d < rhs.d;
  }
  if (!(lhs.e == rhs.e)) {
    return lhs.e < rhs.e;
  }
  if (!(lhs.f == rhs.f)) {
    return lhs.f < rhs.f;
  }
  if (!(lhs.g == rhs.g)) {
    return lhs.g < rhs.g;
  }
  if (!(lhs.h == rhs.h)) {
    return lhs.h < rhs.h;
  }
  if (!(lhs.i == rhs.i)) {
    return lhs.i < rhs.i;
  }
  if (!(lhs.j == rhs.j)) {
    return lhs.j < rhs.j;
  }
  if (!(lhs.j1 == rhs.j1)) {
    return lhs.j1 < rhs.j1;
  }
  if (!(lhs.j2 == rhs.j2)) {
    return lhs.j2 < rhs.j2;
  }
  if (!(lhs.j3 == rhs.j3)) {
    return lhs.j3 < rhs.j3;
  }
  if (!(lhs.k == rhs.k)) {
    return lhs.k < rhs.k;
  }
  if (!(lhs.k1 == rhs.k1)) {
    return lhs.k1 < rhs.k1;
  }
  if (!(lhs.k2 == rhs.k2)) {
    return lhs.k2 < rhs.k2;
  }
  if (!(lhs.k3 == rhs.k3)) {
    return lhs.k3 < rhs.k3;
  }
  if (!(lhs.l == rhs.l)) {
    return lhs.l < rhs.l;
  }
  if (!(lhs.l1 == rhs.l1)) {
    return lhs.l1 < rhs.l1;
  }
  if (!(lhs.l2 == rhs.l2)) {
    return lhs.l2 < rhs.l2;
  }
  if (!(lhs.l3 == rhs.l3)) {
    return lhs.l3 < rhs.l3;
  }
  if (!(lhs.m1 == rhs.m1)) {
    return lhs.m1 < rhs.m1;
  }
  if (!(lhs.m2 == rhs.m2)) {
    return lhs.m2 < rhs.m2;
  }
  if (!(lhs.m3 == rhs.m3)) {
    return lhs.m3 < rhs.m3;
  }
  if (!(lhs.n1 == rhs.n1)) {
    return lhs.n1 < rhs.n1;
  }
  if (!(lhs.n2 == rhs.n2)) {
    return lhs.n2 < rhs.n2;
  }
  if (!(lhs.n3 == rhs.n3)) {
    return lhs.n3 < rhs.n3;
  }
  if (!(lhs.o1 == rhs.o1)) {
    return lhs.o1 < rhs.o1;
  }
  if (!(lhs.o2 == rhs.o2)) {
    return lhs.o2 < rhs.o2;
  }
  if (!(lhs.o3 == rhs.o3)) {
    return lhs.o3 < rhs.o3;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return g;
}

 ::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(g);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return h;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(h);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return i;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(i);
}

const ::std::vector<int32_t>& structC::get_j() const& {
  return j;
}

::std::vector<int32_t> structC::get_j() && {
  return std::move(j);
}

const ::std::vector<int32_t>& structC::get_j1() const& {
  return j1;
}

::std::vector<int32_t> structC::get_j1() && {
  return std::move(j1);
}

const ::std::vector< ::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return j2;
}

::std::vector< ::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(j2);
}

const ::std::vector< ::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return j3;
}

::std::vector< ::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(j3);
}

const ::std::set<int32_t>& structC::get_k() const& {
  return k;
}

::std::set<int32_t> structC::get_k() && {
  return std::move(k);
}

const ::std::set<int32_t>& structC::get_k1() const& {
  return k1;
}

::std::set<int32_t> structC::get_k1() && {
  return std::move(k1);
}

const ::std::set< ::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return k2;
}

::std::set< ::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(k2);
}

const ::std::set< ::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return k3;
}

::std::set< ::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(k3);
}

const ::std::map<int32_t, int32_t>& structC::get_l() const& {
  return l;
}

::std::map<int32_t, int32_t> structC::get_l() && {
  return std::move(l);
}

const ::std::map<int32_t, int32_t>& structC::get_l1() const& {
  return l1;
}

::std::map<int32_t, int32_t> structC::get_l1() && {
  return std::move(l1);
}

const ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return l2;
}

::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(l2);
}

const ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return l3;
}

::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(l3);
}

const ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& structC::get_m1() const& {
  return m1;
}

::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> structC::get_m1() && {
  return std::move(m1);
}

const ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return m2;
}

::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(m2);
}

const ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return m3;
}

::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(m3);
}

const ::std::map<::std::string, int32_t>& structC::get_n1() const& {
  return n1;
}

::std::map<::std::string, int32_t> structC::get_n1() && {
  return std::move(n1);
}

const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return n2;
}

::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(n2);
}

const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return n3;
}

::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(n3);
}

const ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& structC::get_o1() const& {
  return o1;
}

::std::map< ::test_cpp2::cpp_reflection::structA, int32_t> structC::get_o1() && {
  return std::move(o1);
}

const ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return o2;
}

::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(o2);
}

const ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return o3;
}

::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(o3);
}


void swap(structC& a, structC& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.d_ref().value(), b.d_ref().value());
  swap(a.e_ref().value(), b.e_ref().value());
  swap(a.f_ref().value(), b.f_ref().value());
  swap(a.g_ref().value(), b.g_ref().value());
  swap(a.h_ref().value(), b.h_ref().value());
  swap(a.i_ref().value(), b.i_ref().value());
  swap(a.j_ref().value(), b.j_ref().value());
  swap(a.j1_ref().value(), b.j1_ref().value());
  swap(a.j2_ref().value(), b.j2_ref().value());
  swap(a.j3_ref().value(), b.j3_ref().value());
  swap(a.k_ref().value(), b.k_ref().value());
  swap(a.k1_ref().value(), b.k1_ref().value());
  swap(a.k2_ref().value(), b.k2_ref().value());
  swap(a.k3_ref().value(), b.k3_ref().value());
  swap(a.l_ref().value(), b.l_ref().value());
  swap(a.l1_ref().value(), b.l1_ref().value());
  swap(a.l2_ref().value(), b.l2_ref().value());
  swap(a.l3_ref().value(), b.l3_ref().value());
  swap(a.m1_ref().value(), b.m1_ref().value());
  swap(a.m2_ref().value(), b.m2_ref().value());
  swap(a.m3_ref().value(), b.m3_ref().value());
  swap(a.n1_ref().value(), b.n1_ref().value());
  swap(a.n2_ref().value(), b.n2_ref().value());
  swap(a.n3_ref().value(), b.n3_ref().value());
  swap(a.o1_ref().value(), b.o1_ref().value());
  swap(a.o2_ref().value(), b.o2_ref().value());
  swap(a.o3_ref().value(), b.o3_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structC::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structC::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set< ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set< ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct1>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "field0",
    "field1",
    "field2",
    "field3",
    "field4",
    "field5",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I32,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0),
      field3( ::test_cpp2::cpp_reflection::enum2::field0_2) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


struct1::~struct1() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::enum2 field3__arg,  ::test_cpp2::cpp_reflection::union1 field4__arg,  ::test_cpp2::cpp_reflection::union2 field5__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)),
    field4(std::move(field4__arg)),
    field5(std::move(field5__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
  __isset.field4 = true;
  __isset.field5 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct1::__clear() {
  // clear all fields
  field0 = 0;
  field1 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  field3 =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&field4);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&field5);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct1::operator==(const struct1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return false;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return false;
  }
  if (!(lhs.field2 == rhs.field2)) {
    return false;
  }
  if (!(lhs.field3 == rhs.field3)) {
    return false;
  }
  if (lhs.field4_ref() != rhs.field4_ref()) {
    return false;
  }
  if (!(lhs.field5 == rhs.field5)) {
    return false;
  }
  return true;
}

bool struct1::operator<(const struct1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return lhs.field0 < rhs.field0;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2 == rhs.field2)) {
    return lhs.field2 < rhs.field2;
  }
  if (!(lhs.field3 == rhs.field3)) {
    return lhs.field3 < rhs.field3;
  }
  if (lhs.field4_ref() != rhs.field4_ref()) {
    return lhs.field4_ref() < rhs.field4_ref();
  }
  if (!(lhs.field5 == rhs.field5)) {
    return lhs.field5 < rhs.field5;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(field4) : nullptr;
}

 ::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return field4_ref().has_value() ? std::addressof(field4) : nullptr;
}

const  ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return field5;
}

 ::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(field5);
}


void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3_ref().value(), b.field3_ref().value());
  swap(a.field4_ref().value_unchecked(), b.field4_ref().value_unchecked());
  swap(a.field5_ref().value(), b.field5_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct1,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct1,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct2>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 7;
  static constexpr folly::StringPiece _names[] = {
    "fieldA",
    "fieldB",
    "fieldC",
    "fieldD",
    "fieldE",
    "fieldF",
    "fieldG",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I32,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
      fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


struct2::~struct2() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2(apache::thrift::FragileConstructor, int32_t fieldA__arg, ::std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)) {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct2::__clear() {
  // clear all fields
  fieldA = 0;
  fieldB = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct2::operator==(const struct2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return false;
  }
  if (!(lhs.fieldB == rhs.fieldB)) {
    return false;
  }
  if (!(lhs.fieldC == rhs.fieldC)) {
    return false;
  }
  if (!(lhs.fieldD == rhs.fieldD)) {
    return false;
  }
  if (!(lhs.fieldE == rhs.fieldE)) {
    return false;
  }
  if (!(lhs.fieldF == rhs.fieldF)) {
    return false;
  }
  if (!(lhs.fieldG == rhs.fieldG)) {
    return false;
  }
  return true;
}

bool struct2::operator<(const struct2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return lhs.fieldA < rhs.fieldA;
  }
  if (!(lhs.fieldB == rhs.fieldB)) {
    return lhs.fieldB < rhs.fieldB;
  }
  if (!(lhs.fieldC == rhs.fieldC)) {
    return lhs.fieldC < rhs.fieldC;
  }
  if (!(lhs.fieldD == rhs.fieldD)) {
    return lhs.fieldD < rhs.fieldD;
  }
  if (!(lhs.fieldE == rhs.fieldE)) {
    return lhs.fieldE < rhs.fieldE;
  }
  if (!(lhs.fieldF == rhs.fieldF)) {
    return lhs.fieldF < rhs.fieldF;
  }
  if (!(lhs.fieldG == rhs.fieldG)) {
    return lhs.fieldG < rhs.fieldG;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(fieldG);
}


void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
  swap(a.fieldB_ref().value(), b.fieldB_ref().value());
  swap(a.fieldC_ref().value(), b.fieldC_ref().value());
  swap(a.fieldD_ref().value(), b.fieldD_ref().value());
  swap(a.fieldE_ref().value(), b.fieldE_ref().value());
  swap(a.fieldF_ref().value(), b.fieldF_ref().value());
  swap(a.fieldG_ref().value(), b.fieldG_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct3>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 18;
  static constexpr folly::StringPiece _names[] = {
    "fieldA",
    "fieldB",
    "fieldC",
    "fieldD",
    "fieldE",
    "fieldF",
    "fieldG",
    "fieldH",
    "fieldI",
    "fieldJ",
    "fieldK",
    "fieldL",
    "fieldM",
    "fieldN",
    "fieldO",
    "fieldP",
    "fieldQ",
    "fieldR",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I32,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_LIST,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_SET,
    TType::T_MAP,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
      fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


struct3::~struct3() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3(apache::thrift::FragileConstructor, int32_t fieldA__arg, ::std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg,  ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector< ::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set< ::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)),
    fieldH(std::move(fieldH__arg)),
    fieldI(std::move(fieldI__arg)),
    fieldJ(std::move(fieldJ__arg)),
    fieldK(std::move(fieldK__arg)),
    fieldL(std::move(fieldL__arg)),
    fieldM(std::move(fieldM__arg)),
    fieldN(std::move(fieldN__arg)),
    fieldO(std::move(fieldO__arg)),
    fieldP(std::move(fieldP__arg)),
    fieldQ(std::move(fieldQ__arg)),
    fieldR(std::move(fieldR__arg)) {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
  __isset.fieldH = true;
  __isset.fieldI = true;
  __isset.fieldJ = true;
  __isset.fieldK = true;
  __isset.fieldL = true;
  __isset.fieldM = true;
  __isset.fieldN = true;
  __isset.fieldO = true;
  __isset.fieldP = true;
  __isset.fieldQ = true;
  __isset.fieldR = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct3::__clear() {
  // clear all fields
  fieldA = 0;
  fieldB = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldH);
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct3::operator==(const struct3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return false;
  }
  if (!(lhs.fieldB == rhs.fieldB)) {
    return false;
  }
  if (!(lhs.fieldC == rhs.fieldC)) {
    return false;
  }
  if (!(lhs.fieldD == rhs.fieldD)) {
    return false;
  }
  if (!(lhs.fieldE == rhs.fieldE)) {
    return false;
  }
  if (!(lhs.fieldF == rhs.fieldF)) {
    return false;
  }
  if (!(lhs.fieldG == rhs.fieldG)) {
    return false;
  }
  if (!(lhs.fieldH == rhs.fieldH)) {
    return false;
  }
  if (!(lhs.fieldI == rhs.fieldI)) {
    return false;
  }
  if (!(lhs.fieldJ == rhs.fieldJ)) {
    return false;
  }
  if (!(lhs.fieldK == rhs.fieldK)) {
    return false;
  }
  if (!(lhs.fieldL == rhs.fieldL)) {
    return false;
  }
  if (!(lhs.fieldM == rhs.fieldM)) {
    return false;
  }
  if (!(lhs.fieldN == rhs.fieldN)) {
    return false;
  }
  if (!(lhs.fieldO == rhs.fieldO)) {
    return false;
  }
  if (!(lhs.fieldP == rhs.fieldP)) {
    return false;
  }
  if (!(lhs.fieldQ == rhs.fieldQ)) {
    return false;
  }
  if (!(lhs.fieldR == rhs.fieldR)) {
    return false;
  }
  return true;
}

bool struct3::operator<(const struct3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA == rhs.fieldA)) {
    return lhs.fieldA < rhs.fieldA;
  }
  if (!(lhs.fieldB == rhs.fieldB)) {
    return lhs.fieldB < rhs.fieldB;
  }
  if (!(lhs.fieldC == rhs.fieldC)) {
    return lhs.fieldC < rhs.fieldC;
  }
  if (!(lhs.fieldD == rhs.fieldD)) {
    return lhs.fieldD < rhs.fieldD;
  }
  if (!(lhs.fieldE == rhs.fieldE)) {
    return lhs.fieldE < rhs.fieldE;
  }
  if (!(lhs.fieldF == rhs.fieldF)) {
    return lhs.fieldF < rhs.fieldF;
  }
  if (!(lhs.fieldG == rhs.fieldG)) {
    return lhs.fieldG < rhs.fieldG;
  }
  if (!(lhs.fieldH == rhs.fieldH)) {
    return lhs.fieldH < rhs.fieldH;
  }
  if (!(lhs.fieldI == rhs.fieldI)) {
    return lhs.fieldI < rhs.fieldI;
  }
  if (!(lhs.fieldJ == rhs.fieldJ)) {
    return lhs.fieldJ < rhs.fieldJ;
  }
  if (!(lhs.fieldK == rhs.fieldK)) {
    return lhs.fieldK < rhs.fieldK;
  }
  if (!(lhs.fieldL == rhs.fieldL)) {
    return lhs.fieldL < rhs.fieldL;
  }
  if (!(lhs.fieldM == rhs.fieldM)) {
    return lhs.fieldM < rhs.fieldM;
  }
  if (!(lhs.fieldN == rhs.fieldN)) {
    return lhs.fieldN < rhs.fieldN;
  }
  if (!(lhs.fieldO == rhs.fieldO)) {
    return lhs.fieldO < rhs.fieldO;
  }
  if (!(lhs.fieldP == rhs.fieldP)) {
    return lhs.fieldP < rhs.fieldP;
  }
  if (!(lhs.fieldQ == rhs.fieldQ)) {
    return lhs.fieldQ < rhs.fieldQ;
  }
  if (!(lhs.fieldR == rhs.fieldR)) {
    return lhs.fieldR < rhs.fieldR;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(fieldG);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return fieldH;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(fieldH);
}

const ::std::vector<int32_t>& struct3::get_fieldI() const& {
  return fieldI;
}

::std::vector<int32_t> struct3::get_fieldI() && {
  return std::move(fieldI);
}

const ::std::vector<::std::string>& struct3::get_fieldJ() const& {
  return fieldJ;
}

::std::vector<::std::string> struct3::get_fieldJ() && {
  return std::move(fieldJ);
}

const ::std::vector<::std::string>& struct3::get_fieldK() const& {
  return fieldK;
}

::std::vector<::std::string> struct3::get_fieldK() && {
  return std::move(fieldK);
}

const ::std::vector< ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return fieldL;
}

::std::vector< ::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(fieldL);
}

const ::std::set<int32_t>& struct3::get_fieldM() const& {
  return fieldM;
}

::std::set<int32_t> struct3::get_fieldM() && {
  return std::move(fieldM);
}

const ::std::set<::std::string>& struct3::get_fieldN() const& {
  return fieldN;
}

::std::set<::std::string> struct3::get_fieldN() && {
  return std::move(fieldN);
}

const ::std::set<::std::string>& struct3::get_fieldO() const& {
  return fieldO;
}

::std::set<::std::string> struct3::get_fieldO() && {
  return std::move(fieldO);
}

const ::std::set< ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return fieldP;
}

::std::set< ::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(fieldP);
}

const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return fieldQ;
}

::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(fieldQ);
}

const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return fieldR;
}

::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(fieldR);
}


void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
  swap(a.fieldB_ref().value(), b.fieldB_ref().value());
  swap(a.fieldC_ref().value(), b.fieldC_ref().value());
  swap(a.fieldD_ref().value(), b.fieldD_ref().value());
  swap(a.fieldE_ref().value(), b.fieldE_ref().value());
  swap(a.fieldF_ref().value(), b.fieldF_ref().value());
  swap(a.fieldG_ref().value(), b.fieldG_ref().value());
  swap(a.fieldH_ref().value(), b.fieldH_ref().value());
  swap(a.fieldI_ref().value(), b.fieldI_ref().value());
  swap(a.fieldJ_ref().value(), b.fieldJ_ref().value());
  swap(a.fieldK_ref().value(), b.fieldK_ref().value());
  swap(a.fieldL_ref().value(), b.fieldL_ref().value());
  swap(a.fieldM_ref().value(), b.fieldM_ref().value());
  swap(a.fieldN_ref().value(), b.fieldN_ref().value());
  swap(a.fieldO_ref().value(), b.fieldO_ref().value());
  swap(a.fieldP_ref().value(), b.fieldP_ref().value());
  swap(a.fieldQ_ref().value(), b.fieldQ_ref().value());
  swap(a.fieldR_ref().value(), b.fieldR_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set< ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
         ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector< ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set< ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct4>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "field0",
    "field1",
    "field2",
    "field3",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I32,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

struct4::struct4(const struct4& srcObj) {
  field0 = srcObj.field0;
  field1 = srcObj.field1;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.field1 = srcObj.__isset.field1;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  field2 = srcObj.field2;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.field2 = srcObj.__isset.field2;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  if (srcObj.field3) field3.reset(new  ::test_cpp2::cpp_reflection::structA(*srcObj.field3));
}

struct4& struct4::operator=(const struct4& src) {
  struct4 tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct4::struct4(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg, std::unique_ptr< ::test_cpp2::cpp_reflection::structA> field3__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct4::__clear() {
  // clear all fields
  field0 = 0;
  field1 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  if (field3) ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structA>::clear(field3.get());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct4::operator==(const struct4& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return false;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return false;
  }
  if (!(lhs.field2 == rhs.field2)) {
    return false;
  }
  if (!!lhs.field3 != !!rhs.field3) {
    return false;
  }
  if (!!lhs.field3) {
    if (lhs.field3 != rhs.field3 && !(*lhs.field3 == *rhs.field3)) {
      return false;
    }
  }
  return true;
}

bool struct4::operator<(const struct4& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return lhs.field0 < rhs.field0;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2 == rhs.field2)) {
    return lhs.field2 < rhs.field2;
  }
  if (!!lhs.field3 != !!rhs.field3) {
    return !!lhs.field3 < !!rhs.field3;
  }
  if (!!lhs.field3) {
    if (lhs.field3 != rhs.field3 && !(*lhs.field3 == *rhs.field3)) {
      return *lhs.field3 < *rhs.field3;
    }
  }
  return false;
}


void swap(struct4& a, struct4& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3, b.field3);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct4::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct4::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct4,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct4,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct5>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "field0",
    "field1",
    "field2",
    "field3",
    "field4",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I32,
    TType::T_STRUCT,
    TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


struct5::~struct5() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::structA field3__arg,  ::test_cpp2::cpp_reflection::structB field4__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)),
    field4(std::move(field4__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
  __isset.field3 = true;
  __isset.field4 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct5::__clear() {
  // clear all fields
  field0 = 0;
  field1 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structA>::clear(&field3);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structB>::clear(&field4);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct5::operator==(const struct5& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return false;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return false;
  }
  if (!(lhs.field2 == rhs.field2)) {
    return false;
  }
  if (!(lhs.field3 == rhs.field3)) {
    return false;
  }
  if (!(lhs.field4 == rhs.field4)) {
    return false;
  }
  return true;
}

bool struct5::operator<(const struct5& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0 == rhs.field0)) {
    return lhs.field0 < rhs.field0;
  }
  if (lhs.field1_ref() != rhs.field1_ref()) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2 == rhs.field2)) {
    return lhs.field2 < rhs.field2;
  }
  if (!(lhs.field3 == rhs.field3)) {
    return lhs.field3 < rhs.field3;
  }
  if (!(lhs.field4 == rhs.field4)) {
    return lhs.field4 < rhs.field4;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::structA& struct5::get_field3() const& {
  return field3;
}

 ::test_cpp2::cpp_reflection::structA struct5::get_field3() && {
  return std::move(field3);
}

const  ::test_cpp2::cpp_reflection::structB& struct5::get_field4() const& {
  return field4;
}

 ::test_cpp2::cpp_reflection::structB struct5::get_field4() && {
  return std::move(field4);
}


void swap(struct5& a, struct5& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3_ref().value(), b.field3_ref().value());
  swap(a.field4_ref().value(), b.field4_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct5::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct5::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct5,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct5,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_binary>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "bi",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_binary::struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg) :
    bi(std::move(bi__arg)) {
  __isset.bi = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct_binary::__clear() {
  // clear all fields
  bi = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_binary::operator==(const struct_binary& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.bi, rhs.bi)) {
    return false;
  }
  return true;
}

bool struct_binary::operator<(const struct_binary& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.bi, rhs.bi)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.bi, rhs.bi);
  }
  return false;
}


void swap(struct_binary& a, struct_binary& b) {
  using ::std::swap;
  swap(a.bi_ref().value(), b.bi_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_binary::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_binary::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_A_struct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "b",
    "c",
    "i_a",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
dep_A_struct::dep_A_struct(apache::thrift::FragileConstructor,  ::test_cpp2::cpp_reflection::dep_B_struct b__arg,  ::test_cpp2::cpp_reflection::dep_C_struct c__arg, int32_t i_a__arg) :
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    i_a(std::move(i_a__arg)) {
  __isset.b = true;
  __isset.c = true;
  __isset.i_a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void dep_A_struct::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::dep_B_struct>::clear(&b);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::dep_C_struct>::clear(&c);
  i_a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool dep_A_struct::operator==(const dep_A_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  if (!(lhs.c == rhs.c)) {
    return false;
  }
  if (!(lhs.i_a == rhs.i_a)) {
    return false;
  }
  return true;
}

bool dep_A_struct::operator<(const dep_A_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  if (!(lhs.c == rhs.c)) {
    return lhs.c < rhs.c;
  }
  if (!(lhs.i_a == rhs.i_a)) {
    return lhs.i_a < rhs.i_a;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::dep_B_struct& dep_A_struct::get_b() const& {
  return b;
}

 ::test_cpp2::cpp_reflection::dep_B_struct dep_A_struct::get_b() && {
  return std::move(b);
}

const  ::test_cpp2::cpp_reflection::dep_C_struct& dep_A_struct::get_c() const& {
  return c;
}

 ::test_cpp2::cpp_reflection::dep_C_struct dep_A_struct::get_c() && {
  return std::move(c);
}


void swap(dep_A_struct& a, dep_A_struct& b) {
  using ::std::swap;
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.i_a_ref().value(), b.i_a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void dep_A_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_A_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_B_struct>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "b",
    "c",
    "i_a",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_STRUCT,
    TType::T_STRUCT,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
dep_B_struct::dep_B_struct(apache::thrift::FragileConstructor,  ::test_cpp2::cpp_reflection::dep_B_struct b__arg,  ::test_cpp2::cpp_reflection::dep_C_struct c__arg, int32_t i_a__arg) :
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    i_a(std::move(i_a__arg)) {
  __isset.b = true;
  __isset.c = true;
  __isset.i_a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void dep_B_struct::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::dep_B_struct>::clear(&b);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::dep_C_struct>::clear(&c);
  i_a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool dep_B_struct::operator==(const dep_B_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b == rhs.b)) {
    return false;
  }
  if (!(lhs.c == rhs.c)) {
    return false;
  }
  if (!(lhs.i_a == rhs.i_a)) {
    return false;
  }
  return true;
}

bool dep_B_struct::operator<(const dep_B_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b == rhs.b)) {
    return lhs.b < rhs.b;
  }
  if (!(lhs.c == rhs.c)) {
    return lhs.c < rhs.c;
  }
  if (!(lhs.i_a == rhs.i_a)) {
    return lhs.i_a < rhs.i_a;
  }
  return false;
}

const  ::test_cpp2::cpp_reflection::dep_B_struct& dep_B_struct::get_b() const& {
  return b;
}

 ::test_cpp2::cpp_reflection::dep_B_struct dep_B_struct::get_b() && {
  return std::move(b);
}

const  ::test_cpp2::cpp_reflection::dep_C_struct& dep_B_struct::get_c() const& {
  return c;
}

 ::test_cpp2::cpp_reflection::dep_C_struct dep_B_struct::get_c() && {
  return std::move(c);
}


void swap(dep_B_struct& a, dep_B_struct& b) {
  using ::std::swap;
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.i_a_ref().value(), b.i_a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void dep_B_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_B_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
         ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::annotated>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "a",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
annotated::annotated(apache::thrift::FragileConstructor, int32_t a__arg) :
    a(std::move(a__arg)) {
  __isset.a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void annotated::__clear() {
  // clear all fields
  a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool annotated::operator==(const annotated& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return false;
  }
  return true;
}

bool annotated::operator<(const annotated& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a == rhs.a)) {
    return lhs.a < rhs.a;
  }
  return false;
}


void swap(annotated& a, annotated& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void annotated::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void annotated::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union_with_special_names>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 28;
  static constexpr folly::StringPiece _names[] = {
    "get",
    "getter",
    "lists",
    "maps",
    "name",
    "name_to_value",
    "names",
    "prefix_tree",
    "sets",
    "setter",
    "str",
    "strings",
    "type",
    "value",
    "value_to_name",
    "values",
    "id",
    "ids",
    "descriptor",
    "descriptors",
    "key",
    "keys",
    "annotation",
    "annotations",
    "member",
    "members",
    "field",
    "fields",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union_with_special_names::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union_with_special_names::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union_with_special_names::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union_with_special_names::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::get:
    {
      destruct(value_.get);
      break;
    }
    case Type::getter:
    {
      destruct(value_.getter);
      break;
    }
    case Type::lists:
    {
      destruct(value_.lists);
      break;
    }
    case Type::maps:
    {
      destruct(value_.maps);
      break;
    }
    case Type::name:
    {
      destruct(value_.name);
      break;
    }
    case Type::name_to_value:
    {
      destruct(value_.name_to_value);
      break;
    }
    case Type::names:
    {
      destruct(value_.names);
      break;
    }
    case Type::prefix_tree:
    {
      destruct(value_.prefix_tree);
      break;
    }
    case Type::sets:
    {
      destruct(value_.sets);
      break;
    }
    case Type::setter:
    {
      destruct(value_.setter);
      break;
    }
    case Type::str:
    {
      destruct(value_.str);
      break;
    }
    case Type::strings:
    {
      destruct(value_.strings);
      break;
    }
    case Type::type:
    {
      destruct(value_.type);
      break;
    }
    case Type::value:
    {
      destruct(value_.value);
      break;
    }
    case Type::value_to_name:
    {
      destruct(value_.value_to_name);
      break;
    }
    case Type::values:
    {
      destruct(value_.values);
      break;
    }
    case Type::id:
    {
      destruct(value_.id);
      break;
    }
    case Type::ids:
    {
      destruct(value_.ids);
      break;
    }
    case Type::descriptor:
    {
      destruct(value_.descriptor);
      break;
    }
    case Type::descriptors:
    {
      destruct(value_.descriptors);
      break;
    }
    case Type::key:
    {
      destruct(value_.key);
      break;
    }
    case Type::keys:
    {
      destruct(value_.keys);
      break;
    }
    case Type::annotation:
    {
      destruct(value_.annotation);
      break;
    }
    case Type::annotations:
    {
      destruct(value_.annotations);
      break;
    }
    case Type::member:
    {
      destruct(value_.member);
      break;
    }
    case Type::members:
    {
      destruct(value_.members);
      break;
    }
    case Type::field:
    {
      destruct(value_.field);
      break;
    }
    case Type::fields:
    {
      destruct(value_.fields);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::get:
    {
      return value_.get == rhs.value_.get;
    }
    case Type::getter:
    {
      return value_.getter == rhs.value_.getter;
    }
    case Type::lists:
    {
      return value_.lists == rhs.value_.lists;
    }
    case Type::maps:
    {
      return value_.maps == rhs.value_.maps;
    }
    case Type::name:
    {
      return value_.name == rhs.value_.name;
    }
    case Type::name_to_value:
    {
      return value_.name_to_value == rhs.value_.name_to_value;
    }
    case Type::names:
    {
      return value_.names == rhs.value_.names;
    }
    case Type::prefix_tree:
    {
      return value_.prefix_tree == rhs.value_.prefix_tree;
    }
    case Type::sets:
    {
      return value_.sets == rhs.value_.sets;
    }
    case Type::setter:
    {
      return value_.setter == rhs.value_.setter;
    }
    case Type::str:
    {
      return value_.str == rhs.value_.str;
    }
    case Type::strings:
    {
      return value_.strings == rhs.value_.strings;
    }
    case Type::type:
    {
      return value_.type == rhs.value_.type;
    }
    case Type::value:
    {
      return value_.value == rhs.value_.value;
    }
    case Type::value_to_name:
    {
      return value_.value_to_name == rhs.value_.value_to_name;
    }
    case Type::values:
    {
      return value_.values == rhs.value_.values;
    }
    case Type::id:
    {
      return value_.id == rhs.value_.id;
    }
    case Type::ids:
    {
      return value_.ids == rhs.value_.ids;
    }
    case Type::descriptor:
    {
      return value_.descriptor == rhs.value_.descriptor;
    }
    case Type::descriptors:
    {
      return value_.descriptors == rhs.value_.descriptors;
    }
    case Type::key:
    {
      return value_.key == rhs.value_.key;
    }
    case Type::keys:
    {
      return value_.keys == rhs.value_.keys;
    }
    case Type::annotation:
    {
      return value_.annotation == rhs.value_.annotation;
    }
    case Type::annotations:
    {
      return value_.annotations == rhs.value_.annotations;
    }
    case Type::member:
    {
      return value_.member == rhs.value_.member;
    }
    case Type::members:
    {
      return value_.members == rhs.value_.members;
    }
    case Type::field:
    {
      return value_.field == rhs.value_.field;
    }
    case Type::fields:
    {
      return value_.fields == rhs.value_.fields;
    }
    default:
    {
      return true;
    }
  }
}

bool union_with_special_names::operator<(const union_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::get:
      return lhs.value_.get < rhs.value_.get;
    case Type::getter:
      return lhs.value_.getter < rhs.value_.getter;
    case Type::lists:
      return lhs.value_.lists < rhs.value_.lists;
    case Type::maps:
      return lhs.value_.maps < rhs.value_.maps;
    case Type::name:
      return lhs.value_.name < rhs.value_.name;
    case Type::name_to_value:
      return lhs.value_.name_to_value < rhs.value_.name_to_value;
    case Type::names:
      return lhs.value_.names < rhs.value_.names;
    case Type::prefix_tree:
      return lhs.value_.prefix_tree < rhs.value_.prefix_tree;
    case Type::sets:
      return lhs.value_.sets < rhs.value_.sets;
    case Type::setter:
      return lhs.value_.setter < rhs.value_.setter;
    case Type::str:
      return lhs.value_.str < rhs.value_.str;
    case Type::strings:
      return lhs.value_.strings < rhs.value_.strings;
    case Type::type:
      return lhs.value_.type < rhs.value_.type;
    case Type::value:
      return lhs.value_.value < rhs.value_.value;
    case Type::value_to_name:
      return lhs.value_.value_to_name < rhs.value_.value_to_name;
    case Type::values:
      return lhs.value_.values < rhs.value_.values;
    case Type::id:
      return lhs.value_.id < rhs.value_.id;
    case Type::ids:
      return lhs.value_.ids < rhs.value_.ids;
    case Type::descriptor:
      return lhs.value_.descriptor < rhs.value_.descriptor;
    case Type::descriptors:
      return lhs.value_.descriptors < rhs.value_.descriptors;
    case Type::key:
      return lhs.value_.key < rhs.value_.key;
    case Type::keys:
      return lhs.value_.keys < rhs.value_.keys;
    case Type::annotation:
      return lhs.value_.annotation < rhs.value_.annotation;
    case Type::annotations:
      return lhs.value_.annotations < rhs.value_.annotations;
    case Type::member:
      return lhs.value_.member < rhs.value_.member;
    case Type::members:
      return lhs.value_.members < rhs.value_.members;
    case Type::field:
      return lhs.value_.field < rhs.value_.field;
    case Type::fields:
      return lhs.value_.fields < rhs.value_.fields;
    default:
      return false;
  }
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_special_names>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 28;
  static constexpr folly::StringPiece _names[] = {
    "get",
    "getter",
    "lists",
    "maps",
    "name",
    "name_to_value",
    "names",
    "prefix_tree",
    "sets",
    "setter",
    "str",
    "strings",
    "type",
    "value",
    "value_to_name",
    "values",
    "id",
    "ids",
    "descriptor",
    "descriptors",
    "key",
    "keys",
    "annotation",
    "annotations",
    "member",
    "members",
    "field",
    "fields",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_special_names::struct_with_special_names(apache::thrift::FragileConstructor, int32_t get__arg, int32_t getter__arg, int32_t lists__arg, int32_t maps__arg, int32_t name__arg, int32_t name_to_value__arg, int32_t names__arg, int32_t prefix_tree__arg, int32_t sets__arg, int32_t setter__arg, int32_t str__arg, int32_t strings__arg, int32_t type__arg, int32_t value__arg, int32_t value_to_name__arg, int32_t values__arg, int32_t id__arg, int32_t ids__arg, int32_t descriptor__arg, int32_t descriptors__arg, int32_t key__arg, int32_t keys__arg, int32_t annotation__arg, int32_t annotations__arg, int32_t member__arg, int32_t members__arg, int32_t field__arg, int32_t fields__arg) :
    get(std::move(get__arg)),
    getter(std::move(getter__arg)),
    lists(std::move(lists__arg)),
    maps(std::move(maps__arg)),
    name(std::move(name__arg)),
    name_to_value(std::move(name_to_value__arg)),
    names(std::move(names__arg)),
    prefix_tree(std::move(prefix_tree__arg)),
    sets(std::move(sets__arg)),
    setter(std::move(setter__arg)),
    str(std::move(str__arg)),
    strings(std::move(strings__arg)),
    type(std::move(type__arg)),
    value(std::move(value__arg)),
    value_to_name(std::move(value_to_name__arg)),
    values(std::move(values__arg)),
    id(std::move(id__arg)),
    ids(std::move(ids__arg)),
    descriptor(std::move(descriptor__arg)),
    descriptors(std::move(descriptors__arg)),
    key(std::move(key__arg)),
    keys(std::move(keys__arg)),
    annotation(std::move(annotation__arg)),
    annotations(std::move(annotations__arg)),
    member(std::move(member__arg)),
    members(std::move(members__arg)),
    field(std::move(field__arg)),
    fields(std::move(fields__arg)) {
  __isset.get = true;
  __isset.getter = true;
  __isset.lists = true;
  __isset.maps = true;
  __isset.name = true;
  __isset.name_to_value = true;
  __isset.names = true;
  __isset.prefix_tree = true;
  __isset.sets = true;
  __isset.setter = true;
  __isset.str = true;
  __isset.strings = true;
  __isset.type = true;
  __isset.value = true;
  __isset.value_to_name = true;
  __isset.values = true;
  __isset.id = true;
  __isset.ids = true;
  __isset.descriptor = true;
  __isset.descriptors = true;
  __isset.key = true;
  __isset.keys = true;
  __isset.annotation = true;
  __isset.annotations = true;
  __isset.member = true;
  __isset.members = true;
  __isset.field = true;
  __isset.fields = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct_with_special_names::__clear() {
  // clear all fields
  get = 0;
  getter = 0;
  lists = 0;
  maps = 0;
  name = 0;
  name_to_value = 0;
  names = 0;
  prefix_tree = 0;
  sets = 0;
  setter = 0;
  str = 0;
  strings = 0;
  type = 0;
  value = 0;
  value_to_name = 0;
  values = 0;
  id = 0;
  ids = 0;
  descriptor = 0;
  descriptors = 0;
  key = 0;
  keys = 0;
  annotation = 0;
  annotations = 0;
  member = 0;
  members = 0;
  field = 0;
  fields = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_with_special_names::operator==(const struct_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.get == rhs.get)) {
    return false;
  }
  if (!(lhs.getter == rhs.getter)) {
    return false;
  }
  if (!(lhs.lists == rhs.lists)) {
    return false;
  }
  if (!(lhs.maps == rhs.maps)) {
    return false;
  }
  if (!(lhs.name == rhs.name)) {
    return false;
  }
  if (!(lhs.name_to_value == rhs.name_to_value)) {
    return false;
  }
  if (!(lhs.names == rhs.names)) {
    return false;
  }
  if (!(lhs.prefix_tree == rhs.prefix_tree)) {
    return false;
  }
  if (!(lhs.sets == rhs.sets)) {
    return false;
  }
  if (!(lhs.setter == rhs.setter)) {
    return false;
  }
  if (!(lhs.str == rhs.str)) {
    return false;
  }
  if (!(lhs.strings == rhs.strings)) {
    return false;
  }
  if (!(lhs.type == rhs.type)) {
    return false;
  }
  if (!(lhs.value == rhs.value)) {
    return false;
  }
  if (!(lhs.value_to_name == rhs.value_to_name)) {
    return false;
  }
  if (!(lhs.values == rhs.values)) {
    return false;
  }
  if (!(lhs.id == rhs.id)) {
    return false;
  }
  if (!(lhs.ids == rhs.ids)) {
    return false;
  }
  if (!(lhs.descriptor == rhs.descriptor)) {
    return false;
  }
  if (!(lhs.descriptors == rhs.descriptors)) {
    return false;
  }
  if (!(lhs.key == rhs.key)) {
    return false;
  }
  if (!(lhs.keys == rhs.keys)) {
    return false;
  }
  if (!(lhs.annotation == rhs.annotation)) {
    return false;
  }
  if (!(lhs.annotations == rhs.annotations)) {
    return false;
  }
  if (!(lhs.member == rhs.member)) {
    return false;
  }
  if (!(lhs.members == rhs.members)) {
    return false;
  }
  if (!(lhs.field == rhs.field)) {
    return false;
  }
  if (!(lhs.fields == rhs.fields)) {
    return false;
  }
  return true;
}

bool struct_with_special_names::operator<(const struct_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.get == rhs.get)) {
    return lhs.get < rhs.get;
  }
  if (!(lhs.getter == rhs.getter)) {
    return lhs.getter < rhs.getter;
  }
  if (!(lhs.lists == rhs.lists)) {
    return lhs.lists < rhs.lists;
  }
  if (!(lhs.maps == rhs.maps)) {
    return lhs.maps < rhs.maps;
  }
  if (!(lhs.name == rhs.name)) {
    return lhs.name < rhs.name;
  }
  if (!(lhs.name_to_value == rhs.name_to_value)) {
    return lhs.name_to_value < rhs.name_to_value;
  }
  if (!(lhs.names == rhs.names)) {
    return lhs.names < rhs.names;
  }
  if (!(lhs.prefix_tree == rhs.prefix_tree)) {
    return lhs.prefix_tree < rhs.prefix_tree;
  }
  if (!(lhs.sets == rhs.sets)) {
    return lhs.sets < rhs.sets;
  }
  if (!(lhs.setter == rhs.setter)) {
    return lhs.setter < rhs.setter;
  }
  if (!(lhs.str == rhs.str)) {
    return lhs.str < rhs.str;
  }
  if (!(lhs.strings == rhs.strings)) {
    return lhs.strings < rhs.strings;
  }
  if (!(lhs.type == rhs.type)) {
    return lhs.type < rhs.type;
  }
  if (!(lhs.value == rhs.value)) {
    return lhs.value < rhs.value;
  }
  if (!(lhs.value_to_name == rhs.value_to_name)) {
    return lhs.value_to_name < rhs.value_to_name;
  }
  if (!(lhs.values == rhs.values)) {
    return lhs.values < rhs.values;
  }
  if (!(lhs.id == rhs.id)) {
    return lhs.id < rhs.id;
  }
  if (!(lhs.ids == rhs.ids)) {
    return lhs.ids < rhs.ids;
  }
  if (!(lhs.descriptor == rhs.descriptor)) {
    return lhs.descriptor < rhs.descriptor;
  }
  if (!(lhs.descriptors == rhs.descriptors)) {
    return lhs.descriptors < rhs.descriptors;
  }
  if (!(lhs.key == rhs.key)) {
    return lhs.key < rhs.key;
  }
  if (!(lhs.keys == rhs.keys)) {
    return lhs.keys < rhs.keys;
  }
  if (!(lhs.annotation == rhs.annotation)) {
    return lhs.annotation < rhs.annotation;
  }
  if (!(lhs.annotations == rhs.annotations)) {
    return lhs.annotations < rhs.annotations;
  }
  if (!(lhs.member == rhs.member)) {
    return lhs.member < rhs.member;
  }
  if (!(lhs.members == rhs.members)) {
    return lhs.members < rhs.members;
  }
  if (!(lhs.field == rhs.field)) {
    return lhs.field < rhs.field;
  }
  if (!(lhs.fields == rhs.fields)) {
    return lhs.fields < rhs.fields;
  }
  return false;
}


void swap(struct_with_special_names& a, struct_with_special_names& b) {
  using ::std::swap;
  swap(a.get_ref().value(), b.get_ref().value());
  swap(a.getter_ref().value(), b.getter_ref().value());
  swap(a.lists_ref().value(), b.lists_ref().value());
  swap(a.maps_ref().value(), b.maps_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.name_to_value_ref().value(), b.name_to_value_ref().value());
  swap(a.names_ref().value(), b.names_ref().value());
  swap(a.prefix_tree_ref().value(), b.prefix_tree_ref().value());
  swap(a.sets_ref().value(), b.sets_ref().value());
  swap(a.setter_ref().value(), b.setter_ref().value());
  swap(a.str_ref().value(), b.str_ref().value());
  swap(a.strings_ref().value(), b.strings_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.value_to_name_ref().value(), b.value_to_name_ref().value());
  swap(a.values_ref().value(), b.values_ref().value());
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.ids_ref().value(), b.ids_ref().value());
  swap(a.descriptor_ref().value(), b.descriptor_ref().value());
  swap(a.descriptors_ref().value(), b.descriptors_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.keys_ref().value(), b.keys_ref().value());
  swap(a.annotation_ref().value(), b.annotation_ref().value());
  swap(a.annotations_ref().value(), b.annotations_ref().value());
  swap(a.member_ref().value(), b.member_ref().value());
  swap(a.members_ref().value(), b.members_ref().value());
  swap(a.field_ref().value(), b.field_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_indirections>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "real",
    "fake",
    "number",
    "result",
    "phrase",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections() :
      real(0),
      fake(0),
      number(0),
      result(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


struct_with_indirections::~struct_with_indirections() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections(apache::thrift::FragileConstructor, int32_t real__arg,  ::test_cpp2::cpp_reflection::FakeI32 fake__arg,  ::test_cpp2::cpp_reflection::HasANumber number__arg,  ::test_cpp2::cpp_reflection::HasAResult result__arg,  ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg) :
    real(std::move(real__arg)),
    fake(std::move(fake__arg)),
    number(std::move(number__arg)),
    result(std::move(result__arg)),
    phrase(std::move(phrase__arg)) {
  __isset.real = true;
  __isset.fake = true;
  __isset.number = true;
  __isset.result = true;
  __isset.phrase = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void struct_with_indirections::__clear() {
  // clear all fields
  real = 0;
  fake = 0;
  number.number = 0;
  result.foo().result() = 0;
  phrase.phrase = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<CppHasAPhrase>().phrase)>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_with_indirections::operator==(const struct_with_indirections& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.real == rhs.real)) {
    return false;
  }
  if (!(lhs.fake == rhs.fake)) {
    return false;
  }
  if (!(lhs.number == rhs.number)) {
    return false;
  }
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.phrase == rhs.phrase)) {
    return false;
  }
  return true;
}

bool struct_with_indirections::operator<(const struct_with_indirections& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.real == rhs.real)) {
    return lhs.real < rhs.real;
  }
  if (!(lhs.fake == rhs.fake)) {
    return lhs.fake < rhs.fake;
  }
  if (!(lhs.number == rhs.number)) {
    return lhs.number < rhs.number;
  }
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.phrase == rhs.phrase)) {
    return lhs.phrase < rhs.phrase;
  }
  return false;
}


void swap(struct_with_indirections& a, struct_with_indirections& b) {
  using ::std::swap;
  swap(a.real_ref().value(), b.real_ref().value());
  swap(a.fake_ref().value(), b.fake_ref().value());
  swap(a.number_ref().value(), b.number_ref().value());
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.phrase_ref().value(), b.phrase_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_with_indirections::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_indirections::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
