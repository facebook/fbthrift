/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "module_types.h"

#include "module_types.tcc"

#include <algorithm>

namespace test_cpp2 { namespace cpp_reflection {

enum1 _kenum1Values[] = {
  enum1::field0,
  enum1::field1,
  enum1::field2
};

const char* _kenum1Names[] = {
  "field0",
  "field1",
  "field2"
};

const std::map<enum1, const char*> _enum1_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum1>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumIterator<enum1>(-1, nullptr, nullptr));
const std::map<const char*, enum1, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum1>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumInverseIterator<enum1>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum1_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum2 _kenum2Values[] = {
  enum2::field0_2,
  enum2::field1_2,
  enum2::field2_2
};

const char* _kenum2Names[] = {
  "field0_2",
  "field1_2",
  "field2_2"
};

const std::map<enum2, const char*> _enum2_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum2>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumIterator<enum2>(-1, nullptr, nullptr));
const std::map<const char*, enum2, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum2>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumInverseIterator<enum2>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum2_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum3 _kenum3Values[] = {
  enum3::field0_3,
  enum3::field1_3,
  enum3::field2_3
};

const char* _kenum3Names[] = {
  "field0_3",
  "field1_3",
  "field2_3"
};

const std::map<enum3, const char*> _enum3_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum3>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumIterator<enum3>(-1, nullptr, nullptr));
const std::map<const char*, enum3, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum3>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumInverseIterator<enum3>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum3_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union1::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union1::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
    {
      destruct(value_.ui);
      break;
    }
    case Type::ud:
    {
      destruct(value_.ud);
      break;
    }
    case Type::us:
    {
      destruct(value_.us);
      break;
    }
    case Type::ue:
    {
      destruct(value_.ue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
    {
      return value_.ui == rhs.value_.ui;
      break;
    }
    case Type::ud:
    {
      return value_.ud == rhs.value_.ud;
      break;
    }
    case Type::us:
    {
      return value_.us == rhs.value_.us;
      break;
    }
    case Type::ue:
    {
      return value_.ue == rhs.value_.ue;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union2::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union2::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
    {
      destruct(value_.ui_2);
      break;
    }
    case Type::ud_2:
    {
      destruct(value_.ud_2);
      break;
    }
    case Type::us_2:
    {
      destruct(value_.us_2);
      break;
    }
    case Type::ue_2:
    {
      destruct(value_.ue_2);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
    {
      return value_.ui_2 == rhs.value_.ui_2;
      break;
    }
    case Type::ud_2:
    {
      return value_.ud_2 == rhs.value_.ud_2;
      break;
    }
    case Type::us_2:
    {
      return value_.us_2 == rhs.value_.us_2;
      break;
    }
    case Type::ue_2:
    {
      return value_.ue_2 == rhs.value_.ue_2;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union3::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union3::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
    {
      destruct(value_.ui_3);
      break;
    }
    case Type::ud_3:
    {
      destruct(value_.ud_3);
      break;
    }
    case Type::us_3:
    {
      destruct(value_.us_3);
      break;
    }
    case Type::ue_3:
    {
      destruct(value_.ue_3);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
    {
      return value_.ui_3 == rhs.value_.ui_3;
      break;
    }
    case Type::ud_3:
    {
      return value_.ud_3 == rhs.value_.ud_3;
      break;
    }
    case Type::us_3:
    {
      return value_.us_3 == rhs.value_.us_3;
      break;
    }
    case Type::ue_3:
    {
      return value_.ue_3 == rhs.value_.ue_3;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t structA::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void structA::__clear() {
  a = 0;
  b = std::string();
  __isset.__clear();
}

bool structA::operator==(const structA& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  return true;
}

void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t structB::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}

bool structB::operator==(const structB& rhs) const {
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  return true;
}

void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct1::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct1::__clear() {
  field0 = 0;
  field1 = std::string();
  field2 =  ::test_cpp2::cpp_reflection::enum1();
  field3 =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&field4);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&field5);
  __isset.__clear();
}

bool struct1::operator==(const struct1& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (!((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!((field3 == rhs.field3))) {
    return false;
  }
  if (!((field4 == rhs.field4))) {
    return false;
  }
  if (!((field5 == rhs.field5))) {
    return false;
  }
  return true;
}

void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct2::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct2::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  __isset.__clear();
}

bool struct2::operator==(const struct2& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  return true;
}

void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct3::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct3::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldH);
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}

bool struct3::operator==(const struct3& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  if (!((fieldH == rhs.fieldH))) {
    return false;
  }
  if (!((fieldI == rhs.fieldI))) {
    return false;
  }
  if (!((fieldJ == rhs.fieldJ))) {
    return false;
  }
  if (!((fieldK == rhs.fieldK))) {
    return false;
  }
  if (!((fieldL == rhs.fieldL))) {
    return false;
  }
  if (!((fieldM == rhs.fieldM))) {
    return false;
  }
  if (!((fieldN == rhs.fieldN))) {
    return false;
  }
  if (!((fieldO == rhs.fieldO))) {
    return false;
  }
  if (!((fieldP == rhs.fieldP))) {
    return false;
  }
  if (!((fieldQ == rhs.fieldQ))) {
    return false;
  }
  if (!((fieldR == rhs.fieldR))) {
    return false;
  }
  return true;
}

void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection