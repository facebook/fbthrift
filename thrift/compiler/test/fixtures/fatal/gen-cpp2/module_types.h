/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/reflection_dep_B_types.h"
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/reflection_dep_C_types.h"
#include "thrift/test/fatal_custom_types.h"

namespace apache {
namespace thrift {
namespace tag {
struct ui;
struct ud;
struct us;
struct ue;
struct ui_2;
struct ud_2;
struct us_2;
struct ue_2;
struct ui_3;
struct ud_3;
struct us_3;
struct ue_3;
struct a;
struct b;
struct i;
struct d;
struct s;
struct e;
struct a;
struct c;
struct d;
struct a;
struct b;
struct c;
struct d;
struct e;
struct f;
struct g;
struct h;
struct i;
struct j;
struct j1;
struct j2;
struct j3;
struct k;
struct k1;
struct k2;
struct k3;
struct l;
struct l1;
struct l2;
struct l3;
struct m1;
struct m2;
struct m3;
struct n1;
struct n2;
struct n3;
struct o1;
struct o2;
struct o3;
struct field0;
struct field1;
struct field2;
struct field3;
struct field4;
struct field5;
struct fieldA;
struct fieldB;
struct fieldC;
struct fieldD;
struct fieldE;
struct fieldF;
struct fieldG;
struct fieldA;
struct fieldB;
struct fieldC;
struct fieldD;
struct fieldE;
struct fieldF;
struct fieldG;
struct fieldH;
struct fieldI;
struct fieldJ;
struct fieldK;
struct fieldL;
struct fieldM;
struct fieldN;
struct fieldO;
struct fieldP;
struct fieldQ;
struct fieldR;
struct field0;
struct field1;
struct field2;
struct field3;
struct field0;
struct field1;
struct field2;
struct field3;
struct field4;
struct bi;
struct b;
struct c;
struct i_a;
struct b;
struct c;
struct i_a;
struct a;
struct get;
struct getter;
struct lists;
struct maps;
struct name;
struct name_to_value;
struct names;
struct prefix_tree;
struct sets;
struct setter;
struct str;
struct strings;
struct type;
struct value;
struct value_to_name;
struct values;
struct id;
struct ids;
struct descriptor;
struct descriptors;
struct key;
struct keys;
struct annotation;
struct annotations;
struct member;
struct members;
struct field;
struct fields;
struct get;
struct getter;
struct lists;
struct maps;
struct name;
struct name_to_value;
struct names;
struct prefix_tree;
struct sets;
struct setter;
struct str;
struct strings;
struct type;
struct value;
struct value_to_name;
struct values;
struct id;
struct ids;
struct descriptor;
struct descriptors;
struct key;
struct keys;
struct annotation;
struct annotations;
struct member;
struct members;
struct field;
struct fields;
struct real;
struct fake;
struct number;
struct result;
struct phrase;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_ui
#define APACHE_THRIFT_ACCESSOR_ui
APACHE_THRIFT_DEFINE_ACCESSOR(ui);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud
#define APACHE_THRIFT_ACCESSOR_ud
APACHE_THRIFT_DEFINE_ACCESSOR(ud);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us
#define APACHE_THRIFT_ACCESSOR_us
APACHE_THRIFT_DEFINE_ACCESSOR(us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue
#define APACHE_THRIFT_ACCESSOR_ue
APACHE_THRIFT_DEFINE_ACCESSOR(ue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ui_2
#define APACHE_THRIFT_ACCESSOR_ui_2
APACHE_THRIFT_DEFINE_ACCESSOR(ui_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud_2
#define APACHE_THRIFT_ACCESSOR_ud_2
APACHE_THRIFT_DEFINE_ACCESSOR(ud_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us_2
#define APACHE_THRIFT_ACCESSOR_us_2
APACHE_THRIFT_DEFINE_ACCESSOR(us_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue_2
#define APACHE_THRIFT_ACCESSOR_ue_2
APACHE_THRIFT_DEFINE_ACCESSOR(ue_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ui_3
#define APACHE_THRIFT_ACCESSOR_ui_3
APACHE_THRIFT_DEFINE_ACCESSOR(ui_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud_3
#define APACHE_THRIFT_ACCESSOR_ud_3
APACHE_THRIFT_DEFINE_ACCESSOR(ud_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us_3
#define APACHE_THRIFT_ACCESSOR_us_3
APACHE_THRIFT_DEFINE_ACCESSOR(us_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue_3
#define APACHE_THRIFT_ACCESSOR_ue_3
APACHE_THRIFT_DEFINE_ACCESSOR(ue_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i
#define APACHE_THRIFT_ACCESSOR_i
APACHE_THRIFT_DEFINE_ACCESSOR(i);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_s
#define APACHE_THRIFT_ACCESSOR_s
APACHE_THRIFT_DEFINE_ACCESSOR(s);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_e
#define APACHE_THRIFT_ACCESSOR_e
APACHE_THRIFT_DEFINE_ACCESSOR(e);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_e
#define APACHE_THRIFT_ACCESSOR_e
APACHE_THRIFT_DEFINE_ACCESSOR(e);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_f
#define APACHE_THRIFT_ACCESSOR_f
APACHE_THRIFT_DEFINE_ACCESSOR(f);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_g
#define APACHE_THRIFT_ACCESSOR_g
APACHE_THRIFT_DEFINE_ACCESSOR(g);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_h
#define APACHE_THRIFT_ACCESSOR_h
APACHE_THRIFT_DEFINE_ACCESSOR(h);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i
#define APACHE_THRIFT_ACCESSOR_i
APACHE_THRIFT_DEFINE_ACCESSOR(i);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j
#define APACHE_THRIFT_ACCESSOR_j
APACHE_THRIFT_DEFINE_ACCESSOR(j);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j1
#define APACHE_THRIFT_ACCESSOR_j1
APACHE_THRIFT_DEFINE_ACCESSOR(j1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j2
#define APACHE_THRIFT_ACCESSOR_j2
APACHE_THRIFT_DEFINE_ACCESSOR(j2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j3
#define APACHE_THRIFT_ACCESSOR_j3
APACHE_THRIFT_DEFINE_ACCESSOR(j3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k
#define APACHE_THRIFT_ACCESSOR_k
APACHE_THRIFT_DEFINE_ACCESSOR(k);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k1
#define APACHE_THRIFT_ACCESSOR_k1
APACHE_THRIFT_DEFINE_ACCESSOR(k1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k2
#define APACHE_THRIFT_ACCESSOR_k2
APACHE_THRIFT_DEFINE_ACCESSOR(k2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k3
#define APACHE_THRIFT_ACCESSOR_k3
APACHE_THRIFT_DEFINE_ACCESSOR(k3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l
#define APACHE_THRIFT_ACCESSOR_l
APACHE_THRIFT_DEFINE_ACCESSOR(l);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l1
#define APACHE_THRIFT_ACCESSOR_l1
APACHE_THRIFT_DEFINE_ACCESSOR(l1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l2
#define APACHE_THRIFT_ACCESSOR_l2
APACHE_THRIFT_DEFINE_ACCESSOR(l2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l3
#define APACHE_THRIFT_ACCESSOR_l3
APACHE_THRIFT_DEFINE_ACCESSOR(l3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m1
#define APACHE_THRIFT_ACCESSOR_m1
APACHE_THRIFT_DEFINE_ACCESSOR(m1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m2
#define APACHE_THRIFT_ACCESSOR_m2
APACHE_THRIFT_DEFINE_ACCESSOR(m2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m3
#define APACHE_THRIFT_ACCESSOR_m3
APACHE_THRIFT_DEFINE_ACCESSOR(m3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n1
#define APACHE_THRIFT_ACCESSOR_n1
APACHE_THRIFT_DEFINE_ACCESSOR(n1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n2
#define APACHE_THRIFT_ACCESSOR_n2
APACHE_THRIFT_DEFINE_ACCESSOR(n2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n3
#define APACHE_THRIFT_ACCESSOR_n3
APACHE_THRIFT_DEFINE_ACCESSOR(n3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o1
#define APACHE_THRIFT_ACCESSOR_o1
APACHE_THRIFT_DEFINE_ACCESSOR(o1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o2
#define APACHE_THRIFT_ACCESSOR_o2
APACHE_THRIFT_DEFINE_ACCESSOR(o2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o3
#define APACHE_THRIFT_ACCESSOR_o3
APACHE_THRIFT_DEFINE_ACCESSOR(o3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field4
#define APACHE_THRIFT_ACCESSOR_field4
APACHE_THRIFT_DEFINE_ACCESSOR(field4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field5
#define APACHE_THRIFT_ACCESSOR_field5
APACHE_THRIFT_DEFINE_ACCESSOR(field5);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldI
#define APACHE_THRIFT_ACCESSOR_fieldI
APACHE_THRIFT_DEFINE_ACCESSOR(fieldI);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldJ
#define APACHE_THRIFT_ACCESSOR_fieldJ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldJ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldK
#define APACHE_THRIFT_ACCESSOR_fieldK
APACHE_THRIFT_DEFINE_ACCESSOR(fieldK);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldL
#define APACHE_THRIFT_ACCESSOR_fieldL
APACHE_THRIFT_DEFINE_ACCESSOR(fieldL);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldM
#define APACHE_THRIFT_ACCESSOR_fieldM
APACHE_THRIFT_DEFINE_ACCESSOR(fieldM);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldN
#define APACHE_THRIFT_ACCESSOR_fieldN
APACHE_THRIFT_DEFINE_ACCESSOR(fieldN);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldO
#define APACHE_THRIFT_ACCESSOR_fieldO
APACHE_THRIFT_DEFINE_ACCESSOR(fieldO);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldP
#define APACHE_THRIFT_ACCESSOR_fieldP
APACHE_THRIFT_DEFINE_ACCESSOR(fieldP);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldQ
#define APACHE_THRIFT_ACCESSOR_fieldQ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldQ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldR
#define APACHE_THRIFT_ACCESSOR_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field4
#define APACHE_THRIFT_ACCESSOR_field4
APACHE_THRIFT_DEFINE_ACCESSOR(field4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_bi
#define APACHE_THRIFT_ACCESSOR_bi
APACHE_THRIFT_DEFINE_ACCESSOR(bi);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i_a
#define APACHE_THRIFT_ACCESSOR_i_a
APACHE_THRIFT_DEFINE_ACCESSOR(i_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i_a
#define APACHE_THRIFT_ACCESSOR_i_a
APACHE_THRIFT_DEFINE_ACCESSOR(i_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_get
#define APACHE_THRIFT_ACCESSOR_get
APACHE_THRIFT_DEFINE_ACCESSOR(get);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_getter
#define APACHE_THRIFT_ACCESSOR_getter
APACHE_THRIFT_DEFINE_ACCESSOR(getter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lists
#define APACHE_THRIFT_ACCESSOR_lists
APACHE_THRIFT_DEFINE_ACCESSOR(lists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_maps
#define APACHE_THRIFT_ACCESSOR_maps
APACHE_THRIFT_DEFINE_ACCESSOR(maps);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_to_value
#define APACHE_THRIFT_ACCESSOR_name_to_value
APACHE_THRIFT_DEFINE_ACCESSOR(name_to_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_names
#define APACHE_THRIFT_ACCESSOR_names
APACHE_THRIFT_DEFINE_ACCESSOR(names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prefix_tree
#define APACHE_THRIFT_ACCESSOR_prefix_tree
APACHE_THRIFT_DEFINE_ACCESSOR(prefix_tree);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sets
#define APACHE_THRIFT_ACCESSOR_sets
APACHE_THRIFT_DEFINE_ACCESSOR(sets);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setter
#define APACHE_THRIFT_ACCESSOR_setter
APACHE_THRIFT_DEFINE_ACCESSOR(setter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_str
#define APACHE_THRIFT_ACCESSOR_str
APACHE_THRIFT_DEFINE_ACCESSOR(str);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_strings
#define APACHE_THRIFT_ACCESSOR_strings
APACHE_THRIFT_DEFINE_ACCESSOR(strings);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value_to_name
#define APACHE_THRIFT_ACCESSOR_value_to_name
APACHE_THRIFT_DEFINE_ACCESSOR(value_to_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ids
#define APACHE_THRIFT_ACCESSOR_ids
APACHE_THRIFT_DEFINE_ACCESSOR(ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptor
#define APACHE_THRIFT_ACCESSOR_descriptor
APACHE_THRIFT_DEFINE_ACCESSOR(descriptor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptors
#define APACHE_THRIFT_ACCESSOR_descriptors
APACHE_THRIFT_DEFINE_ACCESSOR(descriptors);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keys
#define APACHE_THRIFT_ACCESSOR_keys
APACHE_THRIFT_DEFINE_ACCESSOR(keys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation
#define APACHE_THRIFT_ACCESSOR_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotations
#define APACHE_THRIFT_ACCESSOR_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_member
#define APACHE_THRIFT_ACCESSOR_member
APACHE_THRIFT_DEFINE_ACCESSOR(member);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_members
#define APACHE_THRIFT_ACCESSOR_members
APACHE_THRIFT_DEFINE_ACCESSOR(members);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field
#define APACHE_THRIFT_ACCESSOR_field
APACHE_THRIFT_DEFINE_ACCESSOR(field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_get
#define APACHE_THRIFT_ACCESSOR_get
APACHE_THRIFT_DEFINE_ACCESSOR(get);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_getter
#define APACHE_THRIFT_ACCESSOR_getter
APACHE_THRIFT_DEFINE_ACCESSOR(getter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lists
#define APACHE_THRIFT_ACCESSOR_lists
APACHE_THRIFT_DEFINE_ACCESSOR(lists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_maps
#define APACHE_THRIFT_ACCESSOR_maps
APACHE_THRIFT_DEFINE_ACCESSOR(maps);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_to_value
#define APACHE_THRIFT_ACCESSOR_name_to_value
APACHE_THRIFT_DEFINE_ACCESSOR(name_to_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_names
#define APACHE_THRIFT_ACCESSOR_names
APACHE_THRIFT_DEFINE_ACCESSOR(names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prefix_tree
#define APACHE_THRIFT_ACCESSOR_prefix_tree
APACHE_THRIFT_DEFINE_ACCESSOR(prefix_tree);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sets
#define APACHE_THRIFT_ACCESSOR_sets
APACHE_THRIFT_DEFINE_ACCESSOR(sets);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setter
#define APACHE_THRIFT_ACCESSOR_setter
APACHE_THRIFT_DEFINE_ACCESSOR(setter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_str
#define APACHE_THRIFT_ACCESSOR_str
APACHE_THRIFT_DEFINE_ACCESSOR(str);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_strings
#define APACHE_THRIFT_ACCESSOR_strings
APACHE_THRIFT_DEFINE_ACCESSOR(strings);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value_to_name
#define APACHE_THRIFT_ACCESSOR_value_to_name
APACHE_THRIFT_DEFINE_ACCESSOR(value_to_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ids
#define APACHE_THRIFT_ACCESSOR_ids
APACHE_THRIFT_DEFINE_ACCESSOR(ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptor
#define APACHE_THRIFT_ACCESSOR_descriptor
APACHE_THRIFT_DEFINE_ACCESSOR(descriptor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptors
#define APACHE_THRIFT_ACCESSOR_descriptors
APACHE_THRIFT_DEFINE_ACCESSOR(descriptors);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keys
#define APACHE_THRIFT_ACCESSOR_keys
APACHE_THRIFT_DEFINE_ACCESSOR(keys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation
#define APACHE_THRIFT_ACCESSOR_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotations
#define APACHE_THRIFT_ACCESSOR_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_member
#define APACHE_THRIFT_ACCESSOR_member
APACHE_THRIFT_DEFINE_ACCESSOR(member);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_members
#define APACHE_THRIFT_ACCESSOR_members
APACHE_THRIFT_DEFINE_ACCESSOR(members);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field
#define APACHE_THRIFT_ACCESSOR_field
APACHE_THRIFT_DEFINE_ACCESSOR(field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_real
#define APACHE_THRIFT_ACCESSOR_real
APACHE_THRIFT_DEFINE_ACCESSOR(real);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fake
#define APACHE_THRIFT_ACCESSOR_fake
APACHE_THRIFT_DEFINE_ACCESSOR(fake);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_number
#define APACHE_THRIFT_ACCESSOR_number
APACHE_THRIFT_DEFINE_ACCESSOR(number);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_phrase
#define APACHE_THRIFT_ACCESSOR_phrase
APACHE_THRIFT_DEFINE_ACCESSOR(phrase);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace test_cpp2 { namespace cpp_reflection {

enum class enum1 {
  field0 = 0,
  field1 = 1,
  field2 = 2,
};




enum class enum2 {
  field0_2 = 0,
  field1_2 = 1,
  field2_2 = 2,
};




enum class enum3 {
  field0_3 = 0,
  field1_3 = 1,
};




enum class enum_with_special_names {
  get = 0,
  getter = 1,
  lists = 2,
  maps = 3,
  name = 4,
  name_to_value = 5,
  names = 6,
  prefix_tree = 7,
  sets = 8,
  setter = 9,
  str = 10,
  strings = 11,
  type = 12,
  value = 13,
  value_to_name = 14,
  values = 15,
  id = 16,
  ids = 17,
  descriptor = 18,
  descriptors = 19,
  key = 20,
  keys = 21,
  annotation = 22,
  annotations = 23,
  member = 24,
  members = 25,
  field = 26,
  fields = 27,
};




}} // test_cpp2::cpp_reflection

namespace std {
template<> struct hash<::test_cpp2::cpp_reflection::enum1> :
  ::apache::thrift::detail::enum_hash<::test_cpp2::cpp_reflection::enum1> {};
template<> struct hash<::test_cpp2::cpp_reflection::enum2> :
  ::apache::thrift::detail::enum_hash<::test_cpp2::cpp_reflection::enum2> {};
template<> struct hash<::test_cpp2::cpp_reflection::enum3> :
  ::apache::thrift::detail::enum_hash<::test_cpp2::cpp_reflection::enum3> {};
template<> struct hash<::test_cpp2::cpp_reflection::enum_with_special_names> :
  ::apache::thrift::detail::enum_hash<::test_cpp2::cpp_reflection::enum_with_special_names> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum1> {
  using type = ::test_cpp2::cpp_reflection::enum1;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0; }
  static constexpr type max() { return type::field2; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum2> {
  using type = ::test_cpp2::cpp_reflection::enum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0_2; }
  static constexpr type max() { return type::field2_2; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum3> {
  using type = ::test_cpp2::cpp_reflection::enum3;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0_3; }
  static constexpr type max() { return type::field1_3; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names> {
  using type = ::test_cpp2::cpp_reflection::enum_with_special_names;

  static constexpr std::size_t const size = 28;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::get; }
  static constexpr type max() { return type::fields; }
};


}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {

using _enum1_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum1>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES;

using _enum2_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum2>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES;

using _enum3_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum3>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES;

using _enum_with_special_names_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum_with_special_names>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection

// END declare_enums
// BEGIN forward_declare
namespace test_cpp2 { namespace cpp_reflection {
class union1;
class union2;
class union3;
class structA;
class unionA;
class structB;
class structC;
class struct1;
class struct2;
class struct3;
class struct4;
class struct5;
class struct_binary;
class dep_A_struct;
class dep_B_struct;
class annotated;
class union_with_special_names;
class struct_with_special_names;
class struct_with_indirections;
}} // test_cpp2::cpp_reflection
// END forward_declare
// BEGIN typedefs
namespace test_cpp2 { namespace cpp_reflection {
typedef test_cpp_reflection::custom_structA my_structA;
typedef CppFakeI32 FakeI32;
typedef CppHasANumber HasANumber;
typedef CppHasAResult HasAResult;
typedef CppHasAPhrase HasAPhrase;

}} // test_cpp2::cpp_reflection
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class union1 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = union1;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    ui = 1,
    ud = 3,
    us = 5,
    ue = 7,
  } ;

  union1()
      : type_(Type::__EMPTY__) {}

  union1(union1&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union1(const union1& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union1& operator=(union1&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union1& operator=(const union1& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union1() {
    __clear();
  }
  union storage_type {
    ::std::int32_t ui;
    double ud;
    ::std::string us;
    ::test_cpp2::cpp_reflection::enum1 ue;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const union1&) const;
  bool operator<(const union1&) const;

  ::std::int32_t& set_ui(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::ui;
    ::new (std::addressof(value_.ui)) ::std::int32_t(t);
    return value_.ui;
  }

  double& set_ud(double t = double()) {
    __clear();
    type_ = Type::ud;
    ::new (std::addressof(value_.ud)) double(t);
    return value_.ud;
  }

  ::std::string& set_us(::std::string const &t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(t);
    return value_.us;
  }

  ::std::string& set_us(::std::string&& t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(std::move(t));
    return value_.us;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us(T&&... t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(std::forward<T>(t)...);
    return value_.us;
  }

  ::test_cpp2::cpp_reflection::enum1& set_ue(::test_cpp2::cpp_reflection::enum1 t = ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue;
    ::new (std::addressof(value_.ue)) ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue;
  }

  ::std::int32_t const& get_ui() const {
    if (type_ != Type::ui) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ui;
  }

  double const& get_ud() const {
    if (type_ != Type::ud) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ud;
  }

  ::std::string const& get_us() const {
    if (type_ != Type::us) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.us;
  }

  ::test_cpp2::cpp_reflection::enum1 const& get_ue() const {
    if (type_ != Type::ue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ue;
  }

  ::std::int32_t& mutable_ui() {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double& mutable_ud() {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  ::std::string& mutable_us() {
    assert(type_ == Type::us);
    return value_.us;
  }

  ::test_cpp2::cpp_reflection::enum1& mutable_ue() {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  ::std::int32_t move_ui() {
    assert(type_ == Type::ui);
    return std::move(value_.ui);
  }

  double move_ud() {
    assert(type_ == Type::ud);
    return std::move(value_.ud);
  }

  ::std::string move_us() {
    assert(type_ == Type::us);
    return std::move(value_.us);
  }

  ::test_cpp2::cpp_reflection::enum1 move_ue() {
    assert(type_ == Type::ue);
    return std::move(value_.ue);
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ui_ref() const& {
    return {value_.ui, type_, ui, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ui_ref() const&& {
    return {std::move(value_.ui), type_, ui, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ui_ref() & {
    return {value_.ui, type_, ui, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ui_ref() && {
    return {std::move(value_.ui), type_, ui, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ud_ref() const& {
    return {value_.ud, type_, ud, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ud_ref() const&& {
    return {std::move(value_.ud), type_, ud, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ud_ref() & {
    return {value_.ud, type_, ud, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ud_ref() && {
    return {std::move(value_.ud), type_, ud, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> us_ref() const& {
    return {value_.us, type_, us, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> us_ref() const&& {
    return {std::move(value_.us), type_, us, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> us_ref() & {
    return {value_.us, type_, us, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> us_ref() && {
    return {std::move(value_.us), type_, us, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ue_ref() const& {
    return {value_.ue, type_, ue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ue_ref() const&& {
    return {std::move(value_.ue), type_, ue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ue_ref() & {
    return {value_.ue, type_, ue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ue_ref() && {
    return {std::move(value_.ue), type_, ue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<union1>;
  friend void swap(union1& a, union1& b);
};

template <class Protocol_>
uint32_t union1::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class union2 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = union2;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    ui_2 = 1,
    ud_2 = 2,
    us_2 = 3,
    ue_2 = 4,
  } ;

  union2()
      : type_(Type::__EMPTY__) {}

  union2(union2&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union2(const union2& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union2& operator=(union2&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union2& operator=(const union2& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union2() {
    __clear();
  }
  union storage_type {
    ::std::int32_t ui_2;
    double ud_2;
    ::std::string us_2;
    ::test_cpp2::cpp_reflection::enum1 ue_2;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const union2&) const;
  bool operator<(const union2&) const;

  ::std::int32_t& set_ui_2(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::ui_2;
    ::new (std::addressof(value_.ui_2)) ::std::int32_t(t);
    return value_.ui_2;
  }

  double& set_ud_2(double t = double()) {
    __clear();
    type_ = Type::ud_2;
    ::new (std::addressof(value_.ud_2)) double(t);
    return value_.ud_2;
  }

  ::std::string& set_us_2(::std::string const &t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(t);
    return value_.us_2;
  }

  ::std::string& set_us_2(::std::string&& t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(std::move(t));
    return value_.us_2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us_2(T&&... t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(std::forward<T>(t)...);
    return value_.us_2;
  }

  ::test_cpp2::cpp_reflection::enum1& set_ue_2(::test_cpp2::cpp_reflection::enum1 t = ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_2;
    ::new (std::addressof(value_.ue_2)) ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_2;
  }

  ::std::int32_t const& get_ui_2() const {
    if (type_ != Type::ui_2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ui_2;
  }

  double const& get_ud_2() const {
    if (type_ != Type::ud_2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ud_2;
  }

  ::std::string const& get_us_2() const {
    if (type_ != Type::us_2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.us_2;
  }

  ::test_cpp2::cpp_reflection::enum1 const& get_ue_2() const {
    if (type_ != Type::ue_2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ue_2;
  }

  ::std::int32_t& mutable_ui_2() {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double& mutable_ud_2() {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  ::std::string& mutable_us_2() {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

  ::test_cpp2::cpp_reflection::enum1& mutable_ue_2() {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  ::std::int32_t move_ui_2() {
    assert(type_ == Type::ui_2);
    return std::move(value_.ui_2);
  }

  double move_ud_2() {
    assert(type_ == Type::ud_2);
    return std::move(value_.ud_2);
  }

  ::std::string move_us_2() {
    assert(type_ == Type::us_2);
    return std::move(value_.us_2);
  }

  ::test_cpp2::cpp_reflection::enum1 move_ue_2() {
    assert(type_ == Type::ue_2);
    return std::move(value_.ue_2);
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ui_2_ref() const& {
    return {value_.ui_2, type_, ui_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ui_2_ref() const&& {
    return {std::move(value_.ui_2), type_, ui_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ui_2_ref() & {
    return {value_.ui_2, type_, ui_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ui_2_ref() && {
    return {std::move(value_.ui_2), type_, ui_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ud_2_ref() const& {
    return {value_.ud_2, type_, ud_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ud_2_ref() const&& {
    return {std::move(value_.ud_2), type_, ud_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ud_2_ref() & {
    return {value_.ud_2, type_, ud_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ud_2_ref() && {
    return {std::move(value_.ud_2), type_, ud_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> us_2_ref() const& {
    return {value_.us_2, type_, us_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> us_2_ref() const&& {
    return {std::move(value_.us_2), type_, us_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> us_2_ref() & {
    return {value_.us_2, type_, us_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> us_2_ref() && {
    return {std::move(value_.us_2), type_, us_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ue_2_ref() const& {
    return {value_.ue_2, type_, ue_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ue_2_ref() const&& {
    return {std::move(value_.ue_2), type_, ue_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ue_2_ref() & {
    return {value_.ue_2, type_, ue_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ue_2_ref() && {
    return {std::move(value_.ue_2), type_, ue_2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<union2>;
  friend void swap(union2& a, union2& b);
};

template <class Protocol_>
uint32_t union2::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class union3 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = union3;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    ui_3 = 1,
    ud_3 = 2,
    us_3 = 3,
    ue_3 = 4,
  } ;

  union3()
      : type_(Type::__EMPTY__) {}

  union3(union3&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union3(const union3& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union3& operator=(union3&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union3& operator=(const union3& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union3() {
    __clear();
  }
  union storage_type {
    ::std::int32_t ui_3;
    double ud_3;
    ::std::string us_3;
    ::test_cpp2::cpp_reflection::enum1 ue_3;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const union3&) const;
  bool operator<(const union3&) const;

  ::std::int32_t& set_ui_3(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::ui_3;
    ::new (std::addressof(value_.ui_3)) ::std::int32_t(t);
    return value_.ui_3;
  }

  double& set_ud_3(double t = double()) {
    __clear();
    type_ = Type::ud_3;
    ::new (std::addressof(value_.ud_3)) double(t);
    return value_.ud_3;
  }

  ::std::string& set_us_3(::std::string const &t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(t);
    return value_.us_3;
  }

  ::std::string& set_us_3(::std::string&& t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(std::move(t));
    return value_.us_3;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us_3(T&&... t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(std::forward<T>(t)...);
    return value_.us_3;
  }

  ::test_cpp2::cpp_reflection::enum1& set_ue_3(::test_cpp2::cpp_reflection::enum1 t = ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_3;
    ::new (std::addressof(value_.ue_3)) ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_3;
  }

  ::std::int32_t const& get_ui_3() const {
    if (type_ != Type::ui_3) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ui_3;
  }

  double const& get_ud_3() const {
    if (type_ != Type::ud_3) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ud_3;
  }

  ::std::string const& get_us_3() const {
    if (type_ != Type::us_3) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.us_3;
  }

  ::test_cpp2::cpp_reflection::enum1 const& get_ue_3() const {
    if (type_ != Type::ue_3) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ue_3;
  }

  ::std::int32_t& mutable_ui_3() {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double& mutable_ud_3() {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  ::std::string& mutable_us_3() {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

  ::test_cpp2::cpp_reflection::enum1& mutable_ue_3() {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  ::std::int32_t move_ui_3() {
    assert(type_ == Type::ui_3);
    return std::move(value_.ui_3);
  }

  double move_ud_3() {
    assert(type_ == Type::ud_3);
    return std::move(value_.ud_3);
  }

  ::std::string move_us_3() {
    assert(type_ == Type::us_3);
    return std::move(value_.us_3);
  }

  ::test_cpp2::cpp_reflection::enum1 move_ue_3() {
    assert(type_ == Type::ue_3);
    return std::move(value_.ue_3);
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ui_3_ref() const& {
    return {value_.ui_3, type_, ui_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ui_3_ref() const&& {
    return {std::move(value_.ui_3), type_, ui_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ui_3_ref() & {
    return {value_.ui_3, type_, ui_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ui_3_ref() && {
    return {std::move(value_.ui_3), type_, ui_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ud_3_ref() const& {
    return {value_.ud_3, type_, ud_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ud_3_ref() const&& {
    return {std::move(value_.ud_3), type_, ud_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ud_3_ref() & {
    return {value_.ud_3, type_, ud_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ud_3_ref() && {
    return {std::move(value_.ud_3), type_, ud_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> us_3_ref() const& {
    return {value_.us_3, type_, us_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> us_3_ref() const&& {
    return {std::move(value_.us_3), type_, us_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> us_3_ref() & {
    return {value_.us_3, type_, us_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> us_3_ref() && {
    return {std::move(value_.us_3), type_, us_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ue_3_ref() const& {
    return {value_.ue_3, type_, ue_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ue_3_ref() const&& {
    return {std::move(value_.ue_3), type_, ue_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ue_3_ref() & {
    return {value_.ue_3, type_, ue_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ue_3_ref() && {
    return {std::move(value_.ue_3), type_, ue_3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<union3>;
  friend void swap(union3& a, union3& b);
};

template <class Protocol_>
uint32_t union3::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class structA final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = structA;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  structA() :
      a(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structA(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg);

  structA(structA&&) noexcept;

  structA(const structA& src);


  structA& operator=(structA&&) noexcept;
  structA& operator=(const structA& src);
  void __clear();
 private:
  ::std::int32_t a;
 private:
  ::std::string b;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool a;
    bool b;
  } __isset = {};

 public:

  bool operator==(const structA&) const;
  bool operator<(const structA&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_ref() const& {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_ref() const&& {
    return {std::move(this->a), __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_ref() & {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_ref() && {
    return {std::move(this->a), __isset.a};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> b_ref() const& {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> b_ref() const&& {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> b_ref() & {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> b_ref() && {
    return {std::move(this->b), __isset.b};
  }

  ::std::int32_t get_a() const {
    return a;
  }

  [[deprecated("Use `FOO.a_ref() = BAR;` instead of `FOO.set_a(BAR);`")]]
  ::std::int32_t& set_a(::std::int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  const ::std::string& get_b() const& {
    return b;
  }

  ::std::string get_b() && {
    return std::move(b);
  }

  template <typename T_structA_b_struct_setter = ::std::string>
  [[deprecated("Use `FOO.b_ref() = BAR;` instead of `FOO.set_b(BAR);`")]]
  ::std::string& set_b(T_structA_b_struct_setter&& b_) {
    b = std::forward<T_structA_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<structA>;
  friend void swap(structA& a, structA& b);
};

template <class Protocol_>
uint32_t structA::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class unionA final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = unionA;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    i = 1,
    d = 2,
    s = 3,
    e = 4,
    a = 5,
  } ;

  unionA()
      : type_(Type::__EMPTY__) {}

  unionA(unionA&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  unionA(const unionA& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  unionA& operator=(unionA&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  unionA& operator=(const unionA& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~unionA() {
    __clear();
  }
  union storage_type {
    ::std::int32_t i;
    double d;
    ::std::string s;
    ::test_cpp2::cpp_reflection::enum1 e;
    ::test_cpp2::cpp_reflection::structA a;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const unionA&) const;
  bool operator<(const unionA&) const;

  ::std::int32_t& set_i(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::i;
    ::new (std::addressof(value_.i)) ::std::int32_t(t);
    return value_.i;
  }

  double& set_d(double t = double()) {
    __clear();
    type_ = Type::d;
    ::new (std::addressof(value_.d)) double(t);
    return value_.d;
  }

  ::std::string& set_s(::std::string const &t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(t);
    return value_.s;
  }

  ::std::string& set_s(::std::string&& t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(std::move(t));
    return value_.s;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_s(T&&... t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(std::forward<T>(t)...);
    return value_.s;
  }

  ::test_cpp2::cpp_reflection::enum1& set_e(::test_cpp2::cpp_reflection::enum1 t = ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::e;
    ::new (std::addressof(value_.e)) ::test_cpp2::cpp_reflection::enum1(t);
    return value_.e;
  }

  ::test_cpp2::cpp_reflection::structA& set_a(::test_cpp2::cpp_reflection::structA const &t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a)) ::test_cpp2::cpp_reflection::structA(t);
    return value_.a;
  }

  ::test_cpp2::cpp_reflection::structA& set_a(::test_cpp2::cpp_reflection::structA&& t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a)) ::test_cpp2::cpp_reflection::structA(std::move(t));
    return value_.a;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::test_cpp2::cpp_reflection::structA, T...>> ::test_cpp2::cpp_reflection::structA& set_a(T&&... t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a)) ::test_cpp2::cpp_reflection::structA(std::forward<T>(t)...);
    return value_.a;
  }

  ::std::int32_t const& get_i() const {
    if (type_ != Type::i) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.i;
  }

  double const& get_d() const {
    if (type_ != Type::d) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.d;
  }

  ::std::string const& get_s() const {
    if (type_ != Type::s) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.s;
  }

  ::test_cpp2::cpp_reflection::enum1 const& get_e() const {
    if (type_ != Type::e) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.e;
  }

  ::test_cpp2::cpp_reflection::structA const& get_a() const {
    if (type_ != Type::a) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a;
  }

  ::std::int32_t& mutable_i() {
    assert(type_ == Type::i);
    return value_.i;
  }

  double& mutable_d() {
    assert(type_ == Type::d);
    return value_.d;
  }

  ::std::string& mutable_s() {
    assert(type_ == Type::s);
    return value_.s;
  }

  ::test_cpp2::cpp_reflection::enum1& mutable_e() {
    assert(type_ == Type::e);
    return value_.e;
  }

  ::test_cpp2::cpp_reflection::structA& mutable_a() {
    assert(type_ == Type::a);
    return value_.a;
  }

  ::std::int32_t move_i() {
    assert(type_ == Type::i);
    return std::move(value_.i);
  }

  double move_d() {
    assert(type_ == Type::d);
    return std::move(value_.d);
  }

  ::std::string move_s() {
    assert(type_ == Type::s);
    return std::move(value_.s);
  }

  ::test_cpp2::cpp_reflection::enum1 move_e() {
    assert(type_ == Type::e);
    return std::move(value_.e);
  }

  ::test_cpp2::cpp_reflection::structA move_a() {
    assert(type_ == Type::a);
    return std::move(value_.a);
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> i_ref() const& {
    return {value_.i, type_, i, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> i_ref() const&& {
    return {std::move(value_.i), type_, i, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> i_ref() & {
    return {value_.i, type_, i, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> i_ref() && {
    return {std::move(value_.i), type_, i, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> d_ref() const& {
    return {value_.d, type_, d, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> d_ref() const&& {
    return {std::move(value_.d), type_, d, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> d_ref() & {
    return {value_.d, type_, d, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> d_ref() && {
    return {std::move(value_.d), type_, d, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> s_ref() const& {
    return {value_.s, type_, s, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> s_ref() const&& {
    return {std::move(value_.s), type_, s, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> s_ref() & {
    return {value_.s, type_, s, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> s_ref() && {
    return {std::move(value_.s), type_, s, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> e_ref() const& {
    return {value_.e, type_, e, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> e_ref() const&& {
    return {std::move(value_.e), type_, e, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> e_ref() & {
    return {value_.e, type_, e, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> e_ref() && {
    return {std::move(value_.e), type_, e, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_ref() const& {
    return {value_.a, type_, a, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_ref() const&& {
    return {std::move(value_.a), type_, a, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_ref() & {
    return {value_.a, type_, a, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_ref() && {
    return {std::move(value_.a), type_, a, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<unionA>;
  friend void swap(unionA& a, unionA& b);
};

template <class Protocol_>
uint32_t unionA::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class structB final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = structB;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  structB() :
      c(0),
      d(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg);

  structB(structB&&) = default;

  structB(const structB&) = default;


  structB& operator=(structB&&) = default;

  structB& operator=(const structB&) = default;
  void __clear();
 private:
  double c;
 private:
  bool d;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool c;
    bool d;
  } __isset = {};

 public:

  bool operator==(const structB&) const;
  bool operator<(const structB&) const;

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> c_ref() const& {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> c_ref() const&& {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> c_ref() & {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> c_ref() && {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> d_ref() const& {
    return {this->d, __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> d_ref() const&& {
    return {std::move(this->d), __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> d_ref() & {
    return {this->d, __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> d_ref() && {
    return {std::move(this->d), __isset.d};
  }

  double get_c() const {
    return c;
  }

  [[deprecated("Use `FOO.c_ref() = BAR;` instead of `FOO.set_c(BAR);`")]]
  double& set_c(double c_) {
    c = c_;
    __isset.c = true;
    return c;
  }

  bool get_d() const {
    return d;
  }

  [[deprecated("Use `FOO.d_ref() = BAR;` instead of `FOO.set_d(BAR);`")]]
  bool& set_d(bool d_) {
    d = d_;
    __isset.d = true;
    return d;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<structB>;
  friend void swap(structB& a, structB& b);
};

template <class Protocol_>
uint32_t structB::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class structC final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = structC;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  structC();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structC(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg, ::test_cpp2::cpp_reflection::enum1 e__arg, ::test_cpp2::cpp_reflection::enum2 f__arg, ::test_cpp2::cpp_reflection::union1 g__arg, ::test_cpp2::cpp_reflection::unionA h__arg, ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<::std::int32_t> j__arg, ::std::vector<::std::int32_t> j1__arg, ::std::vector<::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<::std::int32_t> k__arg, ::std::set<::std::int32_t> k1__arg, ::std::set<::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set<::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<::std::int32_t, ::std::int32_t> l__arg, ::std::map<::std::int32_t, ::std::int32_t> l1__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> m1__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, ::std::int32_t> n1__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> o1__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> o3__arg);

  structC(structC&&) noexcept;

  structC(const structC& src);


  structC& operator=(structC&&) noexcept;
  structC& operator=(const structC& src);
  void __clear();

  ~structC();

 private:
  ::std::int32_t a;
 private:
  ::std::string b;
 private:
  double c;
 private:
  bool d;
 private:
  ::test_cpp2::cpp_reflection::enum1 e;
 private:
  ::test_cpp2::cpp_reflection::enum2 f;
 private:
  ::test_cpp2::cpp_reflection::union1 g;
 private:
  ::test_cpp2::cpp_reflection::unionA h;
 private:
  ::test_cpp2::cpp_reflection::unionA i;
 private:
  ::std::vector<::std::int32_t> j;
 private:
  ::std::vector<::std::int32_t> j1;
 private:
  ::std::vector<::test_cpp2::cpp_reflection::enum1> j2;
 private:
  ::std::vector<::test_cpp2::cpp_reflection::structA> j3;
 private:
  ::std::set<::std::int32_t> k;
 private:
  ::std::set<::std::int32_t> k1;
 private:
  ::std::set<::test_cpp2::cpp_reflection::enum2> k2;
 private:
  ::std::set<::test_cpp2::cpp_reflection::structB> k3;
 private:
  ::std::map<::std::int32_t, ::std::int32_t> l;
 private:
  ::std::map<::std::int32_t, ::std::int32_t> l1;
 private:
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> l2;
 private:
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> l3;
 private:
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> m1;
 private:
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> m2;
 private:
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> m3;
 private:
  ::std::map<::std::string, ::std::int32_t> n1;
 private:
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> n2;
 private:
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> n3;
 private:
  ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> o1;
 private:
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> o2;
 private:
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> o3;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool a;
    bool b;
    bool c;
    bool d;
    bool e;
    bool f;
    bool g;
    bool h;
    bool i;
    bool j;
    bool j1;
    bool j2;
    bool j3;
    bool k;
    bool k1;
    bool k2;
    bool k3;
    bool l;
    bool l1;
    bool l2;
    bool l3;
    bool m1;
    bool m2;
    bool m3;
    bool n1;
    bool n2;
    bool n3;
    bool o1;
    bool o2;
    bool o3;
  } __isset = {};

 public:

  bool operator==(const structC&) const;
  bool operator<(const structC&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_ref() const& {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_ref() const&& {
    return {std::move(this->a), __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_ref() & {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_ref() && {
    return {std::move(this->a), __isset.a};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> b_ref() const& {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> b_ref() const&& {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> b_ref() & {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> b_ref() && {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> c_ref() const& {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> c_ref() const&& {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> c_ref() & {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> c_ref() && {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> d_ref() const& {
    return {this->d, __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> d_ref() const&& {
    return {std::move(this->d), __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> d_ref() & {
    return {this->d, __isset.d};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> d_ref() && {
    return {std::move(this->d), __isset.d};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> e_ref() const& {
    return {this->e, __isset.e};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> e_ref() const&& {
    return {std::move(this->e), __isset.e};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> e_ref() & {
    return {this->e, __isset.e};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> e_ref() && {
    return {std::move(this->e), __isset.e};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> f_ref() const& {
    return {this->f, __isset.f};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> f_ref() const&& {
    return {std::move(this->f), __isset.f};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> f_ref() & {
    return {this->f, __isset.f};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> f_ref() && {
    return {std::move(this->f), __isset.f};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> g_ref() const& {
    return {this->g, __isset.g};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> g_ref() const&& {
    return {std::move(this->g), __isset.g};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> g_ref() & {
    return {this->g, __isset.g};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> g_ref() && {
    return {std::move(this->g), __isset.g};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> h_ref() const& {
    return {this->h, __isset.h};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> h_ref() const&& {
    return {std::move(this->h), __isset.h};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> h_ref() & {
    return {this->h, __isset.h};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> h_ref() && {
    return {std::move(this->h), __isset.h};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> i_ref() const& {
    return {this->i, __isset.i};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> i_ref() const&& {
    return {std::move(this->i), __isset.i};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> i_ref() & {
    return {this->i, __isset.i};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::unionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> i_ref() && {
    return {std::move(this->i), __isset.i};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> j_ref() const& {
    return {this->j, __isset.j};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> j_ref() const&& {
    return {std::move(this->j), __isset.j};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> j_ref() & {
    return {this->j, __isset.j};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> j_ref() && {
    return {std::move(this->j), __isset.j};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> j1_ref() const& {
    return {this->j1, __isset.j1};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> j1_ref() const&& {
    return {std::move(this->j1), __isset.j1};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> j1_ref() & {
    return {this->j1, __isset.j1};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> j1_ref() && {
    return {std::move(this->j1), __isset.j1};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> j2_ref() const& {
    return {this->j2, __isset.j2};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> j2_ref() const&& {
    return {std::move(this->j2), __isset.j2};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> j2_ref() & {
    return {this->j2, __isset.j2};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> j2_ref() && {
    return {std::move(this->j2), __isset.j2};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> j3_ref() const& {
    return {this->j3, __isset.j3};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> j3_ref() const&& {
    return {std::move(this->j3), __isset.j3};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> j3_ref() & {
    return {this->j3, __isset.j3};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> j3_ref() && {
    return {std::move(this->j3), __isset.j3};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> k_ref() const& {
    return {this->k, __isset.k};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> k_ref() const&& {
    return {std::move(this->k), __isset.k};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> k_ref() & {
    return {this->k, __isset.k};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> k_ref() && {
    return {std::move(this->k), __isset.k};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> k1_ref() const& {
    return {this->k1, __isset.k1};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> k1_ref() const&& {
    return {std::move(this->k1), __isset.k1};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> k1_ref() & {
    return {this->k1, __isset.k1};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> k1_ref() && {
    return {std::move(this->k1), __isset.k1};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> k2_ref() const& {
    return {this->k2, __isset.k2};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> k2_ref() const&& {
    return {std::move(this->k2), __isset.k2};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> k2_ref() & {
    return {this->k2, __isset.k2};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> k2_ref() && {
    return {std::move(this->k2), __isset.k2};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> k3_ref() const& {
    return {this->k3, __isset.k3};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> k3_ref() const&& {
    return {std::move(this->k3), __isset.k3};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> k3_ref() & {
    return {this->k3, __isset.k3};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> k3_ref() && {
    return {std::move(this->k3), __isset.k3};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> l_ref() const& {
    return {this->l, __isset.l};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> l_ref() const&& {
    return {std::move(this->l), __isset.l};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> l_ref() & {
    return {this->l, __isset.l};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> l_ref() && {
    return {std::move(this->l), __isset.l};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> l1_ref() const& {
    return {this->l1, __isset.l1};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> l1_ref() const&& {
    return {std::move(this->l1), __isset.l1};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> l1_ref() & {
    return {this->l1, __isset.l1};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> l1_ref() && {
    return {std::move(this->l1), __isset.l1};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> l2_ref() const& {
    return {this->l2, __isset.l2};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> l2_ref() const&& {
    return {std::move(this->l2), __isset.l2};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> l2_ref() & {
    return {this->l2, __isset.l2};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> l2_ref() && {
    return {std::move(this->l2), __isset.l2};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> l3_ref() const& {
    return {this->l3, __isset.l3};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> l3_ref() const&& {
    return {std::move(this->l3), __isset.l3};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> l3_ref() & {
    return {this->l3, __isset.l3};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> l3_ref() && {
    return {std::move(this->l3), __isset.l3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> m1_ref() const& {
    return {this->m1, __isset.m1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> m1_ref() const&& {
    return {std::move(this->m1), __isset.m1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> m1_ref() & {
    return {this->m1, __isset.m1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> m1_ref() && {
    return {std::move(this->m1), __isset.m1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> m2_ref() const& {
    return {this->m2, __isset.m2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> m2_ref() const&& {
    return {std::move(this->m2), __isset.m2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> m2_ref() & {
    return {this->m2, __isset.m2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> m2_ref() && {
    return {std::move(this->m2), __isset.m2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> m3_ref() const& {
    return {this->m3, __isset.m3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> m3_ref() const&& {
    return {std::move(this->m3), __isset.m3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> m3_ref() & {
    return {this->m3, __isset.m3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> m3_ref() && {
    return {std::move(this->m3), __isset.m3};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> n1_ref() const& {
    return {this->n1, __isset.n1};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> n1_ref() const&& {
    return {std::move(this->n1), __isset.n1};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> n1_ref() & {
    return {this->n1, __isset.n1};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> n1_ref() && {
    return {std::move(this->n1), __isset.n1};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> n2_ref() const& {
    return {this->n2, __isset.n2};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> n2_ref() const&& {
    return {std::move(this->n2), __isset.n2};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> n2_ref() & {
    return {this->n2, __isset.n2};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> n2_ref() && {
    return {std::move(this->n2), __isset.n2};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> n3_ref() const& {
    return {this->n3, __isset.n3};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> n3_ref() const&& {
    return {std::move(this->n3), __isset.n3};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> n3_ref() & {
    return {this->n3, __isset.n3};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> n3_ref() && {
    return {std::move(this->n3), __isset.n3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> o1_ref() const& {
    return {this->o1, __isset.o1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> o1_ref() const&& {
    return {std::move(this->o1), __isset.o1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> o1_ref() & {
    return {this->o1, __isset.o1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> o1_ref() && {
    return {std::move(this->o1), __isset.o1};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> o2_ref() const& {
    return {this->o2, __isset.o2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> o2_ref() const&& {
    return {std::move(this->o2), __isset.o2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> o2_ref() & {
    return {this->o2, __isset.o2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> o2_ref() && {
    return {std::move(this->o2), __isset.o2};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> o3_ref() const& {
    return {this->o3, __isset.o3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> o3_ref() const&& {
    return {std::move(this->o3), __isset.o3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> o3_ref() & {
    return {this->o3, __isset.o3};
  }

  template <typename..., typename T = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> o3_ref() && {
    return {std::move(this->o3), __isset.o3};
  }

  ::std::int32_t get_a() const {
    return a;
  }

  [[deprecated("Use `FOO.a_ref() = BAR;` instead of `FOO.set_a(BAR);`")]]
  ::std::int32_t& set_a(::std::int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  const ::std::string& get_b() const& {
    return b;
  }

  ::std::string get_b() && {
    return std::move(b);
  }

  template <typename T_structC_b_struct_setter = ::std::string>
  [[deprecated("Use `FOO.b_ref() = BAR;` instead of `FOO.set_b(BAR);`")]]
  ::std::string& set_b(T_structC_b_struct_setter&& b_) {
    b = std::forward<T_structC_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  double get_c() const {
    return c;
  }

  [[deprecated("Use `FOO.c_ref() = BAR;` instead of `FOO.set_c(BAR);`")]]
  double& set_c(double c_) {
    c = c_;
    __isset.c = true;
    return c;
  }

  bool get_d() const {
    return d;
  }

  [[deprecated("Use `FOO.d_ref() = BAR;` instead of `FOO.set_d(BAR);`")]]
  bool& set_d(bool d_) {
    d = d_;
    __isset.d = true;
    return d;
  }

  ::test_cpp2::cpp_reflection::enum1 get_e() const {
    return e;
  }

  [[deprecated("Use `FOO.e_ref() = BAR;` instead of `FOO.set_e(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_e(::test_cpp2::cpp_reflection::enum1 e_) {
    e = e_;
    __isset.e = true;
    return e;
  }

  ::test_cpp2::cpp_reflection::enum2 get_f() const {
    return f;
  }

  [[deprecated("Use `FOO.f_ref() = BAR;` instead of `FOO.set_f(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum2& set_f(::test_cpp2::cpp_reflection::enum2 f_) {
    f = f_;
    __isset.f = true;
    return f;
  }
  const ::test_cpp2::cpp_reflection::union1& get_g() const&;
  ::test_cpp2::cpp_reflection::union1 get_g() &&;

  template <typename T_structC_g_struct_setter = ::test_cpp2::cpp_reflection::union1>
  [[deprecated("Use `FOO.g_ref() = BAR;` instead of `FOO.set_g(BAR);`")]]
  ::test_cpp2::cpp_reflection::union1& set_g(T_structC_g_struct_setter&& g_) {
    g = std::forward<T_structC_g_struct_setter>(g_);
    __isset.g = true;
    return g;
  }
  const ::test_cpp2::cpp_reflection::unionA& get_h() const&;
  ::test_cpp2::cpp_reflection::unionA get_h() &&;

  template <typename T_structC_h_struct_setter = ::test_cpp2::cpp_reflection::unionA>
  [[deprecated("Use `FOO.h_ref() = BAR;` instead of `FOO.set_h(BAR);`")]]
  ::test_cpp2::cpp_reflection::unionA& set_h(T_structC_h_struct_setter&& h_) {
    h = std::forward<T_structC_h_struct_setter>(h_);
    __isset.h = true;
    return h;
  }
  const ::test_cpp2::cpp_reflection::unionA& get_i() const&;
  ::test_cpp2::cpp_reflection::unionA get_i() &&;

  template <typename T_structC_i_struct_setter = ::test_cpp2::cpp_reflection::unionA>
  [[deprecated("Use `FOO.i_ref() = BAR;` instead of `FOO.set_i(BAR);`")]]
  ::test_cpp2::cpp_reflection::unionA& set_i(T_structC_i_struct_setter&& i_) {
    i = std::forward<T_structC_i_struct_setter>(i_);
    __isset.i = true;
    return i;
  }
  const ::std::vector<::std::int32_t>& get_j() const&;
  ::std::vector<::std::int32_t> get_j() &&;

  template <typename T_structC_j_struct_setter = ::std::vector<::std::int32_t>>
  [[deprecated("Use `FOO.j_ref() = BAR;` instead of `FOO.set_j(BAR);`")]]
  ::std::vector<::std::int32_t>& set_j(T_structC_j_struct_setter&& j_) {
    j = std::forward<T_structC_j_struct_setter>(j_);
    __isset.j = true;
    return j;
  }
  const ::std::vector<::std::int32_t>& get_j1() const&;
  ::std::vector<::std::int32_t> get_j1() &&;

  template <typename T_structC_j1_struct_setter = ::std::vector<::std::int32_t>>
  [[deprecated("Use `FOO.j1_ref() = BAR;` instead of `FOO.set_j1(BAR);`")]]
  ::std::vector<::std::int32_t>& set_j1(T_structC_j1_struct_setter&& j1_) {
    j1 = std::forward<T_structC_j1_struct_setter>(j1_);
    __isset.j1 = true;
    return j1;
  }
  const ::std::vector<::test_cpp2::cpp_reflection::enum1>& get_j2() const&;
  ::std::vector<::test_cpp2::cpp_reflection::enum1> get_j2() &&;

  template <typename T_structC_j2_struct_setter = ::std::vector<::test_cpp2::cpp_reflection::enum1>>
  [[deprecated("Use `FOO.j2_ref() = BAR;` instead of `FOO.set_j2(BAR);`")]]
  ::std::vector<::test_cpp2::cpp_reflection::enum1>& set_j2(T_structC_j2_struct_setter&& j2_) {
    j2 = std::forward<T_structC_j2_struct_setter>(j2_);
    __isset.j2 = true;
    return j2;
  }
  const ::std::vector<::test_cpp2::cpp_reflection::structA>& get_j3() const&;
  ::std::vector<::test_cpp2::cpp_reflection::structA> get_j3() &&;

  template <typename T_structC_j3_struct_setter = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  [[deprecated("Use `FOO.j3_ref() = BAR;` instead of `FOO.set_j3(BAR);`")]]
  ::std::vector<::test_cpp2::cpp_reflection::structA>& set_j3(T_structC_j3_struct_setter&& j3_) {
    j3 = std::forward<T_structC_j3_struct_setter>(j3_);
    __isset.j3 = true;
    return j3;
  }
  const ::std::set<::std::int32_t>& get_k() const&;
  ::std::set<::std::int32_t> get_k() &&;

  template <typename T_structC_k_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.k_ref() = BAR;` instead of `FOO.set_k(BAR);`")]]
  ::std::set<::std::int32_t>& set_k(T_structC_k_struct_setter&& k_) {
    k = std::forward<T_structC_k_struct_setter>(k_);
    __isset.k = true;
    return k;
  }
  const ::std::set<::std::int32_t>& get_k1() const&;
  ::std::set<::std::int32_t> get_k1() &&;

  template <typename T_structC_k1_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.k1_ref() = BAR;` instead of `FOO.set_k1(BAR);`")]]
  ::std::set<::std::int32_t>& set_k1(T_structC_k1_struct_setter&& k1_) {
    k1 = std::forward<T_structC_k1_struct_setter>(k1_);
    __isset.k1 = true;
    return k1;
  }
  const ::std::set<::test_cpp2::cpp_reflection::enum2>& get_k2() const&;
  ::std::set<::test_cpp2::cpp_reflection::enum2> get_k2() &&;

  template <typename T_structC_k2_struct_setter = ::std::set<::test_cpp2::cpp_reflection::enum2>>
  [[deprecated("Use `FOO.k2_ref() = BAR;` instead of `FOO.set_k2(BAR);`")]]
  ::std::set<::test_cpp2::cpp_reflection::enum2>& set_k2(T_structC_k2_struct_setter&& k2_) {
    k2 = std::forward<T_structC_k2_struct_setter>(k2_);
    __isset.k2 = true;
    return k2;
  }
  const ::std::set<::test_cpp2::cpp_reflection::structB>& get_k3() const&;
  ::std::set<::test_cpp2::cpp_reflection::structB> get_k3() &&;

  template <typename T_structC_k3_struct_setter = ::std::set<::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.k3_ref() = BAR;` instead of `FOO.set_k3(BAR);`")]]
  ::std::set<::test_cpp2::cpp_reflection::structB>& set_k3(T_structC_k3_struct_setter&& k3_) {
    k3 = std::forward<T_structC_k3_struct_setter>(k3_);
    __isset.k3 = true;
    return k3;
  }
  const ::std::map<::std::int32_t, ::std::int32_t>& get_l() const&;
  ::std::map<::std::int32_t, ::std::int32_t> get_l() &&;

  template <typename T_structC_l_struct_setter = ::std::map<::std::int32_t, ::std::int32_t>>
  [[deprecated("Use `FOO.l_ref() = BAR;` instead of `FOO.set_l(BAR);`")]]
  ::std::map<::std::int32_t, ::std::int32_t>& set_l(T_structC_l_struct_setter&& l_) {
    l = std::forward<T_structC_l_struct_setter>(l_);
    __isset.l = true;
    return l;
  }
  const ::std::map<::std::int32_t, ::std::int32_t>& get_l1() const&;
  ::std::map<::std::int32_t, ::std::int32_t> get_l1() &&;

  template <typename T_structC_l1_struct_setter = ::std::map<::std::int32_t, ::std::int32_t>>
  [[deprecated("Use `FOO.l1_ref() = BAR;` instead of `FOO.set_l1(BAR);`")]]
  ::std::map<::std::int32_t, ::std::int32_t>& set_l1(T_structC_l1_struct_setter&& l1_) {
    l1 = std::forward<T_structC_l1_struct_setter>(l1_);
    __isset.l1 = true;
    return l1;
  }
  const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>& get_l2() const&;
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> get_l2() &&;

  template <typename T_structC_l2_struct_setter = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>>
  [[deprecated("Use `FOO.l2_ref() = BAR;` instead of `FOO.set_l2(BAR);`")]]
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>& set_l2(T_structC_l2_struct_setter&& l2_) {
    l2 = std::forward<T_structC_l2_struct_setter>(l2_);
    __isset.l2 = true;
    return l2;
  }
  const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>& get_l3() const&;
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> get_l3() &&;

  template <typename T_structC_l3_struct_setter = ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.l3_ref() = BAR;` instead of `FOO.set_l3(BAR);`")]]
  ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>& set_l3(T_structC_l3_struct_setter&& l3_) {
    l3 = std::forward<T_structC_l3_struct_setter>(l3_);
    __isset.l3 = true;
    return l3;
  }
  const ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>& get_m1() const&;
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> get_m1() &&;

  template <typename T_structC_m1_struct_setter = ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>>
  [[deprecated("Use `FOO.m1_ref() = BAR;` instead of `FOO.set_m1(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>& set_m1(T_structC_m1_struct_setter&& m1_) {
    m1 = std::forward<T_structC_m1_struct_setter>(m1_);
    __isset.m1 = true;
    return m1;
  }
  const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>& get_m2() const&;
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> get_m2() &&;

  template <typename T_structC_m2_struct_setter = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>>
  [[deprecated("Use `FOO.m2_ref() = BAR;` instead of `FOO.set_m2(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>& set_m2(T_structC_m2_struct_setter&& m2_) {
    m2 = std::forward<T_structC_m2_struct_setter>(m2_);
    __isset.m2 = true;
    return m2;
  }
  const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>& get_m3() const&;
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> get_m3() &&;

  template <typename T_structC_m3_struct_setter = ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.m3_ref() = BAR;` instead of `FOO.set_m3(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>& set_m3(T_structC_m3_struct_setter&& m3_) {
    m3 = std::forward<T_structC_m3_struct_setter>(m3_);
    __isset.m3 = true;
    return m3;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_n1() const&;
  ::std::map<::std::string, ::std::int32_t> get_n1() &&;

  template <typename T_structC_n1_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.n1_ref() = BAR;` instead of `FOO.set_n1(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_n1(T_structC_n1_struct_setter&& n1_) {
    n1 = std::forward<T_structC_n1_struct_setter>(n1_);
    __isset.n1 = true;
    return n1;
  }
  const ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>& get_n2() const&;
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> get_n2() &&;

  template <typename T_structC_n2_struct_setter = ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>>
  [[deprecated("Use `FOO.n2_ref() = BAR;` instead of `FOO.set_n2(BAR);`")]]
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>& set_n2(T_structC_n2_struct_setter&& n2_) {
    n2 = std::forward<T_structC_n2_struct_setter>(n2_);
    __isset.n2 = true;
    return n2;
  }
  const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& get_n3() const&;
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> get_n3() &&;

  template <typename T_structC_n3_struct_setter = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.n3_ref() = BAR;` instead of `FOO.set_n3(BAR);`")]]
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& set_n3(T_structC_n3_struct_setter&& n3_) {
    n3 = std::forward<T_structC_n3_struct_setter>(n3_);
    __isset.n3 = true;
    return n3;
  }
  const ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>& get_o1() const&;
  ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> get_o1() &&;

  template <typename T_structC_o1_struct_setter = ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>
  [[deprecated("Use `FOO.o1_ref() = BAR;` instead of `FOO.set_o1(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>& set_o1(T_structC_o1_struct_setter&& o1_) {
    o1 = std::forward<T_structC_o1_struct_setter>(o1_);
    __isset.o1 = true;
    return o1;
  }
  const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>& get_o2() const&;
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> get_o2() &&;

  template <typename T_structC_o2_struct_setter = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>
  [[deprecated("Use `FOO.o2_ref() = BAR;` instead of `FOO.set_o2(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>& set_o2(T_structC_o2_struct_setter&& o2_) {
    o2 = std::forward<T_structC_o2_struct_setter>(o2_);
    __isset.o2 = true;
    return o2;
  }
  const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>& get_o3() const&;
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> get_o3() &&;

  template <typename T_structC_o3_struct_setter = ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.o3_ref() = BAR;` instead of `FOO.set_o3(BAR);`")]]
  ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>& set_o3(T_structC_o3_struct_setter&& o3_) {
    o3 = std::forward<T_structC_o3_struct_setter>(o3_);
    __isset.o3 = true;
    return o3;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<structC>;
  friend void swap(structC& a, structC& b);
};

template <class Protocol_>
uint32_t structC::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct1 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct1;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct1();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct1(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::enum2 field3__arg, ::test_cpp2::cpp_reflection::union1 field4__arg, ::test_cpp2::cpp_reflection::union2 field5__arg);

  struct1(struct1&&) noexcept;

  struct1(const struct1& src);


  struct1& operator=(struct1&&) noexcept;
  struct1& operator=(const struct1& src);
  void __clear();

  ~struct1();

 public:
  ::std::int32_t field0;
 private:
  ::std::string field1;
 private:
  ::test_cpp2::cpp_reflection::enum1 field2;
 public:
  ::test_cpp2::cpp_reflection::enum2 field3;
 private:
  ::test_cpp2::cpp_reflection::union1 field4;
 private:
  ::test_cpp2::cpp_reflection::union2 field5;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool field1;
    bool field2;
    bool field4;
    bool field5;
  } __isset = {};

 public:

  bool operator==(const struct1&) const;
  bool operator<(const struct1&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> field0_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> field0_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> field0_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> field0_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> field1_ref() const& {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> field1_ref() const&& {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> field1_ref() & {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> field1_ref() && {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field2_ref() const& {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field2_ref() const&& {
    return {std::move(this->field2), __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field2_ref() & {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field2_ref() && {
    return {std::move(this->field2), __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> field3_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> field3_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->field3)};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> field3_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> field3_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->field3)};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> field4_ref() const& {
    return {this->field4, __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> field4_ref() const&& {
    return {std::move(this->field4), __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> field4_ref() & {
    return {this->field4, __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> field4_ref() && {
    return {std::move(this->field4), __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field5_ref() const& {
    return {this->field5, __isset.field5};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field5_ref() const&& {
    return {std::move(this->field5), __isset.field5};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field5_ref() & {
    return {this->field5, __isset.field5};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field5_ref() && {
    return {std::move(this->field5), __isset.field5};
  }

  ::std::int32_t get_field0() const {
    return field0;
  }

  [[deprecated("Use `FOO.field0_ref() = BAR;` instead of `FOO.set_field0(BAR);`")]]
  ::std::int32_t& set_field0(::std::int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct1_field1_struct_setter = ::std::string>
  [[deprecated("Use `FOO.field1_ref() = BAR;` instead of `FOO.set_field1(BAR);`")]]
  ::std::string& set_field1(T_struct1_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct1_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

  ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

  [[deprecated("Use `FOO.field2_ref() = BAR;` instead of `FOO.set_field2(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_field2(::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }

  ::test_cpp2::cpp_reflection::enum2 get_field3() const {
    return field3;
  }

  [[deprecated("Use `FOO.field3_ref() = BAR;` instead of `FOO.set_field3(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum2& set_field3(::test_cpp2::cpp_reflection::enum2 field3_) {
    field3 = field3_;
    return field3;
  }
  const ::test_cpp2::cpp_reflection::union1* get_field4() const&;
  ::test_cpp2::cpp_reflection::union1* get_field4() &;
  ::test_cpp2::cpp_reflection::union1* get_field4() && = delete;

  template <typename T_struct1_field4_struct_setter = ::test_cpp2::cpp_reflection::union1>
  [[deprecated("Use `FOO.field4_ref() = BAR;` instead of `FOO.set_field4(BAR);`")]]
  ::test_cpp2::cpp_reflection::union1& set_field4(T_struct1_field4_struct_setter&& field4_) {
    field4 = std::forward<T_struct1_field4_struct_setter>(field4_);
    __isset.field4 = true;
    return field4;
  }
  const ::test_cpp2::cpp_reflection::union2& get_field5() const&;
  ::test_cpp2::cpp_reflection::union2 get_field5() &&;

  template <typename T_struct1_field5_struct_setter = ::test_cpp2::cpp_reflection::union2>
  [[deprecated("Use `FOO.field5_ref() = BAR;` instead of `FOO.set_field5(BAR);`")]]
  ::test_cpp2::cpp_reflection::union2& set_field5(T_struct1_field5_struct_setter&& field5_) {
    field5 = std::forward<T_struct1_field5_struct_setter>(field5_);
    __isset.field5 = true;
    return field5;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct1>;
  friend void swap(struct1& a, struct1& b);
};

template <class Protocol_>
uint32_t struct1::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct2 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct2;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct2();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct2(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg);

  struct2(struct2&&) noexcept;

  struct2(const struct2& src);


  struct2& operator=(struct2&&) noexcept;
  struct2& operator=(const struct2& src);
  void __clear();

  ~struct2();

 private:
  ::std::int32_t fieldA;
 private:
  ::std::string fieldB;
 private:
  ::test_cpp2::cpp_reflection::enum1 fieldC;
 private:
  ::test_cpp2::cpp_reflection::enum2 fieldD;
 private:
  ::test_cpp2::cpp_reflection::union1 fieldE;
 private:
  ::test_cpp2::cpp_reflection::union2 fieldF;
 private:
  ::test_cpp2::cpp_reflection::struct1 fieldG;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
  } __isset = {};

 public:

  bool operator==(const struct2&) const;
  bool operator<(const struct2&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldA_ref() const& {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldA_ref() const&& {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldA_ref() & {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldA_ref() && {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldB_ref() const& {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldB_ref() const&& {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldB_ref() & {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldB_ref() && {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldC_ref() const& {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldC_ref() const&& {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldC_ref() & {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldC_ref() && {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldD_ref() const& {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldD_ref() const&& {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldD_ref() & {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldD_ref() && {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldE_ref() const& {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldE_ref() const&& {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldE_ref() & {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldE_ref() && {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldF_ref() const& {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldF_ref() const&& {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldF_ref() & {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldF_ref() && {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldG_ref() const& {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldG_ref() const&& {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldG_ref() & {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldG_ref() && {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  ::std::int32_t get_fieldA() const {
    return fieldA;
  }

  [[deprecated("Use `FOO.fieldA_ref() = BAR;` instead of `FOO.set_fieldA(BAR);`")]]
  ::std::int32_t& set_fieldA(::std::int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  const ::std::string& get_fieldB() const& {
    return fieldB;
  }

  ::std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T_struct2_fieldB_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldB_ref() = BAR;` instead of `FOO.set_fieldB(BAR);`")]]
  ::std::string& set_fieldB(T_struct2_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_struct2_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }

  ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

  [[deprecated("Use `FOO.fieldC_ref() = BAR;` instead of `FOO.set_fieldC(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_fieldC(::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
    return fieldC;
  }

  ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

  [[deprecated("Use `FOO.fieldD_ref() = BAR;` instead of `FOO.set_fieldD(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum2& set_fieldD(::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
    return fieldD;
  }
  const ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
  ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;

  template <typename T_struct2_fieldE_struct_setter = ::test_cpp2::cpp_reflection::union1>
  [[deprecated("Use `FOO.fieldE_ref() = BAR;` instead of `FOO.set_fieldE(BAR);`")]]
  ::test_cpp2::cpp_reflection::union1& set_fieldE(T_struct2_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_struct2_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
  ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;

  template <typename T_struct2_fieldF_struct_setter = ::test_cpp2::cpp_reflection::union2>
  [[deprecated("Use `FOO.fieldF_ref() = BAR;` instead of `FOO.set_fieldF(BAR);`")]]
  ::test_cpp2::cpp_reflection::union2& set_fieldF(T_struct2_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_struct2_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
  ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;

  template <typename T_struct2_fieldG_struct_setter = ::test_cpp2::cpp_reflection::struct1>
  [[deprecated("Use `FOO.fieldG_ref() = BAR;` instead of `FOO.set_fieldG(BAR);`")]]
  ::test_cpp2::cpp_reflection::struct1& set_fieldG(T_struct2_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_struct2_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct2>;
  friend void swap(struct2& a, struct2& b);
};

template <class Protocol_>
uint32_t struct2::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct3 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct3;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct3();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct3(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg, ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<::std::int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<::std::int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set<::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> fieldR__arg);

  struct3(struct3&&) noexcept;

  struct3(const struct3& src);


  struct3& operator=(struct3&&) noexcept;
  struct3& operator=(const struct3& src);
  void __clear();

  ~struct3();

 private:
  ::std::int32_t fieldA;
 private:
  ::std::string fieldB;
 private:
  ::test_cpp2::cpp_reflection::enum1 fieldC;
 private:
  ::test_cpp2::cpp_reflection::enum2 fieldD;
 private:
  ::test_cpp2::cpp_reflection::union1 fieldE;
 private:
  ::test_cpp2::cpp_reflection::union2 fieldF;
 private:
  ::test_cpp2::cpp_reflection::struct1 fieldG;
 private:
  ::test_cpp2::cpp_reflection::union2 fieldH;
 private:
  ::std::vector<::std::int32_t> fieldI;
 private:
  ::std::vector<::std::string> fieldJ;
 private:
  ::std::vector<::std::string> fieldK;
 private:
  ::std::vector<::test_cpp2::cpp_reflection::structA> fieldL;
 private:
  ::std::set<::std::int32_t> fieldM;
 private:
  ::std::set<::std::string> fieldN;
 private:
  ::std::set<::std::string> fieldO;
 private:
  ::std::set<::test_cpp2::cpp_reflection::structB> fieldP;
 private:
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> fieldQ;
 private:
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> fieldR;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
  } __isset = {};

 public:

  bool operator==(const struct3&) const;
  bool operator<(const struct3&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldA_ref() const& {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldA_ref() const&& {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldA_ref() & {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldA_ref() && {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldB_ref() const& {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldB_ref() const&& {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldB_ref() & {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldB_ref() && {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldC_ref() const& {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldC_ref() const&& {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldC_ref() & {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldC_ref() && {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldD_ref() const& {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldD_ref() const&& {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldD_ref() & {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldD_ref() && {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldE_ref() const& {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldE_ref() const&& {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldE_ref() & {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldE_ref() && {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldF_ref() const& {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldF_ref() const&& {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldF_ref() & {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldF_ref() && {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldG_ref() const& {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldG_ref() const&& {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldG_ref() & {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::struct1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldG_ref() && {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldH_ref() const& {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldH_ref() const&& {
    return {std::move(this->fieldH), __isset.fieldH};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldH_ref() & {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::union2>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldH_ref() && {
    return {std::move(this->fieldH), __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldI_ref() const& {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldI_ref() const&& {
    return {std::move(this->fieldI), __isset.fieldI};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldI_ref() & {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldI_ref() && {
    return {std::move(this->fieldI), __isset.fieldI};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldJ_ref() const& {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldJ_ref() const&& {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldJ_ref() & {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldJ_ref() && {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldK_ref() const& {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldK_ref() const&& {
    return {std::move(this->fieldK), __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldK_ref() & {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldK_ref() && {
    return {std::move(this->fieldK), __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldL_ref() const& {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldL_ref() const&& {
    return {std::move(this->fieldL), __isset.fieldL};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldL_ref() & {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldL_ref() && {
    return {std::move(this->fieldL), __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldM_ref() const& {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldM_ref() const&& {
    return {std::move(this->fieldM), __isset.fieldM};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldM_ref() & {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldM_ref() && {
    return {std::move(this->fieldM), __isset.fieldM};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldN_ref() const& {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldN_ref() const&& {
    return {std::move(this->fieldN), __isset.fieldN};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldN_ref() & {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldN_ref() && {
    return {std::move(this->fieldN), __isset.fieldN};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldO_ref() const& {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldO_ref() const&& {
    return {std::move(this->fieldO), __isset.fieldO};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldO_ref() & {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T = ::std::set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldO_ref() && {
    return {std::move(this->fieldO), __isset.fieldO};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldP_ref() const& {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldP_ref() const&& {
    return {std::move(this->fieldP), __isset.fieldP};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldP_ref() & {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::set<::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldP_ref() && {
    return {std::move(this->fieldP), __isset.fieldP};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldQ_ref() const& {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldQ_ref() const&& {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldQ_ref() & {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldQ_ref() && {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldR_ref() const& {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldR_ref() const&& {
    return {std::move(this->fieldR), __isset.fieldR};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldR_ref() & {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldR_ref() && {
    return {std::move(this->fieldR), __isset.fieldR};
  }

  ::std::int32_t get_fieldA() const {
    return fieldA;
  }

  [[deprecated("Use `FOO.fieldA_ref() = BAR;` instead of `FOO.set_fieldA(BAR);`")]]
  ::std::int32_t& set_fieldA(::std::int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  const ::std::string& get_fieldB() const& {
    return fieldB;
  }

  ::std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T_struct3_fieldB_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldB_ref() = BAR;` instead of `FOO.set_fieldB(BAR);`")]]
  ::std::string& set_fieldB(T_struct3_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_struct3_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }

  ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

  [[deprecated("Use `FOO.fieldC_ref() = BAR;` instead of `FOO.set_fieldC(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_fieldC(::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
    return fieldC;
  }

  ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

  [[deprecated("Use `FOO.fieldD_ref() = BAR;` instead of `FOO.set_fieldD(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum2& set_fieldD(::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
    return fieldD;
  }
  const ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
  ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;

  template <typename T_struct3_fieldE_struct_setter = ::test_cpp2::cpp_reflection::union1>
  [[deprecated("Use `FOO.fieldE_ref() = BAR;` instead of `FOO.set_fieldE(BAR);`")]]
  ::test_cpp2::cpp_reflection::union1& set_fieldE(T_struct3_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_struct3_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
  ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;

  template <typename T_struct3_fieldF_struct_setter = ::test_cpp2::cpp_reflection::union2>
  [[deprecated("Use `FOO.fieldF_ref() = BAR;` instead of `FOO.set_fieldF(BAR);`")]]
  ::test_cpp2::cpp_reflection::union2& set_fieldF(T_struct3_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_struct3_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
  ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;

  template <typename T_struct3_fieldG_struct_setter = ::test_cpp2::cpp_reflection::struct1>
  [[deprecated("Use `FOO.fieldG_ref() = BAR;` instead of `FOO.set_fieldG(BAR);`")]]
  ::test_cpp2::cpp_reflection::struct1& set_fieldG(T_struct3_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_struct3_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const ::test_cpp2::cpp_reflection::union2& get_fieldH() const&;
  ::test_cpp2::cpp_reflection::union2 get_fieldH() &&;

  template <typename T_struct3_fieldH_struct_setter = ::test_cpp2::cpp_reflection::union2>
  [[deprecated("Use `FOO.fieldH_ref() = BAR;` instead of `FOO.set_fieldH(BAR);`")]]
  ::test_cpp2::cpp_reflection::union2& set_fieldH(T_struct3_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_struct3_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }
  const ::std::vector<::std::int32_t>& get_fieldI() const&;
  ::std::vector<::std::int32_t> get_fieldI() &&;

  template <typename T_struct3_fieldI_struct_setter = ::std::vector<::std::int32_t>>
  [[deprecated("Use `FOO.fieldI_ref() = BAR;` instead of `FOO.set_fieldI(BAR);`")]]
  ::std::vector<::std::int32_t>& set_fieldI(T_struct3_fieldI_struct_setter&& fieldI_) {
    fieldI = std::forward<T_struct3_fieldI_struct_setter>(fieldI_);
    __isset.fieldI = true;
    return fieldI;
  }
  const ::std::vector<::std::string>& get_fieldJ() const&;
  ::std::vector<::std::string> get_fieldJ() &&;

  template <typename T_struct3_fieldJ_struct_setter = ::std::vector<::std::string>>
  [[deprecated("Use `FOO.fieldJ_ref() = BAR;` instead of `FOO.set_fieldJ(BAR);`")]]
  ::std::vector<::std::string>& set_fieldJ(T_struct3_fieldJ_struct_setter&& fieldJ_) {
    fieldJ = std::forward<T_struct3_fieldJ_struct_setter>(fieldJ_);
    __isset.fieldJ = true;
    return fieldJ;
  }
  const ::std::vector<::std::string>& get_fieldK() const&;
  ::std::vector<::std::string> get_fieldK() &&;

  template <typename T_struct3_fieldK_struct_setter = ::std::vector<::std::string>>
  [[deprecated("Use `FOO.fieldK_ref() = BAR;` instead of `FOO.set_fieldK(BAR);`")]]
  ::std::vector<::std::string>& set_fieldK(T_struct3_fieldK_struct_setter&& fieldK_) {
    fieldK = std::forward<T_struct3_fieldK_struct_setter>(fieldK_);
    __isset.fieldK = true;
    return fieldK;
  }
  const ::std::vector<::test_cpp2::cpp_reflection::structA>& get_fieldL() const&;
  ::std::vector<::test_cpp2::cpp_reflection::structA> get_fieldL() &&;

  template <typename T_struct3_fieldL_struct_setter = ::std::vector<::test_cpp2::cpp_reflection::structA>>
  [[deprecated("Use `FOO.fieldL_ref() = BAR;` instead of `FOO.set_fieldL(BAR);`")]]
  ::std::vector<::test_cpp2::cpp_reflection::structA>& set_fieldL(T_struct3_fieldL_struct_setter&& fieldL_) {
    fieldL = std::forward<T_struct3_fieldL_struct_setter>(fieldL_);
    __isset.fieldL = true;
    return fieldL;
  }
  const ::std::set<::std::int32_t>& get_fieldM() const&;
  ::std::set<::std::int32_t> get_fieldM() &&;

  template <typename T_struct3_fieldM_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.fieldM_ref() = BAR;` instead of `FOO.set_fieldM(BAR);`")]]
  ::std::set<::std::int32_t>& set_fieldM(T_struct3_fieldM_struct_setter&& fieldM_) {
    fieldM = std::forward<T_struct3_fieldM_struct_setter>(fieldM_);
    __isset.fieldM = true;
    return fieldM;
  }
  const ::std::set<::std::string>& get_fieldN() const&;
  ::std::set<::std::string> get_fieldN() &&;

  template <typename T_struct3_fieldN_struct_setter = ::std::set<::std::string>>
  [[deprecated("Use `FOO.fieldN_ref() = BAR;` instead of `FOO.set_fieldN(BAR);`")]]
  ::std::set<::std::string>& set_fieldN(T_struct3_fieldN_struct_setter&& fieldN_) {
    fieldN = std::forward<T_struct3_fieldN_struct_setter>(fieldN_);
    __isset.fieldN = true;
    return fieldN;
  }
  const ::std::set<::std::string>& get_fieldO() const&;
  ::std::set<::std::string> get_fieldO() &&;

  template <typename T_struct3_fieldO_struct_setter = ::std::set<::std::string>>
  [[deprecated("Use `FOO.fieldO_ref() = BAR;` instead of `FOO.set_fieldO(BAR);`")]]
  ::std::set<::std::string>& set_fieldO(T_struct3_fieldO_struct_setter&& fieldO_) {
    fieldO = std::forward<T_struct3_fieldO_struct_setter>(fieldO_);
    __isset.fieldO = true;
    return fieldO;
  }
  const ::std::set<::test_cpp2::cpp_reflection::structB>& get_fieldP() const&;
  ::std::set<::test_cpp2::cpp_reflection::structB> get_fieldP() &&;

  template <typename T_struct3_fieldP_struct_setter = ::std::set<::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.fieldP_ref() = BAR;` instead of `FOO.set_fieldP(BAR);`")]]
  ::std::set<::test_cpp2::cpp_reflection::structB>& set_fieldP(T_struct3_fieldP_struct_setter&& fieldP_) {
    fieldP = std::forward<T_struct3_fieldP_struct_setter>(fieldP_);
    __isset.fieldP = true;
    return fieldP;
  }
  const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>& get_fieldQ() const&;
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> get_fieldQ() &&;

  template <typename T_struct3_fieldQ_struct_setter = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>
  [[deprecated("Use `FOO.fieldQ_ref() = BAR;` instead of `FOO.set_fieldQ(BAR);`")]]
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>& set_fieldQ(T_struct3_fieldQ_struct_setter&& fieldQ_) {
    fieldQ = std::forward<T_struct3_fieldQ_struct_setter>(fieldQ_);
    __isset.fieldQ = true;
    return fieldQ;
  }
  const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& get_fieldR() const&;
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> get_fieldR() &&;

  template <typename T_struct3_fieldR_struct_setter = ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>
  [[deprecated("Use `FOO.fieldR_ref() = BAR;` instead of `FOO.set_fieldR(BAR);`")]]
  ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& set_fieldR(T_struct3_fieldR_struct_setter&& fieldR_) {
    fieldR = std::forward<T_struct3_fieldR_struct_setter>(fieldR_);
    __isset.fieldR = true;
    return fieldR;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct3>;
  friend void swap(struct3& a, struct3& b);
};

template <class Protocol_>
uint32_t struct3::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct4 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct4;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct4() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0),
      field3(std::make_unique<::test_cpp2::cpp_reflection::structA>()) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct4(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::std::unique_ptr<::test_cpp2::cpp_reflection::structA> field3__arg);

  struct4(struct4&&) noexcept;
  struct4(const struct4& src);


  struct4& operator=(struct4&&) noexcept;
  struct4& operator=(const struct4& src);
  void __clear();
 public:
  ::std::int32_t field0;
 private:
  ::std::string field1;
 private:
  ::test_cpp2::cpp_reflection::enum1 field2;
 public:
  ::std::unique_ptr<::test_cpp2::cpp_reflection::structA> field3;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool field1;
    bool field2;
  } __isset = {};

 public:

  bool operator==(const struct4&) const;
  bool operator<(const struct4&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> field0_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> field0_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> field0_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> field0_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> field1_ref() const& {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> field1_ref() const&& {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> field1_ref() & {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> field1_ref() && {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field2_ref() const& {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field2_ref() const&& {
    return {std::move(this->field2), __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field2_ref() & {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field2_ref() && {
    return {std::move(this->field2), __isset.field2};
  }
  template <typename ..., typename T = ::std::unique_ptr<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE T& field3_ref() & { return field3; }

  template <typename ..., typename T = ::std::unique_ptr<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE const T& field3_ref() const& { return field3; }

  template <typename ..., typename T = ::std::unique_ptr<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE T&& field3_ref() && { return std::move(field3); }

  template <typename ..., typename T = ::std::unique_ptr<::test_cpp2::cpp_reflection::structA>>
  FOLLY_ERASE const T&& field3_ref() const&& { return std::move(field3); }

  ::std::int32_t get_field0() const {
    return field0;
  }

  [[deprecated("Use `FOO.field0_ref() = BAR;` instead of `FOO.set_field0(BAR);`")]]
  ::std::int32_t& set_field0(::std::int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct4_field1_struct_setter = ::std::string>
  [[deprecated("Use `FOO.field1_ref() = BAR;` instead of `FOO.set_field1(BAR);`")]]
  ::std::string& set_field1(T_struct4_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct4_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

  ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

  [[deprecated("Use `FOO.field2_ref() = BAR;` instead of `FOO.set_field2(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_field2(::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct4>;
  friend void swap(struct4& a, struct4& b);
};

template <class Protocol_>
uint32_t struct4::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct5 final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct5;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct5();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct5(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::structA field3__arg, ::test_cpp2::cpp_reflection::structB field4__arg);

  struct5(struct5&&) noexcept;

  struct5(const struct5& src);


  struct5& operator=(struct5&&) noexcept;
  struct5& operator=(const struct5& src);
  void __clear();

  ~struct5();

 public:
  ::std::int32_t field0;
 private:
  ::std::string field1;
 private:
  ::test_cpp2::cpp_reflection::enum1 field2;
 private:
  ::test_cpp2::cpp_reflection::structA field3;
 private:
  ::test_cpp2::cpp_reflection::structB field4;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool field1;
    bool field2;
    bool field3;
    bool field4;
  } __isset = {};

 public:

  bool operator==(const struct5&) const;
  bool operator<(const struct5&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> field0_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> field0_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> field0_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->field0};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> field0_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->field0)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> field1_ref() const& {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> field1_ref() const&& {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> field1_ref() & {
    return {this->field1, __isset.field1};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> field1_ref() && {
    return {std::move(this->field1), __isset.field1};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field2_ref() const& {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field2_ref() const&& {
    return {std::move(this->field2), __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field2_ref() & {
    return {this->field2, __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::enum1>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field2_ref() && {
    return {std::move(this->field2), __isset.field2};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field3_ref() const& {
    return {this->field3, __isset.field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field3_ref() const&& {
    return {std::move(this->field3), __isset.field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field3_ref() & {
    return {this->field3, __isset.field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field3_ref() && {
    return {std::move(this->field3), __isset.field3};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field4_ref() const& {
    return {this->field4, __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field4_ref() const&& {
    return {std::move(this->field4), __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field4_ref() & {
    return {this->field4, __isset.field4};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::structB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field4_ref() && {
    return {std::move(this->field4), __isset.field4};
  }

  ::std::int32_t get_field0() const {
    return field0;
  }

  [[deprecated("Use `FOO.field0_ref() = BAR;` instead of `FOO.set_field0(BAR);`")]]
  ::std::int32_t& set_field0(::std::int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return field1_ref() ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct5_field1_struct_setter = ::std::string>
  [[deprecated("Use `FOO.field1_ref() = BAR;` instead of `FOO.set_field1(BAR);`")]]
  ::std::string& set_field1(T_struct5_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct5_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

  ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

  [[deprecated("Use `FOO.field2_ref() = BAR;` instead of `FOO.set_field2(BAR);`")]]
  ::test_cpp2::cpp_reflection::enum1& set_field2(::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }
  const ::test_cpp2::cpp_reflection::structA& get_field3() const&;
  ::test_cpp2::cpp_reflection::structA get_field3() &&;

  template <typename T_struct5_field3_struct_setter = ::test_cpp2::cpp_reflection::structA>
  [[deprecated("Use `FOO.field3_ref() = BAR;` instead of `FOO.set_field3(BAR);`")]]
  ::test_cpp2::cpp_reflection::structA& set_field3(T_struct5_field3_struct_setter&& field3_) {
    field3 = std::forward<T_struct5_field3_struct_setter>(field3_);
    __isset.field3 = true;
    return field3;
  }
  const ::test_cpp2::cpp_reflection::structB& get_field4() const&;
  ::test_cpp2::cpp_reflection::structB get_field4() &&;

  template <typename T_struct5_field4_struct_setter = ::test_cpp2::cpp_reflection::structB>
  [[deprecated("Use `FOO.field4_ref() = BAR;` instead of `FOO.set_field4(BAR);`")]]
  ::test_cpp2::cpp_reflection::structB& set_field4(T_struct5_field4_struct_setter&& field4_) {
    field4 = std::forward<T_struct5_field4_struct_setter>(field4_);
    __isset.field4 = true;
    return field4;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct5>;
  friend void swap(struct5& a, struct5& b);
};

template <class Protocol_>
uint32_t struct5::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct_binary final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct_binary;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct_binary() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg);

  struct_binary(struct_binary&&) noexcept;

  struct_binary(const struct_binary& src);


  struct_binary& operator=(struct_binary&&) noexcept;
  struct_binary& operator=(const struct_binary& src);
  void __clear();
 private:
  ::std::string bi;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool bi;
  } __isset = {};

 public:

  bool operator==(const struct_binary&) const;
  bool operator<(const struct_binary&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> bi_ref() const& {
    return {this->bi, __isset.bi};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> bi_ref() const&& {
    return {std::move(this->bi), __isset.bi};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> bi_ref() & {
    return {this->bi, __isset.bi};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> bi_ref() && {
    return {std::move(this->bi), __isset.bi};
  }

  const ::std::string& get_bi() const& {
    return bi;
  }

  ::std::string get_bi() && {
    return std::move(bi);
  }

  template <typename T_struct_binary_bi_struct_setter = ::std::string>
  [[deprecated("Use `FOO.bi_ref() = BAR;` instead of `FOO.set_bi(BAR);`")]]
  ::std::string& set_bi(T_struct_binary_bi_struct_setter&& bi_) {
    bi = std::forward<T_struct_binary_bi_struct_setter>(bi_);
    __isset.bi = true;
    return bi;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct_binary>;
  friend void swap(struct_binary& a, struct_binary& b);
};

template <class Protocol_>
uint32_t struct_binary::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class dep_A_struct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = dep_A_struct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  dep_A_struct() :
      i_a(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  dep_A_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg);

  dep_A_struct(dep_A_struct&&) = default;

  dep_A_struct(const dep_A_struct&) = default;


  dep_A_struct& operator=(dep_A_struct&&) = default;

  dep_A_struct& operator=(const dep_A_struct&) = default;
  void __clear();
 private:
  ::test_cpp2::cpp_reflection::dep_B_struct b;
 private:
  ::test_cpp2::cpp_reflection::dep_C_struct c;
 private:
  ::std::int32_t i_a;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool b;
    bool c;
    bool i_a;
  } __isset = {};

 public:

  bool operator==(const dep_A_struct&) const;
  bool operator<(const dep_A_struct&) const;

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> b_ref() const& {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> b_ref() const&& {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> b_ref() & {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> b_ref() && {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> c_ref() const& {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> c_ref() const&& {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> c_ref() & {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> c_ref() && {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> i_a_ref() const& {
    return {this->i_a, __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> i_a_ref() const&& {
    return {std::move(this->i_a), __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> i_a_ref() & {
    return {this->i_a, __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> i_a_ref() && {
    return {std::move(this->i_a), __isset.i_a};
  }
  const ::test_cpp2::cpp_reflection::dep_B_struct& get_b() const&;
  ::test_cpp2::cpp_reflection::dep_B_struct get_b() &&;

  template <typename T_dep_A_struct_b_struct_setter = ::test_cpp2::cpp_reflection::dep_B_struct>
  [[deprecated("Use `FOO.b_ref() = BAR;` instead of `FOO.set_b(BAR);`")]]
  ::test_cpp2::cpp_reflection::dep_B_struct& set_b(T_dep_A_struct_b_struct_setter&& b_) {
    b = std::forward<T_dep_A_struct_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }
  const ::test_cpp2::cpp_reflection::dep_C_struct& get_c() const&;
  ::test_cpp2::cpp_reflection::dep_C_struct get_c() &&;

  template <typename T_dep_A_struct_c_struct_setter = ::test_cpp2::cpp_reflection::dep_C_struct>
  [[deprecated("Use `FOO.c_ref() = BAR;` instead of `FOO.set_c(BAR);`")]]
  ::test_cpp2::cpp_reflection::dep_C_struct& set_c(T_dep_A_struct_c_struct_setter&& c_) {
    c = std::forward<T_dep_A_struct_c_struct_setter>(c_);
    __isset.c = true;
    return c;
  }

  ::std::int32_t get_i_a() const {
    return i_a;
  }

  [[deprecated("Use `FOO.i_a_ref() = BAR;` instead of `FOO.set_i_a(BAR);`")]]
  ::std::int32_t& set_i_a(::std::int32_t i_a_) {
    i_a = i_a_;
    __isset.i_a = true;
    return i_a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<dep_A_struct>;
  friend void swap(dep_A_struct& a, dep_A_struct& b);
};

template <class Protocol_>
uint32_t dep_A_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class dep_B_struct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = dep_B_struct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  dep_B_struct() :
      i_a(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  dep_B_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg);

  dep_B_struct(dep_B_struct&&) = default;

  dep_B_struct(const dep_B_struct&) = default;


  dep_B_struct& operator=(dep_B_struct&&) = default;

  dep_B_struct& operator=(const dep_B_struct&) = default;
  void __clear();
 private:
  ::test_cpp2::cpp_reflection::dep_B_struct b;
 private:
  ::test_cpp2::cpp_reflection::dep_C_struct c;
 private:
  ::std::int32_t i_a;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool b;
    bool c;
    bool i_a;
  } __isset = {};

 public:

  bool operator==(const dep_B_struct&) const;
  bool operator<(const dep_B_struct&) const;

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> b_ref() const& {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> b_ref() const&& {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> b_ref() & {
    return {this->b, __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_B_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> b_ref() && {
    return {std::move(this->b), __isset.b};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> c_ref() const& {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> c_ref() const&& {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> c_ref() & {
    return {this->c, __isset.c};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::dep_C_struct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> c_ref() && {
    return {std::move(this->c), __isset.c};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> i_a_ref() const& {
    return {this->i_a, __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> i_a_ref() const&& {
    return {std::move(this->i_a), __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> i_a_ref() & {
    return {this->i_a, __isset.i_a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> i_a_ref() && {
    return {std::move(this->i_a), __isset.i_a};
  }
  const ::test_cpp2::cpp_reflection::dep_B_struct& get_b() const&;
  ::test_cpp2::cpp_reflection::dep_B_struct get_b() &&;

  template <typename T_dep_B_struct_b_struct_setter = ::test_cpp2::cpp_reflection::dep_B_struct>
  [[deprecated("Use `FOO.b_ref() = BAR;` instead of `FOO.set_b(BAR);`")]]
  ::test_cpp2::cpp_reflection::dep_B_struct& set_b(T_dep_B_struct_b_struct_setter&& b_) {
    b = std::forward<T_dep_B_struct_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }
  const ::test_cpp2::cpp_reflection::dep_C_struct& get_c() const&;
  ::test_cpp2::cpp_reflection::dep_C_struct get_c() &&;

  template <typename T_dep_B_struct_c_struct_setter = ::test_cpp2::cpp_reflection::dep_C_struct>
  [[deprecated("Use `FOO.c_ref() = BAR;` instead of `FOO.set_c(BAR);`")]]
  ::test_cpp2::cpp_reflection::dep_C_struct& set_c(T_dep_B_struct_c_struct_setter&& c_) {
    c = std::forward<T_dep_B_struct_c_struct_setter>(c_);
    __isset.c = true;
    return c;
  }

  ::std::int32_t get_i_a() const {
    return i_a;
  }

  [[deprecated("Use `FOO.i_a_ref() = BAR;` instead of `FOO.set_i_a(BAR);`")]]
  ::std::int32_t& set_i_a(::std::int32_t i_a_) {
    i_a = i_a_;
    __isset.i_a = true;
    return i_a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<dep_B_struct>;
  friend void swap(dep_B_struct& a, dep_B_struct& b);
};

template <class Protocol_>
uint32_t dep_B_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class annotated final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = annotated;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  annotated() :
      a(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  annotated(apache::thrift::FragileConstructor, ::std::int32_t a__arg);

  annotated(annotated&&) = default;

  annotated(const annotated&) = default;


  annotated& operator=(annotated&&) = default;

  annotated& operator=(const annotated&) = default;
  void __clear();
 private:
  ::std::int32_t a;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool a;
  } __isset = {};

 public:

  bool operator==(const annotated&) const;
  bool operator<(const annotated&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_ref() const& {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_ref() const&& {
    return {std::move(this->a), __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_ref() & {
    return {this->a, __isset.a};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_ref() && {
    return {std::move(this->a), __isset.a};
  }

  ::std::int32_t get_a() const {
    return a;
  }

  [[deprecated("Use `FOO.a_ref() = BAR;` instead of `FOO.set_a(BAR);`")]]
  ::std::int32_t& set_a(::std::int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<annotated>;
  friend void swap(annotated& a, annotated& b);
};

template <class Protocol_>
uint32_t annotated::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class union_with_special_names final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = union_with_special_names;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    get = 1,
    getter = 2,
    lists = 3,
    maps = 4,
    name = 5,
    name_to_value = 6,
    names = 7,
    prefix_tree = 8,
    sets = 9,
    setter = 10,
    str = 11,
    strings = 12,
    type = 13,
    value = 14,
    value_to_name = 15,
    values = 16,
    id = 17,
    ids = 18,
    descriptor = 19,
    descriptors = 20,
    key = 21,
    keys = 22,
    annotation = 23,
    annotations = 24,
    member = 25,
    members = 26,
    field = 27,
    fields = 28,
  } ;

  union_with_special_names()
      : type_(Type::__EMPTY__) {}

  union_with_special_names(union_with_special_names&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter:
      {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists:
      {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps:
      {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name:
      {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names:
      {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets:
      {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter:
      {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str:
      {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings:
      {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type:
      {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value:
      {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values:
      {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id:
      {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids:
      {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key:
      {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys:
      {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation:
      {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations:
      {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member:
      {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members:
      {
        set_members(std::move(rhs.value_.members));
        break;
      }
      case Type::field:
      {
        set_field(std::move(rhs.value_.field));
        break;
      }
      case Type::fields:
      {
        set_fields(std::move(rhs.value_.fields));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union_with_special_names(const union_with_special_names& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter:
      {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists:
      {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps:
      {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name:
      {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names:
      {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets:
      {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter:
      {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str:
      {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings:
      {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type:
      {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value:
      {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values:
      {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id:
      {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids:
      {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key:
      {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys:
      {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation:
      {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations:
      {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member:
      {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members:
      {
        set_members(rhs.value_.members);
        break;
      }
      case Type::field:
      {
        set_field(rhs.value_.field);
        break;
      }
      case Type::fields:
      {
        set_fields(rhs.value_.fields);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union_with_special_names& operator=(union_with_special_names&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter:
      {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists:
      {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps:
      {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name:
      {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names:
      {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets:
      {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter:
      {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str:
      {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings:
      {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type:
      {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value:
      {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values:
      {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id:
      {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids:
      {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key:
      {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys:
      {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation:
      {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations:
      {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member:
      {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members:
      {
        set_members(std::move(rhs.value_.members));
        break;
      }
      case Type::field:
      {
        set_field(std::move(rhs.value_.field));
        break;
      }
      case Type::fields:
      {
        set_fields(std::move(rhs.value_.fields));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union_with_special_names& operator=(const union_with_special_names& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter:
      {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists:
      {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps:
      {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name:
      {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names:
      {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets:
      {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter:
      {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str:
      {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings:
      {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type:
      {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value:
      {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values:
      {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id:
      {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids:
      {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key:
      {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys:
      {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation:
      {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations:
      {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member:
      {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members:
      {
        set_members(rhs.value_.members);
        break;
      }
      case Type::field:
      {
        set_field(rhs.value_.field);
        break;
      }
      case Type::fields:
      {
        set_fields(rhs.value_.fields);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union_with_special_names() {
    __clear();
  }
  union storage_type {
    ::std::int32_t get;
    ::std::int32_t getter;
    ::std::int32_t lists;
    ::std::int32_t maps;
    ::std::int32_t name;
    ::std::int32_t name_to_value;
    ::std::int32_t names;
    ::std::int32_t prefix_tree;
    ::std::int32_t sets;
    ::std::int32_t setter;
    ::std::int32_t str;
    ::std::int32_t strings;
    ::std::int32_t type;
    ::std::int32_t value;
    ::std::int32_t value_to_name;
    ::std::int32_t values;
    ::std::int32_t id;
    ::std::int32_t ids;
    ::std::int32_t descriptor;
    ::std::int32_t descriptors;
    ::std::int32_t key;
    ::std::int32_t keys;
    ::std::int32_t annotation;
    ::std::int32_t annotations;
    ::std::int32_t member;
    ::std::int32_t members;
    ::std::int32_t field;
    ::std::int32_t fields;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const union_with_special_names&) const;
  bool operator<(const union_with_special_names&) const;

  ::std::int32_t& set_get(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::get;
    ::new (std::addressof(value_.get)) ::std::int32_t(t);
    return value_.get;
  }

  ::std::int32_t& set_getter(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::getter;
    ::new (std::addressof(value_.getter)) ::std::int32_t(t);
    return value_.getter;
  }

  ::std::int32_t& set_lists(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::lists;
    ::new (std::addressof(value_.lists)) ::std::int32_t(t);
    return value_.lists;
  }

  ::std::int32_t& set_maps(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::maps;
    ::new (std::addressof(value_.maps)) ::std::int32_t(t);
    return value_.maps;
  }

  ::std::int32_t& set_name(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::name;
    ::new (std::addressof(value_.name)) ::std::int32_t(t);
    return value_.name;
  }

  ::std::int32_t& set_name_to_value(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::name_to_value;
    ::new (std::addressof(value_.name_to_value)) ::std::int32_t(t);
    return value_.name_to_value;
  }

  ::std::int32_t& set_names(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::names;
    ::new (std::addressof(value_.names)) ::std::int32_t(t);
    return value_.names;
  }

  ::std::int32_t& set_prefix_tree(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::prefix_tree;
    ::new (std::addressof(value_.prefix_tree)) ::std::int32_t(t);
    return value_.prefix_tree;
  }

  ::std::int32_t& set_sets(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::sets;
    ::new (std::addressof(value_.sets)) ::std::int32_t(t);
    return value_.sets;
  }

  ::std::int32_t& set_setter(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::setter;
    ::new (std::addressof(value_.setter)) ::std::int32_t(t);
    return value_.setter;
  }

  ::std::int32_t& set_str(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::str;
    ::new (std::addressof(value_.str)) ::std::int32_t(t);
    return value_.str;
  }

  ::std::int32_t& set_strings(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::strings;
    ::new (std::addressof(value_.strings)) ::std::int32_t(t);
    return value_.strings;
  }

  ::std::int32_t& set_type(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::type;
    ::new (std::addressof(value_.type)) ::std::int32_t(t);
    return value_.type;
  }

  ::std::int32_t& set_value(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::value;
    ::new (std::addressof(value_.value)) ::std::int32_t(t);
    return value_.value;
  }

  ::std::int32_t& set_value_to_name(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::value_to_name;
    ::new (std::addressof(value_.value_to_name)) ::std::int32_t(t);
    return value_.value_to_name;
  }

  ::std::int32_t& set_values(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::values;
    ::new (std::addressof(value_.values)) ::std::int32_t(t);
    return value_.values;
  }

  ::std::int32_t& set_id(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::id;
    ::new (std::addressof(value_.id)) ::std::int32_t(t);
    return value_.id;
  }

  ::std::int32_t& set_ids(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::ids;
    ::new (std::addressof(value_.ids)) ::std::int32_t(t);
    return value_.ids;
  }

  ::std::int32_t& set_descriptor(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::descriptor;
    ::new (std::addressof(value_.descriptor)) ::std::int32_t(t);
    return value_.descriptor;
  }

  ::std::int32_t& set_descriptors(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::descriptors;
    ::new (std::addressof(value_.descriptors)) ::std::int32_t(t);
    return value_.descriptors;
  }

  ::std::int32_t& set_key(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::key;
    ::new (std::addressof(value_.key)) ::std::int32_t(t);
    return value_.key;
  }

  ::std::int32_t& set_keys(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::keys;
    ::new (std::addressof(value_.keys)) ::std::int32_t(t);
    return value_.keys;
  }

  ::std::int32_t& set_annotation(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::annotation;
    ::new (std::addressof(value_.annotation)) ::std::int32_t(t);
    return value_.annotation;
  }

  ::std::int32_t& set_annotations(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::annotations;
    ::new (std::addressof(value_.annotations)) ::std::int32_t(t);
    return value_.annotations;
  }

  ::std::int32_t& set_member(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::member;
    ::new (std::addressof(value_.member)) ::std::int32_t(t);
    return value_.member;
  }

  ::std::int32_t& set_members(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::members;
    ::new (std::addressof(value_.members)) ::std::int32_t(t);
    return value_.members;
  }

  ::std::int32_t& set_field(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::field;
    ::new (std::addressof(value_.field)) ::std::int32_t(t);
    return value_.field;
  }

  ::std::int32_t& set_fields(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::fields;
    ::new (std::addressof(value_.fields)) ::std::int32_t(t);
    return value_.fields;
  }

  ::std::int32_t const& get_get() const {
    if (type_ != Type::get) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.get;
  }

  ::std::int32_t const& get_getter() const {
    if (type_ != Type::getter) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.getter;
  }

  ::std::int32_t const& get_lists() const {
    if (type_ != Type::lists) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.lists;
  }

  ::std::int32_t const& get_maps() const {
    if (type_ != Type::maps) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.maps;
  }

  ::std::int32_t const& get_name() const {
    if (type_ != Type::name) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.name;
  }

  ::std::int32_t const& get_name_to_value() const {
    if (type_ != Type::name_to_value) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.name_to_value;
  }

  ::std::int32_t const& get_names() const {
    if (type_ != Type::names) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.names;
  }

  ::std::int32_t const& get_prefix_tree() const {
    if (type_ != Type::prefix_tree) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.prefix_tree;
  }

  ::std::int32_t const& get_sets() const {
    if (type_ != Type::sets) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.sets;
  }

  ::std::int32_t const& get_setter() const {
    if (type_ != Type::setter) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.setter;
  }

  ::std::int32_t const& get_str() const {
    if (type_ != Type::str) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.str;
  }

  ::std::int32_t const& get_strings() const {
    if (type_ != Type::strings) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.strings;
  }

  ::std::int32_t const& get_type() const {
    if (type_ != Type::type) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.type;
  }

  ::std::int32_t const& get_value() const {
    if (type_ != Type::value) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.value;
  }

  ::std::int32_t const& get_value_to_name() const {
    if (type_ != Type::value_to_name) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.value_to_name;
  }

  ::std::int32_t const& get_values() const {
    if (type_ != Type::values) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.values;
  }

  ::std::int32_t const& get_id() const {
    if (type_ != Type::id) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.id;
  }

  ::std::int32_t const& get_ids() const {
    if (type_ != Type::ids) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ids;
  }

  ::std::int32_t const& get_descriptor() const {
    if (type_ != Type::descriptor) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.descriptor;
  }

  ::std::int32_t const& get_descriptors() const {
    if (type_ != Type::descriptors) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.descriptors;
  }

  ::std::int32_t const& get_key() const {
    if (type_ != Type::key) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.key;
  }

  ::std::int32_t const& get_keys() const {
    if (type_ != Type::keys) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.keys;
  }

  ::std::int32_t const& get_annotation() const {
    if (type_ != Type::annotation) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.annotation;
  }

  ::std::int32_t const& get_annotations() const {
    if (type_ != Type::annotations) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.annotations;
  }

  ::std::int32_t const& get_member() const {
    if (type_ != Type::member) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.member;
  }

  ::std::int32_t const& get_members() const {
    if (type_ != Type::members) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.members;
  }

  ::std::int32_t const& get_field() const {
    if (type_ != Type::field) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.field;
  }

  ::std::int32_t const& get_fields() const {
    if (type_ != Type::fields) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.fields;
  }

  ::std::int32_t& mutable_get() {
    assert(type_ == Type::get);
    return value_.get;
  }

  ::std::int32_t& mutable_getter() {
    assert(type_ == Type::getter);
    return value_.getter;
  }

  ::std::int32_t& mutable_lists() {
    assert(type_ == Type::lists);
    return value_.lists;
  }

  ::std::int32_t& mutable_maps() {
    assert(type_ == Type::maps);
    return value_.maps;
  }

  ::std::int32_t& mutable_name() {
    assert(type_ == Type::name);
    return value_.name;
  }

  ::std::int32_t& mutable_name_to_value() {
    assert(type_ == Type::name_to_value);
    return value_.name_to_value;
  }

  ::std::int32_t& mutable_names() {
    assert(type_ == Type::names);
    return value_.names;
  }

  ::std::int32_t& mutable_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return value_.prefix_tree;
  }

  ::std::int32_t& mutable_sets() {
    assert(type_ == Type::sets);
    return value_.sets;
  }

  ::std::int32_t& mutable_setter() {
    assert(type_ == Type::setter);
    return value_.setter;
  }

  ::std::int32_t& mutable_str() {
    assert(type_ == Type::str);
    return value_.str;
  }

  ::std::int32_t& mutable_strings() {
    assert(type_ == Type::strings);
    return value_.strings;
  }

  ::std::int32_t& mutable_type() {
    assert(type_ == Type::type);
    return value_.type;
  }

  ::std::int32_t& mutable_value() {
    assert(type_ == Type::value);
    return value_.value;
  }

  ::std::int32_t& mutable_value_to_name() {
    assert(type_ == Type::value_to_name);
    return value_.value_to_name;
  }

  ::std::int32_t& mutable_values() {
    assert(type_ == Type::values);
    return value_.values;
  }

  ::std::int32_t& mutable_id() {
    assert(type_ == Type::id);
    return value_.id;
  }

  ::std::int32_t& mutable_ids() {
    assert(type_ == Type::ids);
    return value_.ids;
  }

  ::std::int32_t& mutable_descriptor() {
    assert(type_ == Type::descriptor);
    return value_.descriptor;
  }

  ::std::int32_t& mutable_descriptors() {
    assert(type_ == Type::descriptors);
    return value_.descriptors;
  }

  ::std::int32_t& mutable_key() {
    assert(type_ == Type::key);
    return value_.key;
  }

  ::std::int32_t& mutable_keys() {
    assert(type_ == Type::keys);
    return value_.keys;
  }

  ::std::int32_t& mutable_annotation() {
    assert(type_ == Type::annotation);
    return value_.annotation;
  }

  ::std::int32_t& mutable_annotations() {
    assert(type_ == Type::annotations);
    return value_.annotations;
  }

  ::std::int32_t& mutable_member() {
    assert(type_ == Type::member);
    return value_.member;
  }

  ::std::int32_t& mutable_members() {
    assert(type_ == Type::members);
    return value_.members;
  }

  ::std::int32_t& mutable_field() {
    assert(type_ == Type::field);
    return value_.field;
  }

  ::std::int32_t& mutable_fields() {
    assert(type_ == Type::fields);
    return value_.fields;
  }

  ::std::int32_t move_get() {
    assert(type_ == Type::get);
    return std::move(value_.get);
  }

  ::std::int32_t move_getter() {
    assert(type_ == Type::getter);
    return std::move(value_.getter);
  }

  ::std::int32_t move_lists() {
    assert(type_ == Type::lists);
    return std::move(value_.lists);
  }

  ::std::int32_t move_maps() {
    assert(type_ == Type::maps);
    return std::move(value_.maps);
  }

  ::std::int32_t move_name() {
    assert(type_ == Type::name);
    return std::move(value_.name);
  }

  ::std::int32_t move_name_to_value() {
    assert(type_ == Type::name_to_value);
    return std::move(value_.name_to_value);
  }

  ::std::int32_t move_names() {
    assert(type_ == Type::names);
    return std::move(value_.names);
  }

  ::std::int32_t move_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return std::move(value_.prefix_tree);
  }

  ::std::int32_t move_sets() {
    assert(type_ == Type::sets);
    return std::move(value_.sets);
  }

  ::std::int32_t move_setter() {
    assert(type_ == Type::setter);
    return std::move(value_.setter);
  }

  ::std::int32_t move_str() {
    assert(type_ == Type::str);
    return std::move(value_.str);
  }

  ::std::int32_t move_strings() {
    assert(type_ == Type::strings);
    return std::move(value_.strings);
  }

  ::std::int32_t move_type() {
    assert(type_ == Type::type);
    return std::move(value_.type);
  }

  ::std::int32_t move_value() {
    assert(type_ == Type::value);
    return std::move(value_.value);
  }

  ::std::int32_t move_value_to_name() {
    assert(type_ == Type::value_to_name);
    return std::move(value_.value_to_name);
  }

  ::std::int32_t move_values() {
    assert(type_ == Type::values);
    return std::move(value_.values);
  }

  ::std::int32_t move_id() {
    assert(type_ == Type::id);
    return std::move(value_.id);
  }

  ::std::int32_t move_ids() {
    assert(type_ == Type::ids);
    return std::move(value_.ids);
  }

  ::std::int32_t move_descriptor() {
    assert(type_ == Type::descriptor);
    return std::move(value_.descriptor);
  }

  ::std::int32_t move_descriptors() {
    assert(type_ == Type::descriptors);
    return std::move(value_.descriptors);
  }

  ::std::int32_t move_key() {
    assert(type_ == Type::key);
    return std::move(value_.key);
  }

  ::std::int32_t move_keys() {
    assert(type_ == Type::keys);
    return std::move(value_.keys);
  }

  ::std::int32_t move_annotation() {
    assert(type_ == Type::annotation);
    return std::move(value_.annotation);
  }

  ::std::int32_t move_annotations() {
    assert(type_ == Type::annotations);
    return std::move(value_.annotations);
  }

  ::std::int32_t move_member() {
    assert(type_ == Type::member);
    return std::move(value_.member);
  }

  ::std::int32_t move_members() {
    assert(type_ == Type::members);
    return std::move(value_.members);
  }

  ::std::int32_t move_field() {
    assert(type_ == Type::field);
    return std::move(value_.field);
  }

  ::std::int32_t move_fields() {
    assert(type_ == Type::fields);
    return std::move(value_.fields);
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> get_ref() const& {
    return {value_.get, type_, get, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> get_ref() const&& {
    return {std::move(value_.get), type_, get, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> get_ref() & {
    return {value_.get, type_, get, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> get_ref() && {
    return {std::move(value_.get), type_, get, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> getter_ref() const& {
    return {value_.getter, type_, getter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> getter_ref() const&& {
    return {std::move(value_.getter), type_, getter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> getter_ref() & {
    return {value_.getter, type_, getter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> getter_ref() && {
    return {std::move(value_.getter), type_, getter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> lists_ref() const& {
    return {value_.lists, type_, lists, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> lists_ref() const&& {
    return {std::move(value_.lists), type_, lists, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> lists_ref() & {
    return {value_.lists, type_, lists, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> lists_ref() && {
    return {std::move(value_.lists), type_, lists, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> maps_ref() const& {
    return {value_.maps, type_, maps, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> maps_ref() const&& {
    return {std::move(value_.maps), type_, maps, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> maps_ref() & {
    return {value_.maps, type_, maps, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> maps_ref() && {
    return {std::move(value_.maps), type_, maps, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> name_ref() const& {
    return {value_.name, type_, name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> name_ref() const&& {
    return {std::move(value_.name), type_, name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> name_ref() & {
    return {value_.name, type_, name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> name_ref() && {
    return {std::move(value_.name), type_, name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> name_to_value_ref() const& {
    return {value_.name_to_value, type_, name_to_value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> name_to_value_ref() const&& {
    return {std::move(value_.name_to_value), type_, name_to_value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> name_to_value_ref() & {
    return {value_.name_to_value, type_, name_to_value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> name_to_value_ref() && {
    return {std::move(value_.name_to_value), type_, name_to_value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> names_ref() const& {
    return {value_.names, type_, names, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> names_ref() const&& {
    return {std::move(value_.names), type_, names, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> names_ref() & {
    return {value_.names, type_, names, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> names_ref() && {
    return {std::move(value_.names), type_, names, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> prefix_tree_ref() const& {
    return {value_.prefix_tree, type_, prefix_tree, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> prefix_tree_ref() const&& {
    return {std::move(value_.prefix_tree), type_, prefix_tree, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> prefix_tree_ref() & {
    return {value_.prefix_tree, type_, prefix_tree, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> prefix_tree_ref() && {
    return {std::move(value_.prefix_tree), type_, prefix_tree, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> sets_ref() const& {
    return {value_.sets, type_, sets, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> sets_ref() const&& {
    return {std::move(value_.sets), type_, sets, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> sets_ref() & {
    return {value_.sets, type_, sets, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> sets_ref() && {
    return {std::move(value_.sets), type_, sets, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> setter_ref() const& {
    return {value_.setter, type_, setter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> setter_ref() const&& {
    return {std::move(value_.setter), type_, setter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> setter_ref() & {
    return {value_.setter, type_, setter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> setter_ref() && {
    return {std::move(value_.setter), type_, setter, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> str_ref() const& {
    return {value_.str, type_, str, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> str_ref() const&& {
    return {std::move(value_.str), type_, str, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> str_ref() & {
    return {value_.str, type_, str, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> str_ref() && {
    return {std::move(value_.str), type_, str, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> strings_ref() const& {
    return {value_.strings, type_, strings, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> strings_ref() const&& {
    return {std::move(value_.strings), type_, strings, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> strings_ref() & {
    return {value_.strings, type_, strings, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> strings_ref() && {
    return {std::move(value_.strings), type_, strings, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> type_ref() const& {
    return {value_.type, type_, type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> type_ref() const&& {
    return {std::move(value_.type), type_, type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> type_ref() & {
    return {value_.type, type_, type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> type_ref() && {
    return {std::move(value_.type), type_, type, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> value_ref() const& {
    return {value_.value, type_, value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> value_ref() const&& {
    return {std::move(value_.value), type_, value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> value_ref() & {
    return {value_.value, type_, value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> value_ref() && {
    return {std::move(value_.value), type_, value, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> value_to_name_ref() const& {
    return {value_.value_to_name, type_, value_to_name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> value_to_name_ref() const&& {
    return {std::move(value_.value_to_name), type_, value_to_name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> value_to_name_ref() & {
    return {value_.value_to_name, type_, value_to_name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> value_to_name_ref() && {
    return {std::move(value_.value_to_name), type_, value_to_name, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> values_ref() const& {
    return {value_.values, type_, values, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> values_ref() const&& {
    return {std::move(value_.values), type_, values, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> values_ref() & {
    return {value_.values, type_, values, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> values_ref() && {
    return {std::move(value_.values), type_, values, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> id_ref() const& {
    return {value_.id, type_, id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> id_ref() const&& {
    return {std::move(value_.id), type_, id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> id_ref() & {
    return {value_.id, type_, id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> id_ref() && {
    return {std::move(value_.id), type_, id, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ids_ref() const& {
    return {value_.ids, type_, ids, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ids_ref() const&& {
    return {std::move(value_.ids), type_, ids, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ids_ref() & {
    return {value_.ids, type_, ids, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ids_ref() && {
    return {std::move(value_.ids), type_, ids, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> descriptor_ref() const& {
    return {value_.descriptor, type_, descriptor, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> descriptor_ref() const&& {
    return {std::move(value_.descriptor), type_, descriptor, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> descriptor_ref() & {
    return {value_.descriptor, type_, descriptor, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> descriptor_ref() && {
    return {std::move(value_.descriptor), type_, descriptor, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> descriptors_ref() const& {
    return {value_.descriptors, type_, descriptors, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> descriptors_ref() const&& {
    return {std::move(value_.descriptors), type_, descriptors, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> descriptors_ref() & {
    return {value_.descriptors, type_, descriptors, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> descriptors_ref() && {
    return {std::move(value_.descriptors), type_, descriptors, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> key_ref() const& {
    return {value_.key, type_, key, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> key_ref() const&& {
    return {std::move(value_.key), type_, key, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> key_ref() & {
    return {value_.key, type_, key, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> key_ref() && {
    return {std::move(value_.key), type_, key, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> keys_ref() const& {
    return {value_.keys, type_, keys, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> keys_ref() const&& {
    return {std::move(value_.keys), type_, keys, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> keys_ref() & {
    return {value_.keys, type_, keys, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> keys_ref() && {
    return {std::move(value_.keys), type_, keys, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> annotation_ref() const& {
    return {value_.annotation, type_, annotation, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> annotation_ref() const&& {
    return {std::move(value_.annotation), type_, annotation, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> annotation_ref() & {
    return {value_.annotation, type_, annotation, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> annotation_ref() && {
    return {std::move(value_.annotation), type_, annotation, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> annotations_ref() const& {
    return {value_.annotations, type_, annotations, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> annotations_ref() const&& {
    return {std::move(value_.annotations), type_, annotations, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> annotations_ref() & {
    return {value_.annotations, type_, annotations, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> annotations_ref() && {
    return {std::move(value_.annotations), type_, annotations, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> member_ref() const& {
    return {value_.member, type_, member, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> member_ref() const&& {
    return {std::move(value_.member), type_, member, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> member_ref() & {
    return {value_.member, type_, member, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> member_ref() && {
    return {std::move(value_.member), type_, member, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> members_ref() const& {
    return {value_.members, type_, members, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> members_ref() const&& {
    return {std::move(value_.members), type_, members, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> members_ref() & {
    return {value_.members, type_, members, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> members_ref() && {
    return {std::move(value_.members), type_, members, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> field_ref() const& {
    return {value_.field, type_, field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> field_ref() const&& {
    return {std::move(value_.field), type_, field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> field_ref() & {
    return {value_.field, type_, field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> field_ref() && {
    return {std::move(value_.field), type_, field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> fields_ref() const& {
    return {value_.fields, type_, fields, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> fields_ref() const&& {
    return {std::move(value_.fields), type_, fields, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> fields_ref() & {
    return {value_.fields, type_, fields, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> fields_ref() && {
    return {std::move(value_.fields), type_, fields, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<union_with_special_names>;
  friend void swap(union_with_special_names& a, union_with_special_names& b);
};

template <class Protocol_>
uint32_t union_with_special_names::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct_with_special_names final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct_with_special_names;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct_with_special_names() :
      get(0),
      getter(0),
      lists(0),
      maps(0),
      name(0),
      name_to_value(0),
      names(0),
      prefix_tree(0),
      sets(0),
      setter(0),
      str(0),
      strings(0),
      type(0),
      value(0),
      value_to_name(0),
      values(0),
      id(0),
      ids(0),
      descriptor(0),
      descriptors(0),
      key(0),
      keys(0),
      annotation(0),
      annotations(0),
      member(0),
      members(0),
      field(0),
      fields(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_with_special_names(apache::thrift::FragileConstructor, ::std::int32_t get__arg, ::std::int32_t getter__arg, ::std::int32_t lists__arg, ::std::int32_t maps__arg, ::std::int32_t name__arg, ::std::int32_t name_to_value__arg, ::std::int32_t names__arg, ::std::int32_t prefix_tree__arg, ::std::int32_t sets__arg, ::std::int32_t setter__arg, ::std::int32_t str__arg, ::std::int32_t strings__arg, ::std::int32_t type__arg, ::std::int32_t value__arg, ::std::int32_t value_to_name__arg, ::std::int32_t values__arg, ::std::int32_t id__arg, ::std::int32_t ids__arg, ::std::int32_t descriptor__arg, ::std::int32_t descriptors__arg, ::std::int32_t key__arg, ::std::int32_t keys__arg, ::std::int32_t annotation__arg, ::std::int32_t annotations__arg, ::std::int32_t member__arg, ::std::int32_t members__arg, ::std::int32_t field__arg, ::std::int32_t fields__arg);

  struct_with_special_names(struct_with_special_names&&) = default;

  struct_with_special_names(const struct_with_special_names&) = default;


  struct_with_special_names& operator=(struct_with_special_names&&) = default;

  struct_with_special_names& operator=(const struct_with_special_names&) = default;
  void __clear();
 private:
  ::std::int32_t get;
 private:
  ::std::int32_t getter;
 private:
  ::std::int32_t lists;
 private:
  ::std::int32_t maps;
 private:
  ::std::int32_t name;
 private:
  ::std::int32_t name_to_value;
 private:
  ::std::int32_t names;
 private:
  ::std::int32_t prefix_tree;
 private:
  ::std::int32_t sets;
 private:
  ::std::int32_t setter;
 private:
  ::std::int32_t str;
 private:
  ::std::int32_t strings;
 private:
  ::std::int32_t type;
 private:
  ::std::int32_t value;
 private:
  ::std::int32_t value_to_name;
 private:
  ::std::int32_t values;
 private:
  ::std::int32_t id;
 private:
  ::std::int32_t ids;
 private:
  ::std::int32_t descriptor;
 private:
  ::std::int32_t descriptors;
 private:
  ::std::int32_t key;
 private:
  ::std::int32_t keys;
 private:
  ::std::int32_t annotation;
 private:
  ::std::int32_t annotations;
 private:
  ::std::int32_t member;
 private:
  ::std::int32_t members;
 private:
  ::std::int32_t field;
 private:
  ::std::int32_t fields;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool get;
    bool getter;
    bool lists;
    bool maps;
    bool name;
    bool name_to_value;
    bool names;
    bool prefix_tree;
    bool sets;
    bool setter;
    bool str;
    bool strings;
    bool type;
    bool value;
    bool value_to_name;
    bool values;
    bool id;
    bool ids;
    bool descriptor;
    bool descriptors;
    bool key;
    bool keys;
    bool annotation;
    bool annotations;
    bool member;
    bool members;
    bool field;
    bool fields;
  } __isset = {};

 public:

  bool operator==(const struct_with_special_names&) const;
  bool operator<(const struct_with_special_names&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> get_ref() const& {
    return {this->get, __isset.get};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> get_ref() const&& {
    return {std::move(this->get), __isset.get};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> get_ref() & {
    return {this->get, __isset.get};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> get_ref() && {
    return {std::move(this->get), __isset.get};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> getter_ref() const& {
    return {this->getter, __isset.getter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> getter_ref() const&& {
    return {std::move(this->getter), __isset.getter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> getter_ref() & {
    return {this->getter, __isset.getter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> getter_ref() && {
    return {std::move(this->getter), __isset.getter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> lists_ref() const& {
    return {this->lists, __isset.lists};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> lists_ref() const&& {
    return {std::move(this->lists), __isset.lists};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> lists_ref() & {
    return {this->lists, __isset.lists};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> lists_ref() && {
    return {std::move(this->lists), __isset.lists};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> maps_ref() const& {
    return {this->maps, __isset.maps};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> maps_ref() const&& {
    return {std::move(this->maps), __isset.maps};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> maps_ref() & {
    return {this->maps, __isset.maps};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> maps_ref() && {
    return {std::move(this->maps), __isset.maps};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_to_value_ref() const& {
    return {this->name_to_value, __isset.name_to_value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_to_value_ref() const&& {
    return {std::move(this->name_to_value), __isset.name_to_value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_to_value_ref() & {
    return {this->name_to_value, __isset.name_to_value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_to_value_ref() && {
    return {std::move(this->name_to_value), __isset.name_to_value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> names_ref() const& {
    return {this->names, __isset.names};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> names_ref() const&& {
    return {std::move(this->names), __isset.names};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> names_ref() & {
    return {this->names, __isset.names};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> names_ref() && {
    return {std::move(this->names), __isset.names};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> prefix_tree_ref() const& {
    return {this->prefix_tree, __isset.prefix_tree};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> prefix_tree_ref() const&& {
    return {std::move(this->prefix_tree), __isset.prefix_tree};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> prefix_tree_ref() & {
    return {this->prefix_tree, __isset.prefix_tree};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> prefix_tree_ref() && {
    return {std::move(this->prefix_tree), __isset.prefix_tree};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> sets_ref() const& {
    return {this->sets, __isset.sets};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> sets_ref() const&& {
    return {std::move(this->sets), __isset.sets};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> sets_ref() & {
    return {this->sets, __isset.sets};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> sets_ref() && {
    return {std::move(this->sets), __isset.sets};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> setter_ref() const& {
    return {this->setter, __isset.setter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> setter_ref() const&& {
    return {std::move(this->setter), __isset.setter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> setter_ref() & {
    return {this->setter, __isset.setter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> setter_ref() && {
    return {std::move(this->setter), __isset.setter};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> str_ref() const& {
    return {this->str, __isset.str};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> str_ref() const&& {
    return {std::move(this->str), __isset.str};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> str_ref() & {
    return {this->str, __isset.str};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> str_ref() && {
    return {std::move(this->str), __isset.str};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> strings_ref() const& {
    return {this->strings, __isset.strings};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> strings_ref() const&& {
    return {std::move(this->strings), __isset.strings};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> strings_ref() & {
    return {this->strings, __isset.strings};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> strings_ref() && {
    return {std::move(this->strings), __isset.strings};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> value_ref() const& {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> value_ref() const&& {
    return {std::move(this->value), __isset.value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> value_ref() & {
    return {this->value, __isset.value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> value_ref() && {
    return {std::move(this->value), __isset.value};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> value_to_name_ref() const& {
    return {this->value_to_name, __isset.value_to_name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> value_to_name_ref() const&& {
    return {std::move(this->value_to_name), __isset.value_to_name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> value_to_name_ref() & {
    return {this->value_to_name, __isset.value_to_name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> value_to_name_ref() && {
    return {std::move(this->value_to_name), __isset.value_to_name};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> values_ref() const& {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> values_ref() const&& {
    return {std::move(this->values), __isset.values};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> values_ref() & {
    return {this->values, __isset.values};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> values_ref() && {
    return {std::move(this->values), __isset.values};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> ids_ref() const& {
    return {this->ids, __isset.ids};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> ids_ref() const&& {
    return {std::move(this->ids), __isset.ids};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> ids_ref() & {
    return {this->ids, __isset.ids};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> ids_ref() && {
    return {std::move(this->ids), __isset.ids};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> descriptor_ref() const& {
    return {this->descriptor, __isset.descriptor};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> descriptor_ref() const&& {
    return {std::move(this->descriptor), __isset.descriptor};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> descriptor_ref() & {
    return {this->descriptor, __isset.descriptor};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> descriptor_ref() && {
    return {std::move(this->descriptor), __isset.descriptor};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> descriptors_ref() const& {
    return {this->descriptors, __isset.descriptors};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> descriptors_ref() const&& {
    return {std::move(this->descriptors), __isset.descriptors};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> descriptors_ref() & {
    return {this->descriptors, __isset.descriptors};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> descriptors_ref() && {
    return {std::move(this->descriptors), __isset.descriptors};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> key_ref() const& {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> key_ref() const&& {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> key_ref() & {
    return {this->key, __isset.key};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> key_ref() && {
    return {std::move(this->key), __isset.key};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> keys_ref() const& {
    return {this->keys, __isset.keys};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> keys_ref() const&& {
    return {std::move(this->keys), __isset.keys};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> keys_ref() & {
    return {this->keys, __isset.keys};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> keys_ref() && {
    return {std::move(this->keys), __isset.keys};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotation_ref() const& {
    return {this->annotation, __isset.annotation};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotation_ref() const&& {
    return {std::move(this->annotation), __isset.annotation};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotation_ref() & {
    return {this->annotation, __isset.annotation};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotation_ref() && {
    return {std::move(this->annotation), __isset.annotation};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> annotations_ref() const& {
    return {this->annotations, __isset.annotations};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> annotations_ref() const&& {
    return {std::move(this->annotations), __isset.annotations};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> annotations_ref() & {
    return {this->annotations, __isset.annotations};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> annotations_ref() && {
    return {std::move(this->annotations), __isset.annotations};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> member_ref() const& {
    return {this->member, __isset.member};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> member_ref() const&& {
    return {std::move(this->member), __isset.member};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> member_ref() & {
    return {this->member, __isset.member};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> member_ref() && {
    return {std::move(this->member), __isset.member};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> members_ref() const& {
    return {this->members, __isset.members};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> members_ref() const&& {
    return {std::move(this->members), __isset.members};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> members_ref() & {
    return {this->members, __isset.members};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> members_ref() && {
    return {std::move(this->members), __isset.members};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> field_ref() const& {
    return {this->field, __isset.field};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> field_ref() const&& {
    return {std::move(this->field), __isset.field};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> field_ref() & {
    return {this->field, __isset.field};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> field_ref() && {
    return {std::move(this->field), __isset.field};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }

  ::std::int32_t get_get() const {
    return get;
  }

  [[deprecated("Use `FOO.get_ref() = BAR;` instead of `FOO.set_get(BAR);`")]]
  ::std::int32_t& set_get(::std::int32_t get_) {
    get = get_;
    __isset.get = true;
    return get;
  }

  ::std::int32_t get_getter() const {
    return getter;
  }

  [[deprecated("Use `FOO.getter_ref() = BAR;` instead of `FOO.set_getter(BAR);`")]]
  ::std::int32_t& set_getter(::std::int32_t getter_) {
    getter = getter_;
    __isset.getter = true;
    return getter;
  }

  ::std::int32_t get_lists() const {
    return lists;
  }

  [[deprecated("Use `FOO.lists_ref() = BAR;` instead of `FOO.set_lists(BAR);`")]]
  ::std::int32_t& set_lists(::std::int32_t lists_) {
    lists = lists_;
    __isset.lists = true;
    return lists;
  }

  ::std::int32_t get_maps() const {
    return maps;
  }

  [[deprecated("Use `FOO.maps_ref() = BAR;` instead of `FOO.set_maps(BAR);`")]]
  ::std::int32_t& set_maps(::std::int32_t maps_) {
    maps = maps_;
    __isset.maps = true;
    return maps;
  }

  ::std::int32_t get_name() const {
    return name;
  }

  [[deprecated("Use `FOO.name_ref() = BAR;` instead of `FOO.set_name(BAR);`")]]
  ::std::int32_t& set_name(::std::int32_t name_) {
    name = name_;
    __isset.name = true;
    return name;
  }

  ::std::int32_t get_name_to_value() const {
    return name_to_value;
  }

  [[deprecated("Use `FOO.name_to_value_ref() = BAR;` instead of `FOO.set_name_to_value(BAR);`")]]
  ::std::int32_t& set_name_to_value(::std::int32_t name_to_value_) {
    name_to_value = name_to_value_;
    __isset.name_to_value = true;
    return name_to_value;
  }

  ::std::int32_t get_names() const {
    return names;
  }

  [[deprecated("Use `FOO.names_ref() = BAR;` instead of `FOO.set_names(BAR);`")]]
  ::std::int32_t& set_names(::std::int32_t names_) {
    names = names_;
    __isset.names = true;
    return names;
  }

  ::std::int32_t get_prefix_tree() const {
    return prefix_tree;
  }

  [[deprecated("Use `FOO.prefix_tree_ref() = BAR;` instead of `FOO.set_prefix_tree(BAR);`")]]
  ::std::int32_t& set_prefix_tree(::std::int32_t prefix_tree_) {
    prefix_tree = prefix_tree_;
    __isset.prefix_tree = true;
    return prefix_tree;
  }

  ::std::int32_t get_sets() const {
    return sets;
  }

  [[deprecated("Use `FOO.sets_ref() = BAR;` instead of `FOO.set_sets(BAR);`")]]
  ::std::int32_t& set_sets(::std::int32_t sets_) {
    sets = sets_;
    __isset.sets = true;
    return sets;
  }

  ::std::int32_t get_setter() const {
    return setter;
  }

  [[deprecated("Use `FOO.setter_ref() = BAR;` instead of `FOO.set_setter(BAR);`")]]
  ::std::int32_t& set_setter(::std::int32_t setter_) {
    setter = setter_;
    __isset.setter = true;
    return setter;
  }

  ::std::int32_t get_str() const {
    return str;
  }

  [[deprecated("Use `FOO.str_ref() = BAR;` instead of `FOO.set_str(BAR);`")]]
  ::std::int32_t& set_str(::std::int32_t str_) {
    str = str_;
    __isset.str = true;
    return str;
  }

  ::std::int32_t get_strings() const {
    return strings;
  }

  [[deprecated("Use `FOO.strings_ref() = BAR;` instead of `FOO.set_strings(BAR);`")]]
  ::std::int32_t& set_strings(::std::int32_t strings_) {
    strings = strings_;
    __isset.strings = true;
    return strings;
  }

  ::std::int32_t get_type() const {
    return type;
  }

  [[deprecated("Use `FOO.type_ref() = BAR;` instead of `FOO.set_type(BAR);`")]]
  ::std::int32_t& set_type(::std::int32_t type_) {
    type = type_;
    __isset.type = true;
    return type;
  }

  ::std::int32_t get_value() const {
    return value;
  }

  [[deprecated("Use `FOO.value_ref() = BAR;` instead of `FOO.set_value(BAR);`")]]
  ::std::int32_t& set_value(::std::int32_t value_) {
    value = value_;
    __isset.value = true;
    return value;
  }

  ::std::int32_t get_value_to_name() const {
    return value_to_name;
  }

  [[deprecated("Use `FOO.value_to_name_ref() = BAR;` instead of `FOO.set_value_to_name(BAR);`")]]
  ::std::int32_t& set_value_to_name(::std::int32_t value_to_name_) {
    value_to_name = value_to_name_;
    __isset.value_to_name = true;
    return value_to_name;
  }

  ::std::int32_t get_values() const {
    return values;
  }

  [[deprecated("Use `FOO.values_ref() = BAR;` instead of `FOO.set_values(BAR);`")]]
  ::std::int32_t& set_values(::std::int32_t values_) {
    values = values_;
    __isset.values = true;
    return values;
  }

  ::std::int32_t get_id() const {
    return id;
  }

  [[deprecated("Use `FOO.id_ref() = BAR;` instead of `FOO.set_id(BAR);`")]]
  ::std::int32_t& set_id(::std::int32_t id_) {
    id = id_;
    __isset.id = true;
    return id;
  }

  ::std::int32_t get_ids() const {
    return ids;
  }

  [[deprecated("Use `FOO.ids_ref() = BAR;` instead of `FOO.set_ids(BAR);`")]]
  ::std::int32_t& set_ids(::std::int32_t ids_) {
    ids = ids_;
    __isset.ids = true;
    return ids;
  }

  ::std::int32_t get_descriptor() const {
    return descriptor;
  }

  [[deprecated("Use `FOO.descriptor_ref() = BAR;` instead of `FOO.set_descriptor(BAR);`")]]
  ::std::int32_t& set_descriptor(::std::int32_t descriptor_) {
    descriptor = descriptor_;
    __isset.descriptor = true;
    return descriptor;
  }

  ::std::int32_t get_descriptors() const {
    return descriptors;
  }

  [[deprecated("Use `FOO.descriptors_ref() = BAR;` instead of `FOO.set_descriptors(BAR);`")]]
  ::std::int32_t& set_descriptors(::std::int32_t descriptors_) {
    descriptors = descriptors_;
    __isset.descriptors = true;
    return descriptors;
  }

  ::std::int32_t get_key() const {
    return key;
  }

  [[deprecated("Use `FOO.key_ref() = BAR;` instead of `FOO.set_key(BAR);`")]]
  ::std::int32_t& set_key(::std::int32_t key_) {
    key = key_;
    __isset.key = true;
    return key;
  }

  ::std::int32_t get_keys() const {
    return keys;
  }

  [[deprecated("Use `FOO.keys_ref() = BAR;` instead of `FOO.set_keys(BAR);`")]]
  ::std::int32_t& set_keys(::std::int32_t keys_) {
    keys = keys_;
    __isset.keys = true;
    return keys;
  }

  ::std::int32_t get_annotation() const {
    return annotation;
  }

  [[deprecated("Use `FOO.annotation_ref() = BAR;` instead of `FOO.set_annotation(BAR);`")]]
  ::std::int32_t& set_annotation(::std::int32_t annotation_) {
    annotation = annotation_;
    __isset.annotation = true;
    return annotation;
  }

  ::std::int32_t get_annotations() const {
    return annotations;
  }

  [[deprecated("Use `FOO.annotations_ref() = BAR;` instead of `FOO.set_annotations(BAR);`")]]
  ::std::int32_t& set_annotations(::std::int32_t annotations_) {
    annotations = annotations_;
    __isset.annotations = true;
    return annotations;
  }

  ::std::int32_t get_member() const {
    return member;
  }

  [[deprecated("Use `FOO.member_ref() = BAR;` instead of `FOO.set_member(BAR);`")]]
  ::std::int32_t& set_member(::std::int32_t member_) {
    member = member_;
    __isset.member = true;
    return member;
  }

  ::std::int32_t get_members() const {
    return members;
  }

  [[deprecated("Use `FOO.members_ref() = BAR;` instead of `FOO.set_members(BAR);`")]]
  ::std::int32_t& set_members(::std::int32_t members_) {
    members = members_;
    __isset.members = true;
    return members;
  }

  ::std::int32_t get_field() const {
    return field;
  }

  [[deprecated("Use `FOO.field_ref() = BAR;` instead of `FOO.set_field(BAR);`")]]
  ::std::int32_t& set_field(::std::int32_t field_) {
    field = field_;
    __isset.field = true;
    return field;
  }

  ::std::int32_t get_fields() const {
    return fields;
  }

  [[deprecated("Use `FOO.fields_ref() = BAR;` instead of `FOO.set_fields(BAR);`")]]
  ::std::int32_t& set_fields(::std::int32_t fields_) {
    fields = fields_;
    __isset.fields = true;
    return fields;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct_with_special_names>;
  friend void swap(struct_with_special_names& a, struct_with_special_names& b);
};

template <class Protocol_>
uint32_t struct_with_special_names::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class struct_with_indirections final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = struct_with_indirections;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  struct_with_indirections();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_with_indirections(apache::thrift::FragileConstructor, ::std::int32_t real__arg, ::test_cpp2::cpp_reflection::FakeI32 fake__arg, ::test_cpp2::cpp_reflection::HasANumber number__arg, ::test_cpp2::cpp_reflection::HasAResult result__arg, ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg);

  struct_with_indirections(struct_with_indirections&&) noexcept;

  struct_with_indirections(const struct_with_indirections& src);


  struct_with_indirections& operator=(struct_with_indirections&&) noexcept;
  struct_with_indirections& operator=(const struct_with_indirections& src);
  void __clear();

  ~struct_with_indirections();

 private:
  ::std::int32_t real;
 private:
  ::test_cpp2::cpp_reflection::FakeI32 fake;
 private:
  ::test_cpp2::cpp_reflection::HasANumber number;
 private:
  ::test_cpp2::cpp_reflection::HasAResult result;
 private:
  ::test_cpp2::cpp_reflection::HasAPhrase phrase;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool real;
    bool fake;
    bool number;
    bool result;
    bool phrase;
  } __isset = {};

 public:

  bool operator==(const struct_with_indirections&) const;
  bool operator<(const struct_with_indirections&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> real_ref() const& {
    return {this->real, __isset.real};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> real_ref() const&& {
    return {std::move(this->real), __isset.real};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> real_ref() & {
    return {this->real, __isset.real};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> real_ref() && {
    return {std::move(this->real), __isset.real};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::FakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fake_ref() const& {
    return {this->fake, __isset.fake};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::FakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fake_ref() const&& {
    return {std::move(this->fake), __isset.fake};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::FakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fake_ref() & {
    return {this->fake, __isset.fake};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::FakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fake_ref() && {
    return {std::move(this->fake), __isset.fake};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasANumber>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> number_ref() const& {
    return {this->number, __isset.number};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasANumber>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> number_ref() const&& {
    return {std::move(this->number), __isset.number};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasANumber>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> number_ref() & {
    return {this->number, __isset.number};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasANumber>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> number_ref() && {
    return {std::move(this->number), __isset.number};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> result_ref() const& {
    return {this->result, __isset.result};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> result_ref() const&& {
    return {std::move(this->result), __isset.result};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> result_ref() & {
    return {this->result, __isset.result};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> result_ref() && {
    return {std::move(this->result), __isset.result};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAPhrase>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> phrase_ref() const& {
    return {this->phrase, __isset.phrase};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAPhrase>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> phrase_ref() const&& {
    return {std::move(this->phrase), __isset.phrase};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAPhrase>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> phrase_ref() & {
    return {this->phrase, __isset.phrase};
  }

  template <typename..., typename T = ::test_cpp2::cpp_reflection::HasAPhrase>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> phrase_ref() && {
    return {std::move(this->phrase), __isset.phrase};
  }

  ::std::int32_t get_real() const {
    return real;
  }

  [[deprecated("Use `FOO.real_ref() = BAR;` instead of `FOO.set_real(BAR);`")]]
  ::std::int32_t& set_real(::std::int32_t real_) {
    real = real_;
    __isset.real = true;
    return real;
  }

  ::test_cpp2::cpp_reflection::FakeI32 get_fake() const {
    return fake;
  }

  [[deprecated("Use `FOO.fake_ref() = BAR;` instead of `FOO.set_fake(BAR);`")]]
  ::test_cpp2::cpp_reflection::FakeI32& set_fake(::test_cpp2::cpp_reflection::FakeI32 fake_) {
    fake = fake_;
    __isset.fake = true;
    return fake;
  }

  ::test_cpp2::cpp_reflection::HasANumber get_number() const {
    return number;
  }

  [[deprecated("Use `FOO.number_ref() = BAR;` instead of `FOO.set_number(BAR);`")]]
  ::test_cpp2::cpp_reflection::HasANumber& set_number(::test_cpp2::cpp_reflection::HasANumber number_) {
    number = number_;
    __isset.number = true;
    return number;
  }

  ::test_cpp2::cpp_reflection::HasAResult get_result() const {
    return result;
  }

  [[deprecated("Use `FOO.result_ref() = BAR;` instead of `FOO.set_result(BAR);`")]]
  ::test_cpp2::cpp_reflection::HasAResult& set_result(::test_cpp2::cpp_reflection::HasAResult result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const ::test_cpp2::cpp_reflection::HasAPhrase& get_phrase() const& {
    return phrase;
  }

  ::test_cpp2::cpp_reflection::HasAPhrase get_phrase() && {
    return std::move(phrase);
  }

  template <typename T_struct_with_indirections_phrase_struct_setter = ::test_cpp2::cpp_reflection::HasAPhrase>
  [[deprecated("Use `FOO.phrase_ref() = BAR;` instead of `FOO.set_phrase(BAR);`")]]
  ::test_cpp2::cpp_reflection::HasAPhrase& set_phrase(T_struct_with_indirections_phrase_struct_setter&& phrase_) {
    phrase = std::forward<T_struct_with_indirections_phrase_struct_setter>(phrase_);
    __isset.phrase = true;
    return phrase;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<struct_with_indirections>;
  friend void swap(struct_with_indirections& a, struct_with_indirections& b);
};

template <class Protocol_>
uint32_t struct_with_indirections::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::union1::Type> {
  using type = ::test_cpp2::cpp_reflection::union1::Type;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::union2::Type> {
  using type = ::test_cpp2::cpp_reflection::union2::Type;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::union3::Type> {
  using type = ::test_cpp2::cpp_reflection::union3::Type;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type> {
  using type = ::test_cpp2::cpp_reflection::unionA::Type;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type> {
  using type = ::test_cpp2::cpp_reflection::union_with_special_names::Type;

  static constexpr std::size_t const size = 28;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
