/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace test_cpp2 { namespace cpp_reflection {

class union1;
class union2;
class union3;
class structA;
class unionA;
class structB;
class structC;
class struct1;
class struct2;
class struct3;

enum class enum1 {
  field0 = 0,
  field1 = 1,
  field2 = 2
};

extern const std::map<enum1, const char*> _enum1_VALUES_TO_NAMES;
extern const std::map<const char*, enum1, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum1> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum1> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum1 TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::min() {
  return  ::test_cpp2::cpp_reflection::enum1::field0;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum1 TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::max() {
  return  ::test_cpp2::cpp_reflection::enum1::field2;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum class enum2 {
  field0_2 = 0,
  field1_2 = 1,
  field2_2 = 2
};

extern const std::map<enum2, const char*> _enum2_VALUES_TO_NAMES;
extern const std::map<const char*, enum2, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum2> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum2> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum2 TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::min() {
  return  ::test_cpp2::cpp_reflection::enum2::field0_2;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum2 TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::max() {
  return  ::test_cpp2::cpp_reflection::enum2::field2_2;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum class enum3 {
  field0_3 = 0,
  field1_3 = 1,
  field2_3 = 2
};

extern const std::map<enum3, const char*> _enum3_VALUES_TO_NAMES;
extern const std::map<const char*, enum3, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection
namespace std {

template<> struct hash<typename  ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_hash<typename  ::test_cpp2::cpp_reflection::enum3> {};
template<> struct equal_to<typename  ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_equal_to<typename  ::test_cpp2::cpp_reflection::enum3> {};

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value);
template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue);

template <> constexpr  ::test_cpp2::cpp_reflection::enum3 TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::min() {
  return  ::test_cpp2::cpp_reflection::enum3::field0_3;
}

template <> constexpr  ::test_cpp2::cpp_reflection::enum3 TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::max() {
  return  ::test_cpp2::cpp_reflection::enum3::field2_3;
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union1 : private boost::totally_ordered<union1> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui = 1,
    ud = 2,
    us = 3,
    ue = 4,
  } ;

  union1() :
      type_(Type::__EMPTY__) {}

  union1(union1&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union1(const union1& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union1& operator=(union1&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union1& operator=(const union1& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union1() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui;
    double ud;
    std::string us;
     ::test_cpp2::cpp_reflection::enum1 ue;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union1& rhs) const;

  bool operator < (const union1& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui:
      {
        return value_.ui < rhs.value_.ui;
        break;
      }
      case Type::ud:
      {
        return value_.ud < rhs.value_.ud;
        break;
      }
      case Type::us:
      {
        return value_.us < rhs.value_.us;
        break;
      }
      case Type::ue:
      {
        return value_.ue < rhs.value_.ue;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  int32_t& set_ui(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui;
    ::new (std::addressof(value_.ui)) int32_t(t);
    return value_.ui;
  }

  double& set_ud(double t = double()) {
    __clear();
    type_ = Type::ud;
    ::new (std::addressof(value_.ud)) double(t);
    return value_.ud;
  }

  std::string& set_us(std::string const &t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) std::string(t);
    return value_.us;
  }

  std::string& set_us(std::string&& t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) std::string(std::move(t));
    return value_.us;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_us(T&&... t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) std::string(std::forward<T>(t)...);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue;
    ::new (std::addressof(value_.ue))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue;
  }

  int32_t const & get_ui() const {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double const & get_ud() const {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  std::string const & get_us() const {
    assert(type_ == Type::us);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue() const {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t & mutable_ui() {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double & mutable_ud() {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  std::string & mutable_us() {
    assert(type_ == Type::us);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue() {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t move_ui() {
    assert(type_ == Type::ui);
    return std::move(value_.ui);
  }

  double move_ud() {
    assert(type_ == Type::ud);
    return std::move(value_.ud);
  }

  std::string move_us() {
    assert(type_ == Type::us);
    return std::move(value_.us);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue() {
    assert(type_ == Type::ue);
    return std::move(value_.ue);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union1& a, union1& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::clear( ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union1>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union1* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union2 : private boost::totally_ordered<union2> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_2 = 1,
    ud_2 = 2,
    us_2 = 3,
    ue_2 = 4,
  } ;

  union2() :
      type_(Type::__EMPTY__) {}

  union2(union2&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union2(const union2& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union2& operator=(union2&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union2& operator=(const union2& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union2() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_2;
    double ud_2;
    std::string us_2;
     ::test_cpp2::cpp_reflection::enum1 ue_2;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union2& rhs) const;

  bool operator < (const union2& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui_2:
      {
        return value_.ui_2 < rhs.value_.ui_2;
        break;
      }
      case Type::ud_2:
      {
        return value_.ud_2 < rhs.value_.ud_2;
        break;
      }
      case Type::us_2:
      {
        return value_.us_2 < rhs.value_.us_2;
        break;
      }
      case Type::ue_2:
      {
        return value_.ue_2 < rhs.value_.ue_2;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  int32_t& set_ui_2(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui_2;
    ::new (std::addressof(value_.ui_2)) int32_t(t);
    return value_.ui_2;
  }

  double& set_ud_2(double t = double()) {
    __clear();
    type_ = Type::ud_2;
    ::new (std::addressof(value_.ud_2)) double(t);
    return value_.ud_2;
  }

  std::string& set_us_2(std::string const &t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) std::string(t);
    return value_.us_2;
  }

  std::string& set_us_2(std::string&& t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) std::string(std::move(t));
    return value_.us_2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_us_2(T&&... t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) std::string(std::forward<T>(t)...);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue_2( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_2;
    ::new (std::addressof(value_.ue_2))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_2;
  }

  int32_t const & get_ui_2() const {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double const & get_ud_2() const {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  std::string const & get_us_2() const {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue_2() const {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t & mutable_ui_2() {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double & mutable_ud_2() {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  std::string & mutable_us_2() {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue_2() {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t move_ui_2() {
    assert(type_ == Type::ui_2);
    return std::move(value_.ui_2);
  }

  double move_ud_2() {
    assert(type_ == Type::ud_2);
    return std::move(value_.ud_2);
  }

  std::string move_us_2() {
    assert(type_ == Type::us_2);
    return std::move(value_.us_2);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_2() {
    assert(type_ == Type::ue_2);
    return std::move(value_.ue_2);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union2& a, union2& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::clear( ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union2>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union2* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class union3 : private boost::totally_ordered<union3> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_3 = 1,
    ud_3 = 2,
    us_3 = 3,
    ue_3 = 4,
  } ;

  union3() :
      type_(Type::__EMPTY__) {}

  union3(union3&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union3(const union3& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union3& operator=(union3&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union3& operator=(const union3& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~union3() throw() {
    __clear();
  }

  union storage_type {
    int32_t ui_3;
    double ud_3;
    std::string us_3;
     ::test_cpp2::cpp_reflection::enum1 ue_3;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union3& rhs) const;

  bool operator < (const union3& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::ui_3:
      {
        return value_.ui_3 < rhs.value_.ui_3;
        break;
      }
      case Type::ud_3:
      {
        return value_.ud_3 < rhs.value_.ud_3;
        break;
      }
      case Type::us_3:
      {
        return value_.us_3 < rhs.value_.us_3;
        break;
      }
      case Type::ue_3:
      {
        return value_.ue_3 < rhs.value_.ue_3;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  int32_t& set_ui_3(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui_3;
    ::new (std::addressof(value_.ui_3)) int32_t(t);
    return value_.ui_3;
  }

  double& set_ud_3(double t = double()) {
    __clear();
    type_ = Type::ud_3;
    ::new (std::addressof(value_.ud_3)) double(t);
    return value_.ud_3;
  }

  std::string& set_us_3(std::string const &t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) std::string(t);
    return value_.us_3;
  }

  std::string& set_us_3(std::string&& t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) std::string(std::move(t));
    return value_.us_3;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_us_3(T&&... t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) std::string(std::forward<T>(t)...);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue_3( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_3;
    ::new (std::addressof(value_.ue_3))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_3;
  }

  int32_t const & get_ui_3() const {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double const & get_ud_3() const {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  std::string const & get_us_3() const {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue_3() const {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t & mutable_ui_3() {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double & mutable_ud_3() {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  std::string & mutable_us_3() {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue_3() {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t move_ui_3() {
    assert(type_ == Type::ui_3);
    return std::move(value_.ui_3);
  }

  double move_ud_3() {
    assert(type_ == Type::ud_3);
    return std::move(value_.ud_3);
  }

  std::string move_us_3() {
    assert(type_ == Type::us_3);
    return std::move(value_.us_3);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_3() {
    assert(type_ == Type::ue_3);
    return std::move(value_.ue_3);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(union3& a, union3& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::clear( ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::union3>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::union3* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class structA : private boost::totally_ordered<structA> {
 public:

  structA() :
      a(0) {}
  // FragileConstructor for use in initialization lists only

  structA(apache::thrift::FragileConstructor, int32_t a__arg, std::string b__arg) :
      a(std::move(a__arg)),
      b(std::move(b__arg)) {}

  structA(structA&&) = default;

  structA(const structA&) = default;

  structA& operator=(structA&&) = default;

  structA& operator=(const structA&) = default;
  void __clear();

  virtual ~structA() throw() {}

  int32_t a;
  std::string b;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      a = false;
      b = false;
    }

    bool a;
    bool b;
  } __isset;
  bool operator==(const structA& rhs) const;

  bool operator < (const structA& rhs) const {
    if (!(a == rhs.a)) {
      return a < rhs.a;
    }
    if (!(b == rhs.b)) {
      return b < rhs.b;
    }
    return false;
  }

  int32_t get_a() const {
    return a;
  }

  void set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
  }

  const std::string& get_b() const& {
    return b;
  }

  std::string get_b() && {
    return std::move(b);
  }

  template <typename T>
  void set_b(T&& b_) {
    b = std::forward<T>(b_);
    __isset.b = true;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(structA& a, structA& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::clear( ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structA>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::structA* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class unionA : private boost::totally_ordered<unionA> {
 public:
  enum Type {
    __EMPTY__ = 0,
    i = 1,
    d = 2,
    s = 3,
    e = 4,
    a = 5,
  } ;

  unionA() :
      type_(Type::__EMPTY__) {}

  unionA(unionA&& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  unionA(const unionA& rhs) :
      type_(Type::__EMPTY__) {
    if (this == &rhs) {return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch(rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  unionA& operator=(unionA&& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  unionA& operator=(const unionA& rhs) {
    if (this == &rhs) {return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch(rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~unionA() throw() {
    __clear();
  }

  union storage_type {
    int32_t i;
    double d;
    std::string s;
     ::test_cpp2::cpp_reflection::enum1 e;
     ::test_cpp2::cpp_reflection::structA a;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const unionA& rhs) const;

  bool operator < (const unionA& rhs) const {
    if (type_ != rhs.type_) { return type_ < rhs.type_; }
    switch(type_) {
      case Type::i:
      {
        return value_.i < rhs.value_.i;
        break;
      }
      case Type::d:
      {
        return value_.d < rhs.value_.d;
        break;
      }
      case Type::s:
      {
        return value_.s < rhs.value_.s;
        break;
      }
      case Type::e:
      {
        return value_.e < rhs.value_.e;
        break;
      }
      case Type::a:
      {
        return value_.a < rhs.value_.a;
        break;
      }
      default:
      {
        return false;
        break;
      }
    }
  }

  int32_t& set_i(int32_t t = int32_t()) {
    __clear();
    type_ = Type::i;
    ::new (std::addressof(value_.i)) int32_t(t);
    return value_.i;
  }

  double& set_d(double t = double()) {
    __clear();
    type_ = Type::d;
    ::new (std::addressof(value_.d)) double(t);
    return value_.d;
  }

  std::string& set_s(std::string const &t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) std::string(t);
    return value_.s;
  }

  std::string& set_s(std::string&& t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) std::string(std::move(t));
    return value_.s;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_s(T&&... t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) std::string(std::forward<T>(t)...);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1& set_e( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::e;
    ::new (std::addressof(value_.e))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA& set_a( ::test_cpp2::cpp_reflection::structA const &t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(t);
    return value_.a;
  }

   ::test_cpp2::cpp_reflection::structA& set_a( ::test_cpp2::cpp_reflection::structA&& t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(std::move(t));
    return value_.a;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::test_cpp2::cpp_reflection::structA, T...>>  ::test_cpp2::cpp_reflection::structA& set_a(T&&... t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(std::forward<T>(t)...);
    return value_.a;
  }

  int32_t const & get_i() const {
    assert(type_ == Type::i);
    return value_.i;
  }

  double const & get_d() const {
    assert(type_ == Type::d);
    return value_.d;
  }

  std::string const & get_s() const {
    assert(type_ == Type::s);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_e() const {
    assert(type_ == Type::e);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA const & get_a() const {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t & mutable_i() {
    assert(type_ == Type::i);
    return value_.i;
  }

  double & mutable_d() {
    assert(type_ == Type::d);
    return value_.d;
  }

  std::string & mutable_s() {
    assert(type_ == Type::s);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_e() {
    assert(type_ == Type::e);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA & mutable_a() {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t move_i() {
    assert(type_ == Type::i);
    return std::move(value_.i);
  }

  double move_d() {
    assert(type_ == Type::d);
    return std::move(value_.d);
  }

  std::string move_s() {
    assert(type_ == Type::s);
    return std::move(value_.s);
  }

   ::test_cpp2::cpp_reflection::enum1 move_e() {
    assert(type_ == Type::e);
    return std::move(value_.e);
  }

   ::test_cpp2::cpp_reflection::structA move_a() {
    assert(type_ == Type::a);
    return std::move(value_.a);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
};

void swap(unionA& a, unionA& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::clear( ::test_cpp2::cpp_reflection::unionA* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::unionA* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::unionA* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::unionA* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::unionA>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::unionA* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class structB : private boost::totally_ordered<structB> {
 public:

  structB() :
      c(0),
      d(0) {}
  // FragileConstructor for use in initialization lists only

  structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
      c(std::move(c__arg)),
      d(std::move(d__arg)) {}

  structB(structB&&) = default;

  structB(const structB&) = default;

  structB& operator=(structB&&) = default;

  structB& operator=(const structB&) = default;
  void __clear();

  virtual ~structB() throw() {}

  double c;
  bool d;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      c = false;
      d = false;
    }

    bool c;
    bool d;
  } __isset;
  bool operator==(const structB& rhs) const;

  bool operator < (const structB& rhs) const {
    if (!(c == rhs.c)) {
      return c < rhs.c;
    }
    if (!(d == rhs.d)) {
      return d < rhs.d;
    }
    return false;
  }

  double get_c() const {
    return c;
  }

  void set_c(double c_) {
    c = c_;
    __isset.c = true;
  }

  bool get_d() const {
    return d;
  }

  void set_d(bool d_) {
    d = d_;
    __isset.d = true;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(structB& a, structB& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::clear( ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structB>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::structB* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class structC : private boost::totally_ordered<structC> {
 public:

  structC() :
      a(0),
      c(0),
      d(0),
      e( ::test_cpp2::cpp_reflection::enum1()),
      f( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  structC(apache::thrift::FragileConstructor, int32_t a__arg, std::string b__arg, double c__arg, bool d__arg,  ::test_cpp2::cpp_reflection::enum1 e__arg,  ::test_cpp2::cpp_reflection::enum2 f__arg,  ::test_cpp2::cpp_reflection::union1 g__arg,  ::test_cpp2::cpp_reflection::unionA h__arg,  ::test_cpp2::cpp_reflection::unionA i__arg, std::vector<int32_t> j__arg, std::vector<int32_t> j1__arg, std::vector< ::test_cpp2::cpp_reflection::enum1> j2__arg, std::vector< ::test_cpp2::cpp_reflection::structA> j3__arg, std::set<int32_t> k__arg, std::set<int32_t> k1__arg, std::set< ::test_cpp2::cpp_reflection::enum2> k2__arg, std::set< ::test_cpp2::cpp_reflection::structB> k3__arg, std::map<int32_t, int32_t> l__arg, std::map<int32_t, int32_t> l1__arg, std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2__arg, std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3__arg, std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1__arg, std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2__arg, std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3__arg, std::map<std::string, int32_t> n1__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> n2__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structB> n3__arg, std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1__arg, std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2__arg, std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3__arg) :
      a(std::move(a__arg)),
      b(std::move(b__arg)),
      c(std::move(c__arg)),
      d(std::move(d__arg)),
      e(std::move(e__arg)),
      f(std::move(f__arg)),
      g(std::move(g__arg)),
      h(std::move(h__arg)),
      i(std::move(i__arg)),
      j(std::move(j__arg)),
      j1(std::move(j1__arg)),
      j2(std::move(j2__arg)),
      j3(std::move(j3__arg)),
      k(std::move(k__arg)),
      k1(std::move(k1__arg)),
      k2(std::move(k2__arg)),
      k3(std::move(k3__arg)),
      l(std::move(l__arg)),
      l1(std::move(l1__arg)),
      l2(std::move(l2__arg)),
      l3(std::move(l3__arg)),
      m1(std::move(m1__arg)),
      m2(std::move(m2__arg)),
      m3(std::move(m3__arg)),
      n1(std::move(n1__arg)),
      n2(std::move(n2__arg)),
      n3(std::move(n3__arg)),
      o1(std::move(o1__arg)),
      o2(std::move(o2__arg)),
      o3(std::move(o3__arg)) {}

  structC(structC&&) = default;

  structC(const structC&) = default;

  structC& operator=(structC&&) = default;

  structC& operator=(const structC&) = default;
  void __clear();

  virtual ~structC() throw() {}

  int32_t a;
  std::string b;
  double c;
  bool d;
   ::test_cpp2::cpp_reflection::enum1 e;
   ::test_cpp2::cpp_reflection::enum2 f;
   ::test_cpp2::cpp_reflection::union1 g;
   ::test_cpp2::cpp_reflection::unionA h;
   ::test_cpp2::cpp_reflection::unionA i;
  std::vector<int32_t> j;
  std::vector<int32_t> j1;
  std::vector< ::test_cpp2::cpp_reflection::enum1> j2;
  std::vector< ::test_cpp2::cpp_reflection::structA> j3;
  std::set<int32_t> k;
  std::set<int32_t> k1;
  std::set< ::test_cpp2::cpp_reflection::enum2> k2;
  std::set< ::test_cpp2::cpp_reflection::structB> k3;
  std::map<int32_t, int32_t> l;
  std::map<int32_t, int32_t> l1;
  std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2;
  std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3;
  std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1;
  std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2;
  std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3;
  std::map<std::string, int32_t> n1;
  std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> n2;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structB> n3;
  std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1;
  std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2;
  std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      a = false;
      b = false;
      c = false;
      d = false;
      e = false;
      f = false;
      g = false;
      h = false;
      i = false;
      j = false;
      j1 = false;
      j2 = false;
      j3 = false;
      k = false;
      k1 = false;
      k2 = false;
      k3 = false;
      l = false;
      l1 = false;
      l2 = false;
      l3 = false;
      m1 = false;
      m2 = false;
      m3 = false;
      n1 = false;
      n2 = false;
      n3 = false;
      o1 = false;
      o2 = false;
      o3 = false;
    }

    bool a;
    bool b;
    bool c;
    bool d;
    bool e;
    bool f;
    bool g;
    bool h;
    bool i;
    bool j;
    bool j1;
    bool j2;
    bool j3;
    bool k;
    bool k1;
    bool k2;
    bool k3;
    bool l;
    bool l1;
    bool l2;
    bool l3;
    bool m1;
    bool m2;
    bool m3;
    bool n1;
    bool n2;
    bool n3;
    bool o1;
    bool o2;
    bool o3;
  } __isset;
  bool operator==(const structC& rhs) const;

  bool operator < (const structC& rhs) const {
    if (!(a == rhs.a)) {
      return a < rhs.a;
    }
    if (!(b == rhs.b)) {
      return b < rhs.b;
    }
    if (!(c == rhs.c)) {
      return c < rhs.c;
    }
    if (!(d == rhs.d)) {
      return d < rhs.d;
    }
    if (!(e == rhs.e)) {
      return e < rhs.e;
    }
    if (!(f == rhs.f)) {
      return f < rhs.f;
    }
    if (!(g == rhs.g)) {
      return g < rhs.g;
    }
    if (!(h == rhs.h)) {
      return h < rhs.h;
    }
    if (!(i == rhs.i)) {
      return i < rhs.i;
    }
    if (!(j == rhs.j)) {
      return j < rhs.j;
    }
    if (!(j1 == rhs.j1)) {
      return j1 < rhs.j1;
    }
    if (!(j2 == rhs.j2)) {
      return j2 < rhs.j2;
    }
    if (!(j3 == rhs.j3)) {
      return j3 < rhs.j3;
    }
    if (!(k == rhs.k)) {
      return k < rhs.k;
    }
    if (!(k1 == rhs.k1)) {
      return k1 < rhs.k1;
    }
    if (!(k2 == rhs.k2)) {
      return k2 < rhs.k2;
    }
    if (!(k3 == rhs.k3)) {
      return k3 < rhs.k3;
    }
    if (!(l == rhs.l)) {
      return l < rhs.l;
    }
    if (!(l1 == rhs.l1)) {
      return l1 < rhs.l1;
    }
    if (!(l2 == rhs.l2)) {
      return l2 < rhs.l2;
    }
    if (!(l3 == rhs.l3)) {
      return l3 < rhs.l3;
    }
    if (!(m1 == rhs.m1)) {
      return m1 < rhs.m1;
    }
    if (!(m2 == rhs.m2)) {
      return m2 < rhs.m2;
    }
    if (!(m3 == rhs.m3)) {
      return m3 < rhs.m3;
    }
    if (!(n1 == rhs.n1)) {
      return n1 < rhs.n1;
    }
    if (!(n2 == rhs.n2)) {
      return n2 < rhs.n2;
    }
    if (!(n3 == rhs.n3)) {
      return n3 < rhs.n3;
    }
    if (!(o1 == rhs.o1)) {
      return o1 < rhs.o1;
    }
    if (!(o2 == rhs.o2)) {
      return o2 < rhs.o2;
    }
    if (!(o3 == rhs.o3)) {
      return o3 < rhs.o3;
    }
    return false;
  }

  int32_t get_a() const {
    return a;
  }

  void set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
  }

  const std::string& get_b() const& {
    return b;
  }

  std::string get_b() && {
    return std::move(b);
  }

  template <typename T>
  void set_b(T&& b_) {
    b = std::forward<T>(b_);
    __isset.b = true;
  }

  double get_c() const {
    return c;
  }

  void set_c(double c_) {
    c = c_;
    __isset.c = true;
  }

  bool get_d() const {
    return d;
  }

  void set_d(bool d_) {
    d = d_;
    __isset.d = true;
  }

   ::test_cpp2::cpp_reflection::enum1 get_e() const {
    return e;
  }

  void set_e( ::test_cpp2::cpp_reflection::enum1 e_) {
    e = e_;
    __isset.e = true;
  }

   ::test_cpp2::cpp_reflection::enum2 get_f() const {
    return f;
  }

  void set_f( ::test_cpp2::cpp_reflection::enum2 f_) {
    f = f_;
    __isset.f = true;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_g() const&;
   ::test_cpp2::cpp_reflection::union1 get_g() &&;
  template <typename T>
  void set_g(T&& g_);
  const  ::test_cpp2::cpp_reflection::unionA& get_h() const&;
   ::test_cpp2::cpp_reflection::unionA get_h() &&;
  template <typename T>
  void set_h(T&& h_);
  const  ::test_cpp2::cpp_reflection::unionA& get_i() const&;
   ::test_cpp2::cpp_reflection::unionA get_i() &&;
  template <typename T>
  void set_i(T&& i_);
  const std::vector<int32_t>& get_j() const&;
  std::vector<int32_t> get_j() &&;
  template <typename T>
  void set_j(T&& j_);
  const std::vector<int32_t>& get_j1() const&;
  std::vector<int32_t> get_j1() &&;
  template <typename T>
  void set_j1(T&& j1_);
  const std::vector< ::test_cpp2::cpp_reflection::enum1>& get_j2() const&;
  std::vector< ::test_cpp2::cpp_reflection::enum1> get_j2() &&;
  template <typename T>
  void set_j2(T&& j2_);
  const std::vector< ::test_cpp2::cpp_reflection::structA>& get_j3() const&;
  std::vector< ::test_cpp2::cpp_reflection::structA> get_j3() &&;
  template <typename T>
  void set_j3(T&& j3_);
  const std::set<int32_t>& get_k() const&;
  std::set<int32_t> get_k() &&;
  template <typename T>
  void set_k(T&& k_);
  const std::set<int32_t>& get_k1() const&;
  std::set<int32_t> get_k1() &&;
  template <typename T>
  void set_k1(T&& k1_);
  const std::set< ::test_cpp2::cpp_reflection::enum2>& get_k2() const&;
  std::set< ::test_cpp2::cpp_reflection::enum2> get_k2() &&;
  template <typename T>
  void set_k2(T&& k2_);
  const std::set< ::test_cpp2::cpp_reflection::structB>& get_k3() const&;
  std::set< ::test_cpp2::cpp_reflection::structB> get_k3() &&;
  template <typename T>
  void set_k3(T&& k3_);
  const std::map<int32_t, int32_t>& get_l() const&;
  std::map<int32_t, int32_t> get_l() &&;
  template <typename T>
  void set_l(T&& l_);
  const std::map<int32_t, int32_t>& get_l1() const&;
  std::map<int32_t, int32_t> get_l1() &&;
  template <typename T>
  void set_l1(T&& l1_);
  const std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& get_l2() const&;
  std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> get_l2() &&;
  template <typename T>
  void set_l2(T&& l2_);
  const std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& get_l3() const&;
  std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> get_l3() &&;
  template <typename T>
  void set_l3(T&& l3_);
  const std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& get_m1() const&;
  std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> get_m1() &&;
  template <typename T>
  void set_m1(T&& m1_);
  const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& get_m2() const&;
  std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> get_m2() &&;
  template <typename T>
  void set_m2(T&& m2_);
  const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& get_m3() const&;
  std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> get_m3() &&;
  template <typename T>
  void set_m3(T&& m3_);
  const std::map<std::string, int32_t>& get_n1() const&;
  std::map<std::string, int32_t> get_n1() &&;
  template <typename T>
  void set_n1(T&& n1_);
  const std::map<std::string,  ::test_cpp2::cpp_reflection::enum1>& get_n2() const&;
  std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> get_n2() &&;
  template <typename T>
  void set_n2(T&& n2_);
  const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& get_n3() const&;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structB> get_n3() &&;
  template <typename T>
  void set_n3(T&& n3_);
  const std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& get_o1() const&;
  std::map< ::test_cpp2::cpp_reflection::structA, int32_t> get_o1() &&;
  template <typename T>
  void set_o1(T&& o1_);
  const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& get_o2() const&;
  std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> get_o2() &&;
  template <typename T>
  void set_o2(T&& o2_);
  const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& get_o3() const&;
  std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> get_o3() &&;
  template <typename T>
  void set_o3(T&& o3_);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(structC& a, structC& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::clear( ::test_cpp2::cpp_reflection::structC* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::structC* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::structC* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::structC* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::structC>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::structC* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct1 : private boost::totally_ordered<struct1> {
 public:

  struct1() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1()),
      field3( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct1(apache::thrift::FragileConstructor, int32_t field0__arg, std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::enum2 field3__arg,  ::test_cpp2::cpp_reflection::union1 field4__arg,  ::test_cpp2::cpp_reflection::union2 field5__arg) :
      field0(std::move(field0__arg)),
      field1(std::move(field1__arg)),
      field2(std::move(field2__arg)),
      field3(std::move(field3__arg)),
      field4(std::move(field4__arg)),
      field5(std::move(field5__arg)) {}

  struct1(struct1&&) = default;

  struct1(const struct1&) = default;

  struct1& operator=(struct1&&) = default;

  struct1& operator=(const struct1&) = default;
  void __clear();

  virtual ~struct1() throw() {}

  int32_t field0;
  std::string field1;
   ::test_cpp2::cpp_reflection::enum1 field2;
   ::test_cpp2::cpp_reflection::enum2 field3;
   ::test_cpp2::cpp_reflection::union1 field4;
   ::test_cpp2::cpp_reflection::union2 field5;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      field1 = false;
      field2 = false;
      field4 = false;
      field5 = false;
    }

    bool field1;
    bool field2;
    bool field4;
    bool field5;
  } __isset;
  bool operator==(const struct1& rhs) const;
  bool operator < (const struct1& rhs) const;

  int32_t get_field0() const {
    return field0;
  }

  void set_field0(int32_t field0_) {
    field0 = field0_;
  }

  const std::string* get_field1() const& {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }

  std::string* get_field1() & {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }
  std::string* get_field1() && = delete;

  template <typename T>
  void set_field1(T&& field1_) {
    field1 = std::forward<T>(field1_);
    __isset.field1 = true;
  }

   ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

  void set_field2( ::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
  }

   ::test_cpp2::cpp_reflection::enum2 get_field3() const {
    return field3;
  }

  void set_field3( ::test_cpp2::cpp_reflection::enum2 field3_) {
    field3 = field3_;
  }
  const  ::test_cpp2::cpp_reflection::union1* get_field4() const&;
   ::test_cpp2::cpp_reflection::union1* get_field4() &;
   ::test_cpp2::cpp_reflection::union1* get_field4() && = delete;
  template <typename T>
  void set_field4(T&& field4_);
  const  ::test_cpp2::cpp_reflection::union2& get_field5() const&;
   ::test_cpp2::cpp_reflection::union2 get_field5() &&;
  template <typename T>
  void set_field5(T&& field5_);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct1& a, struct1& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::clear( ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct1>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct1* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct2 : private boost::totally_ordered<struct2> {
 public:

  struct2() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1()),
      fieldD( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct2(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
      fieldA(std::move(fieldA__arg)),
      fieldB(std::move(fieldB__arg)),
      fieldC(std::move(fieldC__arg)),
      fieldD(std::move(fieldD__arg)),
      fieldE(std::move(fieldE__arg)),
      fieldF(std::move(fieldF__arg)),
      fieldG(std::move(fieldG__arg)) {}

  struct2(struct2&&) = default;

  struct2(const struct2&) = default;

  struct2& operator=(struct2&&) = default;

  struct2& operator=(const struct2&) = default;
  void __clear();

  virtual ~struct2() throw() {}

  int32_t fieldA;
  std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
    }

    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
  } __isset;
  bool operator==(const struct2& rhs) const;
  bool operator < (const struct2& rhs) const;

  int32_t get_fieldA() const {
    return fieldA;
  }

  void set_fieldA(int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
  }

  const std::string& get_fieldB() const& {
    return fieldB;
  }

  std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T>
  void set_fieldB(T&& fieldB_) {
    fieldB = std::forward<T>(fieldB_);
    __isset.fieldB = true;
  }

   ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

  void set_fieldC( ::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
  }

   ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

  void set_fieldD( ::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
   ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;
  template <typename T>
  void set_fieldE(T&& fieldE_);
  const  ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;
  template <typename T>
  void set_fieldF(T&& fieldF_);
  const  ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
   ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;
  template <typename T>
  void set_fieldG(T&& fieldG_);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct2& a, struct2& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::clear( ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct2>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct2* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

class struct3 : private boost::totally_ordered<struct3> {
 public:

  struct3() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1()),
      fieldD( ::test_cpp2::cpp_reflection::enum2()) {}
  // FragileConstructor for use in initialization lists only

  struct3(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg,  ::test_cpp2::cpp_reflection::union2 fieldH__arg, std::vector<int32_t> fieldI__arg, std::vector<std::string> fieldJ__arg, std::vector<std::string> fieldK__arg, std::vector< ::test_cpp2::cpp_reflection::structA> fieldL__arg, std::set<int32_t> fieldM__arg, std::set<std::string> fieldN__arg, std::set<std::string> fieldO__arg, std::set< ::test_cpp2::cpp_reflection::structB> fieldP__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
      fieldA(std::move(fieldA__arg)),
      fieldB(std::move(fieldB__arg)),
      fieldC(std::move(fieldC__arg)),
      fieldD(std::move(fieldD__arg)),
      fieldE(std::move(fieldE__arg)),
      fieldF(std::move(fieldF__arg)),
      fieldG(std::move(fieldG__arg)),
      fieldH(std::move(fieldH__arg)),
      fieldI(std::move(fieldI__arg)),
      fieldJ(std::move(fieldJ__arg)),
      fieldK(std::move(fieldK__arg)),
      fieldL(std::move(fieldL__arg)),
      fieldM(std::move(fieldM__arg)),
      fieldN(std::move(fieldN__arg)),
      fieldO(std::move(fieldO__arg)),
      fieldP(std::move(fieldP__arg)),
      fieldQ(std::move(fieldQ__arg)),
      fieldR(std::move(fieldR__arg)) {}

  struct3(struct3&&) = default;

  struct3(const struct3&) = default;

  struct3& operator=(struct3&&) = default;

  struct3& operator=(const struct3&) = default;
  void __clear();

  virtual ~struct3() throw() {}

  int32_t fieldA;
  std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;
   ::test_cpp2::cpp_reflection::union2 fieldH;
  std::vector<int32_t> fieldI;
  std::vector<std::string> fieldJ;
  std::vector<std::string> fieldK;
  std::vector< ::test_cpp2::cpp_reflection::structA> fieldL;
  std::set<int32_t> fieldM;
  std::set<std::string> fieldN;
  std::set<std::string> fieldO;
  std::set< ::test_cpp2::cpp_reflection::structB> fieldP;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structB> fieldR;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
      fieldH = false;
      fieldI = false;
      fieldJ = false;
      fieldK = false;
      fieldL = false;
      fieldM = false;
      fieldN = false;
      fieldO = false;
      fieldP = false;
      fieldQ = false;
      fieldR = false;
    }

    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
  } __isset;
  bool operator==(const struct3& rhs) const;
  bool operator < (const struct3& rhs) const;

  int32_t get_fieldA() const {
    return fieldA;
  }

  void set_fieldA(int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
  }

  const std::string& get_fieldB() const& {
    return fieldB;
  }

  std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T>
  void set_fieldB(T&& fieldB_) {
    fieldB = std::forward<T>(fieldB_);
    __isset.fieldB = true;
  }

   ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

  void set_fieldC( ::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
  }

   ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

  void set_fieldD( ::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
   ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;
  template <typename T>
  void set_fieldE(T&& fieldE_);
  const  ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;
  template <typename T>
  void set_fieldF(T&& fieldF_);
  const  ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
   ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;
  template <typename T>
  void set_fieldG(T&& fieldG_);
  const  ::test_cpp2::cpp_reflection::union2& get_fieldH() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldH() &&;
  template <typename T>
  void set_fieldH(T&& fieldH_);
  const std::vector<int32_t>& get_fieldI() const&;
  std::vector<int32_t> get_fieldI() &&;
  template <typename T>
  void set_fieldI(T&& fieldI_);
  const std::vector<std::string>& get_fieldJ() const&;
  std::vector<std::string> get_fieldJ() &&;
  template <typename T>
  void set_fieldJ(T&& fieldJ_);
  const std::vector<std::string>& get_fieldK() const&;
  std::vector<std::string> get_fieldK() &&;
  template <typename T>
  void set_fieldK(T&& fieldK_);
  const std::vector< ::test_cpp2::cpp_reflection::structA>& get_fieldL() const&;
  std::vector< ::test_cpp2::cpp_reflection::structA> get_fieldL() &&;
  template <typename T>
  void set_fieldL(T&& fieldL_);
  const std::set<int32_t>& get_fieldM() const&;
  std::set<int32_t> get_fieldM() &&;
  template <typename T>
  void set_fieldM(T&& fieldM_);
  const std::set<std::string>& get_fieldN() const&;
  std::set<std::string> get_fieldN() &&;
  template <typename T>
  void set_fieldN(T&& fieldN_);
  const std::set<std::string>& get_fieldO() const&;
  std::set<std::string> get_fieldO() &&;
  template <typename T>
  void set_fieldO(T&& fieldO_);
  const std::set< ::test_cpp2::cpp_reflection::structB>& get_fieldP() const&;
  std::set< ::test_cpp2::cpp_reflection::structB> get_fieldP() &&;
  template <typename T>
  void set_fieldP(T&& fieldP_);
  const std::map<std::string,  ::test_cpp2::cpp_reflection::structA>& get_fieldQ() const&;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structA> get_fieldQ() &&;
  template <typename T>
  void set_fieldQ(T&& fieldQ_);
  const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& get_fieldR() const&;
  std::map<std::string,  ::test_cpp2::cpp_reflection::structB> get_fieldR() &&;
  template <typename T>
  void set_fieldR(T&& fieldR_);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(struct3& a, struct3& b);

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::clear( ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::write(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::read(Protocol* proto,   ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::serializedSize(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::test_cpp2::cpp_reflection::struct3>::serializedSizeZC(Protocol* proto, const  ::test_cpp2::cpp_reflection::struct3* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection