#
# Autogenerated by Thrift
#
# DO NOT EDIT
#  @generated
#

import typing as _typing

import enum

import thrift.py3lite.types as _fbthrift_py3lite_types
import thrift.py3lite.exceptions as _fbthrift_py3lite_exceptions


class ComplexUnion(_fbthrift_py3lite_types.Union):
    intValue: _typing.Final[int] = ...
    stringValue: _typing.Final[str] = ...
    intListValue: _typing.Final[_typing.Sequence[int]] = ...
    stringListValue: _typing.Final[_typing.Sequence[str]] = ...
    typedefValue: _typing.Final[_typing.Mapping[int, str]] = ...
    stringRef: _typing.Final[str] = ...
    def __init__(
        self, *,
        intValue: _typing.Optional[int]=...,
        stringValue: _typing.Optional[str]=...,
        intListValue: _typing.Optional[_typing.Sequence[int]]=...,
        stringListValue: _typing.Optional[_typing.Sequence[str]]=...,
        typedefValue: _typing.Optional[_typing.Mapping[int, str]]=...,
        stringRef: _typing.Optional[str]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: ComplexUnion.Type = ...
        intValue: ComplexUnion.Type = ...
        stringValue: ComplexUnion.Type = ...
        intListValue: ComplexUnion.Type = ...
        stringListValue: ComplexUnion.Type = ...
        typedefValue: ComplexUnion.Type = ...
        stringRef: ComplexUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, int, str, _typing.Sequence[int], _typing.Sequence[str], _typing.Mapping[int, str], str]) -> ComplexUnion: ...
    value: _typing.Final[_typing.Union[None, int, str, _typing.Sequence[int], _typing.Sequence[str], _typing.Mapping[int, str], str]]
    type: Type
    def get_type(self) -> Type:...


class ListUnion(_fbthrift_py3lite_types.Union):
    intListValue: _typing.Final[_typing.Sequence[int]] = ...
    stringListValue: _typing.Final[_typing.Sequence[str]] = ...
    def __init__(
        self, *,
        intListValue: _typing.Optional[_typing.Sequence[int]]=...,
        stringListValue: _typing.Optional[_typing.Sequence[str]]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: ListUnion.Type = ...
        intListValue: ListUnion.Type = ...
        stringListValue: ListUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, _typing.Sequence[int], _typing.Sequence[str]]) -> ListUnion: ...
    value: _typing.Final[_typing.Union[None, _typing.Sequence[int], _typing.Sequence[str]]]
    type: Type
    def get_type(self) -> Type:...


class DataUnion(_fbthrift_py3lite_types.Union):
    binaryData: _typing.Final[bytes] = ...
    stringData: _typing.Final[str] = ...
    def __init__(
        self, *,
        binaryData: _typing.Optional[bytes]=...,
        stringData: _typing.Optional[str]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: DataUnion.Type = ...
        binaryData: DataUnion.Type = ...
        stringData: DataUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, bytes, str]) -> DataUnion: ...
    value: _typing.Final[_typing.Union[None, bytes, str]]
    type: Type
    def get_type(self) -> Type:...


class Val(_fbthrift_py3lite_types.Struct):
    strVal: _typing.Final[str] = ...
    intVal: _typing.Final[int] = ...
    typedefValue: _typing.Final[_typing.Mapping[int, str]] = ...
    def __init__(
        self, *,
        strVal: _typing.Optional[str]=...,
        intVal: _typing.Optional[int]=...,
        typedefValue: _typing.Optional[_typing.Mapping[int, str]]=...
    ) -> None: ...

    def __call__(
        self, *,
        strVal: _typing.Optional[str]=...,
        intVal: _typing.Optional[int]=...,
        typedefValue: _typing.Optional[_typing.Mapping[int, str]]=...
    ) -> Val: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, str, int, _typing.Mapping[int, str]]]]: ...


class ValUnion(_fbthrift_py3lite_types.Union):
    v1: _typing.Final[Val] = ...
    v2: _typing.Final[Val] = ...
    def __init__(
        self, *,
        v1: _typing.Optional[Val]=...,
        v2: _typing.Optional[Val]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: ValUnion.Type = ...
        v1: ValUnion.Type = ...
        v2: ValUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, Val, Val]) -> ValUnion: ...
    value: _typing.Final[_typing.Union[None, Val, Val]]
    type: Type
    def get_type(self) -> Type:...


class VirtualComplexUnion(_fbthrift_py3lite_types.Union):
    thingOne: _typing.Final[str] = ...
    thingTwo: _typing.Final[str] = ...
    def __init__(
        self, *,
        thingOne: _typing.Optional[str]=...,
        thingTwo: _typing.Optional[str]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: VirtualComplexUnion.Type = ...
        thingOne: VirtualComplexUnion.Type = ...
        thingTwo: VirtualComplexUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, str, str]) -> VirtualComplexUnion: ...
    value: _typing.Final[_typing.Union[None, str, str]]
    type: Type
    def get_type(self) -> Type:...


class NonCopyableStruct(_fbthrift_py3lite_types.Struct):
    num: _typing.Final[int] = ...
    def __init__(
        self, *,
        num: _typing.Optional[int]=...
    ) -> None: ...

    def __call__(
        self, *,
        num: _typing.Optional[int]=...
    ) -> NonCopyableStruct: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int]]]: ...


class NonCopyableUnion(_fbthrift_py3lite_types.Union):
    s: _typing.Final[NonCopyableStruct] = ...
    def __init__(
        self, *,
        s: _typing.Optional[NonCopyableStruct]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: NonCopyableUnion.Type = ...
        s: NonCopyableUnion.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, NonCopyableStruct]) -> NonCopyableUnion: ...
    value: _typing.Final[_typing.Union[None, NonCopyableStruct]]
    type: Type
    def get_type(self) -> Type:...

containerTypedef = dict
