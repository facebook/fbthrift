#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
import typing as t
import asyncio

from thrift import Thrift
from thrift.protocol.TProtocol import TProtocolBase

import simple.dependent_asyncio.ttypes
from simple.example_asyncio.ttypes import *


class Iface:  # SharedService
    # These have to be Awaitable because handler methods don't return Futures
    # Clients do return Futures but lsp requires us to say they are both Awaitable
    # You can cast the result of a Client if you need Future
    def get_five(self) -> t.Awaitable[int]: ...
    def add_five(self, num: int) -> t.Awaitable[int]: ...
    def do_nothing(self) -> t.Awaitable[None]: ...
    def concat(self, first: str, second: str) -> t.Awaitable[str]: ...
    def get_value(self, simple_struct: SimpleStruct) -> t.Awaitable[int]: ...
    def negate(self, input: bool) -> t.Awaitable[bool]: ...
    def tiny(self, input: int) -> t.Awaitable[int]: ...
    def small(self, input: int) -> t.Awaitable[int]: ...
    def big(self, input: int) -> t.Awaitable[int]: ...
    def two(self, input: float) -> t.Awaitable[float]: ...
    def expected_exception(self) -> t.Awaitable[None]: ...
    def unexpected_exception(self) -> t.Awaitable[int]: ...
    def sum_i16_list(self, numbers: t.List[int]) -> t.Awaitable[int]: ...
    def sum_i32_list(self, numbers: t.List[int]) -> t.Awaitable[int]: ...
    def sum_i64_list(self, numbers: t.List[int]) -> t.Awaitable[int]: ...
    def concat_many(self, words: t.List[str]) -> t.Awaitable[str]: ...
    def count_structs(self, items: t.List[SimpleStruct]) -> t.Awaitable[int]: ...
    def sum_set(self, numbers: t.Set[int]) -> t.Awaitable[int]: ...
    def contains_word(self, words: t.Set[str], word: str) -> t.Awaitable[bool]: ...
    def get_map_value(self, words: t.Dict[str, str], key: str) -> t.Awaitable[str]: ...
    def map_length(self, items: t.Dict[str, SimpleStruct]) -> t.Awaitable[int]: ...
    def sum_map_values(self, items: t.Dict[str, int]) -> t.Awaitable[int]: ...
    def complex_sum_i32(self, counter: ComplexStruct) -> t.Awaitable[int]: ...
    def repeat_name(self, counter: ComplexStruct) -> t.Awaitable[str]: ...
    def get_struct(self) -> t.Awaitable[SimpleStruct]: ...
    def fib(self, n: int) -> t.Awaitable[t.List[int]]: ...
    def unique_words(self, words: t.List[str]) -> t.Awaitable[t.Set[str]]: ...
    def words_count(self, words: t.List[str]) -> t.Awaitable[t.Dict[str, int]]: ...
    def set_enum(self, in_enum: int) -> t.Awaitable[int]: ...
    def get_the_answer(self) -> t.Awaitable[int]: ...
    def all_letters(self) -> t.Awaitable[t.List[str]]: ...
    def nested_map_argument(self, struct_map: t.Dict[str, t.List[SimpleStruct]]) -> t.Awaitable[int]: ...
    def make_sentence(self, word_chars: t.List[t.List[str]]) -> t.Awaitable[str]: ...
    def get_union(self, sets: t.List[t.Set[int]]) -> t.Awaitable[t.Set[int]]: ...
    def get_keys(self, string_map: t.List[t.Dict[str, str]]) -> t.Awaitable[t.Set[str]]: ...
    def get_union_value(self, input: UnionStruct) -> t.Awaitable[None]: ...

class Client(Iface, t.ContextManager):  # SharedService
    def send_get_five(self) -> None: ...
    def recv_get_five(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_add_five(self, num: t.Optional[int] = ...) -> None: ...
    def recv_add_five(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_do_nothing(self) -> None: ...
    def recv_do_nothing(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_concat(self, first: t.Optional[str] = ..., second: t.Optional[str] = ...) -> None: ...
    def recv_concat(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_value(self, simple_struct: t.Optional[SimpleStruct] = ...) -> None: ...
    def recv_get_value(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_negate(self, input: t.Optional[bool] = ...) -> None: ...
    def recv_negate(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_tiny(self, input: t.Optional[int] = ...) -> None: ...
    def recv_tiny(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_small(self, input: t.Optional[int] = ...) -> None: ...
    def recv_small(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_big(self, input: t.Optional[int] = ...) -> None: ...
    def recv_big(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_two(self, input: t.Optional[float] = ...) -> None: ...
    def recv_two(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_expected_exception(self) -> None: ...
    def recv_expected_exception(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_unexpected_exception(self) -> None: ...
    def recv_unexpected_exception(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_sum_i16_list(self, numbers: t.Optional[t.List[int]] = ...) -> None: ...
    def recv_sum_i16_list(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_sum_i32_list(self, numbers: t.Optional[t.List[int]] = ...) -> None: ...
    def recv_sum_i32_list(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_sum_i64_list(self, numbers: t.Optional[t.List[int]] = ...) -> None: ...
    def recv_sum_i64_list(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_concat_many(self, words: t.Optional[t.List[str]] = ...) -> None: ...
    def recv_concat_many(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_count_structs(self, items: t.Optional[t.List[SimpleStruct]] = ...) -> None: ...
    def recv_count_structs(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_sum_set(self, numbers: t.Optional[t.Set[int]] = ...) -> None: ...
    def recv_sum_set(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_contains_word(self, words: t.Optional[t.Set[str]] = ..., word: t.Optional[str] = ...) -> None: ...
    def recv_contains_word(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_map_value(self, words: t.Optional[t.Dict[str, str]] = ..., key: t.Optional[str] = ...) -> None: ...
    def recv_get_map_value(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_map_length(self, items: t.Optional[t.Dict[str, SimpleStruct]] = ...) -> None: ...
    def recv_map_length(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_sum_map_values(self, items: t.Optional[t.Dict[str, int]] = ...) -> None: ...
    def recv_sum_map_values(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_complex_sum_i32(self, counter: t.Optional[ComplexStruct] = ...) -> None: ...
    def recv_complex_sum_i32(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_repeat_name(self, counter: t.Optional[ComplexStruct] = ...) -> None: ...
    def recv_repeat_name(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_struct(self) -> None: ...
    def recv_get_struct(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_fib(self, n: t.Optional[int] = ...) -> None: ...
    def recv_fib(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_unique_words(self, words: t.Optional[t.List[str]] = ...) -> None: ...
    def recv_unique_words(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_words_count(self, words: t.Optional[t.List[str]] = ...) -> None: ...
    def recv_words_count(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_set_enum(self, in_enum: t.Optional[int] = ...) -> None: ...
    def recv_set_enum(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_the_answer(self) -> None: ...
    def recv_get_the_answer(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_all_letters(self) -> None: ...
    def recv_all_letters(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_nested_map_argument(self, struct_map: t.Optional[t.Dict[str, t.List[SimpleStruct]]] = ...) -> None: ...
    def recv_nested_map_argument(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_make_sentence(self, word_chars: t.Optional[t.List[t.List[str]]] = ...) -> None: ...
    def recv_make_sentence(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_union(self, sets: t.Optional[t.List[t.Set[int]]] = ...) -> None: ...
    def recv_get_union(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_keys(self, string_map: t.Optional[t.List[t.Dict[str, str]]] = ...) -> None: ...
    def recv_get_keys(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...
    def send_get_union_value(self, input: t.Optional[UnionStruct] = ...) -> None: ...
    def recv_get_union_value(self, iprot: TProtocolBase, mtype: int, rseqid: int) -> None: ...

class Processor(Iface, Thrift.TProcessor):  # SharedService
    def __init__(self, handler: Iface) -> None:
        self._handler: Iface
        self._onewayMethods: t.Sequence[t.Callable]
        self._processMap: t.Dict[str, t.Callable]

    def process_get_five(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_add_five(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_do_nothing(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_concat(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_value(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_negate(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_tiny(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_small(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_big(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_two(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_expected_exception(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_unexpected_exception(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_sum_i16_list(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_sum_i32_list(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_sum_i64_list(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_concat_many(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_count_structs(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_sum_set(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_contains_word(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_map_value(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_map_length(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_sum_map_values(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_complex_sum_i32(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_repeat_name(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_struct(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_fib(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_unique_words(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_words_count(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_set_enum(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_the_answer(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_all_letters(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_nested_map_argument(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_make_sentence(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_union(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_keys(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_get_union_value(self, seqid: int, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def process_main(self, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: t.Any = ...) -> asyncio.Future: ...
    def onewayMethods(self) -> t.Tuple[t.Callable]: ...

class get_five_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_five_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class add_five_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        num: t.Optional[int] = ...
    ) -> None:
        self.num: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class add_five_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class do_nothing_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class do_nothing_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: None = ...) -> None:
        self.success: None

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class concat_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        first: t.Optional[str] = ...,
        second: t.Optional[str] = ...
    ) -> None:
        self.first: t.Optional[str]
        self.second: t.Optional[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class concat_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: str = ...) -> None:
        self.success: str

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_value_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        simple_struct: t.Optional[SimpleStruct] = ...
    ) -> None:
        self.simple_struct: t.Optional[SimpleStruct]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_value_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class negate_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[bool] = ...
    ) -> None:
        self.input: t.Optional[bool]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class negate_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: bool = ...) -> None:
        self.success: bool

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class tiny_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[int] = ...
    ) -> None:
        self.input: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class tiny_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class small_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[int] = ...
    ) -> None:
        self.input: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class small_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class big_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[int] = ...
    ) -> None:
        self.input: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class big_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class two_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[float] = ...
    ) -> None:
        self.input: t.Optional[float]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class two_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: float = ...) -> None:
        self.success: float

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class expected_exception_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class expected_exception_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: None = ...) -> None:
        self.success: None

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class unexpected_exception_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class unexpected_exception_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i16_list_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        numbers: t.Optional[t.List[int]] = ...
    ) -> None:
        self.numbers: t.Optional[t.List[int]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i16_list_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i32_list_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        numbers: t.Optional[t.List[int]] = ...
    ) -> None:
        self.numbers: t.Optional[t.List[int]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i32_list_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i64_list_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        numbers: t.Optional[t.List[int]] = ...
    ) -> None:
        self.numbers: t.Optional[t.List[int]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_i64_list_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class concat_many_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        words: t.Optional[t.List[str]] = ...
    ) -> None:
        self.words: t.Optional[t.List[str]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class concat_many_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: str = ...) -> None:
        self.success: str

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class count_structs_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        items: t.Optional[t.List[SimpleStruct]] = ...
    ) -> None:
        self.items: t.Optional[t.List[SimpleStruct]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class count_structs_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_set_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        numbers: t.Optional[t.Set[int]] = ...
    ) -> None:
        self.numbers: t.Optional[t.Set[int]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_set_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class contains_word_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        words: t.Optional[t.Set[str]] = ...,
        word: t.Optional[str] = ...
    ) -> None:
        self.words: t.Optional[t.Set[str]]
        self.word: t.Optional[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class contains_word_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: bool = ...) -> None:
        self.success: bool

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_map_value_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        words: t.Optional[t.Dict[str, str]] = ...,
        key: t.Optional[str] = ...
    ) -> None:
        self.words: t.Optional[t.Dict[str, str]]
        self.key: t.Optional[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_map_value_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: str = ...) -> None:
        self.success: str

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class map_length_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        items: t.Optional[t.Dict[str, SimpleStruct]] = ...
    ) -> None:
        self.items: t.Optional[t.Dict[str, SimpleStruct]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class map_length_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_map_values_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        items: t.Optional[t.Dict[str, int]] = ...
    ) -> None:
        self.items: t.Optional[t.Dict[str, int]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class sum_map_values_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class complex_sum_i32_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        counter: t.Optional[ComplexStruct] = ...
    ) -> None:
        self.counter: t.Optional[ComplexStruct]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class complex_sum_i32_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class repeat_name_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        counter: t.Optional[ComplexStruct] = ...
    ) -> None:
        self.counter: t.Optional[ComplexStruct]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class repeat_name_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: str = ...) -> None:
        self.success: str

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_struct_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_struct_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: SimpleStruct = ...) -> None:
        self.success: SimpleStruct

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class fib_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        n: t.Optional[int] = ...
    ) -> None:
        self.n: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class fib_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.List[int] = ...) -> None:
        self.success: t.List[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class unique_words_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        words: t.Optional[t.List[str]] = ...
    ) -> None:
        self.words: t.Optional[t.List[str]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class unique_words_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.Set[str] = ...) -> None:
        self.success: t.Set[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class words_count_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        words: t.Optional[t.List[str]] = ...
    ) -> None:
        self.words: t.Optional[t.List[str]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class words_count_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.Dict[str, int] = ...) -> None:
        self.success: t.Dict[str, int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class set_enum_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        in_enum: t.Optional[int] = ...
    ) -> None:
        self.in_enum: t.Optional[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class set_enum_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_the_answer_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_the_answer_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class all_letters_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class all_letters_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.List[str] = ...) -> None:
        self.success: t.List[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class nested_map_argument_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        struct_map: t.Optional[t.Dict[str, t.List[SimpleStruct]]] = ...
    ) -> None:
        self.struct_map: t.Optional[t.Dict[str, t.List[SimpleStruct]]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class nested_map_argument_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: int = ...) -> None:
        self.success: int

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class make_sentence_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        word_chars: t.Optional[t.List[t.List[str]]] = ...
    ) -> None:
        self.word_chars: t.Optional[t.List[t.List[str]]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class make_sentence_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: str = ...) -> None:
        self.success: str

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_union_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        sets: t.Optional[t.List[t.Set[int]]] = ...
    ) -> None:
        self.sets: t.Optional[t.List[t.Set[int]]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_union_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.Set[int] = ...) -> None:
        self.success: t.Set[int]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_keys_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        string_map: t.Optional[t.List[t.Dict[str, str]]] = ...
    ) -> None:
        self.string_map: t.Optional[t.List[t.Dict[str, str]]]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_keys_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: t.Set[str] = ...) -> None:
        self.success: t.Set[str]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_union_value_args:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(
        self,
        input: t.Optional[UnionStruct] = ...
    ) -> None:
        self.input: t.Optional[UnionStruct]

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...

class get_union_value_result:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    def __init__(self, success: None = ...) -> None:
        self.success: None

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...
