#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
import typing as t

from thrift import Thrift
from thrift.protocol.TProtocol import TProtocolBase

import simple.dependent.ttypes

UTF8STRINGS: bool


class AnEnum(int):
    ONE: AnEnum
    TWO: AnEnum
    THREE: AnEnum
    FOUR: AnEnum

    _VALUES_TO_NAMES: t.Dict[AnEnum, str]
    _NAMES_TO_VALUES: t.Dict[str, AnEnum]


class SimpleException(Thrift.TException):
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    err_code: t.Optional[int]

    def __init__(
        self,
        err_code: t.Optional[int] = ...
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...


class MessageException(Thrift.TException):
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    message: t.Optional[str]
    err_code: t.Optional[int]

    def __init__(
        self,
        message: t.Optional[str] = ...,
        err_code: t.Optional[int] = ...
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...


class SimpleStruct:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    is_on: t.Optional[bool]
    tiny_int: int
    small_int: t.Optional[int]
    nice_sized_int: t.Optional[int]
    big_int: t.Optional[int]
    coarse_real: t.Optional[float]
    precise_real: t.Optional[float]
    a_str: t.Optional[str]
    a_bytes: t.Optional[bytes]

    def __init__(
        self,
        is_on: t.Optional[bool] = ...,
        tiny_int: int = ...,
        small_int: t.Optional[int] = ...,
        nice_sized_int: t.Optional[int] = ...,
        big_int: t.Optional[int] = ...,
        coarse_real: t.Optional[float] = ...,
        precise_real: t.Optional[float] = ...,
        a_str: t.Optional[str] = ...,
        a_bytes: t.Optional[bytes] = ...
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...


class ComplexStruct:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    structOne: t.Optional[SimpleStruct]
    structTwo: t.Optional[SimpleStruct]
    an_integer: t.Optional[int]
    name: t.Optional[str]
    an_enum: t.Optional[int]
    values: t.Optional[t.List[int]]
    structs: t.Optional[t.List[SimpleStruct]]
    amap: t.Optional[t.Dict[str, str]]
    aset: t.Optional[t.Set[str]]
    item: t.Optional[simple.dependent.ttypes.Item]

    def __init__(
        self,
        structOne: t.Optional[SimpleStruct] = ...,
        structTwo: t.Optional[SimpleStruct] = ...,
        an_integer: t.Optional[int] = ...,
        name: t.Optional[str] = ...,
        an_enum: t.Optional[int] = ...,
        values: t.Optional[t.List[int]] = ...,
        structs: t.Optional[t.List[SimpleStruct]] = ...,
        amap: t.Optional[t.Dict[str, str]] = ...,
        aset: t.Optional[t.Set[str]] = ...,
        item: t.Optional[simple.dependent.ttypes.Item] = ...
    ) -> None:
        ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...


class UnionStruct:
    thrift_spec: t.Tuple[t.Optional[t.Tuple[int, int, str, t.Any, t.Optional[int], int]]]
    thrift_field_annotations: t.Dict[int, t.Dict[str, str]]
    thrift_struct_annotations: t.Dict[str, str]

    is_a_bool: t.Optional[bool]
    some_string_goes_here: t.Optional[str]
    perhaps_a_big_int: t.Optional[int]

    def __init__(
        self,
        is_a_bool: t.Optional[bool] = ...,
        some_string_goes_here: t.Optional[str] = ...,
        perhaps_a_big_int: t.Optional[int] = ...
    ) -> None:
        ...

    def getType(self) -> int: ...

    def get_is_a_bool(self) -> t.Optional[bool]: ...
    def get_some_string_goes_here(self) -> t.Optional[str]: ...
    def get_perhaps_a_big_int(self) -> t.Optional[int]: ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: t.Any) -> bool: ...
    def __ne__(self, other: t.Any) -> bool: ...
