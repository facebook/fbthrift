#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

cimport cython
from typing import AsyncIterator
from cpython.version cimport PY_VERSION_HEX
from libc.stdint cimport (
    int8_t as cint8_t,
    int16_t as cint16_t,
    int32_t as cint32_t,
    int64_t as cint64_t,
)
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from libcpp.utility cimport move as cmove
from libcpp.pair cimport pair
from cython.operator cimport dereference as deref
from cpython.ref cimport PyObject
from thrift.py3.exceptions cimport (
    cTApplicationException,
    ApplicationError as __ApplicationError,
    cTApplicationExceptionType__UNKNOWN)
from thrift.py3.server cimport ServiceInterface, RequestContext, Cpp2RequestContext
from thrift.py3.server import RequestContext, pass_context
from folly cimport (
  cFollyPromise,
  cFollyUnit,
  c_unit,
)
from thrift.py3.common cimport (
    cThriftServiceContext as __fbthrift_cThriftServiceContext,
    cThriftMetadata as __fbthrift_cThriftMetadata,
    ServiceMetadata,
    extractMetadataFromServiceContext,
    MetadataBox as __MetadataBox,
)

if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
    from thrift.py3.server cimport THRIFT_REQUEST_CONTEXT as __THRIFT_REQUEST_CONTEXT

cimport folly.futures
from folly.executor cimport get_executor
cimport folly.iobuf as _fbthrift_iobuf
import folly.iobuf as _fbthrift_iobuf
from folly.iobuf cimport move as move_iobuf
from folly.memory cimport to_shared_ptr as __to_shared_ptr

cimport module.types as _module_types
import module.types as _module_types
import includes.types as _includes_types
cimport includes.types as _includes_types

cimport module.services_reflection as _services_reflection

import asyncio
import functools
import sys
import traceback
import types as _py_types

from module.services_wrapper cimport cEmptyServiceInterface
from module.services_wrapper cimport cReturnServiceInterface
from module.services_wrapper cimport cParamServiceInterface



@cython.auto_pickle(False)
cdef class Promise__module_types_cComplexUnion:
    cdef cFollyPromise[unique_ptr[_module_types.cComplexUnion]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[_module_types.cComplexUnion]] cPromise):
        cdef Promise__module_types_cComplexUnion inst = Promise__module_types_cComplexUnion.__new__(Promise__module_types_cComplexUnion)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector___module_types_cComplexUnion:
    cdef cFollyPromise[unique_ptr[vector[_module_types.cComplexUnion]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[_module_types.cComplexUnion]]] cPromise):
        cdef Promise_vector___module_types_cComplexUnion inst = Promise_vector___module_types_cComplexUnion.__new__(Promise_vector___module_types_cComplexUnion)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct:
    cdef cFollyPromise[unique_ptr[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]]] cPromise):
        cdef Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct inst = Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct.__new__(Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct:
    cdef cFollyPromise[unique_ptr[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]] cPromise):
        cdef Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct inst = Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct.__new__(Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector___module_types_cMyEnumA:
    cdef cFollyPromise[unique_ptr[vector[_module_types.cMyEnumA]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[_module_types.cMyEnumA]]] cPromise):
        cdef Promise_vector___module_types_cMyEnumA inst = Promise_vector___module_types_cMyEnumA.__new__(Promise_vector___module_types_cMyEnumA)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__cbool:
    cdef cFollyPromise[unique_ptr[vector[cbool]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[cbool]]] cPromise):
        cdef Promise_vector__cbool inst = Promise_vector__cbool.__new__(Promise_vector__cbool)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_vector__cint32_t:
    cdef cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise):
        cdef Promise_vector__cint32_t inst = Promise_vector__cint32_t.__new__(Promise_vector__cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string:
    cdef cFollyPromise[unique_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]] cPromise):
        cdef Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string inst = Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string.__new__(Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cmap__string_cint64_t:
    cdef cFollyPromise[unique_ptr[cmap[string,cint64_t]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cmap[string,cint64_t]]] cPromise):
        cdef Promise_cmap__string_cint64_t inst = Promise_cmap__string_cint64_t.__new__(Promise_cmap__string_cint64_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise__module_types_cMyEnumA:
    cdef cFollyPromise[_module_types.cMyEnumA] cPromise

    @staticmethod
    cdef create(cFollyPromise[_module_types.cMyEnumA] cPromise):
        cdef Promise__module_types_cMyEnumA inst = Promise__module_types_cMyEnumA.__new__(Promise__module_types_cMyEnumA)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise__module_types_cMyStruct:
    cdef cFollyPromise[unique_ptr[_module_types.cMyStruct]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[_module_types.cMyStruct]] cPromise):
        cdef Promise__module_types_cMyStruct inst = Promise__module_types_cMyStruct.__new__(Promise__module_types_cMyStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cset___module_types_cMyStruct:
    cdef cFollyPromise[unique_ptr[cset[_module_types.cMyStruct]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[cset[_module_types.cMyStruct]]] cPromise):
        cdef Promise_cset___module_types_cMyStruct inst = Promise_cset___module_types_cMyStruct.__new__(Promise_cset___module_types_cMyStruct)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_binary:
    cdef cFollyPromise[unique_ptr[string]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[string]] cPromise):
        cdef Promise_binary inst = Promise_binary.__new__(Promise_binary)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cbool:
    cdef cFollyPromise[cbool] cPromise

    @staticmethod
    cdef create(cFollyPromise[cbool] cPromise):
        cdef Promise_cbool inst = Promise_cbool.__new__(Promise_cbool)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_double:
    cdef cFollyPromise[double] cPromise

    @staticmethod
    cdef create(cFollyPromise[double] cPromise):
        cdef Promise_double inst = Promise_double.__new__(Promise_double)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_float:
    cdef cFollyPromise[float] cPromise

    @staticmethod
    cdef create(cFollyPromise[float] cPromise):
        cdef Promise_float inst = Promise_float.__new__(Promise_float)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise___iobuf_cIOBuf:
    cdef cFollyPromise[unique_ptr[_fbthrift_iobuf.cIOBuf]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[_fbthrift_iobuf.cIOBuf]] cPromise):
        cdef Promise___iobuf_cIOBuf inst = Promise___iobuf_cIOBuf.__new__(Promise___iobuf_cIOBuf)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint16_t:
    cdef cFollyPromise[cint16_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint16_t] cPromise):
        cdef Promise_cint16_t inst = Promise_cint16_t.__new__(Promise_cint16_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint32_t:
    cdef cFollyPromise[cint32_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint32_t] cPromise):
        cdef Promise_cint32_t inst = Promise_cint32_t.__new__(Promise_cint32_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cint64_t:
    cdef cFollyPromise[cint64_t] cPromise

    @staticmethod
    cdef create(cFollyPromise[cint64_t] cPromise):
        cdef Promise_cint64_t inst = Promise_cint64_t.__new__(Promise_cint64_t)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_unique_ptr__iobuf_cIOBuf:
    cdef cFollyPromise[unique_ptr[unique_ptr[_fbthrift_iobuf.cIOBuf]]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[unique_ptr[_fbthrift_iobuf.cIOBuf]]] cPromise):
        cdef Promise_unique_ptr__iobuf_cIOBuf inst = Promise_unique_ptr__iobuf_cIOBuf.__new__(Promise_unique_ptr__iobuf_cIOBuf)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_string:
    cdef cFollyPromise[unique_ptr[string]] cPromise

    @staticmethod
    cdef create(cFollyPromise[unique_ptr[string]] cPromise):
        cdef Promise_string inst = Promise_string.__new__(Promise_string)
        inst.cPromise = cmove(cPromise)
        return inst

@cython.auto_pickle(False)
cdef class Promise_cFollyUnit:
    cdef cFollyPromise[cFollyUnit] cPromise

    @staticmethod
    cdef create(cFollyPromise[cFollyUnit] cPromise):
        cdef Promise_cFollyUnit inst = Promise_cFollyUnit.__new__(Promise_cFollyUnit)
        inst.cPromise = cmove(cPromise)
        return inst

cdef object _EmptyService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class EmptyServiceInterface(
    ServiceInterface
):
    annotations = _EmptyService_annotations

    def __cinit__(self):
        self._cpp_obj = cEmptyServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__EmptyService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cEmptyServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.EmptyService"

cdef object _ReturnService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class ReturnServiceInterface(
    ServiceInterface
):
    annotations = _ReturnService_annotations

    def __cinit__(self):
        self._cpp_obj = cReturnServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @staticmethod
    def pass_context_noReturn(fn):
        return pass_context(fn)

    async def noReturn(
            self):
        raise NotImplementedError("async def noReturn is not implemented")

    @staticmethod
    def pass_context_boolReturn(fn):
        return pass_context(fn)

    async def boolReturn(
            self):
        raise NotImplementedError("async def boolReturn is not implemented")

    @staticmethod
    def pass_context_i16Return(fn):
        return pass_context(fn)

    async def i16Return(
            self):
        raise NotImplementedError("async def i16Return is not implemented")

    @staticmethod
    def pass_context_i32Return(fn):
        return pass_context(fn)

    async def i32Return(
            self):
        raise NotImplementedError("async def i32Return is not implemented")

    @staticmethod
    def pass_context_i64Return(fn):
        return pass_context(fn)

    async def i64Return(
            self):
        raise NotImplementedError("async def i64Return is not implemented")

    @staticmethod
    def pass_context_floatReturn(fn):
        return pass_context(fn)

    async def floatReturn(
            self):
        raise NotImplementedError("async def floatReturn is not implemented")

    @staticmethod
    def pass_context_doubleReturn(fn):
        return pass_context(fn)

    async def doubleReturn(
            self):
        raise NotImplementedError("async def doubleReturn is not implemented")

    @staticmethod
    def pass_context_stringReturn(fn):
        return pass_context(fn)

    async def stringReturn(
            self):
        raise NotImplementedError("async def stringReturn is not implemented")

    @staticmethod
    def pass_context_binaryReturn(fn):
        return pass_context(fn)

    async def binaryReturn(
            self):
        raise NotImplementedError("async def binaryReturn is not implemented")

    @staticmethod
    def pass_context_mapReturn(fn):
        return pass_context(fn)

    async def mapReturn(
            self):
        raise NotImplementedError("async def mapReturn is not implemented")

    @staticmethod
    def pass_context_simpleTypedefReturn(fn):
        return pass_context(fn)

    async def simpleTypedefReturn(
            self):
        raise NotImplementedError("async def simpleTypedefReturn is not implemented")

    @staticmethod
    def pass_context_complexTypedefReturn(fn):
        return pass_context(fn)

    async def complexTypedefReturn(
            self):
        raise NotImplementedError("async def complexTypedefReturn is not implemented")

    @staticmethod
    def pass_context_list_mostComplexTypedefReturn(fn):
        return pass_context(fn)

    async def list_mostComplexTypedefReturn(
            self):
        raise NotImplementedError("async def list_mostComplexTypedefReturn is not implemented")

    @staticmethod
    def pass_context_enumReturn(fn):
        return pass_context(fn)

    async def enumReturn(
            self):
        raise NotImplementedError("async def enumReturn is not implemented")

    @staticmethod
    def pass_context_list_EnumReturn(fn):
        return pass_context(fn)

    async def list_EnumReturn(
            self):
        raise NotImplementedError("async def list_EnumReturn is not implemented")

    @staticmethod
    def pass_context_structReturn(fn):
        return pass_context(fn)

    async def structReturn(
            self):
        raise NotImplementedError("async def structReturn is not implemented")

    @staticmethod
    def pass_context_set_StructReturn(fn):
        return pass_context(fn)

    async def set_StructReturn(
            self):
        raise NotImplementedError("async def set_StructReturn is not implemented")

    @staticmethod
    def pass_context_unionReturn(fn):
        return pass_context(fn)

    async def unionReturn(
            self):
        raise NotImplementedError("async def unionReturn is not implemented")

    @staticmethod
    def pass_context_list_UnionReturn(fn):
        return pass_context(fn)

    async def list_UnionReturn(
            self):
        raise NotImplementedError("async def list_UnionReturn is not implemented")

    @staticmethod
    def pass_context_readDataEb(fn):
        return pass_context(fn)

    async def readDataEb(
            self,
            size):
        raise NotImplementedError("async def readDataEb is not implemented")

    @staticmethod
    def pass_context_readData(fn):
        return pass_context(fn)

    async def readData(
            self,
            size):
        raise NotImplementedError("async def readData is not implemented")

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__ReturnService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cReturnServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.ReturnService"

cdef object _ParamService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class ParamServiceInterface(
    ServiceInterface
):
    annotations = _ParamService_annotations

    def __cinit__(self):
        self._cpp_obj = cParamServiceInterface(
            <PyObject *> self,
            get_executor()
        )

    @staticmethod
    def pass_context_void_ret_i16_param(fn):
        return pass_context(fn)

    async def void_ret_i16_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_i16_param is not implemented")

    @staticmethod
    def pass_context_void_ret_byte_i16_param(fn):
        return pass_context(fn)

    async def void_ret_byte_i16_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def void_ret_byte_i16_param is not implemented")

    @staticmethod
    def pass_context_void_ret_map_param(fn):
        return pass_context(fn)

    async def void_ret_map_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_map_param is not implemented")

    @staticmethod
    def pass_context_void_ret_map_setlist_param(fn):
        return pass_context(fn)

    async def void_ret_map_setlist_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def void_ret_map_setlist_param is not implemented")

    @staticmethod
    def pass_context_void_ret_map_typedef_param(fn):
        return pass_context(fn)

    async def void_ret_map_typedef_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_map_typedef_param is not implemented")

    @staticmethod
    def pass_context_void_ret_enum_param(fn):
        return pass_context(fn)

    async def void_ret_enum_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_enum_param is not implemented")

    @staticmethod
    def pass_context_void_ret_struct_param(fn):
        return pass_context(fn)

    async def void_ret_struct_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_struct_param is not implemented")

    @staticmethod
    def pass_context_void_ret_listunion_param(fn):
        return pass_context(fn)

    async def void_ret_listunion_param(
            self,
            param1):
        raise NotImplementedError("async def void_ret_listunion_param is not implemented")

    @staticmethod
    def pass_context_bool_ret_i32_i64_param(fn):
        return pass_context(fn)

    async def bool_ret_i32_i64_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def bool_ret_i32_i64_param is not implemented")

    @staticmethod
    def pass_context_bool_ret_map_param(fn):
        return pass_context(fn)

    async def bool_ret_map_param(
            self,
            param1):
        raise NotImplementedError("async def bool_ret_map_param is not implemented")

    @staticmethod
    def pass_context_bool_ret_union_param(fn):
        return pass_context(fn)

    async def bool_ret_union_param(
            self,
            param1):
        raise NotImplementedError("async def bool_ret_union_param is not implemented")

    @staticmethod
    def pass_context_i64_ret_float_double_param(fn):
        return pass_context(fn)

    async def i64_ret_float_double_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def i64_ret_float_double_param is not implemented")

    @staticmethod
    def pass_context_i64_ret_string_typedef_param(fn):
        return pass_context(fn)

    async def i64_ret_string_typedef_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def i64_ret_string_typedef_param is not implemented")

    @staticmethod
    def pass_context_i64_ret_i32_i32_i32_i32_i32_param(fn):
        return pass_context(fn)

    async def i64_ret_i32_i32_i32_i32_i32_param(
            self,
            param1,
            param2,
            param3,
            param4,
            param5):
        raise NotImplementedError("async def i64_ret_i32_i32_i32_i32_i32_param is not implemented")

    @staticmethod
    def pass_context_double_ret_setstruct_param(fn):
        return pass_context(fn)

    async def double_ret_setstruct_param(
            self,
            param1):
        raise NotImplementedError("async def double_ret_setstruct_param is not implemented")

    @staticmethod
    def pass_context_string_ret_string_param(fn):
        return pass_context(fn)

    async def string_ret_string_param(
            self,
            param1):
        raise NotImplementedError("async def string_ret_string_param is not implemented")

    @staticmethod
    def pass_context_binary_ret_binary_param(fn):
        return pass_context(fn)

    async def binary_ret_binary_param(
            self,
            param1):
        raise NotImplementedError("async def binary_ret_binary_param is not implemented")

    @staticmethod
    def pass_context_map_ret_bool_param(fn):
        return pass_context(fn)

    async def map_ret_bool_param(
            self,
            param1):
        raise NotImplementedError("async def map_ret_bool_param is not implemented")

    @staticmethod
    def pass_context_list_ret_map_setlist_param(fn):
        return pass_context(fn)

    async def list_ret_map_setlist_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def list_ret_map_setlist_param is not implemented")

    @staticmethod
    def pass_context_mapsetlistmapliststring_ret_listlistlist_param(fn):
        return pass_context(fn)

    async def mapsetlistmapliststring_ret_listlistlist_param(
            self,
            param1):
        raise NotImplementedError("async def mapsetlistmapliststring_ret_listlistlist_param is not implemented")

    @staticmethod
    def pass_context_typedef_ret_i32_param(fn):
        return pass_context(fn)

    async def typedef_ret_i32_param(
            self,
            param1):
        raise NotImplementedError("async def typedef_ret_i32_param is not implemented")

    @staticmethod
    def pass_context_listtypedef_ret_typedef_param(fn):
        return pass_context(fn)

    async def listtypedef_ret_typedef_param(
            self,
            param1):
        raise NotImplementedError("async def listtypedef_ret_typedef_param is not implemented")

    @staticmethod
    def pass_context_enum_ret_double_param(fn):
        return pass_context(fn)

    async def enum_ret_double_param(
            self,
            param1):
        raise NotImplementedError("async def enum_ret_double_param is not implemented")

    @staticmethod
    def pass_context_enum_ret_double_enum_param(fn):
        return pass_context(fn)

    async def enum_ret_double_enum_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def enum_ret_double_enum_param is not implemented")

    @staticmethod
    def pass_context_listenum_ret_map_param(fn):
        return pass_context(fn)

    async def listenum_ret_map_param(
            self,
            param1):
        raise NotImplementedError("async def listenum_ret_map_param is not implemented")

    @staticmethod
    def pass_context_struct_ret_i16_param(fn):
        return pass_context(fn)

    async def struct_ret_i16_param(
            self,
            param1):
        raise NotImplementedError("async def struct_ret_i16_param is not implemented")

    @staticmethod
    def pass_context_setstruct_ret_set_param(fn):
        return pass_context(fn)

    async def setstruct_ret_set_param(
            self,
            param1):
        raise NotImplementedError("async def setstruct_ret_set_param is not implemented")

    @staticmethod
    def pass_context_union_ret_i32_i32_param(fn):
        return pass_context(fn)

    async def union_ret_i32_i32_param(
            self,
            param1,
            param2):
        raise NotImplementedError("async def union_ret_i32_i32_param is not implemented")

    @staticmethod
    def pass_context_listunion_string_param(fn):
        return pass_context(fn)

    async def listunion_string_param(
            self,
            param1):
        raise NotImplementedError("async def listunion_string_param is not implemented")

    @classmethod
    def __get_reflection__(cls):
        return _services_reflection.get_reflection__ParamService(for_clients=False)

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        cdef __fbthrift_cThriftServiceContext context
        ServiceMetadata[_services_reflection.cParamServiceSvIf].gen(meta, context)
        extractMetadataFromServiceContext(meta, context)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.ParamService"



cdef api void call_cy_ReturnService_noReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_noReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_noReturn_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise
):
    try:
        if ctx and getattr(self.noReturn, "pass_context", False):
            result = await self.noReturn(ctx,)
        else:
            result = await self.noReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler noReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ReturnService_boolReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_boolReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_boolReturn_coro(
    object self,
    object ctx,
    Promise_cbool promise
):
    try:
        if ctx and getattr(self.boolReturn, "pass_context", False):
            result = await self.boolReturn(ctx,)
        else:
            result = await self.boolReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler boolReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_ReturnService_i16Return(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint16_t] cPromise
):
    cdef Promise_cint16_t __promise = Promise_cint16_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_i16Return_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_i16Return_coro(
    object self,
    object ctx,
    Promise_cint16_t promise
):
    try:
        if ctx and getattr(self.i16Return, "pass_context", False):
            result = await self.i16Return(ctx,)
        else:
            result = await self.i16Return()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i16Return:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint16_t> result)

cdef api void call_cy_ReturnService_i32Return(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_i32Return_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_i32Return_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.i32Return, "pass_context", False):
            result = await self.i32Return(ctx,)
        else:
            result = await self.i32Return()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i32Return:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_ReturnService_i64Return(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint64_t] cPromise
):
    cdef Promise_cint64_t __promise = Promise_cint64_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_i64Return_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_i64Return_coro(
    object self,
    object ctx,
    Promise_cint64_t promise
):
    try:
        if ctx and getattr(self.i64Return, "pass_context", False):
            result = await self.i64Return(ctx,)
        else:
            result = await self.i64Return()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i64Return:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint64_t> result)

cdef api void call_cy_ReturnService_floatReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[float] cPromise
):
    cdef Promise_float __promise = Promise_float.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_floatReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_floatReturn_coro(
    object self,
    object ctx,
    Promise_float promise
):
    try:
        if ctx and getattr(self.floatReturn, "pass_context", False):
            result = await self.floatReturn(ctx,)
        else:
            result = await self.floatReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler floatReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<float> result)

cdef api void call_cy_ReturnService_doubleReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[double] cPromise
):
    cdef Promise_double __promise = Promise_double.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_doubleReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_doubleReturn_coro(
    object self,
    object ctx,
    Promise_double promise
):
    try:
        if ctx and getattr(self.doubleReturn, "pass_context", False):
            result = await self.doubleReturn(ctx,)
        else:
            result = await self.doubleReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler doubleReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<double> result)

cdef api void call_cy_ReturnService_stringReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_stringReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_stringReturn_coro(
    object self,
    object ctx,
    Promise_string promise
):
    try:
        if ctx and getattr(self.stringReturn, "pass_context", False):
            result = await self.stringReturn(ctx,)
        else:
            result = await self.stringReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler stringReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_ReturnService_binaryReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise
):
    cdef Promise_binary __promise = Promise_binary.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_binaryReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_binaryReturn_coro(
    object self,
    object ctx,
    Promise_binary promise
):
    try:
        if ctx and getattr(self.binaryReturn, "pass_context", False):
            result = await self.binaryReturn(ctx,)
        else:
            result = await self.binaryReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler binaryReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result))

cdef api void call_cy_ReturnService_mapReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cmap[string,cint64_t]]] cPromise
):
    cdef Promise_cmap__string_cint64_t __promise = Promise_cmap__string_cint64_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_mapReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_mapReturn_coro(
    object self,
    object ctx,
    Promise_cmap__string_cint64_t promise
):
    try:
        if ctx and getattr(self.mapReturn, "pass_context", False):
            result = await self.mapReturn(ctx,)
        else:
            result = await self.mapReturn()
        result = _module_types.Map__string_i64(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler mapReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cmap[string,cint64_t]](deref((<_module_types.Map__string_i64?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_simpleTypedefReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_simpleTypedefReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_simpleTypedefReturn_coro(
    object self,
    object ctx,
    Promise_cint32_t promise
):
    try:
        if ctx and getattr(self.simpleTypedefReturn, "pass_context", False):
            result = await self.simpleTypedefReturn(ctx,)
        else:
            result = await self.simpleTypedefReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler simpleTypedefReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_ReturnService_complexTypedefReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]] cPromise
):
    cdef Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct __promise = Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_complexTypedefReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_complexTypedefReturn_coro(
    object self,
    object ctx,
    Promise_vector__cmap___module_types_cEmpty__module_types_cMyStruct promise
):
    try:
        if ctx and getattr(self.complexTypedefReturn, "pass_context", False):
            result = await self.complexTypedefReturn(ctx,)
        else:
            result = await self.complexTypedefReturn()
        result = _module_types.List__Map__Empty_MyStruct(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler complexTypedefReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]](deref((<_module_types.List__Map__Empty_MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_list_mostComplexTypedefReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]]] cPromise
):
    cdef Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct __promise = Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_list_mostComplexTypedefReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_list_mostComplexTypedefReturn_coro(
    object self,
    object ctx,
    Promise_vector__vector__vector__cmap___module_types_cEmpty__module_types_cMyStruct promise
):
    try:
        if ctx and getattr(self.list_mostComplexTypedefReturn, "pass_context", False):
            result = await self.list_mostComplexTypedefReturn(ctx,)
        else:
            result = await self.list_mostComplexTypedefReturn()
        result = _module_types.List__List__List__Map__Empty_MyStruct(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_mostComplexTypedefReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]](deref((<_module_types.List__List__List__Map__Empty_MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_enumReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[_module_types.cMyEnumA] cPromise
):
    cdef Promise__module_types_cMyEnumA __promise = Promise__module_types_cMyEnumA.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_enumReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_enumReturn_coro(
    object self,
    object ctx,
    Promise__module_types_cMyEnumA promise
):
    try:
        if ctx and getattr(self.enumReturn, "pass_context", False):
            result = await self.enumReturn(ctx,)
        else:
            result = await self.enumReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler enumReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<_module_types.cMyEnumA><int>result)

cdef api void call_cy_ReturnService_list_EnumReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[_module_types.cMyEnumA]]] cPromise
):
    cdef Promise_vector___module_types_cMyEnumA __promise = Promise_vector___module_types_cMyEnumA.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_list_EnumReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_list_EnumReturn_coro(
    object self,
    object ctx,
    Promise_vector___module_types_cMyEnumA promise
):
    try:
        if ctx and getattr(self.list_EnumReturn, "pass_context", False):
            result = await self.list_EnumReturn(ctx,)
        else:
            result = await self.list_EnumReturn()
        result = _module_types.List__MyEnumA(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_EnumReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[_module_types.cMyEnumA]](deref((<_module_types.List__MyEnumA?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_structReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cMyStruct]] cPromise
):
    cdef Promise__module_types_cMyStruct __promise = Promise__module_types_cMyStruct.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_structReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_structReturn_coro(
    object self,
    object ctx,
    Promise__module_types_cMyStruct promise
):
    try:
        if ctx and getattr(self.structReturn, "pass_context", False):
            result = await self.structReturn(ctx,)
        else:
            result = await self.structReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler structReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cMyStruct](deref((<_module_types.MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_set_StructReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[_module_types.cMyStruct]]] cPromise
):
    cdef Promise_cset___module_types_cMyStruct __promise = Promise_cset___module_types_cMyStruct.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_set_StructReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_set_StructReturn_coro(
    object self,
    object ctx,
    Promise_cset___module_types_cMyStruct promise
):
    try:
        if ctx and getattr(self.set_StructReturn, "pass_context", False):
            result = await self.set_StructReturn(ctx,)
        else:
            result = await self.set_StructReturn()
        result = _module_types.Set__MyStruct(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler set_StructReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[_module_types.cMyStruct]](deref((<_module_types.Set__MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_unionReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cComplexUnion]] cPromise
):
    cdef Promise__module_types_cComplexUnion __promise = Promise__module_types_cComplexUnion.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_unionReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_unionReturn_coro(
    object self,
    object ctx,
    Promise__module_types_cComplexUnion promise
):
    try:
        if ctx and getattr(self.unionReturn, "pass_context", False):
            result = await self.unionReturn(ctx,)
        else:
            result = await self.unionReturn()
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler unionReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cComplexUnion](deref((<_module_types.ComplexUnion?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_list_UnionReturn(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[_module_types.cComplexUnion]]] cPromise
):
    cdef Promise_vector___module_types_cComplexUnion __promise = Promise_vector___module_types_cComplexUnion.create(cmove(cPromise))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_list_UnionReturn_coro(
            self,
            __context,
            __promise
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_list_UnionReturn_coro(
    object self,
    object ctx,
    Promise_vector___module_types_cComplexUnion promise
):
    try:
        if ctx and getattr(self.list_UnionReturn, "pass_context", False):
            result = await self.list_UnionReturn(ctx,)
        else:
            result = await self.list_UnionReturn()
        result = _module_types.List__ComplexUnion(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_UnionReturn:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[_module_types.cComplexUnion]](deref((<_module_types.List__ComplexUnion?> result)._cpp_obj)))

cdef api void call_cy_ReturnService_readDataEb(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_fbthrift_iobuf.cIOBuf]] cPromise,
    cint64_t size
):
    cdef Promise___iobuf_cIOBuf __promise = Promise___iobuf_cIOBuf.create(cmove(cPromise))
    arg_size = size
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_readDataEb_coro(
            self,
            __context,
            __promise,
            arg_size
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_readDataEb_coro(
    object self,
    object ctx,
    Promise___iobuf_cIOBuf promise,
    size
):
    try:
        if ctx and getattr(self.readDataEb, "pass_context", False):
            result = await self.readDataEb(ctx,
                      size)
        else:
            result = await self.readDataEb(
                      size)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler readDataEb:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(((<_fbthrift_iobuf.IOBuf>result).c_clone()))

cdef api void call_cy_ReturnService_readData(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[unique_ptr[_fbthrift_iobuf.cIOBuf]]] cPromise,
    cint64_t size
):
    cdef Promise_unique_ptr__iobuf_cIOBuf __promise = Promise_unique_ptr__iobuf_cIOBuf.create(cmove(cPromise))
    arg_size = size
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ReturnService_readData_coro(
            self,
            __context,
            __promise,
            arg_size
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ReturnService_readData_coro(
    object self,
    object ctx,
    Promise_unique_ptr__iobuf_cIOBuf promise,
    size
):
    try:
        if ctx and getattr(self.readData, "pass_context", False):
            result = await self.readData(ctx,
                      size)
        else:
            result = await self.readData(
                      size)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler readData:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[unique_ptr[_fbthrift_iobuf.cIOBuf]](((<_fbthrift_iobuf.IOBuf>result).c_clone())))

cdef api void call_cy_ParamService_void_ret_i16_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    cint16_t param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_i16_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_i16_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_i16_param, "pass_context", False):
            result = await self.void_ret_i16_param(ctx,
                      param1)
        else:
            result = await self.void_ret_i16_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_i16_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_byte_i16_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    cint8_t param1,
    cint16_t param2
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = param2
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_byte_i16_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_byte_i16_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.void_ret_byte_i16_param, "pass_context", False):
            result = await self.void_ret_byte_i16_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.void_ret_byte_i16_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_byte_i16_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_map_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    unique_ptr[cmap[string,cint64_t]] param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = _module_types.Map__string_i64.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_map_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_map_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_map_param, "pass_context", False):
            result = await self.void_ret_map_param(ctx,
                      param1)
        else:
            result = await self.void_ret_map_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_map_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_map_setlist_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    unique_ptr[cmap[string,cint64_t]] param1,
    unique_ptr[cset[vector[string]]] param2
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = _module_types.Map__string_i64.create(__to_shared_ptr(cmove(param1)))
    arg_param2 = _module_types.Set__List__string.create(__to_shared_ptr(cmove(param2)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_map_setlist_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_map_setlist_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.void_ret_map_setlist_param, "pass_context", False):
            result = await self.void_ret_map_setlist_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.void_ret_map_setlist_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_map_setlist_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_map_typedef_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    cint32_t param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_map_typedef_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_map_typedef_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_map_typedef_param, "pass_context", False):
            result = await self.void_ret_map_typedef_param(ctx,
                      param1)
        else:
            result = await self.void_ret_map_typedef_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_map_typedef_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_enum_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    _module_types.cMyEnumA param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = _module_types.MyEnumA(<int> param1)
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_enum_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_enum_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_enum_param, "pass_context", False):
            result = await self.void_ret_enum_param(ctx,
                      param1)
        else:
            result = await self.void_ret_enum_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_enum_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_struct_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    unique_ptr[_module_types.cMyStruct] param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = _module_types.MyStruct.create(shared_ptr[_module_types.cMyStruct](param1.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_struct_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_struct_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_struct_param, "pass_context", False):
            result = await self.void_ret_struct_param(ctx,
                      param1)
        else:
            result = await self.void_ret_struct_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_struct_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_void_ret_listunion_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cFollyUnit] cPromise,
    unique_ptr[vector[_module_types.cComplexUnion]] param1
):
    cdef Promise_cFollyUnit __promise = Promise_cFollyUnit.create(cmove(cPromise))
    arg_param1 = _module_types.List__ComplexUnion.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_void_ret_listunion_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_void_ret_listunion_param_coro(
    object self,
    object ctx,
    Promise_cFollyUnit promise,
    param1
):
    try:
        if ctx and getattr(self.void_ret_listunion_param, "pass_context", False):
            result = await self.void_ret_listunion_param(ctx,
                      param1)
        else:
            result = await self.void_ret_listunion_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler void_ret_listunion_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(c_unit)

cdef api void call_cy_ParamService_bool_ret_i32_i64_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise,
    cint32_t param1,
    cint64_t param2
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = param2
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_bool_ret_i32_i64_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_bool_ret_i32_i64_param_coro(
    object self,
    object ctx,
    Promise_cbool promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.bool_ret_i32_i64_param, "pass_context", False):
            result = await self.bool_ret_i32_i64_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.bool_ret_i32_i64_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler bool_ret_i32_i64_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_ParamService_bool_ret_map_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise,
    unique_ptr[cmap[string,cint64_t]] param1
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    arg_param1 = _module_types.Map__string_i64.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_bool_ret_map_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_bool_ret_map_param_coro(
    object self,
    object ctx,
    Promise_cbool promise,
    param1
):
    try:
        if ctx and getattr(self.bool_ret_map_param, "pass_context", False):
            result = await self.bool_ret_map_param(ctx,
                      param1)
        else:
            result = await self.bool_ret_map_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler bool_ret_map_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_ParamService_bool_ret_union_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cbool] cPromise,
    unique_ptr[_module_types.cComplexUnion] param1
):
    cdef Promise_cbool __promise = Promise_cbool.create(cmove(cPromise))
    arg_param1 = _module_types.ComplexUnion.create(shared_ptr[_module_types.cComplexUnion](param1.release()))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_bool_ret_union_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_bool_ret_union_param_coro(
    object self,
    object ctx,
    Promise_cbool promise,
    param1
):
    try:
        if ctx and getattr(self.bool_ret_union_param, "pass_context", False):
            result = await self.bool_ret_union_param(ctx,
                      param1)
        else:
            result = await self.bool_ret_union_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler bool_ret_union_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cbool> result)

cdef api void call_cy_ParamService_i64_ret_float_double_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint64_t] cPromise,
    float param1,
    double param2
):
    cdef Promise_cint64_t __promise = Promise_cint64_t.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = param2
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_i64_ret_float_double_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_i64_ret_float_double_param_coro(
    object self,
    object ctx,
    Promise_cint64_t promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.i64_ret_float_double_param, "pass_context", False):
            result = await self.i64_ret_float_double_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.i64_ret_float_double_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i64_ret_float_double_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint64_t> result)

cdef api void call_cy_ParamService_i64_ret_string_typedef_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint64_t] cPromise,
    unique_ptr[string] param1,
    unique_ptr[cset[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]] param2
):
    cdef Promise_cint64_t __promise = Promise_cint64_t.create(cmove(cPromise))
    arg_param1 = (deref(param1)).data().decode('UTF-8')
    arg_param2 = _module_types.Set__List__List__Map__Empty_MyStruct.create(__to_shared_ptr(cmove(param2)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_i64_ret_string_typedef_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_i64_ret_string_typedef_param_coro(
    object self,
    object ctx,
    Promise_cint64_t promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.i64_ret_string_typedef_param, "pass_context", False):
            result = await self.i64_ret_string_typedef_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.i64_ret_string_typedef_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i64_ret_string_typedef_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint64_t> result)

cdef api void call_cy_ParamService_i64_ret_i32_i32_i32_i32_i32_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint64_t] cPromise,
    cint32_t param1,
    cint32_t param2,
    cint32_t param3,
    cint32_t param4,
    cint32_t param5
):
    cdef Promise_cint64_t __promise = Promise_cint64_t.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = param2
    arg_param3 = param3
    arg_param4 = param4
    arg_param5 = param5
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_i64_ret_i32_i32_i32_i32_i32_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2,
            arg_param3,
            arg_param4,
            arg_param5
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_i64_ret_i32_i32_i32_i32_i32_param_coro(
    object self,
    object ctx,
    Promise_cint64_t promise,
    param1,
    param2,
    param3,
    param4,
    param5
):
    try:
        if ctx and getattr(self.i64_ret_i32_i32_i32_i32_i32_param, "pass_context", False):
            result = await self.i64_ret_i32_i32_i32_i32_i32_param(ctx,
                      param1,
                      param2,
                      param3,
                      param4,
                      param5)
        else:
            result = await self.i64_ret_i32_i32_i32_i32_i32_param(
                      param1,
                      param2,
                      param3,
                      param4,
                      param5)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler i64_ret_i32_i32_i32_i32_i32_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint64_t> result)

cdef api void call_cy_ParamService_double_ret_setstruct_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[double] cPromise,
    unique_ptr[cset[_module_types.cMyStruct]] param1
):
    cdef Promise_double __promise = Promise_double.create(cmove(cPromise))
    arg_param1 = _module_types.Set__MyStruct.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_double_ret_setstruct_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_double_ret_setstruct_param_coro(
    object self,
    object ctx,
    Promise_double promise,
    param1
):
    try:
        if ctx and getattr(self.double_ret_setstruct_param, "pass_context", False):
            result = await self.double_ret_setstruct_param(ctx,
                      param1)
        else:
            result = await self.double_ret_setstruct_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler double_ret_setstruct_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<double> result)

cdef api void call_cy_ParamService_string_ret_string_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[string] param1
):
    cdef Promise_string __promise = Promise_string.create(cmove(cPromise))
    arg_param1 = (deref(param1)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_string_ret_string_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_string_ret_string_param_coro(
    object self,
    object ctx,
    Promise_string promise,
    param1
):
    try:
        if ctx and getattr(self.string_ret_string_param, "pass_context", False):
            result = await self.string_ret_string_param(ctx,
                      param1)
        else:
            result = await self.string_ret_string_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler string_ret_string_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result.encode('UTF-8')))

cdef api void call_cy_ParamService_binary_ret_binary_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[string]] cPromise,
    unique_ptr[string] param1
):
    cdef Promise_binary __promise = Promise_binary.create(cmove(cPromise))
    arg_param1 = (deref(param1))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_binary_ret_binary_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_binary_ret_binary_param_coro(
    object self,
    object ctx,
    Promise_binary promise,
    param1
):
    try:
        if ctx and getattr(self.binary_ret_binary_param, "pass_context", False):
            result = await self.binary_ret_binary_param(ctx,
                      param1)
        else:
            result = await self.binary_ret_binary_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler binary_ret_binary_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[string](<string?> result))

cdef api void call_cy_ParamService_map_ret_bool_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cmap[string,cint64_t]]] cPromise,
    cbool param1
):
    cdef Promise_cmap__string_cint64_t __promise = Promise_cmap__string_cint64_t.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_map_ret_bool_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_map_ret_bool_param_coro(
    object self,
    object ctx,
    Promise_cmap__string_cint64_t promise,
    param1
):
    try:
        if ctx and getattr(self.map_ret_bool_param, "pass_context", False):
            result = await self.map_ret_bool_param(ctx,
                      param1)
        else:
            result = await self.map_ret_bool_param(
                      param1)
        result = _module_types.Map__string_i64(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler map_ret_bool_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cmap[string,cint64_t]](deref((<_module_types.Map__string_i64?> result)._cpp_obj)))

cdef api void call_cy_ParamService_list_ret_map_setlist_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[cbool]]] cPromise,
    unique_ptr[cmap[cint32_t,vector[string]]] param1,
    unique_ptr[vector[string]] param2
):
    cdef Promise_vector__cbool __promise = Promise_vector__cbool.create(cmove(cPromise))
    arg_param1 = _module_types.Map__i32_List__string.create(__to_shared_ptr(cmove(param1)))
    arg_param2 = _module_types.List__string.create(__to_shared_ptr(cmove(param2)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_list_ret_map_setlist_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_list_ret_map_setlist_param_coro(
    object self,
    object ctx,
    Promise_vector__cbool promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.list_ret_map_setlist_param, "pass_context", False):
            result = await self.list_ret_map_setlist_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.list_ret_map_setlist_param(
                      param1,
                      param2)
        result = _module_types.List__bool(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler list_ret_map_setlist_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[cbool]](deref((<_module_types.List__bool?> result)._cpp_obj)))

cdef api void call_cy_ParamService_mapsetlistmapliststring_ret_listlistlist_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]] cPromise,
    unique_ptr[vector[vector[vector[vector[cint32_t]]]]] param1
):
    cdef Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string __promise = Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string.create(cmove(cPromise))
    arg_param1 = _module_types.List__List__List__List__i32.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_mapsetlistmapliststring_ret_listlistlist_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_mapsetlistmapliststring_ret_listlistlist_param_coro(
    object self,
    object ctx,
    Promise_cmap__cset__vector__cint32_t_cmap__vector__cset__string_string promise,
    param1
):
    try:
        if ctx and getattr(self.mapsetlistmapliststring_ret_listlistlist_param, "pass_context", False):
            result = await self.mapsetlistmapliststring_ret_listlistlist_param(ctx,
                      param1)
        else:
            result = await self.mapsetlistmapliststring_ret_listlistlist_param(
                      param1)
        result = _module_types.Map__Set__List__i32_Map__List__Set__string_string(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler mapsetlistmapliststring_ret_listlistlist_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](deref((<_module_types.Map__Set__List__i32_Map__List__Set__string_string?> result)._cpp_obj)))

cdef api void call_cy_ParamService_typedef_ret_i32_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[cint32_t] cPromise,
    cint32_t param1
):
    cdef Promise_cint32_t __promise = Promise_cint32_t.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_typedef_ret_i32_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_typedef_ret_i32_param_coro(
    object self,
    object ctx,
    Promise_cint32_t promise,
    param1
):
    try:
        if ctx and getattr(self.typedef_ret_i32_param, "pass_context", False):
            result = await self.typedef_ret_i32_param(ctx,
                      param1)
        else:
            result = await self.typedef_ret_i32_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler typedef_ret_i32_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<cint32_t> result)

cdef api void call_cy_ParamService_listtypedef_ret_typedef_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[cint32_t]]] cPromise,
    unique_ptr[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]] param1
):
    cdef Promise_vector__cint32_t __promise = Promise_vector__cint32_t.create(cmove(cPromise))
    arg_param1 = _module_types.List__Map__Empty_MyStruct.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_listtypedef_ret_typedef_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_listtypedef_ret_typedef_param_coro(
    object self,
    object ctx,
    Promise_vector__cint32_t promise,
    param1
):
    try:
        if ctx and getattr(self.listtypedef_ret_typedef_param, "pass_context", False):
            result = await self.listtypedef_ret_typedef_param(ctx,
                      param1)
        else:
            result = await self.listtypedef_ret_typedef_param(
                      param1)
        result = _module_types.List__i32(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler listtypedef_ret_typedef_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[cint32_t]](deref((<_module_types.List__i32?> result)._cpp_obj)))

cdef api void call_cy_ParamService_enum_ret_double_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[_module_types.cMyEnumA] cPromise,
    double param1
):
    cdef Promise__module_types_cMyEnumA __promise = Promise__module_types_cMyEnumA.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_enum_ret_double_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_enum_ret_double_param_coro(
    object self,
    object ctx,
    Promise__module_types_cMyEnumA promise,
    param1
):
    try:
        if ctx and getattr(self.enum_ret_double_param, "pass_context", False):
            result = await self.enum_ret_double_param(ctx,
                      param1)
        else:
            result = await self.enum_ret_double_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler enum_ret_double_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<_module_types.cMyEnumA><int>result)

cdef api void call_cy_ParamService_enum_ret_double_enum_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[_module_types.cMyEnumA] cPromise,
    double param1,
    _module_types.cMyEnumA param2
):
    cdef Promise__module_types_cMyEnumA __promise = Promise__module_types_cMyEnumA.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = _module_types.MyEnumA(<int> param2)
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_enum_ret_double_enum_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_enum_ret_double_enum_param_coro(
    object self,
    object ctx,
    Promise__module_types_cMyEnumA promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.enum_ret_double_enum_param, "pass_context", False):
            result = await self.enum_ret_double_enum_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.enum_ret_double_enum_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler enum_ret_double_enum_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(<_module_types.cMyEnumA><int>result)

cdef api void call_cy_ParamService_listenum_ret_map_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[_module_types.cMyEnumA]]] cPromise,
    unique_ptr[cmap[string,cint64_t]] param1
):
    cdef Promise_vector___module_types_cMyEnumA __promise = Promise_vector___module_types_cMyEnumA.create(cmove(cPromise))
    arg_param1 = _module_types.Map__string_i64.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_listenum_ret_map_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_listenum_ret_map_param_coro(
    object self,
    object ctx,
    Promise_vector___module_types_cMyEnumA promise,
    param1
):
    try:
        if ctx and getattr(self.listenum_ret_map_param, "pass_context", False):
            result = await self.listenum_ret_map_param(ctx,
                      param1)
        else:
            result = await self.listenum_ret_map_param(
                      param1)
        result = _module_types.List__MyEnumA(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler listenum_ret_map_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[_module_types.cMyEnumA]](deref((<_module_types.List__MyEnumA?> result)._cpp_obj)))

cdef api void call_cy_ParamService_struct_ret_i16_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cMyStruct]] cPromise,
    cint16_t param1
):
    cdef Promise__module_types_cMyStruct __promise = Promise__module_types_cMyStruct.create(cmove(cPromise))
    arg_param1 = param1
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_struct_ret_i16_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_struct_ret_i16_param_coro(
    object self,
    object ctx,
    Promise__module_types_cMyStruct promise,
    param1
):
    try:
        if ctx and getattr(self.struct_ret_i16_param, "pass_context", False):
            result = await self.struct_ret_i16_param(ctx,
                      param1)
        else:
            result = await self.struct_ret_i16_param(
                      param1)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler struct_ret_i16_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cMyStruct](deref((<_module_types.MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ParamService_setstruct_ret_set_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[cset[_module_types.cMyStruct]]] cPromise,
    unique_ptr[cset[string]] param1
):
    cdef Promise_cset___module_types_cMyStruct __promise = Promise_cset___module_types_cMyStruct.create(cmove(cPromise))
    arg_param1 = _module_types.Set__string.create(__to_shared_ptr(cmove(param1)))
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_setstruct_ret_set_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_setstruct_ret_set_param_coro(
    object self,
    object ctx,
    Promise_cset___module_types_cMyStruct promise,
    param1
):
    try:
        if ctx and getattr(self.setstruct_ret_set_param, "pass_context", False):
            result = await self.setstruct_ret_set_param(ctx,
                      param1)
        else:
            result = await self.setstruct_ret_set_param(
                      param1)
        result = _module_types.Set__MyStruct(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler setstruct_ret_set_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[cset[_module_types.cMyStruct]](deref((<_module_types.Set__MyStruct?> result)._cpp_obj)))

cdef api void call_cy_ParamService_union_ret_i32_i32_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[_module_types.cComplexUnion]] cPromise,
    cint32_t param1,
    cint32_t param2
):
    cdef Promise__module_types_cComplexUnion __promise = Promise__module_types_cComplexUnion.create(cmove(cPromise))
    arg_param1 = param1
    arg_param2 = param2
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_union_ret_i32_i32_param_coro(
            self,
            __context,
            __promise,
            arg_param1,
            arg_param2
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_union_ret_i32_i32_param_coro(
    object self,
    object ctx,
    Promise__module_types_cComplexUnion promise,
    param1,
    param2
):
    try:
        if ctx and getattr(self.union_ret_i32_i32_param, "pass_context", False):
            result = await self.union_ret_i32_i32_param(ctx,
                      param1,
                      param2)
        else:
            result = await self.union_ret_i32_i32_param(
                      param1,
                      param2)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler union_ret_i32_i32_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[_module_types.cComplexUnion](deref((<_module_types.ComplexUnion?> result)._cpp_obj)))

cdef api void call_cy_ParamService_listunion_string_param(
    object self,
    Cpp2RequestContext* ctx,
    cFollyPromise[unique_ptr[vector[_module_types.cComplexUnion]]] cPromise,
    unique_ptr[string] param1
):
    cdef Promise_vector___module_types_cComplexUnion __promise = Promise_vector___module_types_cComplexUnion.create(cmove(cPromise))
    arg_param1 = (deref(param1)).data().decode('UTF-8')
    __context = RequestContext.create(ctx)
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __context_token = __THRIFT_REQUEST_CONTEXT.set(__context)
        __context = None
    asyncio.get_event_loop().create_task(
        ParamService_listunion_string_param_coro(
            self,
            __context,
            __promise,
            arg_param1
        )
    )
    if PY_VERSION_HEX >= 0x030702F0:  # 3.7.2 Final
        __THRIFT_REQUEST_CONTEXT.reset(__context_token)

async def ParamService_listunion_string_param_coro(
    object self,
    object ctx,
    Promise_vector___module_types_cComplexUnion promise,
    param1
):
    try:
        if ctx and getattr(self.listunion_string_param, "pass_context", False):
            result = await self.listunion_string_param(ctx,
                      param1)
        else:
            result = await self.listunion_string_param(
                      param1)
        result = _module_types.List__ComplexUnion(result)
    except __ApplicationError as ex:
        # If the handler raised an ApplicationError convert it to a C++ one
        promise.cPromise.setException(cTApplicationException(
            ex.type.value, ex.message.encode('UTF-8')
        ))
    except Exception as ex:
        print(
            "Unexpected error in service handler listunion_string_param:",
            file=sys.stderr)
        traceback.print_exc()
        promise.cPromise.setException(cTApplicationException(
            cTApplicationExceptionType__UNKNOWN, repr(ex).encode('UTF-8')
        ))
    else:
        promise.cPromise.setValue(make_unique[vector[_module_types.cComplexUnion]](deref((<_module_types.List__ComplexUnion?> result)._cpp_obj)))

