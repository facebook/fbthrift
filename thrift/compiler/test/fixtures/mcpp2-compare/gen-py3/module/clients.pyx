#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libcpp.vector cimport vector as vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper
from thrift.py3.exceptions cimport try_make_shared_exception, raise_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
import thrift.py3.client
cimport thrift.py3.client
from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport cython

import asyncio
import sys
import traceback

cimport module.types
import module.types
cimport includes.types
import includes.types

from module.clients_wrapper cimport cEmptyServiceAsyncClient, cEmptyServiceClientWrapper
from module.clients_wrapper cimport cReturnServiceAsyncClient, cReturnServiceClientWrapper
from module.clients_wrapper cimport cParamServiceAsyncClient, cParamServiceClientWrapper


cdef void ReturnService_noReturn_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ReturnService_boolReturn_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void ReturnService_i16Return_callback(
    cFollyTry[int16_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_i32Return_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_i64Return_callback(
    cFollyTry[int64_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_floatReturn_callback(
    cFollyTry[float]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_doubleReturn_callback(
    cFollyTry[double]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_stringReturn_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void ReturnService_binaryReturn_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_mapReturn_callback(
    cFollyTry[cmap[string,int64_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Map__string_i64.create(make_shared[cmap[string,int64_t]](result.value())))

cdef void ReturnService_simpleTypedefReturn_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_complexTypedefReturn_callback(
    cFollyTry[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__Map__Empty_MyStruct.create(make_shared[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]](result.value())))

cdef void ReturnService_list_mostComplexTypedefReturn_callback(
    cFollyTry[vector[vector[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__List__List__Map__Empty_MyStruct.create(make_shared[vector[vector[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]]]](result.value())))

cdef void ReturnService_enumReturn_callback(
    cFollyTry[module.types.cMyEnumA]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.MyEnumA(<int> result.value()))

cdef void ReturnService_list_EnumReturn_callback(
    cFollyTry[vector[module.types.cMyEnumA]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__MyEnumA.create(make_shared[vector[module.types.cMyEnumA]](result.value())))

cdef void ReturnService_structReturn_callback(
    cFollyTry[module.types.cMyStruct]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.MyStruct.create(make_shared[module.types.cMyStruct](result.value())))

cdef void ReturnService_set_StructReturn_callback(
    cFollyTry[cset[module.types.cMyStruct]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__MyStruct.create(make_shared[cset[module.types.cMyStruct]](result.value())))

cdef void ReturnService_unionReturn_callback(
    cFollyTry[module.types.cComplexUnion]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.ComplexUnion.create(make_shared[module.types.cComplexUnion](result.value())))

cdef void ReturnService_list_UnionReturn_callback(
    cFollyTry[vector[module.types.cComplexUnion]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__ComplexUnion.create(make_shared[vector[module.types.cComplexUnion]](result.value())))

cdef void ReturnService_readDataEb_callback(
    cFollyTry[module.types.folly_IOBuf]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ReturnService_readData_callback(
    cFollyTry[module.types.std_unique_ptr_folly_IOBuf]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_void_ret_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_byte_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_map_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_map_setlist_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_map_typedef_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_enum_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_struct_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_void_ret_listunion_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(None)

cdef void ParamService_bool_ret_i32_i64_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void ParamService_bool_ret_map_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void ParamService_bool_ret_union_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(<bint>result.value())

cdef void ParamService_i64_ret_float_double_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_i64_ret_string_typedef_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_double_ret_setstruct_param_callback(
    cFollyTry[double]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_string_ret_string_param_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value().decode('UTF-8'))

cdef void ParamService_binary_ret_binary_param_callback(
    cFollyTry[string]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_map_ret_bool_param_callback(
    cFollyTry[cmap[string,int64_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Map__string_i64.create(make_shared[cmap[string,int64_t]](result.value())))

cdef void ParamService_list_ret_map_setlist_param_callback(
    cFollyTry[vector[cbool]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__bool.create(make_shared[vector[cbool]](result.value())))

cdef void ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback(
    cFollyTry[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Map__Set__List__i32_Map__List__Set__string_string.create(make_shared[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](result.value())))

cdef void ParamService_typedef_ret_i32_param_callback(
    cFollyTry[int32_t]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(result.value())

cdef void ParamService_listtypedef_ret_typedef_param_callback(
    cFollyTry[vector[int32_t]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__i32.create(make_shared[vector[int32_t]](result.value())))

cdef void ParamService_enum_ret_double_param_callback(
    cFollyTry[module.types.cMyEnumA]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.MyEnumA(<int> result.value()))

cdef void ParamService_enum_ret_double_enum_param_callback(
    cFollyTry[module.types.cMyEnumA]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.MyEnumA(<int> result.value()))

cdef void ParamService_listenum_ret_map_param_callback(
    cFollyTry[vector[module.types.cMyEnumA]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__MyEnumA.create(make_shared[vector[module.types.cMyEnumA]](result.value())))

cdef void ParamService_struct_ret_i16_param_callback(
    cFollyTry[module.types.cMyStruct]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.MyStruct.create(make_shared[module.types.cMyStruct](result.value())))

cdef void ParamService_setstruct_ret_set_param_callback(
    cFollyTry[cset[module.types.cMyStruct]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.Set__MyStruct.create(make_shared[cset[module.types.cMyStruct]](result.value())))

cdef void ParamService_union_ret_i32_i32_param_callback(
    cFollyTry[module.types.cComplexUnion]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.ComplexUnion.create(make_shared[module.types.cComplexUnion](result.value())))

cdef void ParamService_listunion_string_param_callback(
    cFollyTry[vector[module.types.cComplexUnion]]&& result,
    PyObject* future
):
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            raise_py_exception(result.exception())
        except Exception as ex:
            pyfuture.set_exception(ex)
    else:
        pyfuture.set_result(module.types.List__ComplexUnion.create(make_shared[vector[module.types.cComplexUnion]](result.value())))


cdef class EmptyService(thrift.py3.client.Client):

    def __cinit__(EmptyService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(EmptyService self):
        return &typeid(cEmptyServiceAsyncClient)

    @staticmethod
    cdef _module_EmptyService_set_client(EmptyService inst, shared_ptr[cEmptyServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_EmptyService_client = c_obj

    cdef _module_EmptyService_reset_client(EmptyService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_EmptyService_client.reset()

    def __dealloc__(EmptyService self):
        if self._cRequestChannel or self._module_EmptyService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(EmptyService self):
        await self._connect_future
        if self._cRequestChannel:
            EmptyService._module_EmptyService_set_client(
                self,
                makeClientWrapper[cEmptyServiceAsyncClient, cEmptyServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(EmptyService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_EmptyService_client).disconnect(),
            closed_EmptyService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_EmptyService_reset_client()

    def set_persistent_header(EmptyService self, str key, str value):
        if not self._module_EmptyService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_EmptyService_client).setPersistentHeader(ckey, cvalue)



cdef void closed_EmptyService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
cdef class ReturnService(thrift.py3.client.Client):

    def __cinit__(ReturnService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(ReturnService self):
        return &typeid(cReturnServiceAsyncClient)

    @staticmethod
    cdef _module_ReturnService_set_client(ReturnService inst, shared_ptr[cReturnServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_ReturnService_client = c_obj

    cdef _module_ReturnService_reset_client(ReturnService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_ReturnService_client.reset()

    def __dealloc__(ReturnService self):
        if self._cRequestChannel or self._module_ReturnService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(ReturnService self):
        await self._connect_future
        if self._cRequestChannel:
            ReturnService._module_ReturnService_set_client(
                self,
                makeClientWrapper[cReturnServiceAsyncClient, cReturnServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(ReturnService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ReturnService_client).disconnect(),
            closed_ReturnService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_ReturnService_reset_client()

    def set_persistent_header(ReturnService self, str key, str value):
        if not self._module_ReturnService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_ReturnService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    async def noReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ReturnService_client).noReturn(
            ),
            ReturnService_noReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def boolReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ReturnService_client).boolReturn(
            ),
            ReturnService_boolReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i16Return(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int16_t](
            self._executor,
            deref(self._module_ReturnService_client).i16Return(
            ),
            ReturnService_i16Return_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i32Return(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ReturnService_client).i32Return(
            ),
            ReturnService_i32Return_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i64Return(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ReturnService_client).i64Return(
            ),
            ReturnService_i64Return_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def floatReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[float](
            self._executor,
            deref(self._module_ReturnService_client).floatReturn(
            ),
            ReturnService_floatReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def doubleReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_ReturnService_client).doubleReturn(
            ),
            ReturnService_doubleReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def stringReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ReturnService_client).stringReturn(
            ),
            ReturnService_stringReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def binaryReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ReturnService_client).binaryReturn(
            ),
            ReturnService_binaryReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def mapReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cmap[string,int64_t]](
            self._executor,
            deref(self._module_ReturnService_client).mapReturn(
            ),
            ReturnService_mapReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def simpleTypedefReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ReturnService_client).simpleTypedefReturn(
            ),
            ReturnService_simpleTypedefReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def complexTypedefReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]](
            self._executor,
            deref(self._module_ReturnService_client).complexTypedefReturn(
            ),
            ReturnService_complexTypedefReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_mostComplexTypedefReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[vector[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]]]](
            self._executor,
            deref(self._module_ReturnService_client).list_mostComplexTypedefReturn(
            ),
            ReturnService_list_mostComplexTypedefReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def enumReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cMyEnumA](
            self._executor,
            deref(self._module_ReturnService_client).enumReturn(
            ),
            ReturnService_enumReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_EnumReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[module.types.cMyEnumA]](
            self._executor,
            deref(self._module_ReturnService_client).list_EnumReturn(
            ),
            ReturnService_list_EnumReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def structReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cMyStruct](
            self._executor,
            deref(self._module_ReturnService_client).structReturn(
            ),
            ReturnService_structReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def set_StructReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[module.types.cMyStruct]](
            self._executor,
            deref(self._module_ReturnService_client).set_StructReturn(
            ),
            ReturnService_set_StructReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def unionReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cComplexUnion](
            self._executor,
            deref(self._module_ReturnService_client).unionReturn(
            ),
            ReturnService_unionReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_UnionReturn(
            ReturnService self):
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[module.types.cComplexUnion]](
            self._executor,
            deref(self._module_ReturnService_client).list_UnionReturn(
            ),
            ReturnService_list_UnionReturn_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def readDataEb(
            ReturnService self,
            int size):
        if size is None:
            raise TypeError('size can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.folly_IOBuf](
            self._executor,
            deref(self._module_ReturnService_client).readDataEb(
                size,
            ),
            ReturnService_readDataEb_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def readData(
            ReturnService self,
            int size):
        if size is None:
            raise TypeError('size can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.std_unique_ptr_folly_IOBuf](
            self._executor,
            deref(self._module_ReturnService_client).readData(
                size,
            ),
            ReturnService_readData_callback,
            <PyObject *> __future
        )
        return await __future



cdef void closed_ReturnService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
cdef class ParamService(thrift.py3.client.Client):

    def __cinit__(ParamService self):
        loop = asyncio.get_event_loop()
        self._deferred_headers = {}
        self._connect_future = loop.create_future()
        self._executor = get_executor()

    cdef const type_info* _typeid(ParamService self):
        return &typeid(cParamServiceAsyncClient)

    @staticmethod
    cdef _module_ParamService_set_client(ParamService inst, shared_ptr[cParamServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_ParamService_client = c_obj

    cdef _module_ParamService_reset_client(ParamService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_ParamService_client.reset()

    def __dealloc__(ParamService self):
        if self._cRequestChannel or self._module_ParamService_client:
            print('client was not cleaned up, use the context manager', file=sys.stderr)

    async def __aenter__(ParamService self):
        await self._connect_future
        if self._cRequestChannel:
            ParamService._module_ParamService_set_client(
                self,
                makeClientWrapper[cParamServiceAsyncClient, cParamServiceClientWrapper](
                    self._cRequestChannel
                ),
            )
            self._cRequestChannel.reset()
        else:
            raise asyncio.InvalidStateError('Client context has been used already')
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    async def __aexit__(ParamService self, *exc):
        self._check_connect_future()
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).disconnect(),
            closed_ParamService_py3_client_callback,
            <PyObject *>future
        )
        # To break any future usage of this client
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio.InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        await future
        self._module_ParamService_reset_client()

    def set_persistent_header(ParamService self, str key, str value):
        if not self._module_ParamService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_ParamService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    async def void_ret_i16_param(
            ParamService self,
            int param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_i16_param(
                param1,
            ),
            ParamService_void_ret_i16_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_byte_i16_param(
            ParamService self,
            int param1,
            int param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_byte_i16_param(
                param1,
                param2,
            ),
            ParamService_void_ret_byte_i16_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_map_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Map__string_i64):
            param1 = module.types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_param(
                cmap[string,int64_t](deref(module.types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_void_ret_map_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_map_setlist_param(
            ParamService self,
            param1,
            param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Map__string_i64):
            param1 = module.types.Map__string_i64(param1)
        if param2 is None:
            raise TypeError('param2 can not be None')
        if not isinstance(param2, module.types.Set__List__string):
            param2 = module.types.Set__List__string(param2)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_setlist_param(
                cmap[string,int64_t](deref(module.types.Map__string_i64(param1)._cpp_obj.get())),
                cset[vector[string]](deref(module.types.Set__List__string(param2)._cpp_obj.get())),
            ),
            ParamService_void_ret_map_setlist_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_map_typedef_param(
            ParamService self,
            int param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_typedef_param(
                param1,
            ),
            ParamService_void_ret_map_typedef_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_enum_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.MyEnumA):
            raise ValueError('param1 is not of the enum type { module.types.MyEnumA }.')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_enum_param(
                module.types.MyEnumA_to_cpp(param1),
            ),
            ParamService_void_ret_enum_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_struct_param(
            ParamService self,
            module.types.MyStruct param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_struct_param(
                deref((<module.types.MyStruct>param1)._cpp_obj),
            ),
            ParamService_void_ret_struct_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def void_ret_listunion_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.List__ComplexUnion):
            param1 = module.types.List__ComplexUnion(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_listunion_param(
                vector[module.types.cComplexUnion](deref(module.types.List__ComplexUnion(param1)._cpp_obj.get())),
            ),
            ParamService_void_ret_listunion_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def bool_ret_i32_i64_param(
            ParamService self,
            int param1,
            int param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_i32_i64_param(
                param1,
                param2,
            ),
            ParamService_bool_ret_i32_i64_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def bool_ret_map_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Map__string_i64):
            param1 = module.types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_map_param(
                cmap[string,int64_t](deref(module.types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_bool_ret_map_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def bool_ret_union_param(
            ParamService self,
            module.types.ComplexUnion param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_union_param(
                deref((<module.types.ComplexUnion>param1)._cpp_obj),
            ),
            ParamService_bool_ret_union_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i64_ret_float_double_param(
            ParamService self,
            float param1,
            float param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_float_double_param(
                param1,
                param2,
            ),
            ParamService_i64_ret_float_double_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i64_ret_string_typedef_param(
            ParamService self,
            str param1,
            param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        if not isinstance(param2, module.types.Set__List__List__Map__Empty_MyStruct):
            param2 = module.types.Set__List__List__Map__Empty_MyStruct(param2)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_string_typedef_param(
                param1.encode('UTF-8'),
                cset[vector[vector[cmap[module.types.cEmpty,module.types.cMyStruct]]]](deref(module.types.Set__List__List__Map__Empty_MyStruct(param2)._cpp_obj.get())),
            ),
            ParamService_i64_ret_string_typedef_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def i64_ret_i32_i32_i32_i32_i32_param(
            ParamService self,
            int param1,
            int param2,
            int param3,
            int param4,
            int param5):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        if param3 is None:
            raise TypeError('param3 can not be None')
        if param4 is None:
            raise TypeError('param4 can not be None')
        if param5 is None:
            raise TypeError('param5 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_i32_i32_i32_i32_i32_param(
                param1,
                param2,
                param3,
                param4,
                param5,
            ),
            ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def double_ret_setstruct_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Set__MyStruct):
            param1 = module.types.Set__MyStruct(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_ParamService_client).double_ret_setstruct_param(
                cset[module.types.cMyStruct](deref(module.types.Set__MyStruct(param1)._cpp_obj.get())),
            ),
            ParamService_double_ret_setstruct_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def string_ret_string_param(
            ParamService self,
            str param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ParamService_client).string_ret_string_param(
                param1.encode('UTF-8'),
            ),
            ParamService_string_ret_string_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def binary_ret_binary_param(
            ParamService self,
            bytes param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ParamService_client).binary_ret_binary_param(
                param1,
            ),
            ParamService_binary_ret_binary_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def map_ret_bool_param(
            ParamService self,
            pbool param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cmap[string,int64_t]](
            self._executor,
            deref(self._module_ParamService_client).map_ret_bool_param(
                param1,
            ),
            ParamService_map_ret_bool_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def list_ret_map_setlist_param(
            ParamService self,
            param1,
            param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Map__i32_List__string):
            param1 = module.types.Map__i32_List__string(param1)
        if param2 is None:
            raise TypeError('param2 can not be None')
        if not isinstance(param2, module.types.List__string):
            param2 = module.types.List__string(param2)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[cbool]](
            self._executor,
            deref(self._module_ParamService_client).list_ret_map_setlist_param(
                cmap[int32_t,vector[string]](deref(module.types.Map__i32_List__string(param1)._cpp_obj.get())),
                vector[string](deref(module.types.List__string(param2)._cpp_obj.get())),
            ),
            ParamService_list_ret_map_setlist_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def mapsetlistmapliststring_ret_listlistlist_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.List__List__List__List__i32):
            param1 = module.types.List__List__List__List__i32(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](
            self._executor,
            deref(self._module_ParamService_client).mapsetlistmapliststring_ret_listlistlist_param(
                vector[vector[vector[vector[int32_t]]]](deref(module.types.List__List__List__List__i32(param1)._cpp_obj.get())),
            ),
            ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def typedef_ret_i32_param(
            ParamService self,
            int param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ParamService_client).typedef_ret_i32_param(
                param1,
            ),
            ParamService_typedef_ret_i32_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def listtypedef_ret_typedef_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.List__Map__Empty_MyStruct):
            param1 = module.types.List__Map__Empty_MyStruct(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[int32_t]](
            self._executor,
            deref(self._module_ParamService_client).listtypedef_ret_typedef_param(
                vector[cmap[module.types.cEmpty,module.types.cMyStruct]](deref(module.types.List__Map__Empty_MyStruct(param1)._cpp_obj.get())),
            ),
            ParamService_listtypedef_ret_typedef_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def enum_ret_double_param(
            ParamService self,
            float param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cMyEnumA](
            self._executor,
            deref(self._module_ParamService_client).enum_ret_double_param(
                param1,
            ),
            ParamService_enum_ret_double_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def enum_ret_double_enum_param(
            ParamService self,
            float param1,
            param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        if not isinstance(param2, module.types.MyEnumA):
            raise ValueError('param2 is not of the enum type { module.types.MyEnumA }.')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cMyEnumA](
            self._executor,
            deref(self._module_ParamService_client).enum_ret_double_enum_param(
                param1,
                module.types.MyEnumA_to_cpp(param2),
            ),
            ParamService_enum_ret_double_enum_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def listenum_ret_map_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Map__string_i64):
            param1 = module.types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[module.types.cMyEnumA]](
            self._executor,
            deref(self._module_ParamService_client).listenum_ret_map_param(
                cmap[string,int64_t](deref(module.types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_listenum_ret_map_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def struct_ret_i16_param(
            ParamService self,
            int param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cMyStruct](
            self._executor,
            deref(self._module_ParamService_client).struct_ret_i16_param(
                param1,
            ),
            ParamService_struct_ret_i16_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def setstruct_ret_set_param(
            ParamService self,
            param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if not isinstance(param1, module.types.Set__string):
            param1 = module.types.Set__string(param1)
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[cset[module.types.cMyStruct]](
            self._executor,
            deref(self._module_ParamService_client).setstruct_ret_set_param(
                cset[string](deref(module.types.Set__string(param1)._cpp_obj.get())),
            ),
            ParamService_setstruct_ret_set_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def union_ret_i32_i32_param(
            ParamService self,
            int param1,
            int param2):
        if param1 is None:
            raise TypeError('param1 can not be None')
        if param2 is None:
            raise TypeError('param2 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[module.types.cComplexUnion](
            self._executor,
            deref(self._module_ParamService_client).union_ret_i32_i32_param(
                param1,
                param2,
            ),
            ParamService_union_ret_i32_i32_param_callback,
            <PyObject *> __future
        )
        return await __future

    @cython.always_allow_keywords(True)
    async def listunion_string_param(
            ParamService self,
            str param1):
        if param1 is None:
            raise TypeError('param1 can not be None')
        self._check_connect_future()
        __loop = asyncio.get_event_loop()
        __future = __loop.create_future()
        bridgeFutureWith[vector[module.types.cComplexUnion]](
            self._executor,
            deref(self._module_ParamService_client).listunion_string_param(
                param1.encode('UTF-8'),
            ),
            ParamService_listunion_string_param_callback,
            <PyObject *> __future
        )
        return await __future



cdef void closed_ParamService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* fut,
):
    cdef object pyfuture = <object> fut
    pyfuture.set_result(None)
