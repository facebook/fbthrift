#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libcpp.vector cimport vector as vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper
from thrift.py3.exceptions cimport try_make_shared_exception, create_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
import thrift.py3.client
cimport thrift.py3.client
from thrift.py3.common cimport RpcOptions as __RpcOptions
from thrift.py3.common import RpcOptions as __RpcOptions

from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport cython

import sys
import types as _py_types
from asyncio import get_event_loop as asyncio_get_event_loop, shield as asyncio_shield, InvalidStateError as asyncio_InvalidStateError

cimport module.types as _module_types
import module.types as _module_types
cimport includes.types as _includes_types
import includes.types as _includes_types

from module.clients_wrapper cimport cEmptyServiceAsyncClient, cEmptyServiceClientWrapper
from module.clients_wrapper cimport cReturnServiceAsyncClient, cReturnServiceClientWrapper
from module.clients_wrapper cimport cParamServiceAsyncClient, cParamServiceClientWrapper


cdef void ReturnService_noReturn_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_boolReturn_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i16Return_callback(
    cFollyTry[int16_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i32Return_callback(
    cFollyTry[int32_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i64Return_callback(
    cFollyTry[int64_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_floatReturn_callback(
    cFollyTry[float]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_doubleReturn_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_stringReturn_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_binaryReturn_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_mapReturn_callback(
    cFollyTry[cmap[string,int64_t]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_i64.create(make_shared[cmap[string,int64_t]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_simpleTypedefReturn_callback(
    cFollyTry[int32_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_complexTypedefReturn_callback(
    cFollyTry[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__Map__Empty_MyStruct.create(make_shared[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_mostComplexTypedefReturn_callback(
    cFollyTry[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__List__List__Map__Empty_MyStruct.create(make_shared[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_enumReturn_callback(
    cFollyTry[_module_types.cMyEnumA]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_EnumReturn_callback(
    cFollyTry[vector[_module_types.cMyEnumA]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__MyEnumA.create(make_shared[vector[_module_types.cMyEnumA]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_structReturn_callback(
    cFollyTry[_module_types.cMyStruct]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.MyStruct.create(make_shared[_module_types.cMyStruct](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_set_StructReturn_callback(
    cFollyTry[cset[_module_types.cMyStruct]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.Set__MyStruct.create(make_shared[cset[_module_types.cMyStruct]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_unionReturn_callback(
    cFollyTry[_module_types.cComplexUnion]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.ComplexUnion.create(make_shared[_module_types.cComplexUnion](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_UnionReturn_callback(
    cFollyTry[vector[_module_types.cComplexUnion]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__ComplexUnion.create(make_shared[vector[_module_types.cComplexUnion]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_readDataEb_callback(
    cFollyTry[_module_types.folly_IOBuf]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_readData_callback(
    cFollyTry[_module_types.std_unique_ptr_folly_IOBuf]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_byte_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_setlist_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_typedef_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_enum_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_struct_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_listunion_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_i32_i64_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_map_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_union_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_float_double_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_string_typedef_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback(
    cFollyTry[int64_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_double_ret_setstruct_param_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_string_ret_string_param_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_binary_ret_binary_param_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_map_ret_bool_param_callback(
    cFollyTry[cmap[string,int64_t]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_i64.create(make_shared[cmap[string,int64_t]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_list_ret_map_setlist_param_callback(
    cFollyTry[vector[cbool]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__bool.create(make_shared[vector[cbool]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback(
    cFollyTry[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.Map__Set__List__i32_Map__List__Set__string_string.create(make_shared[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_typedef_ret_i32_param_callback(
    cFollyTry[int32_t]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listtypedef_ret_typedef_param_callback(
    cFollyTry[vector[int32_t]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__i32.create(make_shared[vector[int32_t]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_enum_ret_double_param_callback(
    cFollyTry[_module_types.cMyEnumA]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_enum_ret_double_enum_param_callback(
    cFollyTry[_module_types.cMyEnumA]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listenum_ret_map_param_callback(
    cFollyTry[vector[_module_types.cMyEnumA]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__MyEnumA.create(make_shared[vector[_module_types.cMyEnumA]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_struct_ret_i16_param_callback(
    cFollyTry[_module_types.cMyStruct]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.MyStruct.create(make_shared[_module_types.cMyStruct](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_setstruct_ret_set_param_callback(
    cFollyTry[cset[_module_types.cMyStruct]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.Set__MyStruct.create(make_shared[cset[_module_types.cMyStruct]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_union_ret_i32_i32_param_callback(
    cFollyTry[_module_types.cComplexUnion]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.ComplexUnion.create(make_shared[_module_types.cComplexUnion](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listunion_string_param_callback(
    cFollyTry[vector[_module_types.cComplexUnion]]&& result,
    PyObject* userdata
):
    client, pyfuture, _ = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception()))
    else:
        try:
            pyfuture.set_result(_module_types.List__ComplexUnion.create(make_shared[vector[_module_types.cComplexUnion]](result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))


cdef object _EmptyService_annotations = _py_types.MappingProxyType({
})


cdef class EmptyService(thrift.py3.client.Client):
    annotations = _EmptyService_annotations

    def __cinit__(EmptyService self):
        loop = asyncio_get_event_loop()
        self._connect_future = loop.create_future()
        self._deferred_headers = {}

    cdef const type_info* _typeid(EmptyService self):
        return &typeid(cEmptyServiceAsyncClient)

    @staticmethod
    cdef _module_EmptyService_set_client(EmptyService inst, shared_ptr[cEmptyServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_EmptyService_client = c_obj

    cdef _module_EmptyService_reset_client(EmptyService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_EmptyService_client.reset()

    def __dealloc__(EmptyService self):
        if self._connect_future.done() and not self._connect_future.exception():
            print(f'thrift-py3 client: {self!r} was not cleaned up, use the async context manager', file=sys.stderr)
            if self._module_EmptyService_client:
                deref(self._module_EmptyService_client).disconnect().get()
        self._module_EmptyService_reset_client()

    cdef bind_client(EmptyService self, cRequestChannel_ptr&& channel):
        EmptyService._module_EmptyService_set_client(
            self,
            makeClientWrapper[cEmptyServiceAsyncClient, cEmptyServiceClientWrapper](
                thrift.py3.client.move(channel)
            ),
        )

    async def __aenter__(EmptyService self):
        await asyncio_shield(self._connect_future)
        if self._context_entered:
            raise asyncio_InvalidStateError('Client context has been used already')
        self._context_entered = True
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    def __aexit__(EmptyService self, *exc):
        self._check_connect_future()
        loop = asyncio_get_event_loop()
        future = loop.create_future()
        userdata = (self, future)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_EmptyService_client).disconnect(),
            closed_EmptyService_py3_client_callback,
            <PyObject *>userdata  # So we keep client alive until disconnect
        )
        # To break any future usage of this client
        # Also to prevent dealloc from trying to disconnect in a blocking way.
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio_InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        return asyncio_shield(future)

    def set_persistent_header(EmptyService self, str key, str value):
        if not self._module_EmptyService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_EmptyService_client).setPersistentHeader(ckey, cvalue)



cdef void closed_EmptyService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata,
):
    client, pyfuture = <object> userdata 
    pyfuture.set_result(None)
cdef object _ReturnService_annotations = _py_types.MappingProxyType({
})


cdef class ReturnService(thrift.py3.client.Client):
    annotations = _ReturnService_annotations

    def __cinit__(ReturnService self):
        loop = asyncio_get_event_loop()
        self._connect_future = loop.create_future()
        self._deferred_headers = {}

    cdef const type_info* _typeid(ReturnService self):
        return &typeid(cReturnServiceAsyncClient)

    @staticmethod
    cdef _module_ReturnService_set_client(ReturnService inst, shared_ptr[cReturnServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_ReturnService_client = c_obj

    cdef _module_ReturnService_reset_client(ReturnService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_ReturnService_client.reset()

    def __dealloc__(ReturnService self):
        if self._connect_future.done() and not self._connect_future.exception():
            print(f'thrift-py3 client: {self!r} was not cleaned up, use the async context manager', file=sys.stderr)
            if self._module_ReturnService_client:
                deref(self._module_ReturnService_client).disconnect().get()
        self._module_ReturnService_reset_client()

    cdef bind_client(ReturnService self, cRequestChannel_ptr&& channel):
        ReturnService._module_ReturnService_set_client(
            self,
            makeClientWrapper[cReturnServiceAsyncClient, cReturnServiceClientWrapper](
                thrift.py3.client.move(channel)
            ),
        )

    async def __aenter__(ReturnService self):
        await asyncio_shield(self._connect_future)
        if self._context_entered:
            raise asyncio_InvalidStateError('Client context has been used already')
        self._context_entered = True
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    def __aexit__(ReturnService self, *exc):
        self._check_connect_future()
        loop = asyncio_get_event_loop()
        future = loop.create_future()
        userdata = (self, future)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ReturnService_client).disconnect(),
            closed_ReturnService_py3_client_callback,
            <PyObject *>userdata  # So we keep client alive until disconnect
        )
        # To break any future usage of this client
        # Also to prevent dealloc from trying to disconnect in a blocking way.
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio_InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        return asyncio_shield(future)

    def set_persistent_header(ReturnService self, str key, str value):
        if not self._module_ReturnService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_ReturnService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    def noReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ReturnService_client).noReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_noReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def boolReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ReturnService_client).boolReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_boolReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i16Return(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int16_t](
            self._executor,
            deref(self._module_ReturnService_client).i16Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i16Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i32Return(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ReturnService_client).i32Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i32Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i64Return(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ReturnService_client).i64Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i64Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def floatReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[float](
            self._executor,
            deref(self._module_ReturnService_client).floatReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_floatReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def doubleReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_ReturnService_client).doubleReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_doubleReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def stringReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ReturnService_client).stringReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_stringReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def binaryReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ReturnService_client).binaryReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_binaryReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def mapReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,int64_t]](
            self._executor,
            deref(self._module_ReturnService_client).mapReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_mapReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def simpleTypedefReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ReturnService_client).simpleTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_simpleTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def complexTypedefReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]](
            self._executor,
            deref(self._module_ReturnService_client).complexTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_complexTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def list_mostComplexTypedefReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]]](
            self._executor,
            deref(self._module_ReturnService_client).list_mostComplexTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_mostComplexTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def enumReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cMyEnumA](
            self._executor,
            deref(self._module_ReturnService_client).enumReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_enumReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def list_EnumReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_types.cMyEnumA]](
            self._executor,
            deref(self._module_ReturnService_client).list_EnumReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_EnumReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def structReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cMyStruct](
            self._executor,
            deref(self._module_ReturnService_client).structReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_structReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def set_StructReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[_module_types.cMyStruct]](
            self._executor,
            deref(self._module_ReturnService_client).set_StructReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_set_StructReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def unionReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cComplexUnion](
            self._executor,
            deref(self._module_ReturnService_client).unionReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_unionReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def list_UnionReturn(
            ReturnService self,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_types.cComplexUnion]](
            self._executor,
            deref(self._module_ReturnService_client).list_UnionReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_UnionReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def readDataEb(
            ReturnService self,
            size not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(size, int):
            raise TypeError(f'size is not a {int !r}.')
        else:
            <int64_t> size
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.folly_IOBuf](
            self._executor,
            deref(self._module_ReturnService_client).readDataEb(rpc_options._cpp_obj, 
                size,
            ),
            ReturnService_readDataEb_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def readData(
            ReturnService self,
            size not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(size, int):
            raise TypeError(f'size is not a {int !r}.')
        else:
            <int64_t> size
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.std_unique_ptr_folly_IOBuf](
            self._executor,
            deref(self._module_ReturnService_client).readData(rpc_options._cpp_obj, 
                size,
            ),
            ReturnService_readData_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)



cdef void closed_ReturnService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata,
):
    client, pyfuture = <object> userdata 
    pyfuture.set_result(None)
cdef object _ParamService_annotations = _py_types.MappingProxyType({
})


cdef class ParamService(thrift.py3.client.Client):
    annotations = _ParamService_annotations

    def __cinit__(ParamService self):
        loop = asyncio_get_event_loop()
        self._connect_future = loop.create_future()
        self._deferred_headers = {}

    cdef const type_info* _typeid(ParamService self):
        return &typeid(cParamServiceAsyncClient)

    @staticmethod
    cdef _module_ParamService_set_client(ParamService inst, shared_ptr[cParamServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_ParamService_client = c_obj

    cdef _module_ParamService_reset_client(ParamService self):
        """So the class hierarchy resets the shared pointer up the chain"""
        self._module_ParamService_client.reset()

    def __dealloc__(ParamService self):
        if self._connect_future.done() and not self._connect_future.exception():
            print(f'thrift-py3 client: {self!r} was not cleaned up, use the async context manager', file=sys.stderr)
            if self._module_ParamService_client:
                deref(self._module_ParamService_client).disconnect().get()
        self._module_ParamService_reset_client()

    cdef bind_client(ParamService self, cRequestChannel_ptr&& channel):
        ParamService._module_ParamService_set_client(
            self,
            makeClientWrapper[cParamServiceAsyncClient, cParamServiceClientWrapper](
                thrift.py3.client.move(channel)
            ),
        )

    async def __aenter__(ParamService self):
        await asyncio_shield(self._connect_future)
        if self._context_entered:
            raise asyncio_InvalidStateError('Client context has been used already')
        self._context_entered = True
        for key, value in self._deferred_headers.items():
            self.set_persistent_header(key, value)
        self._deferred_headers = None
        return self

    def __aexit__(ParamService self, *exc):
        self._check_connect_future()
        loop = asyncio_get_event_loop()
        future = loop.create_future()
        userdata = (self, future)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).disconnect(),
            closed_ParamService_py3_client_callback,
            <PyObject *>userdata  # So we keep client alive until disconnect
        )
        # To break any future usage of this client
        # Also to prevent dealloc from trying to disconnect in a blocking way.
        badfuture = loop.create_future()
        badfuture.set_exception(asyncio_InvalidStateError('Client Out of Context'))
        badfuture.exception()
        self._connect_future = badfuture
        return asyncio_shield(future)

    def set_persistent_header(ParamService self, str key, str value):
        if not self._module_ParamService_client:
            self._deferred_headers[key] = value
            return

        cdef string ckey = <bytes> key.encode('utf-8')
        cdef string cvalue = <bytes> value.encode('utf-8')
        deref(self._module_ParamService_client).setPersistentHeader(ckey, cvalue)

    @cython.always_allow_keywords(True)
    def void_ret_i16_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int16_t> param1
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_i16_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_void_ret_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_byte_i16_param(
            ParamService self,
            param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int8_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            <int16_t> param2
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_byte_i16_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_void_ret_byte_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_map_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_param(rpc_options._cpp_obj, 
                cmap[string,int64_t](deref(_module_types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_void_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_map_setlist_param(
            ParamService self,
            param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        if not isinstance(param2, _module_types.Set__List__string):
            param2 = _module_types.Set__List__string(param2)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_setlist_param(rpc_options._cpp_obj, 
                cmap[string,int64_t](deref(_module_types.Map__string_i64(param1)._cpp_obj.get())),
                cset[vector[string]](deref(_module_types.Set__List__string(param2)._cpp_obj.get())),
            ),
            ParamService_void_ret_map_setlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_map_typedef_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int32_t> param1
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_map_typedef_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_void_ret_map_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_enum_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.MyEnumA):
            raise TypeError(f'argument param1 value: { param1 !r} is not of the enum type { _module_types.MyEnumA }.')
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_enum_param(rpc_options._cpp_obj, 
                _module_types.MyEnumA_to_cpp(param1),
            ),
            ParamService_void_ret_enum_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_struct_param(
            ParamService self,
            _module_types.MyStruct param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_struct_param(rpc_options._cpp_obj, 
                deref((<_module_types.MyStruct>param1)._cpp_obj),
            ),
            ParamService_void_ret_struct_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def void_ret_listunion_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__ComplexUnion):
            param1 = _module_types.List__ComplexUnion(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            deref(self._module_ParamService_client).void_ret_listunion_param(rpc_options._cpp_obj, 
                vector[_module_types.cComplexUnion](deref(_module_types.List__ComplexUnion(param1)._cpp_obj.get())),
            ),
            ParamService_void_ret_listunion_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def bool_ret_i32_i64_param(
            ParamService self,
            param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            <int64_t> param2
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_i32_i64_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_bool_ret_i32_i64_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def bool_ret_map_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_map_param(rpc_options._cpp_obj, 
                cmap[string,int64_t](deref(_module_types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_bool_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def bool_ret_union_param(
            ParamService self,
            _module_types.ComplexUnion param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            deref(self._module_ParamService_client).bool_ret_union_param(rpc_options._cpp_obj, 
                deref((<_module_types.ComplexUnion>param1)._cpp_obj),
            ),
            ParamService_bool_ret_union_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i64_ret_float_double_param(
            ParamService self,
            float param1,
            double param2,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_float_double_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_i64_ret_float_double_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i64_ret_string_typedef_param(
            ParamService self,
            str param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param2, _module_types.Set__List__List__Map__Empty_MyStruct):
            param2 = _module_types.Set__List__List__Map__Empty_MyStruct(param2)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_string_typedef_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
                cset[vector[vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]]]](deref(_module_types.Set__List__List__Map__Empty_MyStruct(param2)._cpp_obj.get())),
            ),
            ParamService_i64_ret_string_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def i64_ret_i32_i32_i32_i32_i32_param(
            ParamService self,
            param1 not None,
            param2 not None,
            param3 not None,
            param4 not None,
            param5 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            <int32_t> param2
        if not isinstance(param3, int):
            raise TypeError(f'param3 is not a {int !r}.')
        else:
            <int32_t> param3
        if not isinstance(param4, int):
            raise TypeError(f'param4 is not a {int !r}.')
        else:
            <int32_t> param4
        if not isinstance(param5, int):
            raise TypeError(f'param5 is not a {int !r}.')
        else:
            <int32_t> param5
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int64_t](
            self._executor,
            deref(self._module_ParamService_client).i64_ret_i32_i32_i32_i32_i32_param(rpc_options._cpp_obj, 
                param1,
                param2,
                param3,
                param4,
                param5,
            ),
            ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def double_ret_setstruct_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Set__MyStruct):
            param1 = _module_types.Set__MyStruct(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            deref(self._module_ParamService_client).double_ret_setstruct_param(rpc_options._cpp_obj, 
                cset[_module_types.cMyStruct](deref(_module_types.Set__MyStruct(param1)._cpp_obj.get())),
            ),
            ParamService_double_ret_setstruct_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def string_ret_string_param(
            ParamService self,
            str param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ParamService_client).string_ret_string_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
            ),
            ParamService_string_ret_string_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def binary_ret_binary_param(
            ParamService self,
            bytes param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            deref(self._module_ParamService_client).binary_ret_binary_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_binary_ret_binary_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def map_ret_bool_param(
            ParamService self,
            pbool param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,int64_t]](
            self._executor,
            deref(self._module_ParamService_client).map_ret_bool_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_map_ret_bool_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def list_ret_map_setlist_param(
            ParamService self,
            param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__i32_List__string):
            param1 = _module_types.Map__i32_List__string(param1)
        if not isinstance(param2, _module_types.List__string):
            param2 = _module_types.List__string(param2)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cbool]](
            self._executor,
            deref(self._module_ParamService_client).list_ret_map_setlist_param(rpc_options._cpp_obj, 
                cmap[int32_t,vector[string]](deref(_module_types.Map__i32_List__string(param1)._cpp_obj.get())),
                vector[string](deref(_module_types.List__string(param2)._cpp_obj.get())),
            ),
            ParamService_list_ret_map_setlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def mapsetlistmapliststring_ret_listlistlist_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__List__List__List__i32):
            param1 = _module_types.List__List__List__List__i32(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](
            self._executor,
            deref(self._module_ParamService_client).mapsetlistmapliststring_ret_listlistlist_param(rpc_options._cpp_obj, 
                vector[vector[vector[vector[int32_t]]]](deref(_module_types.List__List__List__List__i32(param1)._cpp_obj.get())),
            ),
            ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def typedef_ret_i32_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int32_t> param1
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[int32_t](
            self._executor,
            deref(self._module_ParamService_client).typedef_ret_i32_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_typedef_ret_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def listtypedef_ret_typedef_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__Map__Empty_MyStruct):
            param1 = _module_types.List__Map__Empty_MyStruct(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[int32_t]](
            self._executor,
            deref(self._module_ParamService_client).listtypedef_ret_typedef_param(rpc_options._cpp_obj, 
                vector[cmap[_module_types.cEmpty,_module_types.cMyStruct]](deref(_module_types.List__Map__Empty_MyStruct(param1)._cpp_obj.get())),
            ),
            ParamService_listtypedef_ret_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def enum_ret_double_param(
            ParamService self,
            double param1,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cMyEnumA](
            self._executor,
            deref(self._module_ParamService_client).enum_ret_double_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_enum_ret_double_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def enum_ret_double_enum_param(
            ParamService self,
            double param1,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param2, _module_types.MyEnumA):
            raise TypeError(f'argument param2 value: { param2 !r} is not of the enum type { _module_types.MyEnumA }.')
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cMyEnumA](
            self._executor,
            deref(self._module_ParamService_client).enum_ret_double_enum_param(rpc_options._cpp_obj, 
                param1,
                _module_types.MyEnumA_to_cpp(param2),
            ),
            ParamService_enum_ret_double_enum_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def listenum_ret_map_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_types.cMyEnumA]](
            self._executor,
            deref(self._module_ParamService_client).listenum_ret_map_param(rpc_options._cpp_obj, 
                cmap[string,int64_t](deref(_module_types.Map__string_i64(param1)._cpp_obj.get())),
            ),
            ParamService_listenum_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def struct_ret_i16_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int16_t> param1
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cMyStruct](
            self._executor,
            deref(self._module_ParamService_client).struct_ret_i16_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_struct_ret_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def setstruct_ret_set_param(
            ParamService self,
            param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Set__string):
            param1 = _module_types.Set__string(param1)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[_module_types.cMyStruct]](
            self._executor,
            deref(self._module_ParamService_client).setstruct_ret_set_param(rpc_options._cpp_obj, 
                cset[string](deref(_module_types.Set__string(param1)._cpp_obj.get())),
            ),
            ParamService_setstruct_ret_set_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def union_ret_i32_i32_param(
            ParamService self,
            param1 not None,
            param2 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            <int32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            <int32_t> param2
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_types.cComplexUnion](
            self._executor,
            deref(self._module_ParamService_client).union_ret_i32_i32_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_union_ret_i32_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def listunion_string_param(
            ParamService self,
            str param1 not None,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = asyncio_get_event_loop()
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_types.cComplexUnion]](
            self._executor,
            deref(self._module_ParamService_client).listunion_string_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
            ),
            ParamService_listunion_string_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)



cdef void closed_ParamService_py3_client_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata,
):
    client, pyfuture = <object> userdata 
    pyfuture.set_result(None)
