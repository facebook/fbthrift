/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "src/gen-cpp2/module_types.h"
#include "src/gen-cpp2/module_types.tcc"

#include <algorithm>
#include <folly/Indestructible.h>

#include "src/gen-cpp2/module_data.h"

namespace some { namespace valid { namespace ns {

const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES = _MyEnumA_EnumMapFactory::makeValuesToNamesMap();
const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES = _MyEnumA_EnumMapFactory::makeNamesToValuesMap();

}}} // some::valid::ns
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::some::valid::ns::MyEnumA>::size = 3;
template <> const folly::Range<const  ::some::valid::ns::MyEnumA*> TEnumTraits< ::some::valid::ns::MyEnumA>::values = folly::range( ::some::valid::ns::_MyEnumAEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::some::valid::ns::MyEnumA>::names = folly::range( ::some::valid::ns::_MyEnumAEnumDataStorage::names);
template <> const char* TEnumTraits< ::some::valid::ns::MyEnumA>::findName( ::some::valid::ns::MyEnumA value) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_MyEnumA_EnumMapFactory::ValuesToNamesMapType>{ ::some::valid::ns::_MyEnumA_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::some::valid::ns::MyEnumA>::findValue(const char* name,  ::some::valid::ns::MyEnumA* outValue) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_MyEnumA_EnumMapFactory::NamesToValuesMapType>{ ::some::valid::ns::_MyEnumA_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace some { namespace valid { namespace ns {

const _AnnotatedEnum_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum_VALUES_TO_NAMES = _AnnotatedEnum_EnumMapFactory::makeValuesToNamesMap();
const _AnnotatedEnum_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum_NAMES_TO_VALUES = _AnnotatedEnum_EnumMapFactory::makeNamesToValuesMap();

}}} // some::valid::ns
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::some::valid::ns::AnnotatedEnum>::size = 3;
template <> const folly::Range<const  ::some::valid::ns::AnnotatedEnum*> TEnumTraits< ::some::valid::ns::AnnotatedEnum>::values = folly::range( ::some::valid::ns::_AnnotatedEnumEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::some::valid::ns::AnnotatedEnum>::names = folly::range( ::some::valid::ns::_AnnotatedEnumEnumDataStorage::names);
template <> const char* TEnumTraits< ::some::valid::ns::AnnotatedEnum>::findName( ::some::valid::ns::AnnotatedEnum value) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_AnnotatedEnum_EnumMapFactory::ValuesToNamesMapType>{ ::some::valid::ns::_AnnotatedEnum_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::some::valid::ns::AnnotatedEnum>::findValue(const char* name,  ::some::valid::ns::AnnotatedEnum* outValue) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_AnnotatedEnum_EnumMapFactory::NamesToValuesMapType>{ ::some::valid::ns::_AnnotatedEnum_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace some { namespace valid { namespace ns {

const _AnnotatedEnum2_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum2_VALUES_TO_NAMES = _AnnotatedEnum2_EnumMapFactory::makeValuesToNamesMap();
const _AnnotatedEnum2_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum2_NAMES_TO_VALUES = _AnnotatedEnum2_EnumMapFactory::makeNamesToValuesMap();

}}} // some::valid::ns
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::some::valid::ns::AnnotatedEnum2>::size = 3;
template <> const folly::Range<const  ::some::valid::ns::AnnotatedEnum2*> TEnumTraits< ::some::valid::ns::AnnotatedEnum2>::values = folly::range( ::some::valid::ns::_AnnotatedEnum2EnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::some::valid::ns::AnnotatedEnum2>::names = folly::range( ::some::valid::ns::_AnnotatedEnum2EnumDataStorage::names);
template <> const char* TEnumTraits< ::some::valid::ns::AnnotatedEnum2>::findName( ::some::valid::ns::AnnotatedEnum2 value) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_AnnotatedEnum2_EnumMapFactory::ValuesToNamesMapType>{ ::some::valid::ns::_AnnotatedEnum2_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::some::valid::ns::AnnotatedEnum2>::findValue(const char* name,  ::some::valid::ns::AnnotatedEnum2* outValue) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_AnnotatedEnum2_EnumMapFactory::NamesToValuesMapType>{ ::some::valid::ns::_AnnotatedEnum2_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace some { namespace valid { namespace ns {

const _MyEnumB_EnumMapFactory::ValuesToNamesMapType _MyEnumB_VALUES_TO_NAMES = _MyEnumB_EnumMapFactory::makeValuesToNamesMap();
const _MyEnumB_EnumMapFactory::NamesToValuesMapType _MyEnumB_NAMES_TO_VALUES = _MyEnumB_EnumMapFactory::makeNamesToValuesMap();

}}} // some::valid::ns
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::some::valid::ns::MyEnumB>::size = 1;
template <> const folly::Range<const  ::some::valid::ns::MyEnumB*> TEnumTraits< ::some::valid::ns::MyEnumB>::values = folly::range( ::some::valid::ns::_MyEnumBEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::some::valid::ns::MyEnumB>::names = folly::range( ::some::valid::ns::_MyEnumBEnumDataStorage::names);
template <> const char* TEnumTraits< ::some::valid::ns::MyEnumB>::findName( ::some::valid::ns::MyEnumB value) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_MyEnumB_EnumMapFactory::ValuesToNamesMapType>{ ::some::valid::ns::_MyEnumB_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::some::valid::ns::MyEnumB>::findValue(const char* name,  ::some::valid::ns::MyEnumB* outValue) {
  static auto const map = folly::Indestructible< ::some::valid::ns::_MyEnumB_EnumMapFactory::NamesToValuesMapType>{ ::some::valid::ns::_MyEnumB_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace some { namespace valid { namespace ns {

Empty::Empty(apache::thrift::FragileConstructor) {}

void Empty::__clear() {
  // clear all fields
}

bool Empty::operator==(const Empty& rhs) const {
  (void)rhs;
  return true;
}

bool Empty::operator<(const Empty& rhs) const {
  (void)rhs;
  return false;
}

void Empty::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
}

void swap(Empty& a, Empty& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void Empty::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Empty::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void Empty::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t Empty::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t Empty::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t Empty::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

ASimpleStruct::ASimpleStruct(apache::thrift::FragileConstructor, int64_t boolField__arg) :
    boolField(std::move(boolField__arg)) {
  __isset.boolField = true;
}

void ASimpleStruct::__clear() {
  // clear all fields
  boolField = 0;
  __isset = {};
}

bool ASimpleStruct::operator==(const ASimpleStruct& rhs) const {
  (void)rhs;
  if (!(boolField == rhs.boolField)) {
    return false;
  }
  return true;
}

void ASimpleStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "boolField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
}

void swap(ASimpleStruct& a, ASimpleStruct& b) {
  using ::std::swap;
  swap(a.boolField, b.boolField);
  swap(a.__isset, b.__isset);
}

template void ASimpleStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ASimpleStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ASimpleStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ASimpleStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ASimpleStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ASimpleStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ASimpleStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ASimpleStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ASimpleStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ASimpleStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ASimpleStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ASimpleStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

ASimpleStructNoexcept::ASimpleStructNoexcept(apache::thrift::FragileConstructor, int64_t boolField__arg) :
    boolField(std::move(boolField__arg)) {
  __isset.boolField = true;
}

void ASimpleStructNoexcept::__clear() {
  // clear all fields
  boolField = 0;
  __isset = {};
}

bool ASimpleStructNoexcept::operator==(const ASimpleStructNoexcept& rhs) const {
  (void)rhs;
  if (!(boolField == rhs.boolField)) {
    return false;
  }
  return true;
}

bool ASimpleStructNoexcept::operator<(const ASimpleStructNoexcept& rhs) const {
  (void)rhs;
  if (!(boolField == rhs.boolField)) {
    return boolField < rhs.boolField;
  }
  return false;
}

void ASimpleStructNoexcept::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "boolField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
}

void swap(ASimpleStructNoexcept& a, ASimpleStructNoexcept& b) {
  using ::std::swap;
  swap(a.boolField, b.boolField);
  swap(a.__isset, b.__isset);
}

template void ASimpleStructNoexcept::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ASimpleStructNoexcept::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ASimpleStructNoexcept::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ASimpleStructNoexcept::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ASimpleStructNoexcept::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ASimpleStructNoexcept::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ASimpleStructNoexcept::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ASimpleStructNoexcept::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ASimpleStructNoexcept::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ASimpleStructNoexcept::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ASimpleStructNoexcept::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ASimpleStructNoexcept::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

MyStruct::MyStruct() :
      MyBoolField(0),
      MyIntField(12LL),
      MyStringField(apache::thrift::StringTraits< std::string>::fromStringLiteral("test")),
      MyMapEnumAndInt(std::initializer_list<std::pair<const  ::some::valid::ns::MyEnumA, std::string>>{{ ::some::valid::ns::MyEnumA::fieldA, apache::thrift::StringTraits< std::string>::fromStringLiteral("fieldA")},
  { ::some::valid::ns::MyEnumA::fieldC, apache::thrift::StringTraits< std::string>::fromStringLiteral("fieldC")},
  {static_cast< ::some::valid::ns::MyEnumA>(9), apache::thrift::StringTraits< std::string>::fromStringLiteral("nothing")}}) {}

MyStruct::MyStruct(MyStruct&& other) noexcept :
    MyBoolField(std::move(other.MyBoolField)),
    MyIntField(std::move(other.MyIntField)),
    MyStringField(std::move(other.MyStringField)),
    MyStringField2(std::move(other.MyStringField2)),
    MyBinaryField(std::move(other.MyBinaryField)),
    MyBinaryField2(std::move(other.MyBinaryField2)),
    MyBinaryField3(std::move(other.MyBinaryField3)),
    MyBinaryListField4(std::move(other.MyBinaryListField4)),
    MyMapEnumAndInt(std::move(other.MyMapEnumAndInt)),
    __isset(other.__isset) {}
MyStruct::~MyStruct() {}

MyStruct::MyStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, int64_t MyIntField__arg, std::string MyStringField__arg, std::string MyStringField2__arg, std::string MyBinaryField__arg, std::string MyBinaryField2__arg, std::string MyBinaryField3__arg, std::vector<std::string> MyBinaryListField4__arg, std::map< ::some::valid::ns::MyEnumA, std::string> MyMapEnumAndInt__arg) :
    MyBoolField(std::move(MyBoolField__arg)),
    MyIntField(std::move(MyIntField__arg)),
    MyStringField(std::move(MyStringField__arg)),
    MyStringField2(std::move(MyStringField2__arg)),
    MyBinaryField(std::move(MyBinaryField__arg)),
    MyBinaryField2(std::move(MyBinaryField2__arg)),
    MyBinaryField3(std::move(MyBinaryField3__arg)),
    MyBinaryListField4(std::move(MyBinaryListField4__arg)),
    MyMapEnumAndInt(std::move(MyMapEnumAndInt__arg)) {
  __isset.MyBoolField = true;
  __isset.MyIntField = true;
  __isset.MyStringField = true;
  __isset.MyStringField2 = true;
  __isset.MyBinaryField = true;
  __isset.MyBinaryField2 = true;
  __isset.MyBinaryListField4 = true;
  __isset.MyMapEnumAndInt = true;
}

void MyStruct::__clear() {
  // clear all fields
  MyBoolField = 0;
  MyIntField = 12LL;
  MyStringField = apache::thrift::StringTraits< std::string>::fromStringLiteral("test");
  MyStringField2 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField2 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryField3 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  MyBinaryListField4.clear();
  MyMapEnumAndInt.clear();
  __isset = {};
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  if (!(MyBoolField == rhs.MyBoolField)) {
    return false;
  }
  if (!(MyIntField == rhs.MyIntField)) {
    return false;
  }
  if (!(MyStringField == rhs.MyStringField)) {
    return false;
  }
  if (!(MyStringField2 == rhs.MyStringField2)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField, rhs.MyBinaryField)) {
    return false;
  }
  if (__isset.MyBinaryField2 != rhs.__isset.MyBinaryField2) {
    return false;
  }
  if (__isset.MyBinaryField2) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField2, rhs.MyBinaryField2)) {
      return false;
    }
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField3, rhs.MyBinaryField3)) {
    return false;
  }
  if (!(MyBinaryListField4 == rhs.MyBinaryListField4)) {
    return false;
  }
  if (!(MyMapEnumAndInt == rhs.MyMapEnumAndInt)) {
    return false;
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  if (!(MyBoolField == rhs.MyBoolField)) {
    return MyBoolField < rhs.MyBoolField;
  }
  if (!(MyIntField == rhs.MyIntField)) {
    return MyIntField < rhs.MyIntField;
  }
  if (!(MyStringField == rhs.MyStringField)) {
    return MyStringField < rhs.MyStringField;
  }
  if (!(MyStringField2 == rhs.MyStringField2)) {
    return MyStringField2 < rhs.MyStringField2;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField, rhs.MyBinaryField)) {
    return apache::thrift::StringTraits<std::string>::isLess(MyBinaryField, rhs.MyBinaryField);
  }
  if (__isset.MyBinaryField2 != rhs.__isset.MyBinaryField2) {
    return __isset.MyBinaryField2 < rhs.__isset.MyBinaryField2;
  }
  if (__isset.MyBinaryField2) {
    if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField2, rhs.MyBinaryField2)) {
      return apache::thrift::StringTraits<std::string>::isLess(MyBinaryField2, rhs.MyBinaryField2);
    }
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(MyBinaryField3, rhs.MyBinaryField3)) {
    return apache::thrift::StringTraits<std::string>::isLess(MyBinaryField3, rhs.MyBinaryField3);
  }
  if (!(MyBinaryListField4 == rhs.MyBinaryListField4)) {
    return MyBinaryListField4 < rhs.MyBinaryListField4;
  }
  if (!(MyMapEnumAndInt == rhs.MyMapEnumAndInt)) {
    return MyMapEnumAndInt < rhs.MyMapEnumAndInt;
  }
  return false;
}

const std::vector<std::string>& MyStruct::get_MyBinaryListField4() const& {
  return MyBinaryListField4;
}

std::vector<std::string> MyStruct::get_MyBinaryListField4() && {
  return std::move(MyBinaryListField4);
}

const std::map< ::some::valid::ns::MyEnumA, std::string>& MyStruct::get_MyMapEnumAndInt() const& {
  return MyMapEnumAndInt;
}

std::map< ::some::valid::ns::MyEnumA, std::string> MyStruct::get_MyMapEnumAndInt() && {
  return std::move(MyMapEnumAndInt);
}

void MyStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "MyBoolField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "MyIntField") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "MyStringField") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyStringField2") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryField") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryField2") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryField3") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryListField4") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "MyMapEnumAndInt") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_MAP;
  }
}

void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.MyBoolField, b.MyBoolField);
  swap(a.MyIntField, b.MyIntField);
  swap(a.MyStringField, b.MyStringField);
  swap(a.MyStringField2, b.MyStringField2);
  swap(a.MyBinaryField, b.MyBinaryField);
  swap(a.MyBinaryField2, b.MyBinaryField2);
  swap(a.MyBinaryField3, b.MyBinaryField3);
  swap(a.MyBinaryListField4, b.MyBinaryListField4);
  swap(a.MyMapEnumAndInt, b.MyMapEnumAndInt);
  swap(a.__isset, b.__isset);
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

void SimpleUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::intValue:
    {
      destruct(value_.intValue);
      break;
    }
    case Type::stringValue:
    {
      destruct(value_.stringValue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool SimpleUnion::operator==(const SimpleUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::intValue:
    {
      return value_.intValue == rhs.value_.intValue;
    }
    case Type::stringValue:
    {
      return value_.stringValue == rhs.value_.stringValue;
    }
    default:
    {
      return true;
    }
  }
}
void SimpleUnion::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "intValue") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "stringValue") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

void swap(SimpleUnion& a, SimpleUnion& b) {
  SimpleUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void SimpleUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SimpleUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SimpleUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SimpleUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SimpleUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SimpleUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SimpleUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SimpleUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void SimpleUnion::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t SimpleUnion::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t SimpleUnion::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t SimpleUnion::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

void ComplexUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::intValue:
    {
      destruct(value_.intValue);
      break;
    }
    case Type::req_intValue:
    {
      destruct(value_.req_intValue);
      break;
    }
    case Type::opt_intValue:
    {
      destruct(value_.opt_intValue);
      break;
    }
    case Type::stringValue:
    {
      destruct(value_.stringValue);
      break;
    }
    case Type::req_stringValue:
    {
      destruct(value_.req_stringValue);
      break;
    }
    case Type::opt_stringValue:
    {
      destruct(value_.opt_stringValue);
      break;
    }
    case Type::intValue2:
    {
      destruct(value_.intValue2);
      break;
    }
    case Type::intValue3:
    {
      destruct(value_.intValue3);
      break;
    }
    case Type::doubelValue:
    {
      destruct(value_.doubelValue);
      break;
    }
    case Type::boolValue:
    {
      destruct(value_.boolValue);
      break;
    }
    case Type::union_list:
    {
      destruct(value_.union_list);
      break;
    }
    case Type::union_set:
    {
      destruct(value_.union_set);
      break;
    }
    case Type::union_map:
    {
      destruct(value_.union_map);
      break;
    }
    case Type::req_union_map:
    {
      destruct(value_.req_union_map);
      break;
    }
    case Type::opt_union_map:
    {
      destruct(value_.opt_union_map);
      break;
    }
    case Type::enum_field:
    {
      destruct(value_.enum_field);
      break;
    }
    case Type::enum_container:
    {
      destruct(value_.enum_container);
      break;
    }
    case Type::a_struct:
    {
      destruct(value_.a_struct);
      break;
    }
    case Type::a_set_struct:
    {
      destruct(value_.a_set_struct);
      break;
    }
    case Type::a_union:
    {
      destruct(value_.a_union);
      break;
    }
    case Type::req_a_union:
    {
      destruct(value_.req_a_union);
      break;
    }
    case Type::opt_a_union:
    {
      destruct(value_.opt_a_union);
      break;
    }
    case Type::a_union_list:
    {
      destruct(value_.a_union_list);
      break;
    }
    case Type::a_union_typedef:
    {
      destruct(value_.a_union_typedef);
      break;
    }
    case Type::a_union_typedef_list:
    {
      destruct(value_.a_union_typedef_list);
      break;
    }
    case Type::MyBinaryField:
    {
      destruct(value_.MyBinaryField);
      break;
    }
    case Type::MyBinaryField2:
    {
      destruct(value_.MyBinaryField2);
      break;
    }
    case Type::MyBinaryField3:
    {
      destruct(value_.MyBinaryField3);
      break;
    }
    case Type::MyBinaryListField4:
    {
      destruct(value_.MyBinaryListField4);
      break;
    }
    case Type::ref_field:
    {
      destruct(value_.ref_field);
      break;
    }
    case Type::ref_field2:
    {
      destruct(value_.ref_field2);
      break;
    }
    case Type::excp_field:
    {
      destruct(value_.excp_field);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool ComplexUnion::operator==(const ComplexUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::intValue:
    {
      return value_.intValue == rhs.value_.intValue;
    }
    case Type::req_intValue:
    {
      return value_.req_intValue == rhs.value_.req_intValue;
    }
    case Type::opt_intValue:
    {
      return value_.opt_intValue == rhs.value_.opt_intValue;
    }
    case Type::stringValue:
    {
      return value_.stringValue == rhs.value_.stringValue;
    }
    case Type::req_stringValue:
    {
      return value_.req_stringValue == rhs.value_.req_stringValue;
    }
    case Type::opt_stringValue:
    {
      return value_.opt_stringValue == rhs.value_.opt_stringValue;
    }
    case Type::intValue2:
    {
      return value_.intValue2 == rhs.value_.intValue2;
    }
    case Type::intValue3:
    {
      return value_.intValue3 == rhs.value_.intValue3;
    }
    case Type::doubelValue:
    {
      return value_.doubelValue == rhs.value_.doubelValue;
    }
    case Type::boolValue:
    {
      return value_.boolValue == rhs.value_.boolValue;
    }
    case Type::union_list:
    {
      return value_.union_list == rhs.value_.union_list;
    }
    case Type::union_set:
    {
      return value_.union_set == rhs.value_.union_set;
    }
    case Type::union_map:
    {
      return value_.union_map == rhs.value_.union_map;
    }
    case Type::req_union_map:
    {
      return value_.req_union_map == rhs.value_.req_union_map;
    }
    case Type::opt_union_map:
    {
      return value_.opt_union_map == rhs.value_.opt_union_map;
    }
    case Type::enum_field:
    {
      return value_.enum_field == rhs.value_.enum_field;
    }
    case Type::enum_container:
    {
      return value_.enum_container == rhs.value_.enum_container;
    }
    case Type::a_struct:
    {
      return value_.a_struct == rhs.value_.a_struct;
    }
    case Type::a_set_struct:
    {
      return value_.a_set_struct == rhs.value_.a_set_struct;
    }
    case Type::a_union:
    {
      return value_.a_union == rhs.value_.a_union;
    }
    case Type::req_a_union:
    {
      return value_.req_a_union == rhs.value_.req_a_union;
    }
    case Type::opt_a_union:
    {
      return value_.opt_a_union == rhs.value_.opt_a_union;
    }
    case Type::a_union_list:
    {
      return value_.a_union_list == rhs.value_.a_union_list;
    }
    case Type::a_union_typedef:
    {
      return value_.a_union_typedef == rhs.value_.a_union_typedef;
    }
    case Type::a_union_typedef_list:
    {
      return value_.a_union_typedef_list == rhs.value_.a_union_typedef_list;
    }
    case Type::MyBinaryField:
    {
      return value_.MyBinaryField == rhs.value_.MyBinaryField;
    }
    case Type::MyBinaryField2:
    {
      return value_.MyBinaryField2 == rhs.value_.MyBinaryField2;
    }
    case Type::MyBinaryField3:
    {
      return value_.MyBinaryField3 == rhs.value_.MyBinaryField3;
    }
    case Type::MyBinaryListField4:
    {
      return value_.MyBinaryListField4 == rhs.value_.MyBinaryListField4;
    }
    case Type::ref_field:
    {
      return *value_.ref_field == *rhs.value_.ref_field;
    }
    case Type::ref_field2:
    {
      return *value_.ref_field2 == *rhs.value_.ref_field2;
    }
    case Type::excp_field:
    {
      return value_.excp_field == rhs.value_.excp_field;
    }
    default:
    {
      return true;
    }
  }
}

std::unique_ptr< ::some::valid::ns::MyStruct>& ComplexUnion::set_ref_field( ::some::valid::ns::MyStruct const &t) {
  __clear();
  type_ = Type::ref_field;
  ::new (std::addressof(value_.ref_field)) std::unique_ptr< ::some::valid::ns::MyStruct>(new std::unique_ptr< ::some::valid::ns::MyStruct>::element_type(t));
  return value_.ref_field;
}

std::unique_ptr< ::some::valid::ns::MyStruct>& ComplexUnion::set_ref_field( ::some::valid::ns::MyStruct&& t) {
  __clear();
  type_ = Type::ref_field;
  ::new (std::addressof(value_.ref_field)) std::unique_ptr< ::some::valid::ns::MyStruct>(new std::unique_ptr< ::some::valid::ns::MyStruct>::element_type(std::move(t)));
  return value_.ref_field;
}

std::shared_ptr<const  ::some::valid::ns::MyStruct>& ComplexUnion::set_ref_field2( ::some::valid::ns::MyStruct const &t) {
  __clear();
  type_ = Type::ref_field2;
  ::new (std::addressof(value_.ref_field2)) std::shared_ptr<const  ::some::valid::ns::MyStruct>(new std::shared_ptr<const  ::some::valid::ns::MyStruct>::element_type(t));
  return value_.ref_field2;
}

std::shared_ptr<const  ::some::valid::ns::MyStruct>& ComplexUnion::set_ref_field2( ::some::valid::ns::MyStruct&& t) {
  __clear();
  type_ = Type::ref_field2;
  ::new (std::addressof(value_.ref_field2)) std::shared_ptr<const  ::some::valid::ns::MyStruct>(new std::shared_ptr<const  ::some::valid::ns::MyStruct>::element_type(std::move(t)));
  return value_.ref_field2;
}
void ComplexUnion::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "intValue") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "req_intValue") {
    fid = 101;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "opt_intValue") {
    fid = 201;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "stringValue") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "req_stringValue") {
    fid = 103;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "opt_stringValue") {
    fid = 203;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "intValue2") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I16;
  }
  else if (_fname == "intValue3") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "doubelValue") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "boolValue") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "union_list") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "union_set") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "union_map") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "req_union_map") {
    fid = 111;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "opt_union_map") {
    fid = 211;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "enum_field") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "enum_container") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "a_struct") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "a_set_struct") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "a_union") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_a_union") {
    fid = 116;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_a_union") {
    fid = 216;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "a_union_list") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "a_union_typedef") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "a_union_typedef_list") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "MyBinaryField") {
    fid = 20;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryField2") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryField3") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "MyBinaryListField4") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "ref_field") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ref_field2") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "excp_field") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(ComplexUnion& a, ComplexUnion& b) {
  ComplexUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void ComplexUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void ComplexUnion::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t ComplexUnion::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t ComplexUnion::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t ComplexUnion::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

AnException::AnException() :
      code(0),
      req_code(0),
      exception_list(std::initializer_list<int32_t>{1,
  2,
  3}),
      enum_field(static_cast< ::some::valid::ns::MyEnumA>(0)) {}


AnException::~AnException() {}

AnException::AnException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, std::string message2__arg, std::string req_message__arg, std::vector<int32_t> exception_list__arg, std::set<int64_t> exception_set__arg, std::map<std::string, int32_t> exception_map__arg, std::map<std::string, int32_t> req_exception_map__arg,  ::some::valid::ns::MyEnumA enum_field__arg, std::vector< ::some::valid::ns::MyEnumA> enum_container__arg,  ::some::valid::ns::MyStruct a_struct__arg, std::set< ::some::valid::ns::MyStruct> a_set_struct__arg, std::vector< ::some::valid::ns::SimpleUnion> a_union_list__arg,  ::some::valid::ns::unionTypeDef union_typedef__arg, std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list__arg) :
    code(std::move(code__arg)),
    req_code(std::move(req_code__arg)),
    message2(std::move(message2__arg)),
    req_message(std::move(req_message__arg)),
    exception_list(std::move(exception_list__arg)),
    exception_set(std::move(exception_set__arg)),
    exception_map(std::move(exception_map__arg)),
    req_exception_map(std::move(req_exception_map__arg)),
    enum_field(std::move(enum_field__arg)),
    enum_container(std::move(enum_container__arg)),
    a_struct(std::move(a_struct__arg)),
    a_set_struct(std::move(a_set_struct__arg)),
    a_union_list(std::move(a_union_list__arg)),
    union_typedef(std::move(union_typedef__arg)),
    a_union_typedef_list(std::move(a_union_typedef_list__arg)) {
  __isset.code = true;
  __isset.message2 = true;
  __isset.exception_list = true;
  __isset.exception_set = true;
  __isset.exception_map = true;
  __isset.enum_field = true;
  __isset.enum_container = true;
  __isset.a_struct = true;
  __isset.a_set_struct = true;
  __isset.a_union_list = true;
  __isset.union_typedef = true;
  __isset.a_union_typedef_list = true;
}

void AnException::__clear() {
  // clear all fields
  code = 0;
  req_code = 0;
  message2 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  req_message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  exception_list.clear();
  exception_set.clear();
  exception_map.clear();
  req_exception_map.clear();
  enum_field = static_cast< ::some::valid::ns::MyEnumA>(0);
  enum_container.clear();
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::MyStruct>::clear(&a_struct);
  a_set_struct.clear();
  a_union_list.clear();
  union_typedef.clear();
  a_union_typedef_list.clear();
  __isset = {};
}

bool AnException::operator==(const AnException& rhs) const {
  (void)rhs;
  if (!(code == rhs.code)) {
    return false;
  }
  if (!(req_code == rhs.req_code)) {
    return false;
  }
  if (!(message2 == rhs.message2)) {
    return false;
  }
  if (!(req_message == rhs.req_message)) {
    return false;
  }
  if (!(exception_list == rhs.exception_list)) {
    return false;
  }
  if (!(exception_set == rhs.exception_set)) {
    return false;
  }
  if (!(exception_map == rhs.exception_map)) {
    return false;
  }
  if (!(req_exception_map == rhs.req_exception_map)) {
    return false;
  }
  if (!(enum_field == rhs.enum_field)) {
    return false;
  }
  if (!(enum_container == rhs.enum_container)) {
    return false;
  }
  if (!(a_struct == rhs.a_struct)) {
    return false;
  }
  if (!(a_set_struct == rhs.a_set_struct)) {
    return false;
  }
  if (!(a_union_list == rhs.a_union_list)) {
    return false;
  }
  if (!(union_typedef == rhs.union_typedef)) {
    return false;
  }
  if (!(a_union_typedef_list == rhs.a_union_typedef_list)) {
    return false;
  }
  return true;
}

const std::vector<int32_t>& AnException::get_exception_list() const& {
  return exception_list;
}

std::vector<int32_t> AnException::get_exception_list() && {
  return std::move(exception_list);
}

const std::set<int64_t>& AnException::get_exception_set() const& {
  return exception_set;
}

std::set<int64_t> AnException::get_exception_set() && {
  return std::move(exception_set);
}

const std::map<std::string, int32_t>& AnException::get_exception_map() const& {
  return exception_map;
}

std::map<std::string, int32_t> AnException::get_exception_map() && {
  return std::move(exception_map);
}

const std::map<std::string, int32_t>& AnException::get_req_exception_map() const& {
  return req_exception_map;
}

std::map<std::string, int32_t> AnException::get_req_exception_map() && {
  return std::move(req_exception_map);
}

const std::vector< ::some::valid::ns::MyEnumA>& AnException::get_enum_container() const& {
  return enum_container;
}

std::vector< ::some::valid::ns::MyEnumA> AnException::get_enum_container() && {
  return std::move(enum_container);
}

const  ::some::valid::ns::MyStruct& AnException::get_a_struct() const& {
  return a_struct;
}

 ::some::valid::ns::MyStruct AnException::get_a_struct() && {
  return std::move(a_struct);
}

const std::set< ::some::valid::ns::MyStruct>& AnException::get_a_set_struct() const& {
  return a_set_struct;
}

std::set< ::some::valid::ns::MyStruct> AnException::get_a_set_struct() && {
  return std::move(a_set_struct);
}

const std::vector< ::some::valid::ns::SimpleUnion>& AnException::get_a_union_list() const& {
  return a_union_list;
}

std::vector< ::some::valid::ns::SimpleUnion> AnException::get_a_union_list() && {
  return std::move(a_union_list);
}

const  ::some::valid::ns::unionTypeDef& AnException::get_union_typedef() const& {
  return union_typedef;
}

 ::some::valid::ns::unionTypeDef AnException::get_union_typedef() && {
  return std::move(union_typedef);
}

const std::vector< ::some::valid::ns::unionTypeDef>& AnException::get_a_union_typedef_list() const& {
  return a_union_typedef_list;
}

std::vector< ::some::valid::ns::unionTypeDef> AnException::get_a_union_typedef_list() && {
  return std::move(a_union_typedef_list);
}

void AnException::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "code") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "req_code") {
    fid = 101;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "message2") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "req_message") {
    fid = 102;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "exception_list") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "exception_set") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "exception_map") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "req_exception_map") {
    fid = 105;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "enum_field") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "enum_container") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "a_struct") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "a_set_struct") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "a_union_list") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "union_typedef") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "a_union_typedef_list") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_LIST;
  }
}

void swap(AnException& a, AnException& b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.req_code, b.req_code);
  swap(a.message2, b.message2);
  swap(a.req_message, b.req_message);
  swap(a.exception_list, b.exception_list);
  swap(a.exception_set, b.exception_set);
  swap(a.exception_map, b.exception_map);
  swap(a.req_exception_map, b.req_exception_map);
  swap(a.enum_field, b.enum_field);
  swap(a.enum_container, b.enum_container);
  swap(a.a_struct, b.a_struct);
  swap(a.a_set_struct, b.a_set_struct);
  swap(a.a_union_list, b.a_union_list);
  swap(a.union_typedef, b.union_typedef);
  swap(a.a_union_typedef_list, b.a_union_typedef_list);
  swap(a.__isset, b.__isset);
}

template void AnException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AnException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AnException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AnException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AnException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AnException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AnException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AnException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AnException::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AnException::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AnException::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AnException::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

AnotherException::AnotherException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, std::string message__arg) :
    code(std::move(code__arg)),
    req_code(std::move(req_code__arg)),
    message(std::move(message__arg)) {
  __isset.code = true;
  __isset.message = true;
}

void AnotherException::__clear() {
  // clear all fields
  code = 0;
  req_code = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool AnotherException::operator==(const AnotherException& rhs) const {
  (void)rhs;
  if (!(code == rhs.code)) {
    return false;
  }
  if (!(req_code == rhs.req_code)) {
    return false;
  }
  if (!(message == rhs.message)) {
    return false;
  }
  return true;
}

bool AnotherException::operator<(const AnotherException& rhs) const {
  (void)rhs;
  if (!(code == rhs.code)) {
    return code < rhs.code;
  }
  if (!(req_code == rhs.req_code)) {
    return req_code < rhs.req_code;
  }
  if (!(message == rhs.message)) {
    return message < rhs.message;
  }
  return false;
}

void AnotherException::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "code") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "req_code") {
    fid = 101;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "message") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

void swap(AnotherException& a, AnotherException& b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.req_code, b.req_code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

template void AnotherException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AnotherException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AnotherException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AnotherException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AnotherException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AnotherException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AnotherException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AnotherException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AnotherException::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AnotherException::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AnotherException::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AnotherException::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

containerStruct::containerStruct() :
      fieldA(0),
      req_fieldA(0),
      opt_fieldA(0),
      fieldC(std::initializer_list<int32_t>{1,
  2,
  3,
  4}),
      req_fieldC(std::initializer_list<int32_t>{1,
  2,
  3,
  4}),
      opt_fieldC(std::initializer_list<int32_t>{1,
  2,
  3,
  4}),
      fieldE(apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring")),
      req_fieldE(apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring")),
      opt_fieldE(apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring")),
      fieldF(std::initializer_list<std::vector<int32_t>>{std::initializer_list<int32_t>{1,
  3,
  5,
  7,
  9},
  std::initializer_list<int32_t>{2,
  4,
  8,
  10,
  12}}),
      fieldI(true),
      fieldJ(std::initializer_list<std::pair<const std::string, std::vector<int32_t>>>{{apache::thrift::StringTraits< std::string>::fromStringLiteral("subfieldA"), std::initializer_list<int32_t>{1,
  4,
  8,
  12}},
  {apache::thrift::StringTraits< std::string>::fromStringLiteral("subfieldB"), std::initializer_list<int32_t>{2,
  5,
  9,
  13}}}),
      fieldN(0),
      fieldQ(static_cast< ::some::valid::ns::MyEnumA>(0)),
      fieldR( ::some::valid::ns::MyEnumA::fieldB),
      req_fieldR( ::some::valid::ns::MyEnumA::fieldB),
      opt_fieldR( ::some::valid::ns::MyEnumA::fieldB),
      fieldS( ::some::valid::ns::MyEnumA::fieldB),
      fieldU(std::initializer_list< ::some::valid::ns::MyEnumA>{ ::some::valid::ns::MyEnumA::fieldC,
   ::some::valid::ns::MyEnumA::fieldB,
   ::some::valid::ns::MyEnumA::fieldA}),
      fieldAC( ::some::valid::ns::MyEnumB::AField),
      fieldAD(static_cast< ::a::different::ns::AnEnum>(0)) {}


containerStruct::~containerStruct() {}

containerStruct::containerStruct(apache::thrift::FragileConstructor, bool fieldA__arg, bool req_fieldA__arg, bool opt_fieldA__arg, std::map<std::string, bool> fieldB__arg, std::map<std::string, bool> req_fieldB__arg, std::map<std::string, bool> opt_fieldB__arg, std::set<int32_t> fieldC__arg, std::set<int32_t> req_fieldC__arg, std::set<int32_t> opt_fieldC__arg, std::string fieldD__arg, std::string fieldE__arg, std::string req_fieldE__arg, std::string opt_fieldE__arg, std::vector<std::vector<int32_t>> fieldF__arg, std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>> fieldG__arg, std::vector<std::set<int32_t>> fieldH__arg, bool fieldI__arg, std::map<std::string, std::vector<int32_t>> fieldJ__arg, std::vector<std::vector<std::vector<std::vector<int32_t>>>> fieldK__arg, std::set<std::set<std::set<bool>>> fieldL__arg, std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>> fieldM__arg,  ::some::valid::ns::simpleTypeDef fieldN__arg,  ::some::valid::ns::complexStructTypeDef fieldO__arg, std::vector< ::some::valid::ns::mostComplexTypeDef> fieldP__arg,  ::some::valid::ns::MyEnumA fieldQ__arg,  ::some::valid::ns::MyEnumA fieldR__arg,  ::some::valid::ns::MyEnumA req_fieldR__arg,  ::some::valid::ns::MyEnumA opt_fieldR__arg,  ::some::valid::ns::MyEnumA fieldS__arg, std::vector< ::some::valid::ns::MyEnumA> fieldT__arg, std::vector< ::some::valid::ns::MyEnumA> fieldU__arg,  ::some::valid::ns::MyStruct fieldV__arg,  ::some::valid::ns::MyStruct req_fieldV__arg,  ::some::valid::ns::MyStruct opt_fieldV__arg, std::set< ::some::valid::ns::MyStruct> fieldW__arg,  ::some::valid::ns::ComplexUnion fieldX__arg,  ::some::valid::ns::ComplexUnion req_fieldX__arg,  ::some::valid::ns::ComplexUnion opt_fieldX__arg, std::vector< ::some::valid::ns::ComplexUnion> fieldY__arg,  ::some::valid::ns::unionTypeDef fieldZ__arg, std::vector< ::some::valid::ns::unionTypeDef> fieldAA__arg, std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> fieldAB__arg,  ::some::valid::ns::MyEnumB fieldAC__arg,  ::a::different::ns::AnEnum fieldAD__arg, std::map<std::string, int32_t> fieldAE__arg,  ::some::valid::ns::IndirectionD fieldSD__arg) :
    fieldA(std::move(fieldA__arg)),
    req_fieldA(std::move(req_fieldA__arg)),
    opt_fieldA(std::move(opt_fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    req_fieldB(std::move(req_fieldB__arg)),
    opt_fieldB(std::move(opt_fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    req_fieldC(std::move(req_fieldC__arg)),
    opt_fieldC(std::move(opt_fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    req_fieldE(std::move(req_fieldE__arg)),
    opt_fieldE(std::move(opt_fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)),
    fieldH(std::move(fieldH__arg)),
    fieldI(std::move(fieldI__arg)),
    fieldJ(std::move(fieldJ__arg)),
    fieldK(std::move(fieldK__arg)),
    fieldL(std::move(fieldL__arg)),
    fieldM(std::move(fieldM__arg)),
    fieldN(std::move(fieldN__arg)),
    fieldO(std::move(fieldO__arg)),
    fieldP(std::move(fieldP__arg)),
    fieldQ(std::move(fieldQ__arg)),
    fieldR(std::move(fieldR__arg)),
    req_fieldR(std::move(req_fieldR__arg)),
    opt_fieldR(std::move(opt_fieldR__arg)),
    fieldS(std::move(fieldS__arg)),
    fieldT(std::move(fieldT__arg)),
    fieldU(std::move(fieldU__arg)),
    fieldV(std::move(fieldV__arg)),
    req_fieldV(std::move(req_fieldV__arg)),
    opt_fieldV(std::move(opt_fieldV__arg)),
    fieldW(std::move(fieldW__arg)),
    fieldX(std::move(fieldX__arg)),
    req_fieldX(std::move(req_fieldX__arg)),
    opt_fieldX(std::move(opt_fieldX__arg)),
    fieldY(std::move(fieldY__arg)),
    fieldZ(std::move(fieldZ__arg)),
    fieldAA(std::move(fieldAA__arg)),
    fieldAB(std::move(fieldAB__arg)),
    fieldAC(std::move(fieldAC__arg)),
    fieldAD(std::move(fieldAD__arg)),
    fieldAE(std::move(fieldAE__arg)),
    fieldSD(std::move(fieldSD__arg)) {
  __isset.fieldA = true;
  __isset.opt_fieldA = true;
  __isset.fieldB = true;
  __isset.opt_fieldB = true;
  __isset.fieldC = true;
  __isset.opt_fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.opt_fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
  __isset.fieldH = true;
  __isset.fieldI = true;
  __isset.fieldJ = true;
  __isset.fieldK = true;
  __isset.fieldL = true;
  __isset.fieldM = true;
  __isset.fieldN = true;
  __isset.fieldO = true;
  __isset.fieldP = true;
  __isset.fieldQ = true;
  __isset.fieldR = true;
  __isset.opt_fieldR = true;
  __isset.fieldS = true;
  __isset.fieldT = true;
  __isset.fieldU = true;
  __isset.fieldV = true;
  __isset.opt_fieldV = true;
  __isset.fieldW = true;
  __isset.fieldX = true;
  __isset.opt_fieldX = true;
  __isset.fieldY = true;
  __isset.fieldZ = true;
  __isset.fieldAA = true;
  __isset.fieldAB = true;
  __isset.fieldAC = true;
  __isset.fieldAD = true;
  __isset.fieldAE = true;
  __isset.fieldSD = true;
}

void containerStruct::__clear() {
  // clear all fields
  fieldA = 0;
  req_fieldA = 0;
  opt_fieldA = 0;
  fieldB.clear();
  req_fieldB.clear();
  opt_fieldB.clear();
  fieldC.clear();
  req_fieldC.clear();
  opt_fieldC.clear();
  fieldD = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fieldE = apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring");
  req_fieldE = apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring");
  opt_fieldE = apache::thrift::StringTraits< std::string>::fromStringLiteral("somestring");
  fieldF.clear();
  fieldG.clear();
  fieldH.clear();
  fieldI = true;
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN = 0;
  fieldO.clear();
  fieldP.clear();
  fieldQ = static_cast< ::some::valid::ns::MyEnumA>(0);
  fieldR =  ::some::valid::ns::MyEnumA::fieldB;
  req_fieldR =  ::some::valid::ns::MyEnumA::fieldB;
  opt_fieldR =  ::some::valid::ns::MyEnumA::fieldB;
  fieldS =  ::some::valid::ns::MyEnumA::fieldB;
  fieldT.clear();
  fieldU.clear();
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::MyStruct>::clear(&fieldV);
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::MyStruct>::clear(&req_fieldV);
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::MyStruct>::clear(&opt_fieldV);
  fieldW.clear();
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::ComplexUnion>::clear(&fieldX);
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::ComplexUnion>::clear(&req_fieldX);
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::ComplexUnion>::clear(&opt_fieldX);
  fieldY.clear();
  fieldZ.clear();
  fieldAA.clear();
  fieldAB.clear();
  fieldAC =  ::some::valid::ns::MyEnumB::AField;
  fieldAD = static_cast< ::a::different::ns::AnEnum>(0);
  fieldAE.clear();
  fieldSD.value = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool containerStruct::operator==(const containerStruct& rhs) const {
  (void)rhs;
  if (!(fieldA == rhs.fieldA)) {
    return false;
  }
  if (!(req_fieldA == rhs.req_fieldA)) {
    return false;
  }
  if (__isset.opt_fieldA != rhs.__isset.opt_fieldA) {
    return false;
  }
  if (__isset.opt_fieldA) {
    if (!(opt_fieldA == rhs.opt_fieldA)) {
      return false;
    }
  }
  if (!(fieldB == rhs.fieldB)) {
    return false;
  }
  if (!(req_fieldB == rhs.req_fieldB)) {
    return false;
  }
  if (__isset.opt_fieldB != rhs.__isset.opt_fieldB) {
    return false;
  }
  if (__isset.opt_fieldB) {
    if (!(opt_fieldB == rhs.opt_fieldB)) {
      return false;
    }
  }
  if (!(fieldC == rhs.fieldC)) {
    return false;
  }
  if (!(req_fieldC == rhs.req_fieldC)) {
    return false;
  }
  if (__isset.opt_fieldC != rhs.__isset.opt_fieldC) {
    return false;
  }
  if (__isset.opt_fieldC) {
    if (!(opt_fieldC == rhs.opt_fieldC)) {
      return false;
    }
  }
  if (!(fieldD == rhs.fieldD)) {
    return false;
  }
  if (!(fieldE == rhs.fieldE)) {
    return false;
  }
  if (!(req_fieldE == rhs.req_fieldE)) {
    return false;
  }
  if (__isset.opt_fieldE != rhs.__isset.opt_fieldE) {
    return false;
  }
  if (__isset.opt_fieldE) {
    if (!(opt_fieldE == rhs.opt_fieldE)) {
      return false;
    }
  }
  if (!(fieldF == rhs.fieldF)) {
    return false;
  }
  if (!(fieldG == rhs.fieldG)) {
    return false;
  }
  if (!(fieldH == rhs.fieldH)) {
    return false;
  }
  if (!(fieldI == rhs.fieldI)) {
    return false;
  }
  if (!(fieldJ == rhs.fieldJ)) {
    return false;
  }
  if (!(fieldK == rhs.fieldK)) {
    return false;
  }
  if (!(fieldL == rhs.fieldL)) {
    return false;
  }
  if (!(fieldM == rhs.fieldM)) {
    return false;
  }
  if (!(fieldN == rhs.fieldN)) {
    return false;
  }
  if (!(fieldO == rhs.fieldO)) {
    return false;
  }
  if (!(fieldP == rhs.fieldP)) {
    return false;
  }
  if (!(fieldQ == rhs.fieldQ)) {
    return false;
  }
  if (!(fieldR == rhs.fieldR)) {
    return false;
  }
  if (!(req_fieldR == rhs.req_fieldR)) {
    return false;
  }
  if (__isset.opt_fieldR != rhs.__isset.opt_fieldR) {
    return false;
  }
  if (__isset.opt_fieldR) {
    if (!(opt_fieldR == rhs.opt_fieldR)) {
      return false;
    }
  }
  if (!(fieldS == rhs.fieldS)) {
    return false;
  }
  if (!(fieldT == rhs.fieldT)) {
    return false;
  }
  if (!(fieldU == rhs.fieldU)) {
    return false;
  }
  if (!(fieldV == rhs.fieldV)) {
    return false;
  }
  if (!(req_fieldV == rhs.req_fieldV)) {
    return false;
  }
  if (__isset.opt_fieldV != rhs.__isset.opt_fieldV) {
    return false;
  }
  if (__isset.opt_fieldV) {
    if (!(opt_fieldV == rhs.opt_fieldV)) {
      return false;
    }
  }
  if (!(fieldW == rhs.fieldW)) {
    return false;
  }
  if (!(fieldX == rhs.fieldX)) {
    return false;
  }
  if (!(req_fieldX == rhs.req_fieldX)) {
    return false;
  }
  if (__isset.opt_fieldX != rhs.__isset.opt_fieldX) {
    return false;
  }
  if (__isset.opt_fieldX) {
    if (!(opt_fieldX == rhs.opt_fieldX)) {
      return false;
    }
  }
  if (!(fieldY == rhs.fieldY)) {
    return false;
  }
  if (!(fieldZ == rhs.fieldZ)) {
    return false;
  }
  if (!(fieldAA == rhs.fieldAA)) {
    return false;
  }
  if (!(fieldAB == rhs.fieldAB)) {
    return false;
  }
  if (!(fieldAC == rhs.fieldAC)) {
    return false;
  }
  if (!(fieldAD == rhs.fieldAD)) {
    return false;
  }
  if (!(fieldAE == rhs.fieldAE)) {
    return false;
  }
  if (!(fieldSD == rhs.fieldSD)) {
    return false;
  }
  return true;
}

const std::map<std::string, bool>& containerStruct::get_fieldB() const& {
  return fieldB;
}

std::map<std::string, bool> containerStruct::get_fieldB() && {
  return std::move(fieldB);
}

const std::map<std::string, bool>& containerStruct::get_req_fieldB() const& {
  return req_fieldB;
}

std::map<std::string, bool> containerStruct::get_req_fieldB() && {
  return std::move(req_fieldB);
}

const std::map<std::string, bool>* containerStruct::get_opt_fieldB() const& {
  return __isset.opt_fieldB ? std::addressof(opt_fieldB) : nullptr;
}

std::map<std::string, bool>* containerStruct::get_opt_fieldB() & {
  return __isset.opt_fieldB ? std::addressof(opt_fieldB) : nullptr;
}

const std::set<int32_t>& containerStruct::get_fieldC() const& {
  return fieldC;
}

std::set<int32_t> containerStruct::get_fieldC() && {
  return std::move(fieldC);
}

const std::set<int32_t>& containerStruct::get_req_fieldC() const& {
  return req_fieldC;
}

std::set<int32_t> containerStruct::get_req_fieldC() && {
  return std::move(req_fieldC);
}

const std::set<int32_t>* containerStruct::get_opt_fieldC() const& {
  return __isset.opt_fieldC ? std::addressof(opt_fieldC) : nullptr;
}

std::set<int32_t>* containerStruct::get_opt_fieldC() & {
  return __isset.opt_fieldC ? std::addressof(opt_fieldC) : nullptr;
}

const std::vector<std::vector<int32_t>>& containerStruct::get_fieldF() const& {
  return fieldF;
}

std::vector<std::vector<int32_t>> containerStruct::get_fieldF() && {
  return std::move(fieldF);
}

const std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>>& containerStruct::get_fieldG() const& {
  return fieldG;
}

std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>> containerStruct::get_fieldG() && {
  return std::move(fieldG);
}

const std::vector<std::set<int32_t>>& containerStruct::get_fieldH() const& {
  return fieldH;
}

std::vector<std::set<int32_t>> containerStruct::get_fieldH() && {
  return std::move(fieldH);
}

const std::map<std::string, std::vector<int32_t>>& containerStruct::get_fieldJ() const& {
  return fieldJ;
}

std::map<std::string, std::vector<int32_t>> containerStruct::get_fieldJ() && {
  return std::move(fieldJ);
}

const std::vector<std::vector<std::vector<std::vector<int32_t>>>>& containerStruct::get_fieldK() const& {
  return fieldK;
}

std::vector<std::vector<std::vector<std::vector<int32_t>>>> containerStruct::get_fieldK() && {
  return std::move(fieldK);
}

const std::set<std::set<std::set<bool>>>& containerStruct::get_fieldL() const& {
  return fieldL;
}

std::set<std::set<std::set<bool>>> containerStruct::get_fieldL() && {
  return std::move(fieldL);
}

const std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>>& containerStruct::get_fieldM() const& {
  return fieldM;
}

std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>> containerStruct::get_fieldM() && {
  return std::move(fieldM);
}

const  ::some::valid::ns::complexStructTypeDef& containerStruct::get_fieldO() const& {
  return fieldO;
}

 ::some::valid::ns::complexStructTypeDef containerStruct::get_fieldO() && {
  return std::move(fieldO);
}

const std::vector< ::some::valid::ns::mostComplexTypeDef>& containerStruct::get_fieldP() const& {
  return fieldP;
}

std::vector< ::some::valid::ns::mostComplexTypeDef> containerStruct::get_fieldP() && {
  return std::move(fieldP);
}

const std::vector< ::some::valid::ns::MyEnumA>& containerStruct::get_fieldT() const& {
  return fieldT;
}

std::vector< ::some::valid::ns::MyEnumA> containerStruct::get_fieldT() && {
  return std::move(fieldT);
}

const std::vector< ::some::valid::ns::MyEnumA>& containerStruct::get_fieldU() const& {
  return fieldU;
}

std::vector< ::some::valid::ns::MyEnumA> containerStruct::get_fieldU() && {
  return std::move(fieldU);
}

const  ::some::valid::ns::MyStruct& containerStruct::get_fieldV() const& {
  return fieldV;
}

 ::some::valid::ns::MyStruct containerStruct::get_fieldV() && {
  return std::move(fieldV);
}

const  ::some::valid::ns::MyStruct& containerStruct::get_req_fieldV() const& {
  return req_fieldV;
}

 ::some::valid::ns::MyStruct containerStruct::get_req_fieldV() && {
  return std::move(req_fieldV);
}

const  ::some::valid::ns::MyStruct* containerStruct::get_opt_fieldV() const& {
  return __isset.opt_fieldV ? std::addressof(opt_fieldV) : nullptr;
}

 ::some::valid::ns::MyStruct* containerStruct::get_opt_fieldV() & {
  return __isset.opt_fieldV ? std::addressof(opt_fieldV) : nullptr;
}

const std::set< ::some::valid::ns::MyStruct>& containerStruct::get_fieldW() const& {
  return fieldW;
}

std::set< ::some::valid::ns::MyStruct> containerStruct::get_fieldW() && {
  return std::move(fieldW);
}

const  ::some::valid::ns::ComplexUnion& containerStruct::get_fieldX() const& {
  return fieldX;
}

 ::some::valid::ns::ComplexUnion containerStruct::get_fieldX() && {
  return std::move(fieldX);
}

const  ::some::valid::ns::ComplexUnion& containerStruct::get_req_fieldX() const& {
  return req_fieldX;
}

 ::some::valid::ns::ComplexUnion containerStruct::get_req_fieldX() && {
  return std::move(req_fieldX);
}

const  ::some::valid::ns::ComplexUnion* containerStruct::get_opt_fieldX() const& {
  return __isset.opt_fieldX ? std::addressof(opt_fieldX) : nullptr;
}

 ::some::valid::ns::ComplexUnion* containerStruct::get_opt_fieldX() & {
  return __isset.opt_fieldX ? std::addressof(opt_fieldX) : nullptr;
}

const std::vector< ::some::valid::ns::ComplexUnion>& containerStruct::get_fieldY() const& {
  return fieldY;
}

std::vector< ::some::valid::ns::ComplexUnion> containerStruct::get_fieldY() && {
  return std::move(fieldY);
}

const  ::some::valid::ns::unionTypeDef& containerStruct::get_fieldZ() const& {
  return fieldZ;
}

 ::some::valid::ns::unionTypeDef containerStruct::get_fieldZ() && {
  return std::move(fieldZ);
}

const std::vector< ::some::valid::ns::unionTypeDef>& containerStruct::get_fieldAA() const& {
  return fieldAA;
}

std::vector< ::some::valid::ns::unionTypeDef> containerStruct::get_fieldAA() && {
  return std::move(fieldAA);
}

const std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>& containerStruct::get_fieldAB() const& {
  return fieldAB;
}

std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> containerStruct::get_fieldAB() && {
  return std::move(fieldAB);
}

const std::map<std::string, int32_t>& containerStruct::get_fieldAE() const& {
  return fieldAE;
}

std::map<std::string, int32_t> containerStruct::get_fieldAE() && {
  return std::move(fieldAE);
}

void containerStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "fieldA") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "req_fieldA") {
    fid = 101;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "opt_fieldA") {
    fid = 201;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "fieldB") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "req_fieldB") {
    fid = 102;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "opt_fieldB") {
    fid = 202;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldC") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "req_fieldC") {
    fid = 103;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "opt_fieldC") {
    fid = 203;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldD") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "fieldE") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "req_fieldE") {
    fid = 105;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "opt_fieldE") {
    fid = 205;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "fieldF") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldG") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldH") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldI") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "fieldJ") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldK") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldL") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldM") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldN") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldO") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldP") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldQ") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldR") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "req_fieldR") {
    fid = 118;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "opt_fieldR") {
    fid = 218;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldS") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldT") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldU") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldV") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_fieldV") {
    fid = 123;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_fieldV") {
    fid = 223;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldW") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldX") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_fieldX") {
    fid = 125;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_fieldX") {
    fid = 225;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldY") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldZ") {
    fid = 27;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldAA") {
    fid = 28;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldAB") {
    fid = 29;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldAC") {
    fid = 30;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldAD") {
    fid = 31;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldAE") {
    fid = 32;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldSD") {
    fid = 33;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

void swap(containerStruct& a, containerStruct& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.req_fieldA, b.req_fieldA);
  swap(a.opt_fieldA, b.opt_fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.req_fieldB, b.req_fieldB);
  swap(a.opt_fieldB, b.opt_fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.req_fieldC, b.req_fieldC);
  swap(a.opt_fieldC, b.opt_fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.req_fieldE, b.req_fieldE);
  swap(a.opt_fieldE, b.opt_fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.req_fieldR, b.req_fieldR);
  swap(a.opt_fieldR, b.opt_fieldR);
  swap(a.fieldS, b.fieldS);
  swap(a.fieldT, b.fieldT);
  swap(a.fieldU, b.fieldU);
  swap(a.fieldV, b.fieldV);
  swap(a.req_fieldV, b.req_fieldV);
  swap(a.opt_fieldV, b.opt_fieldV);
  swap(a.fieldW, b.fieldW);
  swap(a.fieldX, b.fieldX);
  swap(a.req_fieldX, b.req_fieldX);
  swap(a.opt_fieldX, b.opt_fieldX);
  swap(a.fieldY, b.fieldY);
  swap(a.fieldZ, b.fieldZ);
  swap(a.fieldAA, b.fieldAA);
  swap(a.fieldAB, b.fieldAB);
  swap(a.fieldAC, b.fieldAC);
  swap(a.fieldAD, b.fieldAD);
  swap(a.fieldAE, b.fieldAE);
  swap(a.fieldSD, b.fieldSD);
  swap(a.__isset, b.__isset);
}

template void containerStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t containerStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t containerStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t containerStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void containerStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t containerStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t containerStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t containerStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void containerStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t containerStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t containerStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t containerStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

MyIncludedStruct::MyIncludedStruct(const MyIncludedStruct& src) {
  MyIncludedInt = src.MyIncludedInt;
  __isset.MyIncludedInt = src.__isset.MyIncludedInt;
  MyIncludedStruct = src.MyIncludedStruct;
  __isset.MyIncludedStruct = src.__isset.MyIncludedStruct;
  if (src.ARefField) ARefField.reset(new  ::some::valid::ns::AStruct(*src.ARefField));
  ARequiredField = src.ARequiredField;
}

MyIncludedStruct& MyIncludedStruct::operator=(const MyIncludedStruct& src) {
  MyIncludedStruct tmp(src);
  swap(*this, tmp);
  return *this;
}

MyIncludedStruct::MyIncludedStruct(apache::thrift::FragileConstructor,  ::a::different::ns::IncludedInt64 MyIncludedInt__arg,  ::some::valid::ns::AStruct MyIncludedStruct__arg, std::unique_ptr< ::some::valid::ns::AStruct> ARefField__arg,  ::some::valid::ns::AStruct ARequiredField__arg) :
    MyIncludedInt(std::move(MyIncludedInt__arg)),
    MyIncludedStruct(std::move(MyIncludedStruct__arg)),
    ARefField(std::move(ARefField__arg)),
    ARequiredField(std::move(ARequiredField__arg)) {
  __isset.MyIncludedInt = true;
  __isset.MyIncludedStruct = true;
}

void MyIncludedStruct::__clear() {
  // clear all fields
  MyIncludedInt = 42LL;
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::AStruct>::clear(&MyIncludedStruct);
  if (ARefField) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::AStruct>::clear(ARefField.get());
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::AStruct>::clear(&ARequiredField);
  __isset = {};
}

bool MyIncludedStruct::operator==(const MyIncludedStruct& rhs) const {
  (void)rhs;
  if (!(MyIncludedInt == rhs.MyIncludedInt)) {
    return false;
  }
  if (!(MyIncludedStruct == rhs.MyIncludedStruct)) {
    return false;
  }
  if (!!ARefField != !!rhs.ARefField) {
    return false;
  }
  if (!!ARefField) {
    if (!(*ARefField == *rhs.ARefField)) {
      return false;
    }
  }
  if (!(ARequiredField == rhs.ARequiredField)) {
    return false;
  }
  return true;
}

const  ::some::valid::ns::AStruct& MyIncludedStruct::get_MyIncludedStruct() const& {
  return MyIncludedStruct;
}

 ::some::valid::ns::AStruct MyIncludedStruct::get_MyIncludedStruct() && {
  return std::move(MyIncludedStruct);
}

const  ::some::valid::ns::AStruct& MyIncludedStruct::get_ARequiredField() const& {
  return ARequiredField;
}

 ::some::valid::ns::AStruct MyIncludedStruct::get_ARequiredField() && {
  return std::move(ARequiredField);
}

void MyIncludedStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "MyIncludedInt") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "MyIncludedStruct") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ARefField") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ARequiredField") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(MyIncludedStruct& a, MyIncludedStruct& b) {
  using ::std::swap;
  swap(a.MyIncludedInt, b.MyIncludedInt);
  swap(a.MyIncludedStruct, b.MyIncludedStruct);
  swap(a.ARefField, b.ARefField);
  swap(a.ARequiredField, b.ARequiredField);
  swap(a.__isset, b.__isset);
}

template void MyIncludedStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyIncludedStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyIncludedStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyIncludedStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyIncludedStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyIncludedStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyIncludedStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyIncludedStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void MyIncludedStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t MyIncludedStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t MyIncludedStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t MyIncludedStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

AnnotatedStruct::AnnotatedStruct() :
      container_with_ref(std::make_unique<std::map<int32_t, std::vector<std::string>>>()),
      req_container_with_ref(std::make_unique<std::vector<std::string>>()),
      opt_container_with_ref(std::make_unique<std::set<int32_t>>()),
      ref_type_const(std::make_shared<std::map<int32_t, std::vector<std::string>>>()),
      req_ref_type_unique(std::make_unique<std::vector<std::string>>()),
      opt_ref_type_shared(std::make_shared<std::set<int32_t>>()),
      base_type(0),
      indirection_a(0),
      iobuf_type_val(apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("value")),
      iobuf_ptr_val(apache::thrift::StringTraits< std::unique_ptr<folly::IOBuf>>::fromStringLiteral("value2")),
      struct_struct( ::some::valid::ns::containerStruct(::apache::thrift::detail::wrap_argument<4>(apache::thrift::StringTraits< std::string>::fromStringLiteral("some string")), ::apache::thrift::detail::wrap_argument<9>(false))) {}

AnnotatedStruct::AnnotatedStruct(AnnotatedStruct&& other) noexcept :
    no_annotation(std::move(other.no_annotation)),
    cpp_unique_ref(std::move(other.cpp_unique_ref)),
    cpp2_unique_ref(std::move(other.cpp2_unique_ref)),
    container_with_ref(std::move(other.container_with_ref)),
    req_cpp_unique_ref(std::move(other.req_cpp_unique_ref)),
    req_cpp2_unique_ref(std::move(other.req_cpp2_unique_ref)),
    req_container_with_ref(std::move(other.req_container_with_ref)),
    opt_cpp_unique_ref(std::move(other.opt_cpp_unique_ref)),
    opt_cpp2_unique_ref(std::move(other.opt_cpp2_unique_ref)),
    opt_container_with_ref(std::move(other.opt_container_with_ref)),
    ref_type_unique(std::move(other.ref_type_unique)),
    ref_type_shared(std::move(other.ref_type_shared)),
    ref_type_const(std::move(other.ref_type_const)),
    req_ref_type_shared(std::move(other.req_ref_type_shared)),
    req_ref_type_const(std::move(other.req_ref_type_const)),
    req_ref_type_unique(std::move(other.req_ref_type_unique)),
    opt_ref_type_const(std::move(other.opt_ref_type_const)),
    opt_ref_type_unique(std::move(other.opt_ref_type_unique)),
    opt_ref_type_shared(std::move(other.opt_ref_type_shared)),
    base_type(std::move(other.base_type)),
    list_type(std::move(other.list_type)),
    set_type(std::move(other.set_type)),
    map_type(std::move(other.map_type)),
    map_struct_type(std::move(other.map_struct_type)),
    iobuf_type(std::move(other.iobuf_type)),
    iobuf_ptr(std::move(other.iobuf_ptr)),
    list_i32_template(std::move(other.list_i32_template)),
    list_string_template(std::move(other.list_string_template)),
    set_template(std::move(other.set_template)),
    map_template(std::move(other.map_template)),
    typedef_list_template(std::move(other.typedef_list_template)),
    typedef_deque_template(std::move(other.typedef_deque_template)),
    typedef_set_template(std::move(other.typedef_set_template)),
    typedef_map_template(std::move(other.typedef_map_template)),
    indirection_a(std::move(other.indirection_a)),
    indirection_b(std::move(other.indirection_b)),
    indirection_c(std::move(other.indirection_c)),
    iobuf_type_val(std::move(other.iobuf_type_val)),
    iobuf_ptr_val(std::move(other.iobuf_ptr_val)),
    struct_struct(std::move(other.struct_struct)),
    __isset(other.__isset) {}
AnnotatedStruct::~AnnotatedStruct() {}

AnnotatedStruct::AnnotatedStruct(apache::thrift::FragileConstructor,  ::some::valid::ns::containerStruct no_annotation__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp2_unique_ref__arg, std::unique_ptr<std::map<int32_t, std::vector<std::string>>> container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp2_unique_ref__arg, std::unique_ptr<std::vector<std::string>> req_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp2_unique_ref__arg, std::unique_ptr<std::set<int32_t>> opt_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> ref_type_unique__arg, std::shared_ptr< ::some::valid::ns::containerStruct> ref_type_shared__arg, std::shared_ptr<const std::map<int32_t, std::vector<std::string>>> ref_type_const__arg, std::shared_ptr< ::some::valid::ns::containerStruct> req_ref_type_shared__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> req_ref_type_const__arg, std::unique_ptr<std::vector<std::string>> req_ref_type_unique__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> opt_ref_type_const__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_ref_type_unique__arg, std::shared_ptr<std::set<int32_t>> opt_ref_type_shared__arg,  ::some::valid::ns::CppFakeI32 base_type__arg,  ::some::valid::ns::FollySmallVectorI64 list_type__arg,  ::some::valid::ns::SortedVectorSetString set_type__arg,  ::some::valid::ns::FakeMap map_type__arg,  ::some::valid::ns::UnorderedMapStruct map_struct_type__arg,  ::some::valid::ns::IOBuf iobuf_type__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr__arg, std::list<int32_t> list_i32_template__arg, std::deque<std::string> list_string_template__arg, folly::sorted_vector_set<std::string> set_template__arg, folly::sorted_vector_map<int64_t, std::string> map_template__arg,  ::some::valid::ns::std_list typedef_list_template__arg,  ::some::valid::ns::std_deque typedef_deque_template__arg,  ::some::valid::ns::folly_set typedef_set_template__arg,  ::some::valid::ns::folly_map typedef_map_template__arg,  ::some::valid::ns::IndirectionA indirection_a__arg, std::vector< ::some::valid::ns::IndirectionB> indirection_b__arg, std::set< ::some::valid::ns::IndirectionC> indirection_c__arg,  ::some::valid::ns::IOBuf iobuf_type_val__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr_val__arg,  ::some::valid::ns::containerStruct struct_struct__arg) :
    no_annotation(std::move(no_annotation__arg)),
    cpp_unique_ref(std::move(cpp_unique_ref__arg)),
    cpp2_unique_ref(std::move(cpp2_unique_ref__arg)),
    container_with_ref(std::move(container_with_ref__arg)),
    req_cpp_unique_ref(std::move(req_cpp_unique_ref__arg)),
    req_cpp2_unique_ref(std::move(req_cpp2_unique_ref__arg)),
    req_container_with_ref(std::move(req_container_with_ref__arg)),
    opt_cpp_unique_ref(std::move(opt_cpp_unique_ref__arg)),
    opt_cpp2_unique_ref(std::move(opt_cpp2_unique_ref__arg)),
    opt_container_with_ref(std::move(opt_container_with_ref__arg)),
    ref_type_unique(std::move(ref_type_unique__arg)),
    ref_type_shared(std::move(ref_type_shared__arg)),
    ref_type_const(std::move(ref_type_const__arg)),
    req_ref_type_shared(std::move(req_ref_type_shared__arg)),
    req_ref_type_const(std::move(req_ref_type_const__arg)),
    req_ref_type_unique(std::move(req_ref_type_unique__arg)),
    opt_ref_type_const(std::move(opt_ref_type_const__arg)),
    opt_ref_type_unique(std::move(opt_ref_type_unique__arg)),
    opt_ref_type_shared(std::move(opt_ref_type_shared__arg)),
    base_type(std::move(base_type__arg)),
    list_type(std::move(list_type__arg)),
    set_type(std::move(set_type__arg)),
    map_type(std::move(map_type__arg)),
    map_struct_type(std::move(map_struct_type__arg)),
    iobuf_type(std::move(iobuf_type__arg)),
    iobuf_ptr(std::move(iobuf_ptr__arg)),
    list_i32_template(std::move(list_i32_template__arg)),
    list_string_template(std::move(list_string_template__arg)),
    set_template(std::move(set_template__arg)),
    map_template(std::move(map_template__arg)),
    typedef_list_template(std::move(typedef_list_template__arg)),
    typedef_deque_template(std::move(typedef_deque_template__arg)),
    typedef_set_template(std::move(typedef_set_template__arg)),
    typedef_map_template(std::move(typedef_map_template__arg)),
    indirection_a(std::move(indirection_a__arg)),
    indirection_b(std::move(indirection_b__arg)),
    indirection_c(std::move(indirection_c__arg)),
    iobuf_type_val(std::move(iobuf_type_val__arg)),
    iobuf_ptr_val(std::move(iobuf_ptr_val__arg)),
    struct_struct(std::move(struct_struct__arg)) {
  __isset.no_annotation = true;
  __isset.base_type = true;
  __isset.list_type = true;
  __isset.set_type = true;
  __isset.map_type = true;
  __isset.map_struct_type = true;
  __isset.iobuf_type = true;
  __isset.iobuf_ptr = true;
  __isset.list_i32_template = true;
  __isset.list_string_template = true;
  __isset.set_template = true;
  __isset.map_template = true;
  __isset.typedef_list_template = true;
  __isset.typedef_deque_template = true;
  __isset.typedef_set_template = true;
  __isset.typedef_map_template = true;
  __isset.indirection_a = true;
  __isset.indirection_b = true;
  __isset.indirection_c = true;
  __isset.iobuf_type_val = true;
  __isset.iobuf_ptr_val = true;
  __isset.struct_struct = true;
}

void AnnotatedStruct::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(&no_annotation);
  if (cpp_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(cpp_unique_ref.get());
  if (cpp2_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(cpp2_unique_ref.get());
  container_with_ref.reset(new typename decltype(container_with_ref)::element_type());
  if (req_cpp_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(req_cpp_unique_ref.get());
  if (req_cpp2_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(req_cpp2_unique_ref.get());
  req_container_with_ref.reset(new typename decltype(req_container_with_ref)::element_type());
  if (opt_cpp_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(opt_cpp_unique_ref.get());
  if (opt_cpp2_unique_ref) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(opt_cpp2_unique_ref.get());
  opt_container_with_ref.reset(new typename decltype(opt_container_with_ref)::element_type());
  if (ref_type_unique) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(ref_type_unique.get());
  if (ref_type_shared) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(ref_type_shared.get());
  ref_type_const.reset(new typename decltype(ref_type_const)::element_type());
  if (req_ref_type_shared) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(req_ref_type_shared.get());
  req_ref_type_const.reset();
  req_ref_type_unique.reset(new typename decltype(req_ref_type_unique)::element_type());
  opt_ref_type_const.reset();
  if (opt_ref_type_unique) ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(opt_ref_type_unique.get());
  opt_ref_type_shared.reset(new typename decltype(opt_ref_type_shared)::element_type());
  base_type = 0;
  list_type.clear();
  set_type.clear();
  map_type.clear();
  map_struct_type.clear();
  iobuf_type = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  iobuf_ptr = apache::thrift::StringTraits< std::unique_ptr<folly::IOBuf>>::fromStringLiteral("");
  list_i32_template.clear();
  list_string_template.clear();
  set_template.clear();
  map_template.clear();
  typedef_list_template.clear();
  typedef_deque_template.clear();
  typedef_set_template.clear();
  typedef_map_template.clear();
  indirection_a.value = 0;
  indirection_b.clear();
  indirection_c.clear();
  iobuf_type_val = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("value");
  iobuf_ptr_val = apache::thrift::StringTraits< std::unique_ptr<folly::IOBuf>>::fromStringLiteral("value2");
  ::apache::thrift::Cpp2Ops<  ::some::valid::ns::containerStruct>::clear(&struct_struct);
  __isset = {};
}

bool AnnotatedStruct::operator==(const AnnotatedStruct& rhs) const {
  (void)rhs;
  if (!(no_annotation == rhs.no_annotation)) {
    return false;
  }
  if (!!cpp_unique_ref != !!rhs.cpp_unique_ref) {
    return false;
  }
  if (!!cpp_unique_ref) {
    if (!(*cpp_unique_ref == *rhs.cpp_unique_ref)) {
      return false;
    }
  }
  if (!!cpp2_unique_ref != !!rhs.cpp2_unique_ref) {
    return false;
  }
  if (!!cpp2_unique_ref) {
    if (!(*cpp2_unique_ref == *rhs.cpp2_unique_ref)) {
      return false;
    }
  }
  if (!!container_with_ref != !!rhs.container_with_ref) {
    return false;
  }
  if (!!container_with_ref) {
    if (!(*container_with_ref == *rhs.container_with_ref)) {
      return false;
    }
  }
  if (!!req_cpp_unique_ref != !!rhs.req_cpp_unique_ref) {
    return false;
  }
  if (!!req_cpp_unique_ref) {
    if (!(*req_cpp_unique_ref == *rhs.req_cpp_unique_ref)) {
      return false;
    }
  }
  if (!!req_cpp2_unique_ref != !!rhs.req_cpp2_unique_ref) {
    return false;
  }
  if (!!req_cpp2_unique_ref) {
    if (!(*req_cpp2_unique_ref == *rhs.req_cpp2_unique_ref)) {
      return false;
    }
  }
  if (!!req_container_with_ref != !!rhs.req_container_with_ref) {
    return false;
  }
  if (!!req_container_with_ref) {
    if (!(*req_container_with_ref == *rhs.req_container_with_ref)) {
      return false;
    }
  }
  if (!!opt_cpp_unique_ref != !!rhs.opt_cpp_unique_ref) {
    return false;
  }
  if (!!opt_cpp_unique_ref) {
    if (!(*opt_cpp_unique_ref == *rhs.opt_cpp_unique_ref)) {
      return false;
    }
  }
  if (!!opt_cpp2_unique_ref != !!rhs.opt_cpp2_unique_ref) {
    return false;
  }
  if (!!opt_cpp2_unique_ref) {
    if (!(*opt_cpp2_unique_ref == *rhs.opt_cpp2_unique_ref)) {
      return false;
    }
  }
  if (!!opt_container_with_ref != !!rhs.opt_container_with_ref) {
    return false;
  }
  if (!!opt_container_with_ref) {
    if (!(*opt_container_with_ref == *rhs.opt_container_with_ref)) {
      return false;
    }
  }
  if (!!ref_type_unique != !!rhs.ref_type_unique) {
    return false;
  }
  if (!!ref_type_unique) {
    if (!(*ref_type_unique == *rhs.ref_type_unique)) {
      return false;
    }
  }
  if (!!ref_type_shared != !!rhs.ref_type_shared) {
    return false;
  }
  if (!!ref_type_shared) {
    if (!(*ref_type_shared == *rhs.ref_type_shared)) {
      return false;
    }
  }
  if (!!ref_type_const != !!rhs.ref_type_const) {
    return false;
  }
  if (!!ref_type_const) {
    if (!(*ref_type_const == *rhs.ref_type_const)) {
      return false;
    }
  }
  if (!!req_ref_type_shared != !!rhs.req_ref_type_shared) {
    return false;
  }
  if (!!req_ref_type_shared) {
    if (!(*req_ref_type_shared == *rhs.req_ref_type_shared)) {
      return false;
    }
  }
  if (!!req_ref_type_const != !!rhs.req_ref_type_const) {
    return false;
  }
  if (!!req_ref_type_const) {
    if (!(*req_ref_type_const == *rhs.req_ref_type_const)) {
      return false;
    }
  }
  if (!!req_ref_type_unique != !!rhs.req_ref_type_unique) {
    return false;
  }
  if (!!req_ref_type_unique) {
    if (!(*req_ref_type_unique == *rhs.req_ref_type_unique)) {
      return false;
    }
  }
  if (!!opt_ref_type_const != !!rhs.opt_ref_type_const) {
    return false;
  }
  if (!!opt_ref_type_const) {
    if (!(*opt_ref_type_const == *rhs.opt_ref_type_const)) {
      return false;
    }
  }
  if (!!opt_ref_type_unique != !!rhs.opt_ref_type_unique) {
    return false;
  }
  if (!!opt_ref_type_unique) {
    if (!(*opt_ref_type_unique == *rhs.opt_ref_type_unique)) {
      return false;
    }
  }
  if (!!opt_ref_type_shared != !!rhs.opt_ref_type_shared) {
    return false;
  }
  if (!!opt_ref_type_shared) {
    if (!(*opt_ref_type_shared == *rhs.opt_ref_type_shared)) {
      return false;
    }
  }
  if (!(base_type == rhs.base_type)) {
    return false;
  }
  if (!(list_type == rhs.list_type)) {
    return false;
  }
  if (!(set_type == rhs.set_type)) {
    return false;
  }
  if (!(map_type == rhs.map_type)) {
    return false;
  }
  if (!(map_struct_type == rhs.map_struct_type)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(iobuf_type, rhs.iobuf_type)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(iobuf_ptr, rhs.iobuf_ptr)) {
    return false;
  }
  if (!(list_i32_template == rhs.list_i32_template)) {
    return false;
  }
  if (!(list_string_template == rhs.list_string_template)) {
    return false;
  }
  if (!(set_template == rhs.set_template)) {
    return false;
  }
  if (!(map_template == rhs.map_template)) {
    return false;
  }
  if (!(typedef_list_template == rhs.typedef_list_template)) {
    return false;
  }
  if (!(typedef_deque_template == rhs.typedef_deque_template)) {
    return false;
  }
  if (!(typedef_set_template == rhs.typedef_set_template)) {
    return false;
  }
  if (!(typedef_map_template == rhs.typedef_map_template)) {
    return false;
  }
  if (!(indirection_a == rhs.indirection_a)) {
    return false;
  }
  if (!(indirection_b == rhs.indirection_b)) {
    return false;
  }
  if (!(indirection_c == rhs.indirection_c)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(iobuf_type_val, rhs.iobuf_type_val)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::unique_ptr<folly::IOBuf>>::isEqual(iobuf_ptr_val, rhs.iobuf_ptr_val)) {
    return false;
  }
  if (!(struct_struct == rhs.struct_struct)) {
    return false;
  }
  return true;
}

const  ::some::valid::ns::containerStruct& AnnotatedStruct::get_no_annotation() const& {
  return no_annotation;
}

 ::some::valid::ns::containerStruct AnnotatedStruct::get_no_annotation() && {
  return std::move(no_annotation);
}

const  ::some::valid::ns::FollySmallVectorI64& AnnotatedStruct::get_list_type() const& {
  return list_type;
}

 ::some::valid::ns::FollySmallVectorI64 AnnotatedStruct::get_list_type() && {
  return std::move(list_type);
}

const  ::some::valid::ns::SortedVectorSetString& AnnotatedStruct::get_set_type() const& {
  return set_type;
}

 ::some::valid::ns::SortedVectorSetString AnnotatedStruct::get_set_type() && {
  return std::move(set_type);
}

const  ::some::valid::ns::FakeMap& AnnotatedStruct::get_map_type() const& {
  return map_type;
}

 ::some::valid::ns::FakeMap AnnotatedStruct::get_map_type() && {
  return std::move(map_type);
}

const  ::some::valid::ns::UnorderedMapStruct& AnnotatedStruct::get_map_struct_type() const& {
  return map_struct_type;
}

 ::some::valid::ns::UnorderedMapStruct AnnotatedStruct::get_map_struct_type() && {
  return std::move(map_struct_type);
}

const std::list<int32_t>& AnnotatedStruct::get_list_i32_template() const& {
  return list_i32_template;
}

std::list<int32_t> AnnotatedStruct::get_list_i32_template() && {
  return std::move(list_i32_template);
}

const std::deque<std::string>& AnnotatedStruct::get_list_string_template() const& {
  return list_string_template;
}

std::deque<std::string> AnnotatedStruct::get_list_string_template() && {
  return std::move(list_string_template);
}

const folly::sorted_vector_set<std::string>& AnnotatedStruct::get_set_template() const& {
  return set_template;
}

folly::sorted_vector_set<std::string> AnnotatedStruct::get_set_template() && {
  return std::move(set_template);
}

const folly::sorted_vector_map<int64_t, std::string>& AnnotatedStruct::get_map_template() const& {
  return map_template;
}

folly::sorted_vector_map<int64_t, std::string> AnnotatedStruct::get_map_template() && {
  return std::move(map_template);
}

const  ::some::valid::ns::std_list& AnnotatedStruct::get_typedef_list_template() const& {
  return typedef_list_template;
}

 ::some::valid::ns::std_list AnnotatedStruct::get_typedef_list_template() && {
  return std::move(typedef_list_template);
}

const  ::some::valid::ns::std_deque& AnnotatedStruct::get_typedef_deque_template() const& {
  return typedef_deque_template;
}

 ::some::valid::ns::std_deque AnnotatedStruct::get_typedef_deque_template() && {
  return std::move(typedef_deque_template);
}

const  ::some::valid::ns::folly_set& AnnotatedStruct::get_typedef_set_template() const& {
  return typedef_set_template;
}

 ::some::valid::ns::folly_set AnnotatedStruct::get_typedef_set_template() && {
  return std::move(typedef_set_template);
}

const  ::some::valid::ns::folly_map& AnnotatedStruct::get_typedef_map_template() const& {
  return typedef_map_template;
}

 ::some::valid::ns::folly_map AnnotatedStruct::get_typedef_map_template() && {
  return std::move(typedef_map_template);
}

const std::vector< ::some::valid::ns::IndirectionB>& AnnotatedStruct::get_indirection_b() const& {
  return indirection_b;
}

std::vector< ::some::valid::ns::IndirectionB> AnnotatedStruct::get_indirection_b() && {
  return std::move(indirection_b);
}

const std::set< ::some::valid::ns::IndirectionC>& AnnotatedStruct::get_indirection_c() const& {
  return indirection_c;
}

std::set< ::some::valid::ns::IndirectionC> AnnotatedStruct::get_indirection_c() && {
  return std::move(indirection_c);
}

const  ::some::valid::ns::containerStruct& AnnotatedStruct::get_struct_struct() const& {
  return struct_struct;
}

 ::some::valid::ns::containerStruct AnnotatedStruct::get_struct_struct() && {
  return std::move(struct_struct);
}

void AnnotatedStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "no_annotation") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "cpp_unique_ref") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "cpp2_unique_ref") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "container_with_ref") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "req_cpp_unique_ref") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_cpp2_unique_ref") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_container_with_ref") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "opt_cpp_unique_ref") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_cpp2_unique_ref") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_container_with_ref") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "ref_type_unique") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ref_type_shared") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "ref_type_const") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "req_ref_type_shared") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_ref_type_const") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "req_ref_type_unique") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "opt_ref_type_const") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_ref_type_unique") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "opt_ref_type_shared") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "base_type") {
    fid = 20;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "list_type") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "set_type") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "map_type") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "map_struct_type") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "iobuf_type") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "iobuf_ptr") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "list_i32_template") {
    fid = 27;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "list_string_template") {
    fid = 28;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "set_template") {
    fid = 29;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "map_template") {
    fid = 30;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "typedef_list_template") {
    fid = 31;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "typedef_deque_template") {
    fid = 32;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "typedef_set_template") {
    fid = 33;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "typedef_map_template") {
    fid = 34;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "indirection_a") {
    fid = 35;
    _ftype = apache::thrift::protocol::T_I64;
  }
  else if (_fname == "indirection_b") {
    fid = 36;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "indirection_c") {
    fid = 37;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "iobuf_type_val") {
    fid = 38;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "iobuf_ptr_val") {
    fid = 39;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "struct_struct") {
    fid = 40;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(AnnotatedStruct& a, AnnotatedStruct& b) {
  using ::std::swap;
  swap(a.no_annotation, b.no_annotation);
  swap(a.cpp_unique_ref, b.cpp_unique_ref);
  swap(a.cpp2_unique_ref, b.cpp2_unique_ref);
  swap(a.container_with_ref, b.container_with_ref);
  swap(a.req_cpp_unique_ref, b.req_cpp_unique_ref);
  swap(a.req_cpp2_unique_ref, b.req_cpp2_unique_ref);
  swap(a.req_container_with_ref, b.req_container_with_ref);
  swap(a.opt_cpp_unique_ref, b.opt_cpp_unique_ref);
  swap(a.opt_cpp2_unique_ref, b.opt_cpp2_unique_ref);
  swap(a.opt_container_with_ref, b.opt_container_with_ref);
  swap(a.ref_type_unique, b.ref_type_unique);
  swap(a.ref_type_shared, b.ref_type_shared);
  swap(a.ref_type_const, b.ref_type_const);
  swap(a.req_ref_type_shared, b.req_ref_type_shared);
  swap(a.req_ref_type_const, b.req_ref_type_const);
  swap(a.req_ref_type_unique, b.req_ref_type_unique);
  swap(a.opt_ref_type_const, b.opt_ref_type_const);
  swap(a.opt_ref_type_unique, b.opt_ref_type_unique);
  swap(a.opt_ref_type_shared, b.opt_ref_type_shared);
  swap(a.base_type, b.base_type);
  swap(a.list_type, b.list_type);
  swap(a.set_type, b.set_type);
  swap(a.map_type, b.map_type);
  swap(a.map_struct_type, b.map_struct_type);
  swap(a.iobuf_type, b.iobuf_type);
  swap(a.iobuf_ptr, b.iobuf_ptr);
  swap(a.list_i32_template, b.list_i32_template);
  swap(a.list_string_template, b.list_string_template);
  swap(a.set_template, b.set_template);
  swap(a.map_template, b.map_template);
  swap(a.typedef_list_template, b.typedef_list_template);
  swap(a.typedef_deque_template, b.typedef_deque_template);
  swap(a.typedef_set_template, b.typedef_set_template);
  swap(a.typedef_map_template, b.typedef_map_template);
  swap(a.indirection_a, b.indirection_a);
  swap(a.indirection_b, b.indirection_b);
  swap(a.indirection_c, b.indirection_c);
  swap(a.iobuf_type_val, b.iobuf_type_val);
  swap(a.iobuf_ptr_val, b.iobuf_ptr_val);
  swap(a.struct_struct, b.struct_struct);
  swap(a.__isset, b.__isset);
}

template void AnnotatedStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AnnotatedStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AnnotatedStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AnnotatedStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AnnotatedStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AnnotatedStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AnnotatedStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AnnotatedStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AnnotatedStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AnnotatedStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AnnotatedStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AnnotatedStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

FloatStruct::FloatStruct(apache::thrift::FragileConstructor, float floatField__arg, double doubleField__arg) :
    floatField(std::move(floatField__arg)),
    doubleField(std::move(doubleField__arg)) {
  __isset.floatField = true;
  __isset.doubleField = true;
}

void FloatStruct::__clear() {
  // clear all fields
  floatField = 0;
  doubleField = 0;
  __isset = {};
}

bool FloatStruct::operator==(const FloatStruct& rhs) const {
  (void)rhs;
  if (!(floatField == rhs.floatField)) {
    return false;
  }
  if (!(doubleField == rhs.doubleField)) {
    return false;
  }
  return true;
}

bool FloatStruct::operator<(const FloatStruct& rhs) const {
  (void)rhs;
  if (!(floatField == rhs.floatField)) {
    return floatField < rhs.floatField;
  }
  if (!(doubleField == rhs.doubleField)) {
    return doubleField < rhs.doubleField;
  }
  return false;
}

void FloatStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "floatField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_FLOAT;
  }
  else if (_fname == "doubleField") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
}

void swap(FloatStruct& a, FloatStruct& b) {
  using ::std::swap;
  swap(a.floatField, b.floatField);
  swap(a.doubleField, b.doubleField);
  swap(a.__isset, b.__isset);
}

template void FloatStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FloatStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FloatStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FloatStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FloatStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FloatStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FloatStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FloatStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void FloatStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t FloatStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t FloatStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t FloatStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

void FloatUnion::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::floatSide:
    {
      destruct(value_.floatSide);
      break;
    }
    case Type::doubleSide:
    {
      destruct(value_.doubleSide);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool FloatUnion::operator==(const FloatUnion& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::floatSide:
    {
      return value_.floatSide == rhs.value_.floatSide;
    }
    case Type::doubleSide:
    {
      return value_.doubleSide == rhs.value_.doubleSide;
    }
    default:
    {
      return true;
    }
  }
}
void FloatUnion::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "floatSide") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_FLOAT;
  }
  else if (_fname == "doubleSide") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
}

void swap(FloatUnion& a, FloatUnion& b) {
  FloatUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void FloatUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FloatUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FloatUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FloatUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FloatUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FloatUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FloatUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FloatUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void FloatUnion::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t FloatUnion::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t FloatUnion::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t FloatUnion::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {

AllRequiredNoExceptMoveCtrStruct::AllRequiredNoExceptMoveCtrStruct(apache::thrift::FragileConstructor, int64_t intField__arg) :
    intField(std::move(intField__arg)) {}

void AllRequiredNoExceptMoveCtrStruct::__clear() {
  // clear all fields
  intField = 0;
}

bool AllRequiredNoExceptMoveCtrStruct::operator==(const AllRequiredNoExceptMoveCtrStruct& rhs) const {
  (void)rhs;
  if (!(intField == rhs.intField)) {
    return false;
  }
  return true;
}

bool AllRequiredNoExceptMoveCtrStruct::operator<(const AllRequiredNoExceptMoveCtrStruct& rhs) const {
  (void)rhs;
  if (!(intField == rhs.intField)) {
    return intField < rhs.intField;
  }
  return false;
}

void AllRequiredNoExceptMoveCtrStruct::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "intField") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I64;
  }
}

void swap(AllRequiredNoExceptMoveCtrStruct& a, AllRequiredNoExceptMoveCtrStruct& b) {
  using ::std::swap;
  swap(a.intField, b.intField);
}

template void AllRequiredNoExceptMoveCtrStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllRequiredNoExceptMoveCtrStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllRequiredNoExceptMoveCtrStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllRequiredNoExceptMoveCtrStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AllRequiredNoExceptMoveCtrStruct::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AllRequiredNoExceptMoveCtrStruct::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AllRequiredNoExceptMoveCtrStruct::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

}}} // some::valid::ns
