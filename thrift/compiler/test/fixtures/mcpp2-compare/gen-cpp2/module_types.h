/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/includes_types.h"
#include <folly/small_vector.h>

namespace apache {
namespace thrift {
namespace tag {
struct boolField;
struct boolField;
struct MyBoolField;
struct MyIntField;
struct MyStringField;
struct MyStringField2;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryField3;
struct MyBinaryListField4;
struct MyMapEnumAndInt;
struct intValue;
struct stringValue;
struct intValue;
struct opt_intValue;
struct stringValue;
struct opt_stringValue;
struct intValue2;
struct intValue3;
struct doubelValue;
struct boolValue;
struct union_list;
struct union_set;
struct union_map;
struct opt_union_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union;
struct opt_a_union;
struct a_union_list;
struct a_union_typedef;
struct a_union_typedef_list;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryListField4;
struct ref_field;
struct ref_field2;
struct excp_field;
struct code;
struct req_code;
struct message2;
struct req_message;
struct exception_list;
struct exception_set;
struct exception_map;
struct req_exception_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union_list;
struct union_typedef;
struct a_union_typedef_list;
struct code;
struct req_code;
struct message;
struct fieldA;
struct req_fieldA;
struct opt_fieldA;
struct fieldB;
struct req_fieldB;
struct opt_fieldB;
struct fieldC;
struct req_fieldC;
struct opt_fieldC;
struct fieldD;
struct fieldE;
struct req_fieldE;
struct opt_fieldE;
struct fieldF;
struct fieldG;
struct fieldH;
struct fieldI;
struct fieldJ;
struct fieldK;
struct fieldL;
struct fieldM;
struct fieldN;
struct fieldO;
struct fieldP;
struct fieldQ;
struct fieldR;
struct req_fieldR;
struct opt_fieldR;
struct fieldS;
struct fieldT;
struct fieldU;
struct fieldV;
struct req_fieldV;
struct opt_fieldV;
struct fieldW;
struct fieldX;
struct req_fieldX;
struct opt_fieldX;
struct fieldY;
struct fieldZ;
struct fieldAA;
struct fieldAB;
struct fieldAC;
struct fieldAD;
struct fieldAE;
struct fieldSD;
struct MyIncludedInt;
struct MyIncludedStruct;
struct ARefField;
struct ARequiredField;
struct no_annotation;
struct cpp_unique_ref;
struct cpp2_unique_ref;
struct container_with_ref;
struct req_cpp_unique_ref;
struct req_cpp2_unique_ref;
struct req_container_with_ref;
struct opt_cpp_unique_ref;
struct opt_cpp2_unique_ref;
struct opt_container_with_ref;
struct ref_type_unique;
struct ref_type_shared;
struct ref_type_const;
struct req_ref_type_shared;
struct req_ref_type_const;
struct req_ref_type_unique;
struct opt_ref_type_const;
struct opt_ref_type_unique;
struct opt_ref_type_shared;
struct base_type;
struct list_type;
struct set_type;
struct map_type;
struct map_struct_type;
struct iobuf_type;
struct iobuf_ptr;
struct list_i32_template;
struct list_string_template;
struct set_template;
struct map_template;
struct typedef_list_template;
struct typedef_deque_template;
struct typedef_set_template;
struct typedef_map_template;
struct indirection_a;
struct indirection_b;
struct indirection_c;
struct iobuf_type_val;
struct iobuf_ptr_val;
struct struct_struct;
struct map_of_iobufs;
struct map_of_iobuf_ptrs;
struct floatField;
struct doubleField;
struct floatSide;
struct doubleSide;
struct intField;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBoolField
#define APACHE_THRIFT_ACCESSOR_MyBoolField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBoolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField
#define APACHE_THRIFT_ACCESSOR_MyStringField
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField2
#define APACHE_THRIFT_ACCESSOR_MyStringField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField3
#define APACHE_THRIFT_ACCESSOR_MyBinaryField3
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
#define APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyMapEnumAndInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_intValue
#define APACHE_THRIFT_ACCESSOR_opt_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_stringValue
#define APACHE_THRIFT_ACCESSOR_opt_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue2
#define APACHE_THRIFT_ACCESSOR_intValue2
APACHE_THRIFT_DEFINE_ACCESSOR(intValue2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue3
#define APACHE_THRIFT_ACCESSOR_intValue3
APACHE_THRIFT_DEFINE_ACCESSOR(intValue3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubelValue
#define APACHE_THRIFT_ACCESSOR_doubelValue
APACHE_THRIFT_DEFINE_ACCESSOR(doubelValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolValue
#define APACHE_THRIFT_ACCESSOR_boolValue
APACHE_THRIFT_DEFINE_ACCESSOR(boolValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_list
#define APACHE_THRIFT_ACCESSOR_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_set
#define APACHE_THRIFT_ACCESSOR_union_set
APACHE_THRIFT_DEFINE_ACCESSOR(union_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_map
#define APACHE_THRIFT_ACCESSOR_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_union_map
#define APACHE_THRIFT_ACCESSOR_opt_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(opt_union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union
#define APACHE_THRIFT_ACCESSOR_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_a_union
#define APACHE_THRIFT_ACCESSOR_opt_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(opt_a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef
#define APACHE_THRIFT_ACCESSOR_a_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field
#define APACHE_THRIFT_ACCESSOR_ref_field
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field2
#define APACHE_THRIFT_ACCESSOR_ref_field2
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_excp_field
#define APACHE_THRIFT_ACCESSOR_excp_field
APACHE_THRIFT_DEFINE_ACCESSOR(excp_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message2
#define APACHE_THRIFT_ACCESSOR_message2
APACHE_THRIFT_DEFINE_ACCESSOR(message2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_message
#define APACHE_THRIFT_ACCESSOR_req_message
APACHE_THRIFT_DEFINE_ACCESSOR(req_message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_list
#define APACHE_THRIFT_ACCESSOR_exception_list
APACHE_THRIFT_DEFINE_ACCESSOR(exception_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_set
#define APACHE_THRIFT_ACCESSOR_exception_set
APACHE_THRIFT_DEFINE_ACCESSOR(exception_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_map
#define APACHE_THRIFT_ACCESSOR_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_exception_map
#define APACHE_THRIFT_ACCESSOR_req_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(req_exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_typedef
#define APACHE_THRIFT_ACCESSOR_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldA
#define APACHE_THRIFT_ACCESSOR_req_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldA
#define APACHE_THRIFT_ACCESSOR_opt_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldB
#define APACHE_THRIFT_ACCESSOR_req_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldB
#define APACHE_THRIFT_ACCESSOR_opt_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldC
#define APACHE_THRIFT_ACCESSOR_req_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldC
#define APACHE_THRIFT_ACCESSOR_opt_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldE
#define APACHE_THRIFT_ACCESSOR_req_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldE
#define APACHE_THRIFT_ACCESSOR_opt_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldI
#define APACHE_THRIFT_ACCESSOR_fieldI
APACHE_THRIFT_DEFINE_ACCESSOR(fieldI);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldJ
#define APACHE_THRIFT_ACCESSOR_fieldJ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldJ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldK
#define APACHE_THRIFT_ACCESSOR_fieldK
APACHE_THRIFT_DEFINE_ACCESSOR(fieldK);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldL
#define APACHE_THRIFT_ACCESSOR_fieldL
APACHE_THRIFT_DEFINE_ACCESSOR(fieldL);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldM
#define APACHE_THRIFT_ACCESSOR_fieldM
APACHE_THRIFT_DEFINE_ACCESSOR(fieldM);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldN
#define APACHE_THRIFT_ACCESSOR_fieldN
APACHE_THRIFT_DEFINE_ACCESSOR(fieldN);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldO
#define APACHE_THRIFT_ACCESSOR_fieldO
APACHE_THRIFT_DEFINE_ACCESSOR(fieldO);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldP
#define APACHE_THRIFT_ACCESSOR_fieldP
APACHE_THRIFT_DEFINE_ACCESSOR(fieldP);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldQ
#define APACHE_THRIFT_ACCESSOR_fieldQ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldQ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldR
#define APACHE_THRIFT_ACCESSOR_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldR
#define APACHE_THRIFT_ACCESSOR_req_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldR
#define APACHE_THRIFT_ACCESSOR_opt_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldS
#define APACHE_THRIFT_ACCESSOR_fieldS
APACHE_THRIFT_DEFINE_ACCESSOR(fieldS);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldT
#define APACHE_THRIFT_ACCESSOR_fieldT
APACHE_THRIFT_DEFINE_ACCESSOR(fieldT);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldU
#define APACHE_THRIFT_ACCESSOR_fieldU
APACHE_THRIFT_DEFINE_ACCESSOR(fieldU);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldV
#define APACHE_THRIFT_ACCESSOR_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldV
#define APACHE_THRIFT_ACCESSOR_req_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldV
#define APACHE_THRIFT_ACCESSOR_opt_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldW
#define APACHE_THRIFT_ACCESSOR_fieldW
APACHE_THRIFT_DEFINE_ACCESSOR(fieldW);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldX
#define APACHE_THRIFT_ACCESSOR_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldX
#define APACHE_THRIFT_ACCESSOR_req_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldX
#define APACHE_THRIFT_ACCESSOR_opt_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldY
#define APACHE_THRIFT_ACCESSOR_fieldY
APACHE_THRIFT_DEFINE_ACCESSOR(fieldY);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldZ
#define APACHE_THRIFT_ACCESSOR_fieldZ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldZ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAA
#define APACHE_THRIFT_ACCESSOR_fieldAA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAB
#define APACHE_THRIFT_ACCESSOR_fieldAB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAC
#define APACHE_THRIFT_ACCESSOR_fieldAC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAD
#define APACHE_THRIFT_ACCESSOR_fieldAD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAE
#define APACHE_THRIFT_ACCESSOR_fieldAE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldSD
#define APACHE_THRIFT_ACCESSOR_fieldSD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldSD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedInt
#define APACHE_THRIFT_ACCESSOR_MyIncludedInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedStruct
#define APACHE_THRIFT_ACCESSOR_MyIncludedStruct
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedStruct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARefField
#define APACHE_THRIFT_ACCESSOR_ARefField
APACHE_THRIFT_DEFINE_ACCESSOR(ARefField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARequiredField
#define APACHE_THRIFT_ACCESSOR_ARequiredField
APACHE_THRIFT_DEFINE_ACCESSOR(ARequiredField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_no_annotation
#define APACHE_THRIFT_ACCESSOR_no_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(no_annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_container_with_ref
#define APACHE_THRIFT_ACCESSOR_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_container_with_ref
#define APACHE_THRIFT_ACCESSOR_req_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_container_with_ref
#define APACHE_THRIFT_ACCESSOR_opt_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_const
#define APACHE_THRIFT_ACCESSOR_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_req_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_const
#define APACHE_THRIFT_ACCESSOR_req_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_req_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_const
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_base_type
#define APACHE_THRIFT_ACCESSOR_base_type
APACHE_THRIFT_DEFINE_ACCESSOR(base_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_type
#define APACHE_THRIFT_ACCESSOR_list_type
APACHE_THRIFT_DEFINE_ACCESSOR(list_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_type
#define APACHE_THRIFT_ACCESSOR_set_type
APACHE_THRIFT_DEFINE_ACCESSOR(set_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_type
#define APACHE_THRIFT_ACCESSOR_map_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_struct_type
#define APACHE_THRIFT_ACCESSOR_map_struct_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_struct_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type
#define APACHE_THRIFT_ACCESSOR_iobuf_type
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_i32_template
#define APACHE_THRIFT_ACCESSOR_list_i32_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_i32_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_string_template
#define APACHE_THRIFT_ACCESSOR_list_string_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_string_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_template
#define APACHE_THRIFT_ACCESSOR_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_template
#define APACHE_THRIFT_ACCESSOR_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_list_template
#define APACHE_THRIFT_ACCESSOR_typedef_list_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_list_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_deque_template
#define APACHE_THRIFT_ACCESSOR_typedef_deque_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_deque_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_set_template
#define APACHE_THRIFT_ACCESSOR_typedef_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_map_template
#define APACHE_THRIFT_ACCESSOR_typedef_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_a
#define APACHE_THRIFT_ACCESSOR_indirection_a
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_b
#define APACHE_THRIFT_ACCESSOR_indirection_b
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_c
#define APACHE_THRIFT_ACCESSOR_indirection_c
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type_val
#define APACHE_THRIFT_ACCESSOR_iobuf_type_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_struct_struct
#define APACHE_THRIFT_ACCESSOR_struct_struct
APACHE_THRIFT_DEFINE_ACCESSOR(struct_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobufs
#define APACHE_THRIFT_ACCESSOR_map_of_iobufs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobufs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
#define APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobuf_ptrs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatField
#define APACHE_THRIFT_ACCESSOR_floatField
APACHE_THRIFT_DEFINE_ACCESSOR(floatField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleField
#define APACHE_THRIFT_ACCESSOR_doubleField
APACHE_THRIFT_DEFINE_ACCESSOR(doubleField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatSide
#define APACHE_THRIFT_ACCESSOR_floatSide
APACHE_THRIFT_DEFINE_ACCESSOR(floatSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleSide
#define APACHE_THRIFT_ACCESSOR_doubleSide
APACHE_THRIFT_DEFINE_ACCESSOR(doubleSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intField
#define APACHE_THRIFT_ACCESSOR_intField
APACHE_THRIFT_DEFINE_ACCESSOR(intField);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace some { namespace valid { namespace ns {

enum class MyEnumA {
  fieldA = 1,
  fieldB = 2,
  fieldC = 4,
};




enum class AnnotatedEnum : std::uint32_t {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};


inline constexpr AnnotatedEnum operator&(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator&=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum operator|(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator|=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum operator^(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator^=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum operator~(AnnotatedEnum a) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class AnnotatedEnum2 : short {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};


inline constexpr AnnotatedEnum2 operator&(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator&=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum2 operator|(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator|=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum2 operator^(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator^=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum2 operator~(AnnotatedEnum2 a) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class MyEnumB {
  AField = 0,
};




}}} // some::valid::ns
namespace std {


template<> struct hash<typename ::some::valid::ns::MyEnumA> : public apache::thrift::detail::enum_hash<typename ::some::valid::ns::MyEnumA> {};
template<> struct equal_to<typename ::some::valid::ns::MyEnumA> : public apache::thrift::detail::enum_equal_to<typename ::some::valid::ns::MyEnumA> {};


template<> struct hash<typename ::some::valid::ns::AnnotatedEnum> : public apache::thrift::detail::enum_hash<typename ::some::valid::ns::AnnotatedEnum> {};
template<> struct equal_to<typename ::some::valid::ns::AnnotatedEnum> : public apache::thrift::detail::enum_equal_to<typename ::some::valid::ns::AnnotatedEnum> {};


template<> struct hash<typename ::some::valid::ns::AnnotatedEnum2> : public apache::thrift::detail::enum_hash<typename ::some::valid::ns::AnnotatedEnum2> {};
template<> struct equal_to<typename ::some::valid::ns::AnnotatedEnum2> : public apache::thrift::detail::enum_equal_to<typename ::some::valid::ns::AnnotatedEnum2> {};


template<> struct hash<typename ::some::valid::ns::MyEnumB> : public apache::thrift::detail::enum_hash<typename ::some::valid::ns::MyEnumB> {};
template<> struct equal_to<typename ::some::valid::ns::MyEnumB> : public apache::thrift::detail::enum_equal_to<typename ::some::valid::ns::MyEnumB> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumA>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumA> {
  using type = ::some::valid::ns::MyEnumA;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::fieldA; }
  static constexpr type max() { return type::fieldC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum> {
  using type = ::some::valid::ns::AnnotatedEnum;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum2>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum2> {
  using type = ::some::valid::ns::AnnotatedEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumB>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumB> {
  using type = ::some::valid::ns::MyEnumB;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::AField; }
  static constexpr type max() { return type::AField; }
};


}} // apache::thrift

namespace some { namespace valid { namespace ns {

using _MyEnumA_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumA>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES;

using _AnnotatedEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum_NAMES_TO_VALUES;

using _AnnotatedEnum2_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum2>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum2_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum2_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum2_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum2_NAMES_TO_VALUES;

using _MyEnumB_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumB>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _MyEnumB_EnumMapFactory::ValuesToNamesMapType _MyEnumB_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _MyEnumB_EnumMapFactory::NamesToValuesMapType _MyEnumB_NAMES_TO_VALUES;

}}} // some::valid::ns

// END declare_enums
// BEGIN struct_indirection
namespace some { namespace valid { namespace ns {
struct apache_thrift_indirection_module_IndirectionA {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};

struct apache_thrift_indirection_module_IndirectionC {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).__value();
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).__value();
  }
};

struct apache_thrift_indirection_module_IndirectionB {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};

struct apache_thrift_indirection_module_IndirectionD {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};


}}} // some::valid::ns
// END struct_indirection
// BEGIN forward_declare
namespace some { namespace valid { namespace ns {
class Empty;
class ASimpleStruct;
class ASimpleStructNoexcept;
class MyStruct;
class SimpleUnion;
class ComplexUnion;
class AnException;
class AnotherException;
class containerStruct;
class MyIncludedStruct;
class AnnotatedStruct;
class ComplexContainerStruct;
class FloatStruct;
class FloatUnion;
class AllRequiredNoExceptMoveCtrStruct;
}}} // some::valid::ns
// END forward_declare
// BEGIN typedefs
namespace some { namespace valid { namespace ns {
typedef  ::a::different::ns::AStruct AStruct;
typedef int32_t simpleTypeDef;
typedef ::std::map<int16_t, ::std::string> containerTypeDef;
typedef ::std::vector<::std::map<int16_t, ::std::string>> complexContainerTypeDef;
typedef ::std::set< ::some::valid::ns::SimpleUnion> unionTypeDef;
typedef ::std::vector< ::some::valid::ns::MyStruct> structTypeDef;
typedef ::std::vector<::std::map< ::some::valid::ns::Empty,  ::some::valid::ns::MyStruct>> complexStructTypeDef;
typedef ::std::vector< ::some::valid::ns::complexStructTypeDef> mostComplexTypeDef;
typedef Foo IndirectionA;
typedef Baz IndirectionC;
typedef Bar IndirectionB;
typedef FooBar IndirectionD;
typedef ::std::map< ::some::valid::ns::MyEnumA, ::std::string> HashedTypedef;
typedef CppFakeI32 CppFakeI32;
typedef folly::small_vector<int64_t, 8 /* maxInline */> FollySmallVectorI64;
typedef folly::sorted_vector_set<std::string> SortedVectorSetString;
typedef FakeMap FakeMap;
typedef std::unordered_map<std::string, containerStruct> UnorderedMapStruct;
typedef std::list<int32_t> std_list;
typedef std::deque<::std::string> std_deque;
typedef folly::sorted_vector_set<::std::string> folly_set;
typedef folly::sorted_vector_map<int64_t, ::std::string> folly_map;
typedef folly::IOBuf IOBuf;
typedef std::unique_ptr<folly::IOBuf> IOBufPtr;

}}} // some::valid::ns
// END typedefs
// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename ::some::valid::ns::MyIncludedStruct> {
  size_t operator()(const ::some::valid::ns::MyIncludedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::MyIncludedStruct> {
  bool operator()(const ::some::valid::ns::MyIncludedStruct&,const ::some::valid::ns::MyIncludedStruct&) const;
};

template<> struct hash<typename ::some::valid::ns::AnnotatedStruct> {
  size_t operator()(const ::some::valid::ns::AnnotatedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::AnnotatedStruct> {
  bool operator()(const ::some::valid::ns::AnnotatedStruct&,const ::some::valid::ns::AnnotatedStruct&) const;
};
} // std
// END hash_and_equal_to
namespace some { namespace valid { namespace ns {
class Empty final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = Empty;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  Empty() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Empty(apache::thrift::FragileConstructor);
  Empty(Empty&& other) noexcept {}

  Empty(const Empty&) = default;


  Empty& operator=(Empty&&) = default;

  Empty& operator=(const Empty&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
  bool operator==(const Empty& rhs) const;
#ifndef SWIG
  friend bool operator!=(const Empty& __x, const Empty& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const Empty& rhs) const;
#ifndef SWIG
  friend bool operator>(const Empty& __x, const Empty& __y) {
    return __y < __x;
  }
  friend bool operator<=(const Empty& __x, const Empty& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const Empty& __x, const Empty& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Empty >;
  friend void swap(Empty& a, Empty& b);
};

template <class Protocol_>
uint32_t Empty::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ASimpleStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = ASimpleStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ASimpleStruct() :
      boolField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStruct(apache::thrift::FragileConstructor, int64_t boolField__arg);

  ASimpleStruct(ASimpleStruct&&) = default;

  ASimpleStruct(const ASimpleStruct&) = default;


  ASimpleStruct& operator=(ASimpleStruct&&) = default;

  ASimpleStruct& operator=(const ASimpleStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  int64_t boolField;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool boolField;
  } __isset = {};
  bool operator==(const ASimpleStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ASimpleStruct& __x, const ASimpleStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ASimpleStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const ASimpleStruct& __x, const ASimpleStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ASimpleStruct& __x, const ASimpleStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ASimpleStruct& __x, const ASimpleStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {std::move(this->boolField), __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {std::move(this->boolField), __isset.boolField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int64_t get_boolField() const {
    return boolField;
  }

  int64_t& set_boolField(int64_t boolField_) {
    boolField = boolField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.boolField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ASimpleStruct >;
  friend void swap(ASimpleStruct& a, ASimpleStruct& b);
};

template <class Protocol_>
uint32_t ASimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ASimpleStructNoexcept final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = ASimpleStructNoexcept;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ASimpleStructNoexcept() :
      boolField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStructNoexcept(apache::thrift::FragileConstructor, int64_t boolField__arg);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ASimpleStructNoexcept(ASimpleStructNoexcept&& other) noexcept :
      boolField(std::move(other.boolField)),
      __isset(other.__isset) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
  ASimpleStructNoexcept(const ASimpleStructNoexcept&) = default;


  ASimpleStructNoexcept& operator=(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept& operator=(const ASimpleStructNoexcept&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  int64_t boolField;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool boolField;
  } __isset = {};
  bool operator==(const ASimpleStructNoexcept& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ASimpleStructNoexcept& __x, const ASimpleStructNoexcept& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ASimpleStructNoexcept& rhs) const;
#ifndef SWIG
  friend bool operator>(const ASimpleStructNoexcept& __x, const ASimpleStructNoexcept& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ASimpleStructNoexcept& __x, const ASimpleStructNoexcept& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ASimpleStructNoexcept& __x, const ASimpleStructNoexcept& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {std::move(this->boolField), __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {std::move(this->boolField), __isset.boolField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int64_t get_boolField() const {
    return boolField;
  }

  int64_t& set_boolField(int64_t boolField_) {
    boolField = boolField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.boolField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ASimpleStructNoexcept >;
  friend void swap(ASimpleStructNoexcept& a, ASimpleStructNoexcept& b);
};

template <class Protocol_>
uint32_t ASimpleStructNoexcept::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class MyStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = MyStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyStruct();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map< ::some::valid::ns::MyEnumA, ::std::string> MyMapEnumAndInt__arg);
  MyStruct(MyStruct&& other) noexcept;

  MyStruct(const MyStruct&) = default;


  MyStruct& operator=(MyStruct&&) = default;

  MyStruct& operator=(const MyStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~MyStruct();

 public:
  bool MyBoolField;
 public:
  int64_t MyIntField;
 public:
  ::std::string MyStringField;
 public:
  ::std::string MyStringField2;
 public:
  ::std::string MyBinaryField;
 private:
  ::std::string MyBinaryField2;
 public:
  ::std::string MyBinaryField3;
 public:
  ::std::vector<::std::string> MyBinaryListField4;
 public:
  ::std::map< ::some::valid::ns::MyEnumA, ::std::string> MyMapEnumAndInt;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool MyBoolField;
    bool MyIntField;
    bool MyStringField;
    bool MyStringField2;
    bool MyBinaryField;
    bool MyBinaryField2;
    bool MyBinaryListField4;
    bool MyMapEnumAndInt;
  } __isset = {};
  bool operator==(const MyStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const MyStruct& __x, const MyStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const MyStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const MyStruct& __x, const MyStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const MyStruct& __x, const MyStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const MyStruct& __x, const MyStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBoolField_ref() const& {
    return {this->MyBoolField, __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBoolField_ref() const&& {
    return {std::move(this->MyBoolField), __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBoolField_ref() & {
    return {this->MyBoolField, __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBoolField_ref() && {
    return {std::move(this->MyBoolField), __isset.MyBoolField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIntField_ref() const& {
    return {this->MyIntField, __isset.MyIntField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIntField_ref() const&& {
    return {std::move(this->MyIntField), __isset.MyIntField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIntField_ref() & {
    return {this->MyIntField, __isset.MyIntField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIntField_ref() && {
    return {std::move(this->MyIntField), __isset.MyIntField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField_ref() const& {
    return {this->MyStringField, __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField_ref() const&& {
    return {std::move(this->MyStringField), __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField_ref() & {
    return {this->MyStringField, __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField_ref() && {
    return {std::move(this->MyStringField), __isset.MyStringField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField2_ref() const& {
    return {this->MyStringField2, __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField2_ref() const&& {
    return {std::move(this->MyStringField2), __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField2_ref() & {
    return {this->MyStringField2, __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField2_ref() && {
    return {std::move(this->MyStringField2), __isset.MyStringField2};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryField_ref() const& {
    return {this->MyBinaryField, __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryField_ref() const&& {
    return {std::move(this->MyBinaryField), __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryField_ref() & {
    return {this->MyBinaryField, __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryField_ref() && {
    return {std::move(this->MyBinaryField), __isset.MyBinaryField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyBinaryField2_ref() const& {
    return {this->MyBinaryField2, __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {std::move(this->MyBinaryField2), __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyBinaryField2_ref() & {
    return {this->MyBinaryField2, __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyBinaryField2_ref() && {
    return {std::move(this->MyBinaryField2), __isset.MyBinaryField2};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto MyBinaryField3_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto MyBinaryField3_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->MyBinaryField3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto MyBinaryField3_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto MyBinaryField3_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->MyBinaryField3)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryListField4_ref() const& {
    return {this->MyBinaryListField4, __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {std::move(this->MyBinaryListField4), __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryListField4_ref() & {
    return {this->MyBinaryListField4, __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryListField4_ref() && {
    return {std::move(this->MyBinaryListField4), __isset.MyBinaryListField4};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map< ::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyMapEnumAndInt_ref() const& {
    return {this->MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyMapEnumAndInt_ref() const&& {
    return {std::move(this->MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyMapEnumAndInt_ref() & {
    return {this->MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyMapEnumAndInt_ref() && {
    return {std::move(this->MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  bool get_MyBoolField() const {
    return MyBoolField;
  }

  bool& set_MyBoolField(bool MyBoolField_) {
    MyBoolField = MyBoolField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyBoolField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyBoolField;
  }

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyIntField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyIntField;
  }

  const ::std::string& get_MyStringField() const& {
    return MyStringField;
  }

  ::std::string get_MyStringField() && {
    return std::move(MyStringField);
  }

  template <typename T_MyStruct_MyStringField_struct_setter = ::std::string>
  ::std::string& set_MyStringField(T_MyStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField = std::forward<T_MyStruct_MyStringField_struct_setter>(MyStringField_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyStringField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyStringField;
  }

  const ::std::string& get_MyStringField2() const& {
    return MyStringField2;
  }

  ::std::string get_MyStringField2() && {
    return std::move(MyStringField2);
  }

  template <typename T_MyStruct_MyStringField2_struct_setter = ::std::string>
  ::std::string& set_MyStringField2(T_MyStruct_MyStringField2_struct_setter&& MyStringField2_) {
    MyStringField2 = std::forward<T_MyStruct_MyStringField2_struct_setter>(MyStringField2_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyStringField2 = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyStringField2;
  }

  const ::std::string& get_MyBinaryField() const& {
    return MyBinaryField;
  }

  ::std::string get_MyBinaryField() && {
    return std::move(MyBinaryField);
  }

  template <typename T_MyStruct_MyBinaryField_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField(T_MyStruct_MyBinaryField_struct_setter&& MyBinaryField_) {
    MyBinaryField = std::forward<T_MyStruct_MyBinaryField_struct_setter>(MyBinaryField_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyBinaryField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyBinaryField;
  }

  const ::std::string* get_MyBinaryField2() const& {
    return MyBinaryField2_ref() ? std::addressof(MyBinaryField2) : nullptr;
  }

  ::std::string* get_MyBinaryField2() & {
    return MyBinaryField2_ref() ? std::addressof(MyBinaryField2) : nullptr;
  }
  ::std::string* get_MyBinaryField2() && = delete;

  template <typename T_MyStruct_MyBinaryField2_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField2(T_MyStruct_MyBinaryField2_struct_setter&& MyBinaryField2_) {
    MyBinaryField2 = std::forward<T_MyStruct_MyBinaryField2_struct_setter>(MyBinaryField2_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyBinaryField2 = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyBinaryField2;
  }

  const ::std::string& get_MyBinaryField3() const& {
    return MyBinaryField3;
  }

  ::std::string get_MyBinaryField3() && {
    return std::move(MyBinaryField3);
  }

  template <typename T_MyStruct_MyBinaryField3_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField3(T_MyStruct_MyBinaryField3_struct_setter&& MyBinaryField3_) {
    MyBinaryField3 = std::forward<T_MyStruct_MyBinaryField3_struct_setter>(MyBinaryField3_);
    return MyBinaryField3;
  }
  const ::std::vector<::std::string>& get_MyBinaryListField4() const&;
  ::std::vector<::std::string> get_MyBinaryListField4() &&;

  template <typename T_MyStruct_MyBinaryListField4_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_MyBinaryListField4(T_MyStruct_MyBinaryListField4_struct_setter&& MyBinaryListField4_) {
    MyBinaryListField4 = std::forward<T_MyStruct_MyBinaryListField4_struct_setter>(MyBinaryListField4_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyBinaryListField4 = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyBinaryListField4;
  }
  const ::std::map< ::some::valid::ns::MyEnumA, ::std::string>& get_MyMapEnumAndInt() const&;
  ::std::map< ::some::valid::ns::MyEnumA, ::std::string> get_MyMapEnumAndInt() &&;

  template <typename T_MyStruct_MyMapEnumAndInt_struct_setter = ::std::map< ::some::valid::ns::MyEnumA, ::std::string>>
  ::std::map< ::some::valid::ns::MyEnumA, ::std::string>& set_MyMapEnumAndInt(T_MyStruct_MyMapEnumAndInt_struct_setter&& MyMapEnumAndInt_) {
    MyMapEnumAndInt = std::forward<T_MyStruct_MyMapEnumAndInt_struct_setter>(MyMapEnumAndInt_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyMapEnumAndInt = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyMapEnumAndInt;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyStruct >;
  friend void swap(MyStruct& a, MyStruct& b);
};

template <class Protocol_>
uint32_t MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class SimpleUnion  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = SimpleUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 7,
    stringValue = 2,
  } ;

  SimpleUnion()
      : type_(Type::__EMPTY__) {}

  SimpleUnion(SimpleUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  SimpleUnion(const SimpleUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  SimpleUnion& operator=(SimpleUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  SimpleUnion& operator=(const SimpleUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~SimpleUnion() {
    __clear();
  }

  union storage_type {
    int64_t intValue;
    ::std::string stringValue;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const SimpleUnion& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SimpleUnion& __x, const SimpleUnion& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SimpleUnion& rhs) const;
#ifndef SWIG
  friend bool operator>(const SimpleUnion& __x, const SimpleUnion& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SimpleUnion& __x, const SimpleUnion& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SimpleUnion& __x, const SimpleUnion& __y) {
    return !(__x < __y);
  }
#endif

  int64_t& set_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) int64_t(t);
    return value_.intValue;
  }

  ::std::string& set_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(t);
    return value_.stringValue;
  }

  ::std::string& set_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  int64_t const & get_intValue() const {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  ::std::string const & get_stringValue() const {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  int64_t & mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  ::std::string & mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  ::std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  std::underlying_type_t<Type> type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SimpleUnion >;
  friend void swap(SimpleUnion& a, SimpleUnion& b);
};

template <class Protocol_>
uint32_t SimpleUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ComplexUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = ComplexUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 1,
    opt_intValue = 201,
    stringValue = 3,
    opt_stringValue = 203,
    intValue2 = 4,
    intValue3 = 6,
    doubelValue = 7,
    boolValue = 8,
    union_list = 9,
    union_set = 10,
    union_map = 11,
    opt_union_map = 211,
    enum_field = 12,
    enum_container = 13,
    a_struct = 14,
    a_set_struct = 15,
    a_union = 16,
    opt_a_union = 216,
    a_union_list = 17,
    a_union_typedef = 18,
    a_union_typedef_list = 19,
    MyBinaryField = 20,
    MyBinaryField2 = 21,
    MyBinaryListField4 = 23,
    ref_field = 24,
    ref_field2 = 25,
    excp_field = 26,
  } ;

  ComplexUnion()
      : type_(Type::__EMPTY__) {}

  ComplexUnion(ComplexUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ComplexUnion(const ComplexUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ComplexUnion& operator=(ComplexUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ComplexUnion& operator=(const ComplexUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ComplexUnion() {
    __clear();
  }
  union storage_type {
    int64_t intValue;
    int64_t opt_intValue;
    ::std::string stringValue;
    ::std::string opt_stringValue;
    int16_t intValue2;
    int32_t intValue3;
    double doubelValue;
    bool boolValue;
    ::std::vector<int32_t> union_list;
    ::std::set<int64_t> union_set;
    ::std::map<::std::string, int32_t> union_map;
    ::std::map<::std::string, int32_t> opt_union_map;
     ::some::valid::ns::MyEnumA enum_field;
    ::std::vector< ::some::valid::ns::MyEnumA> enum_container;
     ::some::valid::ns::MyStruct a_struct;
    ::std::set< ::some::valid::ns::MyStruct> a_set_struct;
     ::some::valid::ns::SimpleUnion a_union;
     ::some::valid::ns::SimpleUnion opt_a_union;
    ::std::vector< ::some::valid::ns::SimpleUnion> a_union_list;
     ::some::valid::ns::unionTypeDef a_union_typedef;
    ::std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list;
    ::std::string MyBinaryField;
    ::std::string MyBinaryField2;
    ::std::vector<::std::string> MyBinaryListField4;
    std::unique_ptr< ::some::valid::ns::MyStruct> ref_field;
    std::shared_ptr<const  ::some::valid::ns::MyStruct> ref_field2;
     ::some::valid::ns::AnException excp_field;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ComplexUnion& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ComplexUnion& __x, const ComplexUnion& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ComplexUnion& rhs) const;
#ifndef SWIG
  friend bool operator>(const ComplexUnion& __x, const ComplexUnion& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ComplexUnion& __x, const ComplexUnion& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ComplexUnion& __x, const ComplexUnion& __y) {
    return !(__x < __y);
  }
#endif

  int64_t& set_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) int64_t(t);
    return value_.intValue;
  }

  int64_t& set_opt_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::opt_intValue;
    ::new (std::addressof(value_.opt_intValue)) int64_t(t);
    return value_.opt_intValue;
  }

  ::std::string& set_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(t);
    return value_.stringValue;
  }

  ::std::string& set_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  ::std::string& set_opt_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(t);
    return value_.opt_stringValue;
  }

  ::std::string& set_opt_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(std::move(t));
    return value_.opt_stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_opt_stringValue(T&&... t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.opt_stringValue;
  }

  int16_t& set_intValue2(int16_t t = int16_t()) {
    __clear();
    type_ = Type::intValue2;
    ::new (std::addressof(value_.intValue2)) int16_t(t);
    return value_.intValue2;
  }

  int32_t& set_intValue3(int32_t t = int32_t()) {
    __clear();
    type_ = Type::intValue3;
    ::new (std::addressof(value_.intValue3)) int32_t(t);
    return value_.intValue3;
  }

  double& set_doubelValue(double t = double()) {
    __clear();
    type_ = Type::doubelValue;
    ::new (std::addressof(value_.doubelValue)) double(t);
    return value_.doubelValue;
  }

  bool& set_boolValue(bool t = bool()) {
    __clear();
    type_ = Type::boolValue;
    ::new (std::addressof(value_.boolValue)) bool(t);
    return value_.boolValue;
  }

  ::std::vector<int32_t>& set_union_list(::std::vector<int32_t> const &t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<int32_t>(t);
    return value_.union_list;
  }

  ::std::vector<int32_t>& set_union_list(::std::vector<int32_t>&& t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<int32_t>(std::move(t));
    return value_.union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<int32_t>, T...>> ::std::vector<int32_t>& set_union_list(T&&... t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<int32_t>(std::forward<T>(t)...);
    return value_.union_list;
  }

  ::std::set<int64_t>& set_union_set(::std::set<int64_t> const &t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<int64_t>(t);
    return value_.union_set;
  }

  ::std::set<int64_t>& set_union_set(::std::set<int64_t>&& t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<int64_t>(std::move(t));
    return value_.union_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set<int64_t>, T...>> ::std::set<int64_t>& set_union_set(T&&... t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<int64_t>(std::forward<T>(t)...);
    return value_.union_set;
  }

  ::std::map<::std::string, int32_t>& set_union_map(::std::map<::std::string, int32_t> const &t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, int32_t>(t);
    return value_.union_map;
  }

  ::std::map<::std::string, int32_t>& set_union_map(::std::map<::std::string, int32_t>&& t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, int32_t>(std::move(t));
    return value_.union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, int32_t>, T...>> ::std::map<::std::string, int32_t>& set_union_map(T&&... t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, int32_t>(std::forward<T>(t)...);
    return value_.union_map;
  }

  ::std::map<::std::string, int32_t>& set_opt_union_map(::std::map<::std::string, int32_t> const &t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, int32_t>(t);
    return value_.opt_union_map;
  }

  ::std::map<::std::string, int32_t>& set_opt_union_map(::std::map<::std::string, int32_t>&& t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, int32_t>(std::move(t));
    return value_.opt_union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, int32_t>, T...>> ::std::map<::std::string, int32_t>& set_opt_union_map(T&&... t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, int32_t>(std::forward<T>(t)...);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA& set_enum_field( ::some::valid::ns::MyEnumA t =  ::some::valid::ns::MyEnumA()) {
    __clear();
    type_ = Type::enum_field;
    ::new (std::addressof(value_.enum_field))  ::some::valid::ns::MyEnumA(t);
    return value_.enum_field;
  }

  ::std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(::std::vector< ::some::valid::ns::MyEnumA> const &t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector< ::some::valid::ns::MyEnumA>(t);
    return value_.enum_container;
  }

  ::std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(::std::vector< ::some::valid::ns::MyEnumA>&& t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector< ::some::valid::ns::MyEnumA>(std::move(t));
    return value_.enum_container;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector< ::some::valid::ns::MyEnumA>, T...>> ::std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(T&&... t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector< ::some::valid::ns::MyEnumA>(std::forward<T>(t)...);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct& set_a_struct( ::some::valid::ns::MyStruct const &t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(t);
    return value_.a_struct;
  }

   ::some::valid::ns::MyStruct& set_a_struct( ::some::valid::ns::MyStruct&& t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(std::move(t));
    return value_.a_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>>  ::some::valid::ns::MyStruct& set_a_struct(T&&... t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(std::forward<T>(t)...);
    return value_.a_struct;
  }

  ::std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(::std::set< ::some::valid::ns::MyStruct> const &t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set< ::some::valid::ns::MyStruct>(t);
    return value_.a_set_struct;
  }

  ::std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(::std::set< ::some::valid::ns::MyStruct>&& t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set< ::some::valid::ns::MyStruct>(std::move(t));
    return value_.a_set_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set< ::some::valid::ns::MyStruct>, T...>> ::std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(T&&... t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set< ::some::valid::ns::MyStruct>(std::forward<T>(t)...);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion& set_a_union( ::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(t);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion& set_a_union( ::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::SimpleUnion, T...>>  ::some::valid::ns::SimpleUnion& set_a_union(T&&... t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion& set_opt_a_union( ::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(t);
    return value_.opt_a_union;
  }

   ::some::valid::ns::SimpleUnion& set_opt_a_union( ::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.opt_a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::SimpleUnion, T...>>  ::some::valid::ns::SimpleUnion& set_opt_a_union(T&&... t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.opt_a_union;
  }

  ::std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector< ::some::valid::ns::SimpleUnion> const &t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector< ::some::valid::ns::SimpleUnion>(t);
    return value_.a_union_list;
  }

  ::std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector< ::some::valid::ns::SimpleUnion>&& t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector< ::some::valid::ns::SimpleUnion>(std::move(t));
    return value_.a_union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector< ::some::valid::ns::SimpleUnion>, T...>> ::std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(T&&... t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector< ::some::valid::ns::SimpleUnion>(std::forward<T>(t)...);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef& set_a_union_typedef( ::some::valid::ns::unionTypeDef const &t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(t);
    return value_.a_union_typedef;
  }

   ::some::valid::ns::unionTypeDef& set_a_union_typedef( ::some::valid::ns::unionTypeDef&& t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(std::move(t));
    return value_.a_union_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::unionTypeDef, T...>>  ::some::valid::ns::unionTypeDef& set_a_union_typedef(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(std::forward<T>(t)...);
    return value_.a_union_typedef;
  }

  ::std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector< ::some::valid::ns::unionTypeDef> const &t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector< ::some::valid::ns::unionTypeDef>(t);
    return value_.a_union_typedef_list;
  }

  ::std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector< ::some::valid::ns::unionTypeDef>&& t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector< ::some::valid::ns::unionTypeDef>(std::move(t));
    return value_.a_union_typedef_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector< ::some::valid::ns::unionTypeDef>, T...>> ::std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector< ::some::valid::ns::unionTypeDef>(std::forward<T>(t)...);
    return value_.a_union_typedef_list;
  }

  ::std::string& set_MyBinaryField(::std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(t);
    return value_.MyBinaryField;
  }

  ::std::string& set_MyBinaryField(::std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(std::move(t));
    return value_.MyBinaryField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField;
  }

  ::std::string& set_MyBinaryField2(::std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(t);
    return value_.MyBinaryField2;
  }

  ::std::string& set_MyBinaryField2(::std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(std::move(t));
    return value_.MyBinaryField2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField2(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string> const &t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(t);
    return value_.MyBinaryListField4;
  }

  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string>&& t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(std::move(t));
    return value_.MyBinaryListField4;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::string>, T...>> ::std::vector<::std::string>& set_MyBinaryListField4(T&&... t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(std::forward<T>(t)...);
    return value_.MyBinaryListField4;
  }
  std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field( ::some::valid::ns::MyStruct const &t);
  std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field( ::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>> std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::unique_ptr< ::some::valid::ns::MyStruct>, void>;
    __clear();
    type_ = Type::ref_field;
    ::new (std::addressof(value_.ref_field)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field;
  }
  std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2( ::some::valid::ns::MyStruct const &t);
  std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2( ::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>> std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), std::shared_ptr<const  ::some::valid::ns::MyStruct>, void>;
    __clear();
    type_ = Type::ref_field2;
    ::new (std::addressof(value_.ref_field2)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field2;
  }

   ::some::valid::ns::AnException& set_excp_field( ::some::valid::ns::AnException const &t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(t);
    return value_.excp_field;
  }

   ::some::valid::ns::AnException& set_excp_field( ::some::valid::ns::AnException&& t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(std::move(t));
    return value_.excp_field;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::AnException, T...>>  ::some::valid::ns::AnException& set_excp_field(T&&... t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(std::forward<T>(t)...);
    return value_.excp_field;
  }

  int64_t const & get_intValue() const {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  int64_t const & get_opt_intValue() const {
    assert(type_ == Type::opt_intValue);
    return value_.opt_intValue;
  }

  ::std::string const & get_stringValue() const {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  ::std::string const & get_opt_stringValue() const {
    assert(type_ == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  int16_t const & get_intValue2() const {
    assert(type_ == Type::intValue2);
    return value_.intValue2;
  }

  int32_t const & get_intValue3() const {
    assert(type_ == Type::intValue3);
    return value_.intValue3;
  }

  double const & get_doubelValue() const {
    assert(type_ == Type::doubelValue);
    return value_.doubelValue;
  }

  bool const & get_boolValue() const {
    assert(type_ == Type::boolValue);
    return value_.boolValue;
  }

  ::std::vector<int32_t> const & get_union_list() const {
    assert(type_ == Type::union_list);
    return value_.union_list;
  }

  ::std::set<int64_t> const & get_union_set() const {
    assert(type_ == Type::union_set);
    return value_.union_set;
  }

  ::std::map<::std::string, int32_t> const & get_union_map() const {
    assert(type_ == Type::union_map);
    return value_.union_map;
  }

  ::std::map<::std::string, int32_t> const & get_opt_union_map() const {
    assert(type_ == Type::opt_union_map);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA const & get_enum_field() const {
    assert(type_ == Type::enum_field);
    return value_.enum_field;
  }

  ::std::vector< ::some::valid::ns::MyEnumA> const & get_enum_container() const {
    assert(type_ == Type::enum_container);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct const & get_a_struct() const {
    assert(type_ == Type::a_struct);
    return value_.a_struct;
  }

  ::std::set< ::some::valid::ns::MyStruct> const & get_a_set_struct() const {
    assert(type_ == Type::a_set_struct);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion const & get_a_union() const {
    assert(type_ == Type::a_union);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion const & get_opt_a_union() const {
    assert(type_ == Type::opt_a_union);
    return value_.opt_a_union;
  }

  ::std::vector< ::some::valid::ns::SimpleUnion> const & get_a_union_list() const {
    assert(type_ == Type::a_union_list);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef const & get_a_union_typedef() const {
    assert(type_ == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  ::std::vector< ::some::valid::ns::unionTypeDef> const & get_a_union_typedef_list() const {
    assert(type_ == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  ::std::string const & get_MyBinaryField() const {
    assert(type_ == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  ::std::string const & get_MyBinaryField2() const {
    assert(type_ == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string> const & get_MyBinaryListField4() const {
    assert(type_ == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> const & get_ref_field() const {
    assert(type_ == Type::ref_field);
    return value_.ref_field;
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> const & get_ref_field2() const {
    assert(type_ == Type::ref_field2);
    return value_.ref_field2;
  }

   ::some::valid::ns::AnException const & get_excp_field() const {
    assert(type_ == Type::excp_field);
    return value_.excp_field;
  }

  int64_t & mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  int64_t & mutable_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return value_.opt_intValue;
  }

  ::std::string & mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  ::std::string & mutable_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  int16_t & mutable_intValue2() {
    assert(type_ == Type::intValue2);
    return value_.intValue2;
  }

  int32_t & mutable_intValue3() {
    assert(type_ == Type::intValue3);
    return value_.intValue3;
  }

  double & mutable_doubelValue() {
    assert(type_ == Type::doubelValue);
    return value_.doubelValue;
  }

  bool & mutable_boolValue() {
    assert(type_ == Type::boolValue);
    return value_.boolValue;
  }

  ::std::vector<int32_t> & mutable_union_list() {
    assert(type_ == Type::union_list);
    return value_.union_list;
  }

  ::std::set<int64_t> & mutable_union_set() {
    assert(type_ == Type::union_set);
    return value_.union_set;
  }

  ::std::map<::std::string, int32_t> & mutable_union_map() {
    assert(type_ == Type::union_map);
    return value_.union_map;
  }

  ::std::map<::std::string, int32_t> & mutable_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA & mutable_enum_field() {
    assert(type_ == Type::enum_field);
    return value_.enum_field;
  }

  ::std::vector< ::some::valid::ns::MyEnumA> & mutable_enum_container() {
    assert(type_ == Type::enum_container);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct & mutable_a_struct() {
    assert(type_ == Type::a_struct);
    return value_.a_struct;
  }

  ::std::set< ::some::valid::ns::MyStruct> & mutable_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion & mutable_a_union() {
    assert(type_ == Type::a_union);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion & mutable_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return value_.opt_a_union;
  }

  ::std::vector< ::some::valid::ns::SimpleUnion> & mutable_a_union_list() {
    assert(type_ == Type::a_union_list);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef & mutable_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  ::std::vector< ::some::valid::ns::unionTypeDef> & mutable_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  ::std::string & mutable_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  ::std::string & mutable_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string> & mutable_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> & mutable_ref_field() {
    assert(type_ == Type::ref_field);
    return value_.ref_field;
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> & mutable_ref_field2() {
    assert(type_ == Type::ref_field2);
    return value_.ref_field2;
  }

   ::some::valid::ns::AnException & mutable_excp_field() {
    assert(type_ == Type::excp_field);
    return value_.excp_field;
  }

  int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  int64_t move_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return std::move(value_.opt_intValue);
  }

  ::std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  ::std::string move_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return std::move(value_.opt_stringValue);
  }

  int16_t move_intValue2() {
    assert(type_ == Type::intValue2);
    return std::move(value_.intValue2);
  }

  int32_t move_intValue3() {
    assert(type_ == Type::intValue3);
    return std::move(value_.intValue3);
  }

  double move_doubelValue() {
    assert(type_ == Type::doubelValue);
    return std::move(value_.doubelValue);
  }

  bool move_boolValue() {
    assert(type_ == Type::boolValue);
    return std::move(value_.boolValue);
  }

  ::std::vector<int32_t> move_union_list() {
    assert(type_ == Type::union_list);
    return std::move(value_.union_list);
  }

  ::std::set<int64_t> move_union_set() {
    assert(type_ == Type::union_set);
    return std::move(value_.union_set);
  }

  ::std::map<::std::string, int32_t> move_union_map() {
    assert(type_ == Type::union_map);
    return std::move(value_.union_map);
  }

  ::std::map<::std::string, int32_t> move_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return std::move(value_.opt_union_map);
  }

   ::some::valid::ns::MyEnumA move_enum_field() {
    assert(type_ == Type::enum_field);
    return std::move(value_.enum_field);
  }

  ::std::vector< ::some::valid::ns::MyEnumA> move_enum_container() {
    assert(type_ == Type::enum_container);
    return std::move(value_.enum_container);
  }

   ::some::valid::ns::MyStruct move_a_struct() {
    assert(type_ == Type::a_struct);
    return std::move(value_.a_struct);
  }

  ::std::set< ::some::valid::ns::MyStruct> move_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return std::move(value_.a_set_struct);
  }

   ::some::valid::ns::SimpleUnion move_a_union() {
    assert(type_ == Type::a_union);
    return std::move(value_.a_union);
  }

   ::some::valid::ns::SimpleUnion move_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return std::move(value_.opt_a_union);
  }

  ::std::vector< ::some::valid::ns::SimpleUnion> move_a_union_list() {
    assert(type_ == Type::a_union_list);
    return std::move(value_.a_union_list);
  }

   ::some::valid::ns::unionTypeDef move_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return std::move(value_.a_union_typedef);
  }

  ::std::vector< ::some::valid::ns::unionTypeDef> move_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return std::move(value_.a_union_typedef_list);
  }

  ::std::string move_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return std::move(value_.MyBinaryField);
  }

  ::std::string move_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return std::move(value_.MyBinaryField2);
  }

  ::std::vector<::std::string> move_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return std::move(value_.MyBinaryListField4);
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> move_ref_field() {
    assert(type_ == Type::ref_field);
    return std::move(value_.ref_field);
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> move_ref_field2() {
    assert(type_ == Type::ref_field2);
    return std::move(value_.ref_field2);
  }

   ::some::valid::ns::AnException move_excp_field() {
    assert(type_ == Type::excp_field);
    return std::move(value_.excp_field);
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_intValue_ref() const& {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_intValue_ref() const&& {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_intValue_ref() & {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_intValue_ref() && {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_stringValue_ref() const& {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_stringValue_ref() const&& {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_stringValue_ref() & {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_stringValue_ref() && {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue2_ref() const& {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue2_ref() const&& {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue2_ref() & {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue2_ref() && {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue3_ref() const& {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue3_ref() const&& {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue3_ref() & {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue3_ref() && {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubelValue_ref() const& {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubelValue_ref() const&& {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubelValue_ref() & {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubelValue_ref() && {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> boolValue_ref() const& {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> boolValue_ref() const&& {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> boolValue_ref() & {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> boolValue_ref() && {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_list_ref() const& {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_list_ref() const&& {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_list_ref() & {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_list_ref() && {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_set_ref() const& {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_set_ref() const&& {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_set_ref() & {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_set_ref() && {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_map_ref() const& {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_map_ref() const&& {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_map_ref() & {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_map_ref() && {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_union_map_ref() const& {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_union_map_ref() const&& {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_union_map_ref() & {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_union_map_ref() && {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_field_ref() const& {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_field_ref() const&& {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_field_ref() & {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_field_ref() && {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_container_ref() const& {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_container_ref() const&& {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_container_ref() & {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_container_ref() && {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_struct_ref() const& {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_struct_ref() const&& {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_struct_ref() & {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_struct_ref() && {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_set_struct_ref() const& {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_set_struct_ref() const&& {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_set_struct_ref() & {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_set_struct_ref() && {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_ref() const& {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_ref() const&& {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_ref() & {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_ref() && {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_a_union_ref() const& {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_a_union_ref() const&& {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_a_union_ref() & {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_a_union_ref() && {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_list_ref() const& {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_list_ref() const&& {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_list_ref() & {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_list_ref() && {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_ref() const& {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_ref() const&& {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_ref() & {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_ref() && {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_list_ref() const& {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_list_ref() & {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_list_ref() && {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField_ref() const& {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField_ref() const&& {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField_ref() & {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField_ref() && {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField2_ref() const& {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField2_ref() & {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField2_ref() && {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryListField4_ref() const& {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryListField4_ref() & {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryListField4_ref() && {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field_ref() const& {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field_ref() const&& {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field_ref() & {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field_ref() && {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field2_ref() const& {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field2_ref() const&& {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field2_ref() & {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field2_ref() && {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T =  ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> excp_field_ref() const& {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> excp_field_ref() const&& {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> excp_field_ref() & {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T =  ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> excp_field_ref() && {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  std::underlying_type_t<Type> type_;
  storage_type value_;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexUnion >;
  friend void swap(ComplexUnion& a, ComplexUnion& b);
};

template <class Protocol_>
uint32_t ComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = AnException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnException();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN


  explicit AnException(const std::string& __message) :
      message2(__message) {}

  explicit AnException(std::string&& __message) :
      message2(std::move(__message)) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, ::std::string message2__arg, ::std::string req_message__arg, ::std::vector<int32_t> exception_list__arg, ::std::set<int64_t> exception_set__arg, ::std::map<::std::string, int32_t> exception_map__arg, ::std::map<::std::string, int32_t> req_exception_map__arg,  ::some::valid::ns::MyEnumA enum_field__arg, ::std::vector< ::some::valid::ns::MyEnumA> enum_container__arg,  ::some::valid::ns::MyStruct a_struct__arg, ::std::set< ::some::valid::ns::MyStruct> a_set_struct__arg, ::std::vector< ::some::valid::ns::SimpleUnion> a_union_list__arg,  ::some::valid::ns::unionTypeDef union_typedef__arg, ::std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list__arg);

  AnException(AnException&&) = default;

  AnException(const AnException&) = default;


  AnException& operator=(AnException&&) = default;

  AnException& operator=(const AnException&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  ~AnException();

 public:
  int32_t code;
 public:
  int32_t req_code;
 public:
  ::std::string message2;
 public:
  ::std::string req_message;
 public:
  ::std::vector<int32_t> exception_list;
 public:
  ::std::set<int64_t> exception_set;
 public:
  ::std::map<::std::string, int32_t> exception_map;
 public:
  ::std::map<::std::string, int32_t> req_exception_map;
 public:
   ::some::valid::ns::MyEnumA enum_field;
 public:
  ::std::vector< ::some::valid::ns::MyEnumA> enum_container;
 public:
   ::some::valid::ns::MyStruct a_struct;
 public:
  ::std::set< ::some::valid::ns::MyStruct> a_set_struct;
 public:
  ::std::vector< ::some::valid::ns::SimpleUnion> a_union_list;
 public:
   ::some::valid::ns::unionTypeDef union_typedef;
 public:
  ::std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool message2;
    bool exception_list;
    bool exception_set;
    bool exception_map;
    bool enum_field;
    bool enum_container;
    bool a_struct;
    bool a_set_struct;
    bool a_union_list;
    bool union_typedef;
    bool a_union_typedef_list;
  } __isset = {};
  bool operator==(const AnException& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AnException& __x, const AnException& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AnException& rhs) const;
#ifndef SWIG
  friend bool operator>(const AnException& __x, const AnException& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AnException& __x, const AnException& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AnException& __x, const AnException& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_code)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message2_ref() const& {
    return {this->message2, __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message2_ref() const&& {
    return {std::move(this->message2), __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message2_ref() & {
    return {this->message2, __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message2_ref() && {
    return {std::move(this->message2), __isset.message2};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_message_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_message_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_message)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_message_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_message_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_message)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_list_ref() const& {
    return {this->exception_list, __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_list_ref() const&& {
    return {std::move(this->exception_list), __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_list_ref() & {
    return {this->exception_list, __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_list_ref() && {
    return {std::move(this->exception_list), __isset.exception_list};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_set_ref() const& {
    return {this->exception_set, __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_set_ref() const&& {
    return {std::move(this->exception_set), __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_set_ref() & {
    return {this->exception_set, __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_set_ref() && {
    return {std::move(this->exception_set), __isset.exception_set};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_map_ref() const& {
    return {this->exception_map, __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_map_ref() const&& {
    return {std::move(this->exception_map), __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_map_ref() & {
    return {this->exception_map, __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_map_ref() && {
    return {std::move(this->exception_map), __isset.exception_map};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE auto req_exception_map_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE auto req_exception_map_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_exception_map)};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE auto req_exception_map_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE auto req_exception_map_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_exception_map)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_field_ref() const& {
    return {this->enum_field, __isset.enum_field};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_field_ref() const&& {
    return {std::move(this->enum_field), __isset.enum_field};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_field_ref() & {
    return {this->enum_field, __isset.enum_field};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_field_ref() && {
    return {std::move(this->enum_field), __isset.enum_field};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_container_ref() const& {
    return {this->enum_container, __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_container_ref() const&& {
    return {std::move(this->enum_container), __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_container_ref() & {
    return {this->enum_container, __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_container_ref() && {
    return {std::move(this->enum_container), __isset.enum_container};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_struct_ref() const& {
    return {this->a_struct, __isset.a_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_struct_ref() const&& {
    return {std::move(this->a_struct), __isset.a_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_struct_ref() & {
    return {this->a_struct, __isset.a_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_struct_ref() && {
    return {std::move(this->a_struct), __isset.a_struct};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_set_struct_ref() const& {
    return {this->a_set_struct, __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_set_struct_ref() const&& {
    return {std::move(this->a_set_struct), __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_set_struct_ref() & {
    return {this->a_set_struct, __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_set_struct_ref() && {
    return {std::move(this->a_set_struct), __isset.a_set_struct};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_list_ref() const& {
    return {this->a_union_list, __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_list_ref() const&& {
    return {std::move(this->a_union_list), __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_list_ref() & {
    return {this->a_union_list, __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_list_ref() && {
    return {std::move(this->a_union_list), __isset.a_union_list};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> union_typedef_ref() const& {
    return {this->union_typedef, __isset.union_typedef};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> union_typedef_ref() const&& {
    return {std::move(this->union_typedef), __isset.union_typedef};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> union_typedef_ref() & {
    return {this->union_typedef, __isset.union_typedef};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> union_typedef_ref() && {
    return {std::move(this->union_typedef), __isset.union_typedef};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_typedef_list_ref() const& {
    return {this->a_union_typedef_list, __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {std::move(this->a_union_typedef_list), __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_typedef_list_ref() & {
    return {this->a_union_typedef_list, __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_typedef_list_ref() && {
    return {std::move(this->a_union_typedef_list), __isset.a_union_typedef_list};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int32_t get_code() const {
    return code;
  }

  int32_t& set_code(int32_t code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }

  int32_t get_req_code() const {
    return req_code;
  }

  int32_t& set_req_code(int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const ::std::string& get_message2() const& {
    return message2;
  }

  ::std::string get_message2() && {
    return std::move(message2);
  }

  template <typename T_AnException_message2_struct_setter = ::std::string>
  ::std::string& set_message2(T_AnException_message2_struct_setter&& message2_) {
    message2 = std::forward<T_AnException_message2_struct_setter>(message2_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.message2 = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return message2;
  }

  const ::std::string& get_req_message() const& {
    return req_message;
  }

  ::std::string get_req_message() && {
    return std::move(req_message);
  }

  template <typename T_AnException_req_message_struct_setter = ::std::string>
  ::std::string& set_req_message(T_AnException_req_message_struct_setter&& req_message_) {
    req_message = std::forward<T_AnException_req_message_struct_setter>(req_message_);
    return req_message;
  }
  const ::std::vector<int32_t>& get_exception_list() const&;
  ::std::vector<int32_t> get_exception_list() &&;

  template <typename T_AnException_exception_list_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_exception_list(T_AnException_exception_list_struct_setter&& exception_list_) {
    exception_list = std::forward<T_AnException_exception_list_struct_setter>(exception_list_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.exception_list = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return exception_list;
  }
  const ::std::set<int64_t>& get_exception_set() const&;
  ::std::set<int64_t> get_exception_set() &&;

  template <typename T_AnException_exception_set_struct_setter = ::std::set<int64_t>>
  ::std::set<int64_t>& set_exception_set(T_AnException_exception_set_struct_setter&& exception_set_) {
    exception_set = std::forward<T_AnException_exception_set_struct_setter>(exception_set_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.exception_set = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return exception_set;
  }
  const ::std::map<::std::string, int32_t>& get_exception_map() const&;
  ::std::map<::std::string, int32_t> get_exception_map() &&;

  template <typename T_AnException_exception_map_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_exception_map(T_AnException_exception_map_struct_setter&& exception_map_) {
    exception_map = std::forward<T_AnException_exception_map_struct_setter>(exception_map_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.exception_map = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return exception_map;
  }
  const ::std::map<::std::string, int32_t>& get_req_exception_map() const&;
  ::std::map<::std::string, int32_t> get_req_exception_map() &&;

  template <typename T_AnException_req_exception_map_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_req_exception_map(T_AnException_req_exception_map_struct_setter&& req_exception_map_) {
    req_exception_map = std::forward<T_AnException_req_exception_map_struct_setter>(req_exception_map_);
    return req_exception_map;
  }

   ::some::valid::ns::MyEnumA get_enum_field() const {
    return enum_field;
  }

   ::some::valid::ns::MyEnumA& set_enum_field( ::some::valid::ns::MyEnumA enum_field_) {
    enum_field = enum_field_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.enum_field = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return enum_field;
  }
  const ::std::vector< ::some::valid::ns::MyEnumA>& get_enum_container() const&;
  ::std::vector< ::some::valid::ns::MyEnumA> get_enum_container() &&;

  template <typename T_AnException_enum_container_struct_setter = ::std::vector< ::some::valid::ns::MyEnumA>>
  ::std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(T_AnException_enum_container_struct_setter&& enum_container_) {
    enum_container = std::forward<T_AnException_enum_container_struct_setter>(enum_container_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.enum_container = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return enum_container;
  }
  const  ::some::valid::ns::MyStruct& get_a_struct() const&;
   ::some::valid::ns::MyStruct get_a_struct() &&;

  template <typename T_AnException_a_struct_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_a_struct(T_AnException_a_struct_struct_setter&& a_struct_) {
    a_struct = std::forward<T_AnException_a_struct_struct_setter>(a_struct_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.a_struct = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return a_struct;
  }
  const ::std::set< ::some::valid::ns::MyStruct>& get_a_set_struct() const&;
  ::std::set< ::some::valid::ns::MyStruct> get_a_set_struct() &&;

  template <typename T_AnException_a_set_struct_struct_setter = ::std::set< ::some::valid::ns::MyStruct>>
  ::std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(T_AnException_a_set_struct_struct_setter&& a_set_struct_) {
    a_set_struct = std::forward<T_AnException_a_set_struct_struct_setter>(a_set_struct_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.a_set_struct = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return a_set_struct;
  }
  const ::std::vector< ::some::valid::ns::SimpleUnion>& get_a_union_list() const&;
  ::std::vector< ::some::valid::ns::SimpleUnion> get_a_union_list() &&;

  template <typename T_AnException_a_union_list_struct_setter = ::std::vector< ::some::valid::ns::SimpleUnion>>
  ::std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(T_AnException_a_union_list_struct_setter&& a_union_list_) {
    a_union_list = std::forward<T_AnException_a_union_list_struct_setter>(a_union_list_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.a_union_list = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return a_union_list;
  }
  const  ::some::valid::ns::unionTypeDef& get_union_typedef() const&;
   ::some::valid::ns::unionTypeDef get_union_typedef() &&;

  template <typename T_AnException_union_typedef_struct_setter =  ::some::valid::ns::unionTypeDef>
   ::some::valid::ns::unionTypeDef& set_union_typedef(T_AnException_union_typedef_struct_setter&& union_typedef_) {
    union_typedef = std::forward<T_AnException_union_typedef_struct_setter>(union_typedef_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.union_typedef = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return union_typedef;
  }
  const ::std::vector< ::some::valid::ns::unionTypeDef>& get_a_union_typedef_list() const&;
  ::std::vector< ::some::valid::ns::unionTypeDef> get_a_union_typedef_list() &&;

  template <typename T_AnException_a_union_typedef_list_struct_setter = ::std::vector< ::some::valid::ns::unionTypeDef>>
  ::std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T_AnException_a_union_typedef_list_struct_setter&& a_union_typedef_list_) {
    a_union_typedef_list = std::forward<T_AnException_a_union_typedef_list_struct_setter>(a_union_typedef_list_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.a_union_typedef_list = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return a_union_typedef_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return message2.c_str();
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnException >;
  friend void swap(AnException& a, AnException& b);
};

template <class Protocol_>
uint32_t AnException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnotherException : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = AnotherException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AnotherException() :
      code(0),
      req_code(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnotherException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, ::std::string message__arg);

  AnotherException(AnotherException&&) = default;

  AnotherException(const AnotherException&) = default;


  AnotherException& operator=(AnotherException&&) = default;

  AnotherException& operator=(const AnotherException&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();

  virtual ~AnotherException() {}

 public:
  int32_t code;
 public:
  int32_t req_code;
 public:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool message;
  } __isset = {};
  bool operator==(const AnotherException& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AnotherException& __x, const AnotherException& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AnotherException& rhs) const;
#ifndef SWIG
  friend bool operator>(const AnotherException& __x, const AnotherException& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AnotherException& __x, const AnotherException& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AnotherException& __x, const AnotherException& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_code};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE auto req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_code)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  int32_t get_code() const {
    return code;
  }

  int32_t& set_code(int32_t code_) {
    code = code_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.code = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return code;
  }

  int32_t get_req_code() const {
    return req_code;
  }

  int32_t& set_req_code(int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_AnotherException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_AnotherException_message_struct_setter&& message_) {
    message = std::forward<T_AnotherException_message_struct_setter>(message_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.message = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::some::valid::ns::AnotherException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnotherException >;
  friend void swap(AnotherException& a, AnotherException& b);
};

template <class Protocol_>
uint32_t AnotherException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class containerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = containerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  containerStruct();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  containerStruct(apache::thrift::FragileConstructor, bool fieldA__arg, bool req_fieldA__arg, bool opt_fieldA__arg, ::std::map<::std::string, bool> fieldB__arg, ::std::map<::std::string, bool> req_fieldB__arg, ::std::map<::std::string, bool> opt_fieldB__arg, ::std::set<int32_t> fieldC__arg, ::std::set<int32_t> req_fieldC__arg, ::std::set<int32_t> opt_fieldC__arg, ::std::string fieldD__arg, ::std::string fieldE__arg, ::std::string req_fieldE__arg, ::std::string opt_fieldE__arg, ::std::vector<::std::vector<int32_t>> fieldF__arg, ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>> fieldG__arg, ::std::vector<::std::set<int32_t>> fieldH__arg, bool fieldI__arg, ::std::map<::std::string, ::std::vector<int32_t>> fieldJ__arg, ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>> fieldK__arg, ::std::set<::std::set<::std::set<bool>>> fieldL__arg, ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM__arg,  ::some::valid::ns::simpleTypeDef fieldN__arg,  ::some::valid::ns::complexStructTypeDef fieldO__arg, ::std::vector< ::some::valid::ns::mostComplexTypeDef> fieldP__arg,  ::some::valid::ns::MyEnumA fieldQ__arg,  ::some::valid::ns::MyEnumA fieldR__arg,  ::some::valid::ns::MyEnumA req_fieldR__arg,  ::some::valid::ns::MyEnumA opt_fieldR__arg,  ::some::valid::ns::MyEnumA fieldS__arg, ::std::vector< ::some::valid::ns::MyEnumA> fieldT__arg, ::std::vector< ::some::valid::ns::MyEnumA> fieldU__arg,  ::some::valid::ns::MyStruct fieldV__arg,  ::some::valid::ns::MyStruct req_fieldV__arg,  ::some::valid::ns::MyStruct opt_fieldV__arg, ::std::set< ::some::valid::ns::MyStruct> fieldW__arg,  ::some::valid::ns::ComplexUnion fieldX__arg,  ::some::valid::ns::ComplexUnion req_fieldX__arg,  ::some::valid::ns::ComplexUnion opt_fieldX__arg, ::std::vector< ::some::valid::ns::ComplexUnion> fieldY__arg,  ::some::valid::ns::unionTypeDef fieldZ__arg, ::std::vector< ::some::valid::ns::unionTypeDef> fieldAA__arg, ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> fieldAB__arg,  ::some::valid::ns::MyEnumB fieldAC__arg,  ::a::different::ns::AnEnum fieldAD__arg, ::std::map<::std::string, int32_t> fieldAE__arg,  ::some::valid::ns::IndirectionD fieldSD__arg);

  containerStruct(containerStruct&&) = default;


  containerStruct& operator=(containerStruct&&) = default;
  void __clear();

  ~containerStruct();

 public:
  bool fieldA;
 public:
  bool req_fieldA;
 private:
  bool opt_fieldA;
 public:
  ::std::map<::std::string, bool> fieldB;
 public:
  ::std::map<::std::string, bool> req_fieldB;
 private:
  ::std::map<::std::string, bool> opt_fieldB;
 public:
  ::std::set<int32_t> fieldC;
 public:
  ::std::set<int32_t> req_fieldC;
 private:
  ::std::set<int32_t> opt_fieldC;
 public:
  ::std::string fieldD;
 public:
  ::std::string fieldE;
 public:
  ::std::string req_fieldE;
 private:
  ::std::string opt_fieldE;
 public:
  ::std::vector<::std::vector<int32_t>> fieldF;
 public:
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>> fieldG;
 public:
  ::std::vector<::std::set<int32_t>> fieldH;
 public:
  bool fieldI;
 public:
  ::std::map<::std::string, ::std::vector<int32_t>> fieldJ;
 public:
  ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>> fieldK;
 public:
  ::std::set<::std::set<::std::set<bool>>> fieldL;
 public:
  ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM;
 public:
   ::some::valid::ns::simpleTypeDef fieldN;
 public:
   ::some::valid::ns::complexStructTypeDef fieldO;
 public:
  ::std::vector< ::some::valid::ns::mostComplexTypeDef> fieldP;
 public:
   ::some::valid::ns::MyEnumA fieldQ;
 public:
   ::some::valid::ns::MyEnumA fieldR;
 public:
   ::some::valid::ns::MyEnumA req_fieldR;
 private:
   ::some::valid::ns::MyEnumA opt_fieldR;
 public:
   ::some::valid::ns::MyEnumA fieldS;
 public:
  ::std::vector< ::some::valid::ns::MyEnumA> fieldT;
 public:
  ::std::vector< ::some::valid::ns::MyEnumA> fieldU;
 public:
   ::some::valid::ns::MyStruct fieldV;
 public:
   ::some::valid::ns::MyStruct req_fieldV;
 private:
   ::some::valid::ns::MyStruct opt_fieldV;
 public:
  ::std::set< ::some::valid::ns::MyStruct> fieldW;
 public:
   ::some::valid::ns::ComplexUnion fieldX;
 public:
   ::some::valid::ns::ComplexUnion req_fieldX;
 private:
   ::some::valid::ns::ComplexUnion opt_fieldX;
 public:
  ::std::vector< ::some::valid::ns::ComplexUnion> fieldY;
 public:
   ::some::valid::ns::unionTypeDef fieldZ;
 public:
  ::std::vector< ::some::valid::ns::unionTypeDef> fieldAA;
 public:
  ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> fieldAB;
 public:
   ::some::valid::ns::MyEnumB fieldAC;
 public:
   ::a::different::ns::AnEnum fieldAD;
 public:
  ::std::map<::std::string, int32_t> fieldAE;
 public:
   ::some::valid::ns::IndirectionD fieldSD;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool fieldA;
    bool opt_fieldA;
    bool fieldB;
    bool opt_fieldB;
    bool fieldC;
    bool opt_fieldC;
    bool fieldD;
    bool fieldE;
    bool opt_fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
    bool opt_fieldR;
    bool fieldS;
    bool fieldT;
    bool fieldU;
    bool fieldV;
    bool opt_fieldV;
    bool fieldW;
    bool fieldX;
    bool opt_fieldX;
    bool fieldY;
    bool fieldZ;
    bool fieldAA;
    bool fieldAB;
    bool fieldAC;
    bool fieldAD;
    bool fieldAE;
    bool fieldSD;
  } __isset = {};
  bool operator==(const containerStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const containerStruct& __x, const containerStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const containerStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const containerStruct& __x, const containerStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const containerStruct& __x, const containerStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const containerStruct& __x, const containerStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldA_ref() const& {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldA_ref() const&& {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldA_ref() & {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldA_ref() && {
    return {std::move(this->fieldA), __isset.fieldA};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = bool>
  FOLLY_ERASE auto req_fieldA_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE auto req_fieldA_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldA)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE auto req_fieldA_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE auto req_fieldA_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldA)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldA_ref() const& {
    return {this->opt_fieldA, __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldA_ref() const&& {
    return {std::move(this->opt_fieldA), __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldA_ref() & {
    return {this->opt_fieldA, __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldA_ref() && {
    return {std::move(this->opt_fieldA), __isset.opt_fieldA};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldB_ref() const& {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldB_ref() const&& {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldB_ref() & {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldB_ref() && {
    return {std::move(this->fieldB), __isset.fieldB};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE auto req_fieldB_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE auto req_fieldB_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldB)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE auto req_fieldB_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE auto req_fieldB_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldB)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldB_ref() const& {
    return {this->opt_fieldB, __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldB_ref() const&& {
    return {std::move(this->opt_fieldB), __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldB_ref() & {
    return {this->opt_fieldB, __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldB_ref() && {
    return {std::move(this->opt_fieldB), __isset.opt_fieldB};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldC_ref() const& {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldC_ref() const&& {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldC_ref() & {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldC_ref() && {
    return {std::move(this->fieldC), __isset.fieldC};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE auto req_fieldC_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE auto req_fieldC_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldC)};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE auto req_fieldC_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE auto req_fieldC_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldC)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldC_ref() const& {
    return {this->opt_fieldC, __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldC_ref() const&& {
    return {std::move(this->opt_fieldC), __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldC_ref() & {
    return {this->opt_fieldC, __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldC_ref() && {
    return {std::move(this->opt_fieldC), __isset.opt_fieldC};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldD_ref() const& {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldD_ref() const&& {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldD_ref() & {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldD_ref() && {
    return {std::move(this->fieldD), __isset.fieldD};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldE_ref() const& {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldE_ref() const&& {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldE_ref() & {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldE_ref() && {
    return {std::move(this->fieldE), __isset.fieldE};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_fieldE_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_fieldE_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldE)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_fieldE_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE auto req_fieldE_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldE)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldE_ref() const& {
    return {this->opt_fieldE, __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldE_ref() const&& {
    return {std::move(this->opt_fieldE), __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldE_ref() & {
    return {this->opt_fieldE, __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldE_ref() && {
    return {std::move(this->opt_fieldE), __isset.opt_fieldE};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldF_ref() const& {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldF_ref() const&& {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldF_ref() & {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldF_ref() && {
    return {std::move(this->fieldF), __isset.fieldF};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldG_ref() const& {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldG_ref() const&& {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldG_ref() & {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldG_ref() && {
    return {std::move(this->fieldG), __isset.fieldG};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::set<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldH_ref() const& {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldH_ref() const&& {
    return {std::move(this->fieldH), __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldH_ref() & {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldH_ref() && {
    return {std::move(this->fieldH), __isset.fieldH};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldI_ref() const& {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldI_ref() const&& {
    return {std::move(this->fieldI), __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldI_ref() & {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldI_ref() && {
    return {std::move(this->fieldI), __isset.fieldI};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, ::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldJ_ref() const& {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldJ_ref() const&& {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldJ_ref() & {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldJ_ref() && {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldK_ref() const& {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldK_ref() const&& {
    return {std::move(this->fieldK), __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldK_ref() & {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldK_ref() && {
    return {std::move(this->fieldK), __isset.fieldK};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldL_ref() const& {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldL_ref() const&& {
    return {std::move(this->fieldL), __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldL_ref() & {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldL_ref() && {
    return {std::move(this->fieldL), __isset.fieldL};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldM_ref() const& {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldM_ref() const&& {
    return {std::move(this->fieldM), __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldM_ref() & {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldM_ref() && {
    return {std::move(this->fieldM), __isset.fieldM};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldN_ref() const& {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T =  ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldN_ref() const&& {
    return {std::move(this->fieldN), __isset.fieldN};
  }

  template <typename..., typename T =  ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldN_ref() & {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T =  ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldN_ref() && {
    return {std::move(this->fieldN), __isset.fieldN};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldO_ref() const& {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T =  ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldO_ref() const&& {
    return {std::move(this->fieldO), __isset.fieldO};
  }

  template <typename..., typename T =  ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldO_ref() & {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T =  ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldO_ref() && {
    return {std::move(this->fieldO), __isset.fieldO};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldP_ref() const& {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldP_ref() const&& {
    return {std::move(this->fieldP), __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldP_ref() & {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldP_ref() && {
    return {std::move(this->fieldP), __isset.fieldP};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldQ_ref() const& {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldQ_ref() const&& {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldQ_ref() & {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldQ_ref() && {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldR_ref() const& {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldR_ref() const&& {
    return {std::move(this->fieldR), __isset.fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldR_ref() & {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldR_ref() && {
    return {std::move(this->fieldR), __isset.fieldR};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE auto req_fieldR_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE auto req_fieldR_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldR)};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE auto req_fieldR_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE auto req_fieldR_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldR)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldR_ref() const& {
    return {this->opt_fieldR, __isset.opt_fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldR_ref() const&& {
    return {std::move(this->opt_fieldR), __isset.opt_fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldR_ref() & {
    return {this->opt_fieldR, __isset.opt_fieldR};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldR_ref() && {
    return {std::move(this->opt_fieldR), __isset.opt_fieldR};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldS_ref() const& {
    return {this->fieldS, __isset.fieldS};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldS_ref() const&& {
    return {std::move(this->fieldS), __isset.fieldS};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldS_ref() & {
    return {this->fieldS, __isset.fieldS};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldS_ref() && {
    return {std::move(this->fieldS), __isset.fieldS};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldT_ref() const& {
    return {this->fieldT, __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldT_ref() const&& {
    return {std::move(this->fieldT), __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldT_ref() & {
    return {this->fieldT, __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldT_ref() && {
    return {std::move(this->fieldT), __isset.fieldT};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldU_ref() const& {
    return {this->fieldU, __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldU_ref() const&& {
    return {std::move(this->fieldU), __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldU_ref() & {
    return {this->fieldU, __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldU_ref() && {
    return {std::move(this->fieldU), __isset.fieldU};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldV_ref() const& {
    return {this->fieldV, __isset.fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldV_ref() const&& {
    return {std::move(this->fieldV), __isset.fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldV_ref() & {
    return {this->fieldV, __isset.fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldV_ref() && {
    return {std::move(this->fieldV), __isset.fieldV};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE auto req_fieldV_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE auto req_fieldV_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldV)};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE auto req_fieldV_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE auto req_fieldV_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldV)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldV_ref() const& {
    return {this->opt_fieldV, __isset.opt_fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldV_ref() const&& {
    return {std::move(this->opt_fieldV), __isset.opt_fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldV_ref() & {
    return {this->opt_fieldV, __isset.opt_fieldV};
  }

  template <typename..., typename T =  ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldV_ref() && {
    return {std::move(this->opt_fieldV), __isset.opt_fieldV};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldW_ref() const& {
    return {this->fieldW, __isset.fieldW};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldW_ref() const&& {
    return {std::move(this->fieldW), __isset.fieldW};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldW_ref() & {
    return {this->fieldW, __isset.fieldW};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldW_ref() && {
    return {std::move(this->fieldW), __isset.fieldW};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldX_ref() const& {
    return {this->fieldX, __isset.fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldX_ref() const&& {
    return {std::move(this->fieldX), __isset.fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldX_ref() & {
    return {this->fieldX, __isset.fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldX_ref() && {
    return {std::move(this->fieldX), __isset.fieldX};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE auto req_fieldX_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE auto req_fieldX_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldX)};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE auto req_fieldX_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE auto req_fieldX_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldX)};
  }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldX_ref() const& {
    return {this->opt_fieldX, __isset.opt_fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldX_ref() const&& {
    return {std::move(this->opt_fieldX), __isset.opt_fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldX_ref() & {
    return {this->opt_fieldX, __isset.opt_fieldX};
  }

  template <typename..., typename T =  ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldX_ref() && {
    return {std::move(this->opt_fieldX), __isset.opt_fieldX};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldY_ref() const& {
    return {this->fieldY, __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldY_ref() const&& {
    return {std::move(this->fieldY), __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldY_ref() & {
    return {this->fieldY, __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldY_ref() && {
    return {std::move(this->fieldY), __isset.fieldY};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldZ_ref() const& {
    return {this->fieldZ, __isset.fieldZ};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldZ_ref() const&& {
    return {std::move(this->fieldZ), __isset.fieldZ};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldZ_ref() & {
    return {this->fieldZ, __isset.fieldZ};
  }

  template <typename..., typename T =  ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldZ_ref() && {
    return {std::move(this->fieldZ), __isset.fieldZ};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAA_ref() const& {
    return {this->fieldAA, __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAA_ref() const&& {
    return {std::move(this->fieldAA), __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAA_ref() & {
    return {this->fieldAA, __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAA_ref() && {
    return {std::move(this->fieldAA), __isset.fieldAA};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAB_ref() const& {
    return {this->fieldAB, __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAB_ref() const&& {
    return {std::move(this->fieldAB), __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAB_ref() & {
    return {this->fieldAB, __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAB_ref() && {
    return {std::move(this->fieldAB), __isset.fieldAB};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAC_ref() const& {
    return {this->fieldAC, __isset.fieldAC};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAC_ref() const&& {
    return {std::move(this->fieldAC), __isset.fieldAC};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAC_ref() & {
    return {this->fieldAC, __isset.fieldAC};
  }

  template <typename..., typename T =  ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAC_ref() && {
    return {std::move(this->fieldAC), __isset.fieldAC};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAD_ref() const& {
    return {this->fieldAD, __isset.fieldAD};
  }

  template <typename..., typename T =  ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAD_ref() const&& {
    return {std::move(this->fieldAD), __isset.fieldAD};
  }

  template <typename..., typename T =  ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAD_ref() & {
    return {this->fieldAD, __isset.fieldAD};
  }

  template <typename..., typename T =  ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAD_ref() && {
    return {std::move(this->fieldAD), __isset.fieldAD};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAE_ref() const& {
    return {this->fieldAE, __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAE_ref() const&& {
    return {std::move(this->fieldAE), __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAE_ref() & {
    return {this->fieldAE, __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAE_ref() && {
    return {std::move(this->fieldAE), __isset.fieldAE};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldSD_ref() const& {
    return {this->fieldSD, __isset.fieldSD};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldSD_ref() const&& {
    return {std::move(this->fieldSD), __isset.fieldSD};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldSD_ref() & {
    return {this->fieldSD, __isset.fieldSD};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldSD_ref() && {
    return {std::move(this->fieldSD), __isset.fieldSD};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  bool get_fieldA() const {
    return fieldA;
  }

  bool& set_fieldA(bool fieldA_) {
    fieldA = fieldA_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldA = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldA;
  }

  bool get_req_fieldA() const {
    return req_fieldA;
  }

  bool& set_req_fieldA(bool req_fieldA_) {
    req_fieldA = req_fieldA_;
    return req_fieldA;
  }

  const bool* get_opt_fieldA() const& {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }

  bool* get_opt_fieldA() & {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }
  bool* get_opt_fieldA() && = delete;

  bool& set_opt_fieldA(bool opt_fieldA_) {
    opt_fieldA = opt_fieldA_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldA = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldA;
  }
  const ::std::map<::std::string, bool>& get_fieldB() const&;
  ::std::map<::std::string, bool> get_fieldB() &&;

  template <typename T_containerStruct_fieldB_struct_setter = ::std::map<::std::string, bool>>
  ::std::map<::std::string, bool>& set_fieldB(T_containerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_containerStruct_fieldB_struct_setter>(fieldB_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldB = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldB;
  }
  const ::std::map<::std::string, bool>& get_req_fieldB() const&;
  ::std::map<::std::string, bool> get_req_fieldB() &&;

  template <typename T_containerStruct_req_fieldB_struct_setter = ::std::map<::std::string, bool>>
  ::std::map<::std::string, bool>& set_req_fieldB(T_containerStruct_req_fieldB_struct_setter&& req_fieldB_) {
    req_fieldB = std::forward<T_containerStruct_req_fieldB_struct_setter>(req_fieldB_);
    return req_fieldB;
  }
  const ::std::map<::std::string, bool>* get_opt_fieldB() const&;
  ::std::map<::std::string, bool>* get_opt_fieldB() &;
  ::std::map<::std::string, bool>* get_opt_fieldB() && = delete;

  template <typename T_containerStruct_opt_fieldB_struct_setter = ::std::map<::std::string, bool>>
  ::std::map<::std::string, bool>& set_opt_fieldB(T_containerStruct_opt_fieldB_struct_setter&& opt_fieldB_) {
    opt_fieldB = std::forward<T_containerStruct_opt_fieldB_struct_setter>(opt_fieldB_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldB = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldB;
  }
  const ::std::set<int32_t>& get_fieldC() const&;
  ::std::set<int32_t> get_fieldC() &&;

  template <typename T_containerStruct_fieldC_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_fieldC(T_containerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC = std::forward<T_containerStruct_fieldC_struct_setter>(fieldC_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldC = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldC;
  }
  const ::std::set<int32_t>& get_req_fieldC() const&;
  ::std::set<int32_t> get_req_fieldC() &&;

  template <typename T_containerStruct_req_fieldC_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_req_fieldC(T_containerStruct_req_fieldC_struct_setter&& req_fieldC_) {
    req_fieldC = std::forward<T_containerStruct_req_fieldC_struct_setter>(req_fieldC_);
    return req_fieldC;
  }
  const ::std::set<int32_t>* get_opt_fieldC() const&;
  ::std::set<int32_t>* get_opt_fieldC() &;
  ::std::set<int32_t>* get_opt_fieldC() && = delete;

  template <typename T_containerStruct_opt_fieldC_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_opt_fieldC(T_containerStruct_opt_fieldC_struct_setter&& opt_fieldC_) {
    opt_fieldC = std::forward<T_containerStruct_opt_fieldC_struct_setter>(opt_fieldC_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldC = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldC;
  }

  const ::std::string& get_fieldD() const& {
    return fieldD;
  }

  ::std::string get_fieldD() && {
    return std::move(fieldD);
  }

  template <typename T_containerStruct_fieldD_struct_setter = ::std::string>
  ::std::string& set_fieldD(T_containerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD = std::forward<T_containerStruct_fieldD_struct_setter>(fieldD_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldD = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldD;
  }

  const ::std::string& get_fieldE() const& {
    return fieldE;
  }

  ::std::string get_fieldE() && {
    return std::move(fieldE);
  }

  template <typename T_containerStruct_fieldE_struct_setter = ::std::string>
  ::std::string& set_fieldE(T_containerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_containerStruct_fieldE_struct_setter>(fieldE_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldE = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldE;
  }

  const ::std::string& get_req_fieldE() const& {
    return req_fieldE;
  }

  ::std::string get_req_fieldE() && {
    return std::move(req_fieldE);
  }

  template <typename T_containerStruct_req_fieldE_struct_setter = ::std::string>
  ::std::string& set_req_fieldE(T_containerStruct_req_fieldE_struct_setter&& req_fieldE_) {
    req_fieldE = std::forward<T_containerStruct_req_fieldE_struct_setter>(req_fieldE_);
    return req_fieldE;
  }

  const ::std::string* get_opt_fieldE() const& {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }

  ::std::string* get_opt_fieldE() & {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }
  ::std::string* get_opt_fieldE() && = delete;

  template <typename T_containerStruct_opt_fieldE_struct_setter = ::std::string>
  ::std::string& set_opt_fieldE(T_containerStruct_opt_fieldE_struct_setter&& opt_fieldE_) {
    opt_fieldE = std::forward<T_containerStruct_opt_fieldE_struct_setter>(opt_fieldE_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldE = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldE;
  }
  const ::std::vector<::std::vector<int32_t>>& get_fieldF() const&;
  ::std::vector<::std::vector<int32_t>> get_fieldF() &&;

  template <typename T_containerStruct_fieldF_struct_setter = ::std::vector<::std::vector<int32_t>>>
  ::std::vector<::std::vector<int32_t>>& set_fieldF(T_containerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_containerStruct_fieldF_struct_setter>(fieldF_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldF = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldF;
  }
  const ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>& get_fieldG() const&;
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>> get_fieldG() &&;

  template <typename T_containerStruct_fieldG_struct_setter = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>>
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, int32_t>>>& set_fieldG(T_containerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_containerStruct_fieldG_struct_setter>(fieldG_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldG = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldG;
  }
  const ::std::vector<::std::set<int32_t>>& get_fieldH() const&;
  ::std::vector<::std::set<int32_t>> get_fieldH() &&;

  template <typename T_containerStruct_fieldH_struct_setter = ::std::vector<::std::set<int32_t>>>
  ::std::vector<::std::set<int32_t>>& set_fieldH(T_containerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_containerStruct_fieldH_struct_setter>(fieldH_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldH = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldH;
  }

  bool get_fieldI() const {
    return fieldI;
  }

  bool& set_fieldI(bool fieldI_) {
    fieldI = fieldI_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldI = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldI;
  }
  const ::std::map<::std::string, ::std::vector<int32_t>>& get_fieldJ() const&;
  ::std::map<::std::string, ::std::vector<int32_t>> get_fieldJ() &&;

  template <typename T_containerStruct_fieldJ_struct_setter = ::std::map<::std::string, ::std::vector<int32_t>>>
  ::std::map<::std::string, ::std::vector<int32_t>>& set_fieldJ(T_containerStruct_fieldJ_struct_setter&& fieldJ_) {
    fieldJ = std::forward<T_containerStruct_fieldJ_struct_setter>(fieldJ_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldJ = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldJ;
  }
  const ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>& get_fieldK() const&;
  ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>> get_fieldK() &&;

  template <typename T_containerStruct_fieldK_struct_setter = ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>>
  ::std::vector<::std::vector<::std::vector<::std::vector<int32_t>>>>& set_fieldK(T_containerStruct_fieldK_struct_setter&& fieldK_) {
    fieldK = std::forward<T_containerStruct_fieldK_struct_setter>(fieldK_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldK = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldK;
  }
  const ::std::set<::std::set<::std::set<bool>>>& get_fieldL() const&;
  ::std::set<::std::set<::std::set<bool>>> get_fieldL() &&;

  template <typename T_containerStruct_fieldL_struct_setter = ::std::set<::std::set<::std::set<bool>>>>
  ::std::set<::std::set<::std::set<bool>>>& set_fieldL(T_containerStruct_fieldL_struct_setter&& fieldL_) {
    fieldL = std::forward<T_containerStruct_fieldL_struct_setter>(fieldL_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldL = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldL;
  }
  const ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& get_fieldM() const&;
  ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> get_fieldM() &&;

  template <typename T_containerStruct_fieldM_struct_setter = ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  ::std::map<::std::set<::std::vector<int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& set_fieldM(T_containerStruct_fieldM_struct_setter&& fieldM_) {
    fieldM = std::forward<T_containerStruct_fieldM_struct_setter>(fieldM_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldM = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldM;
  }

   ::some::valid::ns::simpleTypeDef get_fieldN() const {
    return fieldN;
  }

   ::some::valid::ns::simpleTypeDef& set_fieldN( ::some::valid::ns::simpleTypeDef fieldN_) {
    fieldN = fieldN_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldN = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldN;
  }
  const  ::some::valid::ns::complexStructTypeDef& get_fieldO() const&;
   ::some::valid::ns::complexStructTypeDef get_fieldO() &&;

  template <typename T_containerStruct_fieldO_struct_setter =  ::some::valid::ns::complexStructTypeDef>
   ::some::valid::ns::complexStructTypeDef& set_fieldO(T_containerStruct_fieldO_struct_setter&& fieldO_) {
    fieldO = std::forward<T_containerStruct_fieldO_struct_setter>(fieldO_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldO = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldO;
  }
  const ::std::vector< ::some::valid::ns::mostComplexTypeDef>& get_fieldP() const&;
  ::std::vector< ::some::valid::ns::mostComplexTypeDef> get_fieldP() &&;

  template <typename T_containerStruct_fieldP_struct_setter = ::std::vector< ::some::valid::ns::mostComplexTypeDef>>
  ::std::vector< ::some::valid::ns::mostComplexTypeDef>& set_fieldP(T_containerStruct_fieldP_struct_setter&& fieldP_) {
    fieldP = std::forward<T_containerStruct_fieldP_struct_setter>(fieldP_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldP = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldP;
  }

   ::some::valid::ns::MyEnumA get_fieldQ() const {
    return fieldQ;
  }

   ::some::valid::ns::MyEnumA& set_fieldQ( ::some::valid::ns::MyEnumA fieldQ_) {
    fieldQ = fieldQ_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldQ = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldQ;
  }

   ::some::valid::ns::MyEnumA get_fieldR() const {
    return fieldR;
  }

   ::some::valid::ns::MyEnumA& set_fieldR( ::some::valid::ns::MyEnumA fieldR_) {
    fieldR = fieldR_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldR = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldR;
  }

   ::some::valid::ns::MyEnumA get_req_fieldR() const {
    return req_fieldR;
  }

   ::some::valid::ns::MyEnumA& set_req_fieldR( ::some::valid::ns::MyEnumA req_fieldR_) {
    req_fieldR = req_fieldR_;
    return req_fieldR;
  }

  const  ::some::valid::ns::MyEnumA* get_opt_fieldR() const& {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }

   ::some::valid::ns::MyEnumA* get_opt_fieldR() & {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }
   ::some::valid::ns::MyEnumA* get_opt_fieldR() && = delete;

   ::some::valid::ns::MyEnumA& set_opt_fieldR( ::some::valid::ns::MyEnumA opt_fieldR_) {
    opt_fieldR = opt_fieldR_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldR = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldR;
  }

   ::some::valid::ns::MyEnumA get_fieldS() const {
    return fieldS;
  }

   ::some::valid::ns::MyEnumA& set_fieldS( ::some::valid::ns::MyEnumA fieldS_) {
    fieldS = fieldS_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldS = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldS;
  }
  const ::std::vector< ::some::valid::ns::MyEnumA>& get_fieldT() const&;
  ::std::vector< ::some::valid::ns::MyEnumA> get_fieldT() &&;

  template <typename T_containerStruct_fieldT_struct_setter = ::std::vector< ::some::valid::ns::MyEnumA>>
  ::std::vector< ::some::valid::ns::MyEnumA>& set_fieldT(T_containerStruct_fieldT_struct_setter&& fieldT_) {
    fieldT = std::forward<T_containerStruct_fieldT_struct_setter>(fieldT_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldT = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldT;
  }
  const ::std::vector< ::some::valid::ns::MyEnumA>& get_fieldU() const&;
  ::std::vector< ::some::valid::ns::MyEnumA> get_fieldU() &&;

  template <typename T_containerStruct_fieldU_struct_setter = ::std::vector< ::some::valid::ns::MyEnumA>>
  ::std::vector< ::some::valid::ns::MyEnumA>& set_fieldU(T_containerStruct_fieldU_struct_setter&& fieldU_) {
    fieldU = std::forward<T_containerStruct_fieldU_struct_setter>(fieldU_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldU = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldU;
  }
  const  ::some::valid::ns::MyStruct& get_fieldV() const&;
   ::some::valid::ns::MyStruct get_fieldV() &&;

  template <typename T_containerStruct_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_fieldV(T_containerStruct_fieldV_struct_setter&& fieldV_) {
    fieldV = std::forward<T_containerStruct_fieldV_struct_setter>(fieldV_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldV = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldV;
  }
  const  ::some::valid::ns::MyStruct& get_req_fieldV() const&;
   ::some::valid::ns::MyStruct get_req_fieldV() &&;

  template <typename T_containerStruct_req_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_req_fieldV(T_containerStruct_req_fieldV_struct_setter&& req_fieldV_) {
    req_fieldV = std::forward<T_containerStruct_req_fieldV_struct_setter>(req_fieldV_);
    return req_fieldV;
  }
  const  ::some::valid::ns::MyStruct* get_opt_fieldV() const&;
   ::some::valid::ns::MyStruct* get_opt_fieldV() &;
   ::some::valid::ns::MyStruct* get_opt_fieldV() && = delete;

  template <typename T_containerStruct_opt_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_opt_fieldV(T_containerStruct_opt_fieldV_struct_setter&& opt_fieldV_) {
    opt_fieldV = std::forward<T_containerStruct_opt_fieldV_struct_setter>(opt_fieldV_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldV = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldV;
  }
  const ::std::set< ::some::valid::ns::MyStruct>& get_fieldW() const&;
  ::std::set< ::some::valid::ns::MyStruct> get_fieldW() &&;

  template <typename T_containerStruct_fieldW_struct_setter = ::std::set< ::some::valid::ns::MyStruct>>
  ::std::set< ::some::valid::ns::MyStruct>& set_fieldW(T_containerStruct_fieldW_struct_setter&& fieldW_) {
    fieldW = std::forward<T_containerStruct_fieldW_struct_setter>(fieldW_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldW = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldW;
  }
  const  ::some::valid::ns::ComplexUnion& get_fieldX() const&;
   ::some::valid::ns::ComplexUnion get_fieldX() &&;

  template <typename T_containerStruct_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_fieldX(T_containerStruct_fieldX_struct_setter&& fieldX_) {
    fieldX = std::forward<T_containerStruct_fieldX_struct_setter>(fieldX_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldX = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldX;
  }
  const  ::some::valid::ns::ComplexUnion& get_req_fieldX() const&;
   ::some::valid::ns::ComplexUnion get_req_fieldX() &&;

  template <typename T_containerStruct_req_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_req_fieldX(T_containerStruct_req_fieldX_struct_setter&& req_fieldX_) {
    req_fieldX = std::forward<T_containerStruct_req_fieldX_struct_setter>(req_fieldX_);
    return req_fieldX;
  }
  const  ::some::valid::ns::ComplexUnion* get_opt_fieldX() const&;
   ::some::valid::ns::ComplexUnion* get_opt_fieldX() &;
   ::some::valid::ns::ComplexUnion* get_opt_fieldX() && = delete;

  template <typename T_containerStruct_opt_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_opt_fieldX(T_containerStruct_opt_fieldX_struct_setter&& opt_fieldX_) {
    opt_fieldX = std::forward<T_containerStruct_opt_fieldX_struct_setter>(opt_fieldX_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.opt_fieldX = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return opt_fieldX;
  }
  const ::std::vector< ::some::valid::ns::ComplexUnion>& get_fieldY() const&;
  ::std::vector< ::some::valid::ns::ComplexUnion> get_fieldY() &&;

  template <typename T_containerStruct_fieldY_struct_setter = ::std::vector< ::some::valid::ns::ComplexUnion>>
  ::std::vector< ::some::valid::ns::ComplexUnion>& set_fieldY(T_containerStruct_fieldY_struct_setter&& fieldY_) {
    fieldY = std::forward<T_containerStruct_fieldY_struct_setter>(fieldY_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldY = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldY;
  }
  const  ::some::valid::ns::unionTypeDef& get_fieldZ() const&;
   ::some::valid::ns::unionTypeDef get_fieldZ() &&;

  template <typename T_containerStruct_fieldZ_struct_setter =  ::some::valid::ns::unionTypeDef>
   ::some::valid::ns::unionTypeDef& set_fieldZ(T_containerStruct_fieldZ_struct_setter&& fieldZ_) {
    fieldZ = std::forward<T_containerStruct_fieldZ_struct_setter>(fieldZ_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldZ = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldZ;
  }
  const ::std::vector< ::some::valid::ns::unionTypeDef>& get_fieldAA() const&;
  ::std::vector< ::some::valid::ns::unionTypeDef> get_fieldAA() &&;

  template <typename T_containerStruct_fieldAA_struct_setter = ::std::vector< ::some::valid::ns::unionTypeDef>>
  ::std::vector< ::some::valid::ns::unionTypeDef>& set_fieldAA(T_containerStruct_fieldAA_struct_setter&& fieldAA_) {
    fieldAA = std::forward<T_containerStruct_fieldAA_struct_setter>(fieldAA_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldAA = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldAA;
  }
  const ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>& get_fieldAB() const&;
  ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> get_fieldAB() &&;

  template <typename T_containerStruct_fieldAB_struct_setter = ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  ::std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>& set_fieldAB(T_containerStruct_fieldAB_struct_setter&& fieldAB_) {
    fieldAB = std::forward<T_containerStruct_fieldAB_struct_setter>(fieldAB_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldAB = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldAB;
  }

   ::some::valid::ns::MyEnumB get_fieldAC() const {
    return fieldAC;
  }

   ::some::valid::ns::MyEnumB& set_fieldAC( ::some::valid::ns::MyEnumB fieldAC_) {
    fieldAC = fieldAC_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldAC = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldAC;
  }

   ::a::different::ns::AnEnum get_fieldAD() const {
    return fieldAD;
  }

   ::a::different::ns::AnEnum& set_fieldAD( ::a::different::ns::AnEnum fieldAD_) {
    fieldAD = fieldAD_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldAD = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldAD;
  }
  const ::std::map<::std::string, int32_t>& get_fieldAE() const&;
  ::std::map<::std::string, int32_t> get_fieldAE() &&;

  template <typename T_containerStruct_fieldAE_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_fieldAE(T_containerStruct_fieldAE_struct_setter&& fieldAE_) {
    fieldAE = std::forward<T_containerStruct_fieldAE_struct_setter>(fieldAE_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldAE = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldAE;
  }

  const  ::some::valid::ns::IndirectionD& get_fieldSD() const& {
    return fieldSD;
  }

   ::some::valid::ns::IndirectionD get_fieldSD() && {
    return std::move(fieldSD);
  }

  template <typename T_containerStruct_fieldSD_struct_setter =  ::some::valid::ns::IndirectionD>
   ::some::valid::ns::IndirectionD& set_fieldSD(T_containerStruct_fieldSD_struct_setter&& fieldSD_) {
    fieldSD = std::forward<T_containerStruct_fieldSD_struct_setter>(fieldSD_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.fieldSD = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return fieldSD;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< containerStruct >;
  friend void swap(containerStruct& a, containerStruct& b);
};

template <class Protocol_>
uint32_t containerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class MyIncludedStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = MyIncludedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  MyIncludedStruct() :
      MyIncludedInt(42LL),
      ARefField(std::make_unique< ::some::valid::ns::AStruct>()) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyIncludedStruct(apache::thrift::FragileConstructor,  ::a::different::ns::IncludedInt64 MyIncludedInt__arg,  ::some::valid::ns::AStruct MyIncludedStruct__arg, std::unique_ptr< ::some::valid::ns::AStruct> ARefField__arg,  ::some::valid::ns::AStruct ARequiredField__arg);

  MyIncludedStruct(MyIncludedStruct&&) = default;
  MyIncludedStruct(const MyIncludedStruct& src);


  MyIncludedStruct& operator=(MyIncludedStruct&&) = default;
  MyIncludedStruct& operator=(const MyIncludedStruct& src);
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
   ::a::different::ns::IncludedInt64 MyIncludedInt;
 public:
   ::some::valid::ns::AStruct MyIncludedStruct;
 public:
  std::unique_ptr< ::some::valid::ns::AStruct> ARefField;
 public:
   ::some::valid::ns::AStruct ARequiredField;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool MyIncludedInt;
    bool MyIncludedStruct;
  } __isset = {};
  bool operator==(const MyIncludedStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const MyIncludedStruct& __x, const MyIncludedStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const MyIncludedStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const MyIncludedStruct& __x, const MyIncludedStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const MyIncludedStruct& __x, const MyIncludedStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const MyIncludedStruct& __x, const MyIncludedStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedInt_ref() const& {
    return {this->MyIncludedInt, __isset.MyIncludedInt};
  }

  template <typename..., typename T =  ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedInt_ref() const&& {
    return {std::move(this->MyIncludedInt), __isset.MyIncludedInt};
  }

  template <typename..., typename T =  ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedInt_ref() & {
    return {this->MyIncludedInt, __isset.MyIncludedInt};
  }

  template <typename..., typename T =  ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedInt_ref() && {
    return {std::move(this->MyIncludedInt), __isset.MyIncludedInt};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedStruct_ref() const& {
    return {this->MyIncludedStruct, __isset.MyIncludedStruct};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedStruct_ref() const&& {
    return {std::move(this->MyIncludedStruct), __isset.MyIncludedStruct};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedStruct_ref() & {
    return {this->MyIncludedStruct, __isset.MyIncludedStruct};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedStruct_ref() && {
    return {std::move(this->MyIncludedStruct), __isset.MyIncludedStruct};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::AStruct>>
  FOLLY_ERASE T& ARefField_ref() & { return ARefField; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::AStruct>>
  FOLLY_ERASE const T& ARefField_ref() const& { return ARefField; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::AStruct>>
  FOLLY_ERASE T&& ARefField_ref() && { return std::move(ARefField); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::AStruct>>
  FOLLY_ERASE const T&& ARefField_ref() const&& { return std::move(ARefField); }
  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE auto ARequiredField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->ARequiredField};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE auto ARequiredField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->ARequiredField)};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE auto ARequiredField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->ARequiredField};
  }

  template <typename..., typename T =  ::some::valid::ns::AStruct>
  FOLLY_ERASE auto ARequiredField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->ARequiredField)};
  }

   ::a::different::ns::IncludedInt64 get_MyIncludedInt() const {
    return MyIncludedInt;
  }

   ::a::different::ns::IncludedInt64& set_MyIncludedInt( ::a::different::ns::IncludedInt64 MyIncludedInt_) {
    MyIncludedInt = MyIncludedInt_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyIncludedInt = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyIncludedInt;
  }
  const  ::some::valid::ns::AStruct& get_MyIncludedStruct() const&;
   ::some::valid::ns::AStruct get_MyIncludedStruct() &&;

  template <typename T_MyIncludedStruct_MyIncludedStruct_struct_setter =  ::some::valid::ns::AStruct>
   ::some::valid::ns::AStruct& set_MyIncludedStruct(T_MyIncludedStruct_MyIncludedStruct_struct_setter&& MyIncludedStruct_) {
    MyIncludedStruct = std::forward<T_MyIncludedStruct_MyIncludedStruct_struct_setter>(MyIncludedStruct_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.MyIncludedStruct = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return MyIncludedStruct;
  }
  const  ::some::valid::ns::AStruct& get_ARequiredField() const&;
   ::some::valid::ns::AStruct get_ARequiredField() &&;

  template <typename T_MyIncludedStruct_ARequiredField_struct_setter =  ::some::valid::ns::AStruct>
   ::some::valid::ns::AStruct& set_ARequiredField(T_MyIncludedStruct_ARequiredField_struct_setter&& ARequiredField_) {
    ARequiredField = std::forward<T_MyIncludedStruct_ARequiredField_struct_setter>(ARequiredField_);
    return ARequiredField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyIncludedStruct >;
  friend void swap(MyIncludedStruct& a, MyIncludedStruct& b);
};

template <class Protocol_>
uint32_t MyIncludedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnnotatedStruct  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = AnnotatedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnnotatedStruct();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnnotatedStruct(apache::thrift::FragileConstructor,  ::some::valid::ns::containerStruct no_annotation__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp2_unique_ref__arg, std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>> container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp2_unique_ref__arg, std::unique_ptr<::std::vector<::std::string>> req_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp2_unique_ref__arg, std::unique_ptr<::std::set<int32_t>> opt_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> ref_type_unique__arg, std::shared_ptr< ::some::valid::ns::containerStruct> ref_type_shared__arg, std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>> ref_type_const__arg, std::shared_ptr< ::some::valid::ns::containerStruct> req_ref_type_shared__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> req_ref_type_const__arg, std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> opt_ref_type_const__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_ref_type_unique__arg, std::shared_ptr<::std::set<int32_t>> opt_ref_type_shared__arg,  ::some::valid::ns::CppFakeI32 base_type__arg,  ::some::valid::ns::FollySmallVectorI64 list_type__arg,  ::some::valid::ns::SortedVectorSetString set_type__arg,  ::some::valid::ns::FakeMap map_type__arg,  ::some::valid::ns::UnorderedMapStruct map_struct_type__arg,  ::some::valid::ns::IOBuf iobuf_type__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr__arg, std::list<int32_t> list_i32_template__arg, std::deque<::std::string> list_string_template__arg, folly::sorted_vector_set<::std::string> set_template__arg, folly::sorted_vector_map<int64_t, ::std::string> map_template__arg,  ::some::valid::ns::std_list typedef_list_template__arg,  ::some::valid::ns::std_deque typedef_deque_template__arg,  ::some::valid::ns::folly_set typedef_set_template__arg,  ::some::valid::ns::folly_map typedef_map_template__arg,  ::some::valid::ns::IndirectionA indirection_a__arg, ::std::vector< ::some::valid::ns::IndirectionB> indirection_b__arg, ::std::set< ::some::valid::ns::IndirectionC> indirection_c__arg,  ::some::valid::ns::IOBuf iobuf_type_val__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr_val__arg,  ::some::valid::ns::containerStruct struct_struct__arg);
  AnnotatedStruct(AnnotatedStruct&& other) noexcept;


  AnnotatedStruct& operator=(AnnotatedStruct&&) = default;
  void __clear();

  virtual ~AnnotatedStruct();

 public:
   ::some::valid::ns::containerStruct no_annotation;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> cpp_unique_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> cpp2_unique_ref;
 public:
  std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>> container_with_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp_unique_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp2_unique_ref;
 public:
  std::unique_ptr<::std::vector<::std::string>> req_container_with_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp_unique_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp2_unique_ref;
 public:
  std::unique_ptr<::std::set<int32_t>> opt_container_with_ref;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> ref_type_unique;
 public:
  std::shared_ptr< ::some::valid::ns::containerStruct> ref_type_shared;
 public:
  std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>> ref_type_const;
 public:
  std::shared_ptr< ::some::valid::ns::containerStruct> req_ref_type_shared;
 public:
  std::shared_ptr<const  ::some::valid::ns::containerStruct> req_ref_type_const;
 public:
  std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique;
 public:
  std::shared_ptr<const  ::some::valid::ns::containerStruct> opt_ref_type_const;
 public:
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_ref_type_unique;
 public:
  std::shared_ptr<::std::set<int32_t>> opt_ref_type_shared;
 public:
   ::some::valid::ns::CppFakeI32 base_type;
 public:
   ::some::valid::ns::FollySmallVectorI64 list_type;
 public:
   ::some::valid::ns::SortedVectorSetString set_type;
 public:
   ::some::valid::ns::FakeMap map_type;
 public:
   ::some::valid::ns::UnorderedMapStruct map_struct_type;
 public:
   ::some::valid::ns::IOBuf iobuf_type;
 public:
   ::some::valid::ns::IOBufPtr iobuf_ptr;
 public:
  std::list<int32_t> list_i32_template;
 public:
  std::deque<::std::string> list_string_template;
 public:
  folly::sorted_vector_set<::std::string> set_template;
 public:
  folly::sorted_vector_map<int64_t, ::std::string> map_template;
 public:
   ::some::valid::ns::std_list typedef_list_template;
 public:
   ::some::valid::ns::std_deque typedef_deque_template;
 public:
   ::some::valid::ns::folly_set typedef_set_template;
 public:
   ::some::valid::ns::folly_map typedef_map_template;
 public:
   ::some::valid::ns::IndirectionA indirection_a;
 public:
  ::std::vector< ::some::valid::ns::IndirectionB> indirection_b;
 public:
  ::std::set< ::some::valid::ns::IndirectionC> indirection_c;
 public:
   ::some::valid::ns::IOBuf iobuf_type_val;
 public:
   ::some::valid::ns::IOBufPtr iobuf_ptr_val;
 public:
   ::some::valid::ns::containerStruct struct_struct;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool no_annotation;
    bool base_type;
    bool list_type;
    bool set_type;
    bool map_type;
    bool map_struct_type;
    bool iobuf_type;
    bool iobuf_ptr;
    bool list_i32_template;
    bool list_string_template;
    bool set_template;
    bool map_template;
    bool typedef_list_template;
    bool typedef_deque_template;
    bool typedef_set_template;
    bool typedef_map_template;
    bool indirection_a;
    bool indirection_b;
    bool indirection_c;
    bool iobuf_type_val;
    bool iobuf_ptr_val;
    bool struct_struct;
  } __isset = {};
  bool operator==(const AnnotatedStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AnnotatedStruct& __x, const AnnotatedStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AnnotatedStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const AnnotatedStruct& __x, const AnnotatedStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AnnotatedStruct& __x, const AnnotatedStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AnnotatedStruct& __x, const AnnotatedStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> no_annotation_ref() const& {
    return {this->no_annotation, __isset.no_annotation};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> no_annotation_ref() const&& {
    return {std::move(this->no_annotation), __isset.no_annotation};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> no_annotation_ref() & {
    return {this->no_annotation, __isset.no_annotation};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> no_annotation_ref() && {
    return {std::move(this->no_annotation), __isset.no_annotation};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp_unique_ref_ref() & { return cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp_unique_ref_ref() const& { return cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp_unique_ref_ref() && { return std::move(cpp_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp_unique_ref_ref() const&& { return std::move(cpp_unique_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp2_unique_ref_ref() & { return cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp2_unique_ref_ref() const& { return cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp2_unique_ref_ref() && { return std::move(cpp2_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp2_unique_ref_ref() const&& { return std::move(cpp2_unique_ref); }
  template <typename ..., typename T = std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& container_with_ref_ref() & { return container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& container_with_ref_ref() const& { return container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& container_with_ref_ref() && { return std::move(container_with_ref); }

  template <typename ..., typename T = std::unique_ptr<::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& container_with_ref_ref() const&& { return std::move(container_with_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp_unique_ref_ref() & { return req_cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp_unique_ref_ref() const& { return req_cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp_unique_ref_ref() && { return std::move(req_cpp_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp_unique_ref_ref() const&& { return std::move(req_cpp_unique_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp2_unique_ref_ref() & { return req_cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp2_unique_ref_ref() const& { return req_cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp2_unique_ref_ref() && { return std::move(req_cpp2_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp2_unique_ref_ref() const&& { return std::move(req_cpp2_unique_ref); }
  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_container_with_ref_ref() & { return req_container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_container_with_ref_ref() const& { return req_container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_container_with_ref_ref() && { return std::move(req_container_with_ref); }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_container_with_ref_ref() const&& { return std::move(req_container_with_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp_unique_ref_ref() & { return opt_cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp_unique_ref_ref() const& { return opt_cpp_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp_unique_ref_ref() && { return std::move(opt_cpp_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp_unique_ref_ref() const&& { return std::move(opt_cpp_unique_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp2_unique_ref_ref() & { return opt_cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp2_unique_ref_ref() const& { return opt_cpp2_unique_ref; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp2_unique_ref_ref() && { return std::move(opt_cpp2_unique_ref); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp2_unique_ref_ref() const&& { return std::move(opt_cpp2_unique_ref); }
  template <typename ..., typename T = std::unique_ptr<::std::set<int32_t>>>
  FOLLY_ERASE T& opt_container_with_ref_ref() & { return opt_container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::set<int32_t>>>
  FOLLY_ERASE const T& opt_container_with_ref_ref() const& { return opt_container_with_ref; }

  template <typename ..., typename T = std::unique_ptr<::std::set<int32_t>>>
  FOLLY_ERASE T&& opt_container_with_ref_ref() && { return std::move(opt_container_with_ref); }

  template <typename ..., typename T = std::unique_ptr<::std::set<int32_t>>>
  FOLLY_ERASE const T&& opt_container_with_ref_ref() const&& { return std::move(opt_container_with_ref); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_unique_ref() & { return ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_unique_ref() const& { return ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_unique_ref() && { return std::move(ref_type_unique); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_unique_ref() const&& { return std::move(ref_type_unique); }
  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_shared_ref() & { return ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_shared_ref() const& { return ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_shared_ref() && { return std::move(ref_type_shared); }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_shared_ref() const&& { return std::move(ref_type_shared); }
  template <typename ..., typename T = std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& ref_type_const_ref() & { return ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& ref_type_const_ref() const& { return ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& ref_type_const_ref() && { return std::move(ref_type_const); }

  template <typename ..., typename T = std::shared_ptr<const ::std::map<int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& ref_type_const_ref() const&& { return std::move(ref_type_const); }
  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_shared_ref() & { return req_ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_shared_ref() const& { return req_ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_shared_ref() && { return std::move(req_ref_type_shared); }

  template <typename ..., typename T = std::shared_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_shared_ref() const&& { return std::move(req_ref_type_shared); }
  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_const_ref() & { return req_ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_const_ref() const& { return req_ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_const_ref() && { return std::move(req_ref_type_const); }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_const_ref() const&& { return std::move(req_ref_type_const); }
  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_ref_type_unique_ref() & { return req_ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_ref_type_unique_ref() const& { return req_ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_ref_type_unique_ref() && { return std::move(req_ref_type_unique); }

  template <typename ..., typename T = std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_ref_type_unique_ref() const&& { return std::move(req_ref_type_unique); }
  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_const_ref() & { return opt_ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_const_ref() const& { return opt_ref_type_const; }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_const_ref() && { return std::move(opt_ref_type_const); }

  template <typename ..., typename T = std::shared_ptr<const  ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_const_ref() const&& { return std::move(opt_ref_type_const); }
  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_unique_ref() & { return opt_ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_unique_ref() const& { return opt_ref_type_unique; }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_unique_ref() && { return std::move(opt_ref_type_unique); }

  template <typename ..., typename T = std::unique_ptr< ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_unique_ref() const&& { return std::move(opt_ref_type_unique); }
  template <typename ..., typename T = std::shared_ptr<::std::set<int32_t>>>
  FOLLY_ERASE T& opt_ref_type_shared_ref() & { return opt_ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr<::std::set<int32_t>>>
  FOLLY_ERASE const T& opt_ref_type_shared_ref() const& { return opt_ref_type_shared; }

  template <typename ..., typename T = std::shared_ptr<::std::set<int32_t>>>
  FOLLY_ERASE T&& opt_ref_type_shared_ref() && { return std::move(opt_ref_type_shared); }

  template <typename ..., typename T = std::shared_ptr<::std::set<int32_t>>>
  FOLLY_ERASE const T&& opt_ref_type_shared_ref() const&& { return std::move(opt_ref_type_shared); }

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> base_type_ref() const& {
    return {this->base_type, __isset.base_type};
  }

  template <typename..., typename T =  ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> base_type_ref() const&& {
    return {std::move(this->base_type), __isset.base_type};
  }

  template <typename..., typename T =  ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> base_type_ref() & {
    return {this->base_type, __isset.base_type};
  }

  template <typename..., typename T =  ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> base_type_ref() && {
    return {std::move(this->base_type), __isset.base_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_type_ref() const& {
    return {this->list_type, __isset.list_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_type_ref() const&& {
    return {std::move(this->list_type), __isset.list_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_type_ref() & {
    return {this->list_type, __isset.list_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_type_ref() && {
    return {std::move(this->list_type), __isset.list_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_type_ref() const& {
    return {this->set_type, __isset.set_type};
  }

  template <typename..., typename T =  ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_type_ref() const&& {
    return {std::move(this->set_type), __isset.set_type};
  }

  template <typename..., typename T =  ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_type_ref() & {
    return {this->set_type, __isset.set_type};
  }

  template <typename..., typename T =  ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_type_ref() && {
    return {std::move(this->set_type), __isset.set_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_type_ref() const& {
    return {this->map_type, __isset.map_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_type_ref() const&& {
    return {std::move(this->map_type), __isset.map_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_type_ref() & {
    return {this->map_type, __isset.map_type};
  }

  template <typename..., typename T =  ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_type_ref() && {
    return {std::move(this->map_type), __isset.map_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_struct_type_ref() const& {
    return {this->map_struct_type, __isset.map_struct_type};
  }

  template <typename..., typename T =  ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_struct_type_ref() const&& {
    return {std::move(this->map_struct_type), __isset.map_struct_type};
  }

  template <typename..., typename T =  ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_struct_type_ref() & {
    return {this->map_struct_type, __isset.map_struct_type};
  }

  template <typename..., typename T =  ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_struct_type_ref() && {
    return {std::move(this->map_struct_type), __isset.map_struct_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_ref() const& {
    return {this->iobuf_type, __isset.iobuf_type};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_ref() const&& {
    return {std::move(this->iobuf_type), __isset.iobuf_type};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_ref() & {
    return {this->iobuf_type, __isset.iobuf_type};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_ref() && {
    return {std::move(this->iobuf_type), __isset.iobuf_type};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_ref() const& {
    return {this->iobuf_ptr, __isset.iobuf_ptr};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_ref() const&& {
    return {std::move(this->iobuf_ptr), __isset.iobuf_ptr};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_ref() & {
    return {this->iobuf_ptr, __isset.iobuf_ptr};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_ref() && {
    return {std::move(this->iobuf_ptr), __isset.iobuf_ptr};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::list<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_i32_template_ref() const& {
    return {this->list_i32_template, __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_i32_template_ref() const&& {
    return {std::move(this->list_i32_template), __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_i32_template_ref() & {
    return {this->list_i32_template, __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_i32_template_ref() && {
    return {std::move(this->list_i32_template), __isset.list_i32_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_string_template_ref() const& {
    return {this->list_string_template, __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_string_template_ref() const&& {
    return {std::move(this->list_string_template), __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_string_template_ref() & {
    return {this->list_string_template, __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_string_template_ref() && {
    return {std::move(this->list_string_template), __isset.list_string_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_template_ref() const& {
    return {this->set_template, __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_template_ref() const&& {
    return {std::move(this->set_template), __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_template_ref() & {
    return {this->set_template, __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_template_ref() && {
    return {std::move(this->set_template), __isset.set_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = folly::sorted_vector_map<int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_template_ref() const& {
    return {this->map_template, __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_template_ref() const&& {
    return {std::move(this->map_template), __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_template_ref() & {
    return {this->map_template, __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_template_ref() && {
    return {std::move(this->map_template), __isset.map_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_list_template_ref() const& {
    return {this->typedef_list_template, __isset.typedef_list_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_list_template_ref() const&& {
    return {std::move(this->typedef_list_template), __isset.typedef_list_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_list_template_ref() & {
    return {this->typedef_list_template, __isset.typedef_list_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_list_template_ref() && {
    return {std::move(this->typedef_list_template), __isset.typedef_list_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_deque_template_ref() const& {
    return {this->typedef_deque_template, __isset.typedef_deque_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_deque_template_ref() const&& {
    return {std::move(this->typedef_deque_template), __isset.typedef_deque_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_deque_template_ref() & {
    return {this->typedef_deque_template, __isset.typedef_deque_template};
  }

  template <typename..., typename T =  ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_deque_template_ref() && {
    return {std::move(this->typedef_deque_template), __isset.typedef_deque_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_set_template_ref() const& {
    return {this->typedef_set_template, __isset.typedef_set_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_set_template_ref() const&& {
    return {std::move(this->typedef_set_template), __isset.typedef_set_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_set_template_ref() & {
    return {this->typedef_set_template, __isset.typedef_set_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_set_template_ref() && {
    return {std::move(this->typedef_set_template), __isset.typedef_set_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_map_template_ref() const& {
    return {this->typedef_map_template, __isset.typedef_map_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_map_template_ref() const&& {
    return {std::move(this->typedef_map_template), __isset.typedef_map_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_map_template_ref() & {
    return {this->typedef_map_template, __isset.typedef_map_template};
  }

  template <typename..., typename T =  ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_map_template_ref() && {
    return {std::move(this->typedef_map_template), __isset.typedef_map_template};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_a_ref() const& {
    return {this->indirection_a, __isset.indirection_a};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_a_ref() const&& {
    return {std::move(this->indirection_a), __isset.indirection_a};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_a_ref() & {
    return {this->indirection_a, __isset.indirection_a};
  }

  template <typename..., typename T =  ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_a_ref() && {
    return {std::move(this->indirection_a), __isset.indirection_a};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::vector< ::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_b_ref() const& {
    return {this->indirection_b, __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_b_ref() const&& {
    return {std::move(this->indirection_b), __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_b_ref() & {
    return {this->indirection_b, __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector< ::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_b_ref() && {
    return {std::move(this->indirection_b), __isset.indirection_b};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::set< ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_c_ref() const& {
    return {this->indirection_c, __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_c_ref() const&& {
    return {std::move(this->indirection_c), __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_c_ref() & {
    return {this->indirection_c, __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set< ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_c_ref() && {
    return {std::move(this->indirection_c), __isset.indirection_c};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_val_ref() const& {
    return {this->iobuf_type_val, __isset.iobuf_type_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_val_ref() const&& {
    return {std::move(this->iobuf_type_val), __isset.iobuf_type_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_val_ref() & {
    return {this->iobuf_type_val, __isset.iobuf_type_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_val_ref() && {
    return {std::move(this->iobuf_type_val), __isset.iobuf_type_val};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_val_ref() const& {
    return {this->iobuf_ptr_val, __isset.iobuf_ptr_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_val_ref() const&& {
    return {std::move(this->iobuf_ptr_val), __isset.iobuf_ptr_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_val_ref() & {
    return {this->iobuf_ptr_val, __isset.iobuf_ptr_val};
  }

  template <typename..., typename T =  ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_val_ref() && {
    return {std::move(this->iobuf_ptr_val), __isset.iobuf_ptr_val};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> struct_struct_ref() const& {
    return {this->struct_struct, __isset.struct_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> struct_struct_ref() const&& {
    return {std::move(this->struct_struct), __isset.struct_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> struct_struct_ref() & {
    return {this->struct_struct, __isset.struct_struct};
  }

  template <typename..., typename T =  ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> struct_struct_ref() && {
    return {std::move(this->struct_struct), __isset.struct_struct};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const  ::some::valid::ns::containerStruct& get_no_annotation() const&;
   ::some::valid::ns::containerStruct get_no_annotation() &&;

  template <typename T_AnnotatedStruct_no_annotation_struct_setter =  ::some::valid::ns::containerStruct>
   ::some::valid::ns::containerStruct& set_no_annotation(T_AnnotatedStruct_no_annotation_struct_setter&& no_annotation_) {
    no_annotation = std::forward<T_AnnotatedStruct_no_annotation_struct_setter>(no_annotation_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.no_annotation = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return no_annotation;
  }

   ::some::valid::ns::CppFakeI32 get_base_type() const {
    return base_type;
  }

   ::some::valid::ns::CppFakeI32& set_base_type( ::some::valid::ns::CppFakeI32 base_type_) {
    base_type = base_type_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.base_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return base_type;
  }
  const  ::some::valid::ns::FollySmallVectorI64& get_list_type() const&;
   ::some::valid::ns::FollySmallVectorI64 get_list_type() &&;

  template <typename T_AnnotatedStruct_list_type_struct_setter =  ::some::valid::ns::FollySmallVectorI64>
   ::some::valid::ns::FollySmallVectorI64& set_list_type(T_AnnotatedStruct_list_type_struct_setter&& list_type_) {
    list_type = std::forward<T_AnnotatedStruct_list_type_struct_setter>(list_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.list_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return list_type;
  }
  const  ::some::valid::ns::SortedVectorSetString& get_set_type() const&;
   ::some::valid::ns::SortedVectorSetString get_set_type() &&;

  template <typename T_AnnotatedStruct_set_type_struct_setter =  ::some::valid::ns::SortedVectorSetString>
   ::some::valid::ns::SortedVectorSetString& set_set_type(T_AnnotatedStruct_set_type_struct_setter&& set_type_) {
    set_type = std::forward<T_AnnotatedStruct_set_type_struct_setter>(set_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.set_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return set_type;
  }
  const  ::some::valid::ns::FakeMap& get_map_type() const&;
   ::some::valid::ns::FakeMap get_map_type() &&;

  template <typename T_AnnotatedStruct_map_type_struct_setter =  ::some::valid::ns::FakeMap>
   ::some::valid::ns::FakeMap& set_map_type(T_AnnotatedStruct_map_type_struct_setter&& map_type_) {
    map_type = std::forward<T_AnnotatedStruct_map_type_struct_setter>(map_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.map_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return map_type;
  }
  const  ::some::valid::ns::UnorderedMapStruct& get_map_struct_type() const&;
   ::some::valid::ns::UnorderedMapStruct get_map_struct_type() &&;

  template <typename T_AnnotatedStruct_map_struct_type_struct_setter =  ::some::valid::ns::UnorderedMapStruct>
   ::some::valid::ns::UnorderedMapStruct& set_map_struct_type(T_AnnotatedStruct_map_struct_type_struct_setter&& map_struct_type_) {
    map_struct_type = std::forward<T_AnnotatedStruct_map_struct_type_struct_setter>(map_struct_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.map_struct_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return map_struct_type;
  }

  const  ::some::valid::ns::IOBuf& get_iobuf_type() const& {
    return iobuf_type;
  }

   ::some::valid::ns::IOBuf get_iobuf_type() && {
    return std::move(iobuf_type);
  }

  template <typename T_AnnotatedStruct_iobuf_type_struct_setter =  ::some::valid::ns::IOBuf>
   ::some::valid::ns::IOBuf& set_iobuf_type(T_AnnotatedStruct_iobuf_type_struct_setter&& iobuf_type_) {
    iobuf_type = std::forward<T_AnnotatedStruct_iobuf_type_struct_setter>(iobuf_type_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.iobuf_type = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return iobuf_type;
  }

  const  ::some::valid::ns::IOBufPtr& get_iobuf_ptr() const& {
    return iobuf_ptr;
  }

   ::some::valid::ns::IOBufPtr get_iobuf_ptr() && {
    return std::move(iobuf_ptr);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_struct_setter =  ::some::valid::ns::IOBufPtr>
   ::some::valid::ns::IOBufPtr& set_iobuf_ptr(T_AnnotatedStruct_iobuf_ptr_struct_setter&& iobuf_ptr_) {
    iobuf_ptr = std::forward<T_AnnotatedStruct_iobuf_ptr_struct_setter>(iobuf_ptr_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.iobuf_ptr = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return iobuf_ptr;
  }
  const std::list<int32_t>& get_list_i32_template() const&;
  std::list<int32_t> get_list_i32_template() &&;

  template <typename T_AnnotatedStruct_list_i32_template_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_list_i32_template(T_AnnotatedStruct_list_i32_template_struct_setter&& list_i32_template_) {
    list_i32_template = std::forward<T_AnnotatedStruct_list_i32_template_struct_setter>(list_i32_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.list_i32_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return list_i32_template;
  }
  const std::deque<::std::string>& get_list_string_template() const&;
  std::deque<::std::string> get_list_string_template() &&;

  template <typename T_AnnotatedStruct_list_string_template_struct_setter = std::deque<::std::string>>
  std::deque<::std::string>& set_list_string_template(T_AnnotatedStruct_list_string_template_struct_setter&& list_string_template_) {
    list_string_template = std::forward<T_AnnotatedStruct_list_string_template_struct_setter>(list_string_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.list_string_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return list_string_template;
  }
  const folly::sorted_vector_set<::std::string>& get_set_template() const&;
  folly::sorted_vector_set<::std::string> get_set_template() &&;

  template <typename T_AnnotatedStruct_set_template_struct_setter = folly::sorted_vector_set<::std::string>>
  folly::sorted_vector_set<::std::string>& set_set_template(T_AnnotatedStruct_set_template_struct_setter&& set_template_) {
    set_template = std::forward<T_AnnotatedStruct_set_template_struct_setter>(set_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.set_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return set_template;
  }
  const folly::sorted_vector_map<int64_t, ::std::string>& get_map_template() const&;
  folly::sorted_vector_map<int64_t, ::std::string> get_map_template() &&;

  template <typename T_AnnotatedStruct_map_template_struct_setter = folly::sorted_vector_map<int64_t, ::std::string>>
  folly::sorted_vector_map<int64_t, ::std::string>& set_map_template(T_AnnotatedStruct_map_template_struct_setter&& map_template_) {
    map_template = std::forward<T_AnnotatedStruct_map_template_struct_setter>(map_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.map_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return map_template;
  }
  const  ::some::valid::ns::std_list& get_typedef_list_template() const&;
   ::some::valid::ns::std_list get_typedef_list_template() &&;

  template <typename T_AnnotatedStruct_typedef_list_template_struct_setter =  ::some::valid::ns::std_list>
   ::some::valid::ns::std_list& set_typedef_list_template(T_AnnotatedStruct_typedef_list_template_struct_setter&& typedef_list_template_) {
    typedef_list_template = std::forward<T_AnnotatedStruct_typedef_list_template_struct_setter>(typedef_list_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.typedef_list_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return typedef_list_template;
  }
  const  ::some::valid::ns::std_deque& get_typedef_deque_template() const&;
   ::some::valid::ns::std_deque get_typedef_deque_template() &&;

  template <typename T_AnnotatedStruct_typedef_deque_template_struct_setter =  ::some::valid::ns::std_deque>
   ::some::valid::ns::std_deque& set_typedef_deque_template(T_AnnotatedStruct_typedef_deque_template_struct_setter&& typedef_deque_template_) {
    typedef_deque_template = std::forward<T_AnnotatedStruct_typedef_deque_template_struct_setter>(typedef_deque_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.typedef_deque_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return typedef_deque_template;
  }
  const  ::some::valid::ns::folly_set& get_typedef_set_template() const&;
   ::some::valid::ns::folly_set get_typedef_set_template() &&;

  template <typename T_AnnotatedStruct_typedef_set_template_struct_setter =  ::some::valid::ns::folly_set>
   ::some::valid::ns::folly_set& set_typedef_set_template(T_AnnotatedStruct_typedef_set_template_struct_setter&& typedef_set_template_) {
    typedef_set_template = std::forward<T_AnnotatedStruct_typedef_set_template_struct_setter>(typedef_set_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.typedef_set_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return typedef_set_template;
  }
  const  ::some::valid::ns::folly_map& get_typedef_map_template() const&;
   ::some::valid::ns::folly_map get_typedef_map_template() &&;

  template <typename T_AnnotatedStruct_typedef_map_template_struct_setter =  ::some::valid::ns::folly_map>
   ::some::valid::ns::folly_map& set_typedef_map_template(T_AnnotatedStruct_typedef_map_template_struct_setter&& typedef_map_template_) {
    typedef_map_template = std::forward<T_AnnotatedStruct_typedef_map_template_struct_setter>(typedef_map_template_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.typedef_map_template = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return typedef_map_template;
  }

   ::some::valid::ns::IndirectionA get_indirection_a() const {
    return indirection_a;
  }

   ::some::valid::ns::IndirectionA& set_indirection_a( ::some::valid::ns::IndirectionA indirection_a_) {
    indirection_a = indirection_a_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indirection_a = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indirection_a;
  }
  const ::std::vector< ::some::valid::ns::IndirectionB>& get_indirection_b() const&;
  ::std::vector< ::some::valid::ns::IndirectionB> get_indirection_b() &&;

  template <typename T_AnnotatedStruct_indirection_b_struct_setter = ::std::vector< ::some::valid::ns::IndirectionB>>
  ::std::vector< ::some::valid::ns::IndirectionB>& set_indirection_b(T_AnnotatedStruct_indirection_b_struct_setter&& indirection_b_) {
    indirection_b = std::forward<T_AnnotatedStruct_indirection_b_struct_setter>(indirection_b_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indirection_b = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indirection_b;
  }
  const ::std::set< ::some::valid::ns::IndirectionC>& get_indirection_c() const&;
  ::std::set< ::some::valid::ns::IndirectionC> get_indirection_c() &&;

  template <typename T_AnnotatedStruct_indirection_c_struct_setter = ::std::set< ::some::valid::ns::IndirectionC>>
  ::std::set< ::some::valid::ns::IndirectionC>& set_indirection_c(T_AnnotatedStruct_indirection_c_struct_setter&& indirection_c_) {
    indirection_c = std::forward<T_AnnotatedStruct_indirection_c_struct_setter>(indirection_c_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.indirection_c = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return indirection_c;
  }

  const  ::some::valid::ns::IOBuf& get_iobuf_type_val() const& {
    return iobuf_type_val;
  }

   ::some::valid::ns::IOBuf get_iobuf_type_val() && {
    return std::move(iobuf_type_val);
  }

  template <typename T_AnnotatedStruct_iobuf_type_val_struct_setter =  ::some::valid::ns::IOBuf>
   ::some::valid::ns::IOBuf& set_iobuf_type_val(T_AnnotatedStruct_iobuf_type_val_struct_setter&& iobuf_type_val_) {
    iobuf_type_val = std::forward<T_AnnotatedStruct_iobuf_type_val_struct_setter>(iobuf_type_val_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.iobuf_type_val = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return iobuf_type_val;
  }

  const  ::some::valid::ns::IOBufPtr& get_iobuf_ptr_val() const& {
    return iobuf_ptr_val;
  }

   ::some::valid::ns::IOBufPtr get_iobuf_ptr_val() && {
    return std::move(iobuf_ptr_val);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_val_struct_setter =  ::some::valid::ns::IOBufPtr>
   ::some::valid::ns::IOBufPtr& set_iobuf_ptr_val(T_AnnotatedStruct_iobuf_ptr_val_struct_setter&& iobuf_ptr_val_) {
    iobuf_ptr_val = std::forward<T_AnnotatedStruct_iobuf_ptr_val_struct_setter>(iobuf_ptr_val_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.iobuf_ptr_val = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return iobuf_ptr_val;
  }
  const  ::some::valid::ns::containerStruct& get_struct_struct() const&;
   ::some::valid::ns::containerStruct get_struct_struct() &&;

  template <typename T_AnnotatedStruct_struct_struct_struct_setter =  ::some::valid::ns::containerStruct>
   ::some::valid::ns::containerStruct& set_struct_struct(T_AnnotatedStruct_struct_struct_struct_setter&& struct_struct_) {
    struct_struct = std::forward<T_AnnotatedStruct_struct_struct_struct_setter>(struct_struct_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.struct_struct = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return struct_struct;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnnotatedStruct >;
  friend void swap(AnnotatedStruct& a, AnnotatedStruct& b);
};

template <class Protocol_>
uint32_t AnnotatedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ComplexContainerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = ComplexContainerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  ComplexContainerStruct() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexContainerStruct(apache::thrift::FragileConstructor, ::std::map<::std::string,  ::some::valid::ns::IOBuf> map_of_iobufs__arg, ::std::map<::std::string,  ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs__arg);

  ComplexContainerStruct(ComplexContainerStruct&&) = default;

  ComplexContainerStruct(const ComplexContainerStruct&) = default;


  ComplexContainerStruct& operator=(ComplexContainerStruct&&) = default;

  ComplexContainerStruct& operator=(const ComplexContainerStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  ::std::map<::std::string,  ::some::valid::ns::IOBuf> map_of_iobufs;
 public:
  ::std::map<::std::string,  ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool map_of_iobufs;
    bool map_of_iobuf_ptrs;
  } __isset = {};
  bool operator==(const ComplexContainerStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ComplexContainerStruct& __x, const ComplexContainerStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ComplexContainerStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const ComplexContainerStruct& __x, const ComplexContainerStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ComplexContainerStruct& __x, const ComplexContainerStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ComplexContainerStruct& __x, const ComplexContainerStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobufs_ref() const& {
    return {this->map_of_iobufs, __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobufs_ref() const&& {
    return {std::move(this->map_of_iobufs), __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobufs_ref() & {
    return {this->map_of_iobufs, __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobufs_ref() && {
    return {std::move(this->map_of_iobufs), __isset.map_of_iobufs};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobuf_ptrs_ref() const& {
    return {this->map_of_iobuf_ptrs, __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobuf_ptrs_ref() const&& {
    return {std::move(this->map_of_iobuf_ptrs), __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobuf_ptrs_ref() & {
    return {this->map_of_iobuf_ptrs, __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobuf_ptrs_ref() && {
    return {std::move(this->map_of_iobuf_ptrs), __isset.map_of_iobuf_ptrs};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END
  const ::std::map<::std::string,  ::some::valid::ns::IOBuf>& get_map_of_iobufs() const&;
  ::std::map<::std::string,  ::some::valid::ns::IOBuf> get_map_of_iobufs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobufs_struct_setter = ::std::map<::std::string,  ::some::valid::ns::IOBuf>>
  ::std::map<::std::string,  ::some::valid::ns::IOBuf>& set_map_of_iobufs(T_ComplexContainerStruct_map_of_iobufs_struct_setter&& map_of_iobufs_) {
    map_of_iobufs = std::forward<T_ComplexContainerStruct_map_of_iobufs_struct_setter>(map_of_iobufs_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.map_of_iobufs = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return map_of_iobufs;
  }
  const ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>& get_map_of_iobuf_ptrs() const&;
  ::std::map<::std::string,  ::some::valid::ns::IOBufPtr> get_map_of_iobuf_ptrs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter = ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>>
  ::std::map<::std::string,  ::some::valid::ns::IOBufPtr>& set_map_of_iobuf_ptrs(T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter&& map_of_iobuf_ptrs_) {
    map_of_iobuf_ptrs = std::forward<T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter>(map_of_iobuf_ptrs_);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.map_of_iobuf_ptrs = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return map_of_iobuf_ptrs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexContainerStruct >;
  friend void swap(ComplexContainerStruct& a, ComplexContainerStruct& b);
};

template <class Protocol_>
uint32_t ComplexContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class FloatStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = FloatStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  FloatStruct() :
      floatField(0),
      doubleField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FloatStruct(apache::thrift::FragileConstructor, float floatField__arg, double doubleField__arg);

  FloatStruct(FloatStruct&&) = default;

  FloatStruct(const FloatStruct&) = default;


  FloatStruct& operator=(FloatStruct&&) = default;

  FloatStruct& operator=(const FloatStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  float floatField;
 public:
  double doubleField;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool floatField;
    bool doubleField;
  } __isset = {};
  bool operator==(const FloatStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const FloatStruct& __x, const FloatStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const FloatStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const FloatStruct& __x, const FloatStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const FloatStruct& __x, const FloatStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const FloatStruct& __x, const FloatStruct& __y) {
    return !(__x < __y);
  }
#endif

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> floatField_ref() const& {
    return {this->floatField, __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> floatField_ref() const&& {
    return {std::move(this->floatField), __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> floatField_ref() & {
    return {this->floatField, __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> floatField_ref() && {
    return {std::move(this->floatField), __isset.floatField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> doubleField_ref() const& {
    return {this->doubleField, __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> doubleField_ref() const&& {
    return {std::move(this->doubleField), __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> doubleField_ref() & {
    return {this->doubleField, __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> doubleField_ref() && {
    return {std::move(this->doubleField), __isset.doubleField};
  }
THRIFT_IGNORE_ISSET_USE_WARNING_END

  float get_floatField() const {
    return floatField;
  }

  float& set_floatField(float floatField_) {
    floatField = floatField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.floatField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return floatField;
  }

  double get_doubleField() const {
    return doubleField;
  }

  double& set_doubleField(double doubleField_) {
    doubleField = doubleField_;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
    __isset.doubleField = true;
THRIFT_IGNORE_ISSET_USE_WARNING_END
    return doubleField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< FloatStruct >;
  friend void swap(FloatStruct& a, FloatStruct& b);
};

template <class Protocol_>
uint32_t FloatStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class FloatUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = FloatUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    floatSide = 1,
    doubleSide = 2,
  } ;

  FloatUnion()
      : type_(Type::__EMPTY__) {}

  FloatUnion(FloatUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  FloatUnion(const FloatUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  FloatUnion& operator=(FloatUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  FloatUnion& operator=(const FloatUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~FloatUnion() {
    __clear();
  }
  union storage_type {
    float floatSide;
    double doubleSide;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const FloatUnion& rhs) const;
#ifndef SWIG
  friend bool operator!=(const FloatUnion& __x, const FloatUnion& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const FloatUnion& rhs) const;
#ifndef SWIG
  friend bool operator>(const FloatUnion& __x, const FloatUnion& __y) {
    return __y < __x;
  }
  friend bool operator<=(const FloatUnion& __x, const FloatUnion& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const FloatUnion& __x, const FloatUnion& __y) {
    return !(__x < __y);
  }
#endif

  float& set_floatSide(float t = float()) {
    __clear();
    type_ = Type::floatSide;
    ::new (std::addressof(value_.floatSide)) float(t);
    return value_.floatSide;
  }

  double& set_doubleSide(double t = double()) {
    __clear();
    type_ = Type::doubleSide;
    ::new (std::addressof(value_.doubleSide)) double(t);
    return value_.doubleSide;
  }

  float const & get_floatSide() const {
    assert(type_ == Type::floatSide);
    return value_.floatSide;
  }

  double const & get_doubleSide() const {
    assert(type_ == Type::doubleSide);
    return value_.doubleSide;
  }

  float & mutable_floatSide() {
    assert(type_ == Type::floatSide);
    return value_.floatSide;
  }

  double & mutable_doubleSide() {
    assert(type_ == Type::doubleSide);
    return value_.doubleSide;
  }

  float move_floatSide() {
    assert(type_ == Type::floatSide);
    return std::move(value_.floatSide);
  }

  double move_doubleSide() {
    assert(type_ == Type::doubleSide);
    return std::move(value_.doubleSide);
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> floatSide_ref() const& {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> floatSide_ref() const&& {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> floatSide_ref() & {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> floatSide_ref() && {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubleSide_ref() const& {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubleSide_ref() const&& {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubleSide_ref() & {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubleSide_ref() && {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  std::underlying_type_t<Type> type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< FloatUnion >;
  friend void swap(FloatUnion& a, FloatUnion& b);
};

template <class Protocol_>
uint32_t FloatUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AllRequiredNoExceptMoveCtrStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;

 public:
  using __fbthrift_cpp2_type = AllRequiredNoExceptMoveCtrStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  AllRequiredNoExceptMoveCtrStruct() :
      intField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AllRequiredNoExceptMoveCtrStruct(apache::thrift::FragileConstructor, int64_t intField__arg);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
AllRequiredNoExceptMoveCtrStruct(AllRequiredNoExceptMoveCtrStruct&& other) noexcept :
      intField(std::move(other.intField)) {}

THRIFT_IGNORE_ISSET_USE_WARNING_END
  AllRequiredNoExceptMoveCtrStruct(const AllRequiredNoExceptMoveCtrStruct&) = default;


  AllRequiredNoExceptMoveCtrStruct& operator=(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct& operator=(const AllRequiredNoExceptMoveCtrStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  void __clear();
 public:
  int64_t intField;

 public:
  bool operator==(const AllRequiredNoExceptMoveCtrStruct& rhs) const;
#ifndef SWIG
  friend bool operator!=(const AllRequiredNoExceptMoveCtrStruct& __x, const AllRequiredNoExceptMoveCtrStruct& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const AllRequiredNoExceptMoveCtrStruct& rhs) const;
#ifndef SWIG
  friend bool operator>(const AllRequiredNoExceptMoveCtrStruct& __x, const AllRequiredNoExceptMoveCtrStruct& __y) {
    return __y < __x;
  }
  friend bool operator<=(const AllRequiredNoExceptMoveCtrStruct& __x, const AllRequiredNoExceptMoveCtrStruct& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const AllRequiredNoExceptMoveCtrStruct& __x, const AllRequiredNoExceptMoveCtrStruct& __y) {
    return !(__x < __y);
  }
#endif
  template <typename..., typename T = int64_t>
  FOLLY_ERASE auto intField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->intField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE auto intField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->intField)};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE auto intField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->intField};
  }

  template <typename..., typename T = int64_t>
  FOLLY_ERASE auto intField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->intField)};
  }

  int64_t get_intField() const {
    return intField;
  }

  int64_t& set_intField(int64_t intField_) {
    intField = intField_;
    return intField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AllRequiredNoExceptMoveCtrStruct >;
  friend void swap(AllRequiredNoExceptMoveCtrStruct& a, AllRequiredNoExceptMoveCtrStruct& b);
};

template <class Protocol_>
uint32_t AllRequiredNoExceptMoveCtrStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::some::valid::ns::SimpleUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::SimpleUnion::Type> {
  using type = ::some::valid::ns::SimpleUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::some::valid::ns::ComplexUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::ComplexUnion::Type> {
  using type = ::some::valid::ns::ComplexUnion::Type;

  static constexpr std::size_t const size = 27;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::some::valid::ns::FloatUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::FloatUnion::Type> {
  using type = ::some::valid::ns::FloatUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
