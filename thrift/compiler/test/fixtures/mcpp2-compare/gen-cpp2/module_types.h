/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/includes_types.h"
#include <folly/small_vector.h>

namespace apache {
namespace thrift {
namespace tag {
struct boolField;
struct boolField;
struct MyBoolField;
struct MyIntField;
struct MyStringField;
struct MyStringField2;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryField3;
struct MyBinaryListField4;
struct MyMapEnumAndInt;
struct intValue;
struct stringValue;
struct intValue;
struct opt_intValue;
struct stringValue;
struct opt_stringValue;
struct intValue2;
struct intValue3;
struct doubelValue;
struct boolValue;
struct union_list;
struct union_set;
struct union_map;
struct opt_union_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union;
struct opt_a_union;
struct a_union_list;
struct a_union_typedef;
struct a_union_typedef_list;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryListField4;
struct ref_field;
struct ref_field2;
struct excp_field;
struct code;
struct req_code;
struct message2;
struct req_message;
struct exception_list;
struct exception_set;
struct exception_map;
struct req_exception_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union_list;
struct union_typedef;
struct a_union_typedef_list;
struct code;
struct req_code;
struct message;
struct fieldA;
struct req_fieldA;
struct opt_fieldA;
struct fieldB;
struct req_fieldB;
struct opt_fieldB;
struct fieldC;
struct req_fieldC;
struct opt_fieldC;
struct fieldD;
struct fieldE;
struct req_fieldE;
struct opt_fieldE;
struct fieldF;
struct fieldG;
struct fieldH;
struct fieldI;
struct fieldJ;
struct fieldK;
struct fieldL;
struct fieldM;
struct fieldN;
struct fieldO;
struct fieldP;
struct fieldQ;
struct fieldR;
struct req_fieldR;
struct opt_fieldR;
struct fieldS;
struct fieldT;
struct fieldU;
struct fieldV;
struct req_fieldV;
struct opt_fieldV;
struct fieldW;
struct fieldX;
struct req_fieldX;
struct opt_fieldX;
struct fieldY;
struct fieldZ;
struct fieldAA;
struct fieldAB;
struct fieldAC;
struct fieldAD;
struct fieldAE;
struct fieldSD;
struct MyIncludedInt;
struct MyIncludedStruct;
struct ARefField;
struct ARequiredField;
struct no_annotation;
struct cpp_unique_ref;
struct cpp2_unique_ref;
struct container_with_ref;
struct req_cpp_unique_ref;
struct req_cpp2_unique_ref;
struct req_container_with_ref;
struct opt_cpp_unique_ref;
struct opt_cpp2_unique_ref;
struct opt_container_with_ref;
struct ref_type_unique;
struct ref_type_shared;
struct ref_type_const;
struct req_ref_type_shared;
struct req_ref_type_const;
struct req_ref_type_unique;
struct opt_ref_type_const;
struct opt_ref_type_unique;
struct opt_ref_type_shared;
struct base_type;
struct list_type;
struct set_type;
struct map_type;
struct map_struct_type;
struct iobuf_type;
struct iobuf_ptr;
struct list_i32_template;
struct list_string_template;
struct set_template;
struct map_template;
struct typedef_list_template;
struct typedef_deque_template;
struct typedef_set_template;
struct typedef_map_template;
struct indirection_a;
struct indirection_b;
struct indirection_c;
struct iobuf_type_val;
struct iobuf_ptr_val;
struct struct_struct;
struct map_of_iobufs;
struct map_of_iobuf_ptrs;
struct floatField;
struct doubleField;
struct floatSide;
struct doubleSide;
struct intField;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBoolField
#define APACHE_THRIFT_ACCESSOR_MyBoolField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBoolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField
#define APACHE_THRIFT_ACCESSOR_MyStringField
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField2
#define APACHE_THRIFT_ACCESSOR_MyStringField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField3
#define APACHE_THRIFT_ACCESSOR_MyBinaryField3
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
#define APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyMapEnumAndInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_intValue
#define APACHE_THRIFT_ACCESSOR_opt_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_stringValue
#define APACHE_THRIFT_ACCESSOR_opt_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue2
#define APACHE_THRIFT_ACCESSOR_intValue2
APACHE_THRIFT_DEFINE_ACCESSOR(intValue2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue3
#define APACHE_THRIFT_ACCESSOR_intValue3
APACHE_THRIFT_DEFINE_ACCESSOR(intValue3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubelValue
#define APACHE_THRIFT_ACCESSOR_doubelValue
APACHE_THRIFT_DEFINE_ACCESSOR(doubelValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolValue
#define APACHE_THRIFT_ACCESSOR_boolValue
APACHE_THRIFT_DEFINE_ACCESSOR(boolValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_list
#define APACHE_THRIFT_ACCESSOR_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_set
#define APACHE_THRIFT_ACCESSOR_union_set
APACHE_THRIFT_DEFINE_ACCESSOR(union_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_map
#define APACHE_THRIFT_ACCESSOR_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_union_map
#define APACHE_THRIFT_ACCESSOR_opt_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(opt_union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union
#define APACHE_THRIFT_ACCESSOR_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_a_union
#define APACHE_THRIFT_ACCESSOR_opt_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(opt_a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef
#define APACHE_THRIFT_ACCESSOR_a_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field
#define APACHE_THRIFT_ACCESSOR_ref_field
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field2
#define APACHE_THRIFT_ACCESSOR_ref_field2
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_excp_field
#define APACHE_THRIFT_ACCESSOR_excp_field
APACHE_THRIFT_DEFINE_ACCESSOR(excp_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message2
#define APACHE_THRIFT_ACCESSOR_message2
APACHE_THRIFT_DEFINE_ACCESSOR(message2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_message
#define APACHE_THRIFT_ACCESSOR_req_message
APACHE_THRIFT_DEFINE_ACCESSOR(req_message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_list
#define APACHE_THRIFT_ACCESSOR_exception_list
APACHE_THRIFT_DEFINE_ACCESSOR(exception_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_set
#define APACHE_THRIFT_ACCESSOR_exception_set
APACHE_THRIFT_DEFINE_ACCESSOR(exception_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_map
#define APACHE_THRIFT_ACCESSOR_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_exception_map
#define APACHE_THRIFT_ACCESSOR_req_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(req_exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_typedef
#define APACHE_THRIFT_ACCESSOR_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldA
#define APACHE_THRIFT_ACCESSOR_req_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldA
#define APACHE_THRIFT_ACCESSOR_opt_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldB
#define APACHE_THRIFT_ACCESSOR_req_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldB
#define APACHE_THRIFT_ACCESSOR_opt_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldC
#define APACHE_THRIFT_ACCESSOR_req_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldC
#define APACHE_THRIFT_ACCESSOR_opt_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldE
#define APACHE_THRIFT_ACCESSOR_req_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldE
#define APACHE_THRIFT_ACCESSOR_opt_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldI
#define APACHE_THRIFT_ACCESSOR_fieldI
APACHE_THRIFT_DEFINE_ACCESSOR(fieldI);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldJ
#define APACHE_THRIFT_ACCESSOR_fieldJ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldJ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldK
#define APACHE_THRIFT_ACCESSOR_fieldK
APACHE_THRIFT_DEFINE_ACCESSOR(fieldK);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldL
#define APACHE_THRIFT_ACCESSOR_fieldL
APACHE_THRIFT_DEFINE_ACCESSOR(fieldL);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldM
#define APACHE_THRIFT_ACCESSOR_fieldM
APACHE_THRIFT_DEFINE_ACCESSOR(fieldM);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldN
#define APACHE_THRIFT_ACCESSOR_fieldN
APACHE_THRIFT_DEFINE_ACCESSOR(fieldN);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldO
#define APACHE_THRIFT_ACCESSOR_fieldO
APACHE_THRIFT_DEFINE_ACCESSOR(fieldO);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldP
#define APACHE_THRIFT_ACCESSOR_fieldP
APACHE_THRIFT_DEFINE_ACCESSOR(fieldP);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldQ
#define APACHE_THRIFT_ACCESSOR_fieldQ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldQ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldR
#define APACHE_THRIFT_ACCESSOR_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldR
#define APACHE_THRIFT_ACCESSOR_req_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldR
#define APACHE_THRIFT_ACCESSOR_opt_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldS
#define APACHE_THRIFT_ACCESSOR_fieldS
APACHE_THRIFT_DEFINE_ACCESSOR(fieldS);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldT
#define APACHE_THRIFT_ACCESSOR_fieldT
APACHE_THRIFT_DEFINE_ACCESSOR(fieldT);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldU
#define APACHE_THRIFT_ACCESSOR_fieldU
APACHE_THRIFT_DEFINE_ACCESSOR(fieldU);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldV
#define APACHE_THRIFT_ACCESSOR_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldV
#define APACHE_THRIFT_ACCESSOR_req_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldV
#define APACHE_THRIFT_ACCESSOR_opt_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldW
#define APACHE_THRIFT_ACCESSOR_fieldW
APACHE_THRIFT_DEFINE_ACCESSOR(fieldW);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldX
#define APACHE_THRIFT_ACCESSOR_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldX
#define APACHE_THRIFT_ACCESSOR_req_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldX
#define APACHE_THRIFT_ACCESSOR_opt_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldY
#define APACHE_THRIFT_ACCESSOR_fieldY
APACHE_THRIFT_DEFINE_ACCESSOR(fieldY);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldZ
#define APACHE_THRIFT_ACCESSOR_fieldZ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldZ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAA
#define APACHE_THRIFT_ACCESSOR_fieldAA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAB
#define APACHE_THRIFT_ACCESSOR_fieldAB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAC
#define APACHE_THRIFT_ACCESSOR_fieldAC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAD
#define APACHE_THRIFT_ACCESSOR_fieldAD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAE
#define APACHE_THRIFT_ACCESSOR_fieldAE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldSD
#define APACHE_THRIFT_ACCESSOR_fieldSD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldSD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedInt
#define APACHE_THRIFT_ACCESSOR_MyIncludedInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedStruct
#define APACHE_THRIFT_ACCESSOR_MyIncludedStruct
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedStruct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARefField
#define APACHE_THRIFT_ACCESSOR_ARefField
APACHE_THRIFT_DEFINE_ACCESSOR(ARefField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARequiredField
#define APACHE_THRIFT_ACCESSOR_ARequiredField
APACHE_THRIFT_DEFINE_ACCESSOR(ARequiredField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_no_annotation
#define APACHE_THRIFT_ACCESSOR_no_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(no_annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_container_with_ref
#define APACHE_THRIFT_ACCESSOR_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_container_with_ref
#define APACHE_THRIFT_ACCESSOR_req_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_container_with_ref
#define APACHE_THRIFT_ACCESSOR_opt_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_const
#define APACHE_THRIFT_ACCESSOR_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_req_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_const
#define APACHE_THRIFT_ACCESSOR_req_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_req_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_const
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_base_type
#define APACHE_THRIFT_ACCESSOR_base_type
APACHE_THRIFT_DEFINE_ACCESSOR(base_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_type
#define APACHE_THRIFT_ACCESSOR_list_type
APACHE_THRIFT_DEFINE_ACCESSOR(list_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_type
#define APACHE_THRIFT_ACCESSOR_set_type
APACHE_THRIFT_DEFINE_ACCESSOR(set_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_type
#define APACHE_THRIFT_ACCESSOR_map_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_struct_type
#define APACHE_THRIFT_ACCESSOR_map_struct_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_struct_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type
#define APACHE_THRIFT_ACCESSOR_iobuf_type
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_i32_template
#define APACHE_THRIFT_ACCESSOR_list_i32_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_i32_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_string_template
#define APACHE_THRIFT_ACCESSOR_list_string_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_string_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_template
#define APACHE_THRIFT_ACCESSOR_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_template
#define APACHE_THRIFT_ACCESSOR_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_list_template
#define APACHE_THRIFT_ACCESSOR_typedef_list_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_list_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_deque_template
#define APACHE_THRIFT_ACCESSOR_typedef_deque_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_deque_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_set_template
#define APACHE_THRIFT_ACCESSOR_typedef_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_map_template
#define APACHE_THRIFT_ACCESSOR_typedef_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_a
#define APACHE_THRIFT_ACCESSOR_indirection_a
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_b
#define APACHE_THRIFT_ACCESSOR_indirection_b
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_c
#define APACHE_THRIFT_ACCESSOR_indirection_c
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type_val
#define APACHE_THRIFT_ACCESSOR_iobuf_type_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_struct_struct
#define APACHE_THRIFT_ACCESSOR_struct_struct
APACHE_THRIFT_DEFINE_ACCESSOR(struct_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobufs
#define APACHE_THRIFT_ACCESSOR_map_of_iobufs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobufs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
#define APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobuf_ptrs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatField
#define APACHE_THRIFT_ACCESSOR_floatField
APACHE_THRIFT_DEFINE_ACCESSOR(floatField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleField
#define APACHE_THRIFT_ACCESSOR_doubleField
APACHE_THRIFT_DEFINE_ACCESSOR(doubleField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatSide
#define APACHE_THRIFT_ACCESSOR_floatSide
APACHE_THRIFT_DEFINE_ACCESSOR(floatSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleSide
#define APACHE_THRIFT_ACCESSOR_doubleSide
APACHE_THRIFT_DEFINE_ACCESSOR(doubleSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intField
#define APACHE_THRIFT_ACCESSOR_intField
APACHE_THRIFT_DEFINE_ACCESSOR(intField);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace some { namespace valid { namespace ns {

enum class MyEnumA {
  fieldA = 1,
  fieldB = 2,
  fieldC = 4,
};




enum class AnnotatedEnum : std::uint32_t {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};


inline constexpr AnnotatedEnum operator&(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator&=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum operator|(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator|=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum operator^(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator^=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum operator~(AnnotatedEnum a) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class AnnotatedEnum2 : short {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};


inline constexpr AnnotatedEnum2 operator&(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator&=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum2 operator|(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator|=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum2 operator^(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator^=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum2 operator~(AnnotatedEnum2 a) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class MyEnumB {
  AField = 0,
};




}}} // some::valid::ns

namespace std {
template<> struct hash<::some::valid::ns::MyEnumA> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::MyEnumA> {};
template<> struct hash<::some::valid::ns::AnnotatedEnum> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::AnnotatedEnum> {};
template<> struct hash<::some::valid::ns::AnnotatedEnum2> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::AnnotatedEnum2> {};
template<> struct hash<::some::valid::ns::MyEnumB> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::MyEnumB> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumA>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumA> {
  using type = ::some::valid::ns::MyEnumA;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::fieldA; }
  static constexpr type max() { return type::fieldC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum> {
  using type = ::some::valid::ns::AnnotatedEnum;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum2>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum2> {
  using type = ::some::valid::ns::AnnotatedEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumB>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumB> {
  using type = ::some::valid::ns::MyEnumB;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::AField; }
  static constexpr type max() { return type::AField; }
};


}} // apache::thrift

namespace some { namespace valid { namespace ns {

using _MyEnumA_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumA>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES;

using _AnnotatedEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum_NAMES_TO_VALUES;

using _AnnotatedEnum2_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum2>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum2_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum2_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _AnnotatedEnum2_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum2_NAMES_TO_VALUES;

using _MyEnumB_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumB>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _MyEnumB_EnumMapFactory::ValuesToNamesMapType _MyEnumB_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _MyEnumB_EnumMapFactory::NamesToValuesMapType _MyEnumB_NAMES_TO_VALUES;

}}} // some::valid::ns

// END declare_enums
// BEGIN forward_declare
namespace some { namespace valid { namespace ns {
class Empty;
class ASimpleStruct;
class ASimpleStructNoexcept;
class MyStruct;
class SimpleUnion;
class ComplexUnion;
class AnException;
class AnotherException;
class containerStruct;
class MyIncludedStruct;
class AnnotatedStruct;
class ComplexContainerStruct;
class FloatStruct;
class FloatUnion;
class AllRequiredNoExceptMoveCtrStruct;
}}} // some::valid::ns
// END forward_declare
// BEGIN typedefs
namespace some { namespace valid { namespace ns {
typedef ::a::different::ns::AStruct AStruct;
typedef ::std::int32_t simpleTypeDef;
typedef ::std::map<::std::int16_t, ::std::string> containerTypeDef;
typedef ::std::vector<::std::map<::std::int16_t, ::std::string>> complexContainerTypeDef;
typedef ::std::set<::some::valid::ns::SimpleUnion> unionTypeDef;
typedef ::std::vector<::some::valid::ns::MyStruct> structTypeDef;
typedef ::std::vector<::std::map<::some::valid::ns::Empty, ::some::valid::ns::MyStruct>> complexStructTypeDef;
typedef ::std::vector<::some::valid::ns::complexStructTypeDef> mostComplexTypeDef;
typedef Foo IndirectionA;
typedef Baz IndirectionC;
typedef Bar IndirectionB;
typedef FooBar IndirectionD;
typedef ::std::map<::some::valid::ns::MyEnumA, ::std::string> HashedTypedef;
typedef CppFakeI32 CppFakeI32;
typedef folly::small_vector<int64_t, 8 /* maxInline */> FollySmallVectorI64;
typedef folly::sorted_vector_set<std::string> SortedVectorSetString;
typedef FakeMap FakeMap;
typedef std::unordered_map<std::string, containerStruct> UnorderedMapStruct;
typedef std::list<::std::int32_t> std_list;
typedef std::deque<::std::string> std_deque;
typedef folly::sorted_vector_set<::std::string> folly_set;
typedef folly::sorted_vector_map<::std::int64_t, ::std::string> folly_map;
typedef folly::IOBuf IOBuf;
typedef std::unique_ptr<folly::IOBuf> IOBufPtr;

}}} // some::valid::ns
// END typedefs
// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename ::some::valid::ns::MyIncludedStruct> {
  size_t operator()(const ::some::valid::ns::MyIncludedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::MyIncludedStruct> {
  bool operator()(const ::some::valid::ns::MyIncludedStruct&,const ::some::valid::ns::MyIncludedStruct&) const;
};

template<> struct hash<typename ::some::valid::ns::AnnotatedStruct> {
  size_t operator()(const ::some::valid::ns::AnnotatedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::AnnotatedStruct> {
  bool operator()(const ::some::valid::ns::AnnotatedStruct&,const ::some::valid::ns::AnnotatedStruct&) const;
};
} // std
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class Empty final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Empty;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Empty() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Empty(apache::thrift::FragileConstructor);

  Empty(Empty&&) = default;

  Empty(const Empty&) = default;


  Empty& operator=(Empty&&) = default;

  Empty& operator=(const Empty&) = default;
  void __clear();

 public:

  bool operator==(const Empty&) const;
  bool operator<(const Empty&) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Empty>;
  friend void swap(Empty& a, Empty& b);
};

template <class Protocol_>
uint32_t Empty::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class ASimpleStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ASimpleStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ASimpleStruct() :
      boolField(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStruct(apache::thrift::FragileConstructor, ::std::int64_t boolField__arg);

  ASimpleStruct(ASimpleStruct&&) = default;

  ASimpleStruct(const ASimpleStruct&) = default;


  ASimpleStruct& operator=(ASimpleStruct&&) = default;

  ASimpleStruct& operator=(const ASimpleStruct&) = default;
  void __clear();
 private:
  ::std::int64_t boolField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool boolField;
  } __isset = {};

 public:

  bool operator==(const ASimpleStruct&) const;
  bool operator<(const ASimpleStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {std::move(this->boolField), __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {std::move(this->boolField), __isset.boolField};
  }

  ::std::int64_t get_boolField() const {
    return boolField;
  }

  [[deprecated("Use `FOO.boolField_ref() = BAR;` instead of `FOO.set_boolField(BAR);`")]]
  ::std::int64_t& set_boolField(::std::int64_t boolField_) {
    boolField = boolField_;
    __isset.boolField = true;
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ASimpleStruct>;
  friend void swap(ASimpleStruct& a, ASimpleStruct& b);
};

template <class Protocol_>
uint32_t ASimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class ASimpleStructNoexcept final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ASimpleStructNoexcept;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ASimpleStructNoexcept() :
      boolField(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStructNoexcept(apache::thrift::FragileConstructor, ::std::int64_t boolField__arg);

  ASimpleStructNoexcept(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept(const ASimpleStructNoexcept&) = default;


  ASimpleStructNoexcept& operator=(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept& operator=(const ASimpleStructNoexcept&) = default;
  void __clear();
 private:
  ::std::int64_t boolField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool boolField;
  } __isset = {};

 public:

  bool operator==(const ASimpleStructNoexcept&) const;
  bool operator<(const ASimpleStructNoexcept&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {std::move(this->boolField), __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->boolField, __isset.boolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {std::move(this->boolField), __isset.boolField};
  }

  ::std::int64_t get_boolField() const {
    return boolField;
  }

  [[deprecated("Use `FOO.boolField_ref() = BAR;` instead of `FOO.set_boolField(BAR);`")]]
  ::std::int64_t& set_boolField(::std::int64_t boolField_) {
    boolField = boolField_;
    __isset.boolField = true;
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ASimpleStructNoexcept>;
  friend void swap(ASimpleStructNoexcept& a, ASimpleStructNoexcept& b);
};

template <class Protocol_>
uint32_t ASimpleStructNoexcept::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class MyStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = MyStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map<::some::valid::ns::MyEnumA, ::std::string> MyMapEnumAndInt__arg);

  MyStruct(MyStruct&&) noexcept;

  MyStruct(const MyStruct& src);


  MyStruct& operator=(MyStruct&&) noexcept;
  MyStruct& operator=(const MyStruct& src);
  void __clear();

  ~MyStruct();

 private:
  bool MyBoolField;
 private:
  ::std::int64_t MyIntField;
 private:
  ::std::string MyStringField;
 private:
  ::std::string MyStringField2;
 private:
  ::std::string MyBinaryField;
 private:
  ::std::string MyBinaryField2;
 public:
  ::std::string MyBinaryField3;
 private:
  ::std::vector<::std::string> MyBinaryListField4;
 private:
  ::std::map<::some::valid::ns::MyEnumA, ::std::string> MyMapEnumAndInt;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool MyBoolField;
    bool MyIntField;
    bool MyStringField;
    bool MyStringField2;
    bool MyBinaryField;
    bool MyBinaryField2;
    bool MyBinaryListField4;
    bool MyMapEnumAndInt;
  } __isset = {};

 public:

  bool operator==(const MyStruct&) const;
  bool operator<(const MyStruct&) const;

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBoolField_ref() const& {
    return {this->MyBoolField, __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBoolField_ref() const&& {
    return {std::move(this->MyBoolField), __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBoolField_ref() & {
    return {this->MyBoolField, __isset.MyBoolField};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBoolField_ref() && {
    return {std::move(this->MyBoolField), __isset.MyBoolField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIntField_ref() const& {
    return {this->MyIntField, __isset.MyIntField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIntField_ref() const&& {
    return {std::move(this->MyIntField), __isset.MyIntField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIntField_ref() & {
    return {this->MyIntField, __isset.MyIntField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIntField_ref() && {
    return {std::move(this->MyIntField), __isset.MyIntField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField_ref() const& {
    return {this->MyStringField, __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField_ref() const&& {
    return {std::move(this->MyStringField), __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField_ref() & {
    return {this->MyStringField, __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField_ref() && {
    return {std::move(this->MyStringField), __isset.MyStringField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField2_ref() const& {
    return {this->MyStringField2, __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField2_ref() const&& {
    return {std::move(this->MyStringField2), __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField2_ref() & {
    return {this->MyStringField2, __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField2_ref() && {
    return {std::move(this->MyStringField2), __isset.MyStringField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryField_ref() const& {
    return {this->MyBinaryField, __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryField_ref() const&& {
    return {std::move(this->MyBinaryField), __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryField_ref() & {
    return {this->MyBinaryField, __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryField_ref() && {
    return {std::move(this->MyBinaryField), __isset.MyBinaryField};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyBinaryField2_ref() const& {
    return {this->MyBinaryField2, __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {std::move(this->MyBinaryField2), __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyBinaryField2_ref() & {
    return {this->MyBinaryField2, __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyBinaryField2_ref() && {
    return {std::move(this->MyBinaryField2), __isset.MyBinaryField2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> MyBinaryField3_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> MyBinaryField3_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->MyBinaryField3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> MyBinaryField3_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> MyBinaryField3_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->MyBinaryField3)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryListField4_ref() const& {
    return {this->MyBinaryListField4, __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {std::move(this->MyBinaryListField4), __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryListField4_ref() & {
    return {this->MyBinaryListField4, __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryListField4_ref() && {
    return {std::move(this->MyBinaryListField4), __isset.MyBinaryListField4};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyMapEnumAndInt_ref() const& {
    return {this->MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyMapEnumAndInt_ref() const&& {
    return {std::move(this->MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyMapEnumAndInt_ref() & {
    return {this->MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyMapEnumAndInt_ref() && {
    return {std::move(this->MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }

  bool get_MyBoolField() const {
    return MyBoolField;
  }

  [[deprecated("Use `FOO.MyBoolField_ref() = BAR;` instead of `FOO.set_MyBoolField(BAR);`")]]
  bool& set_MyBoolField(bool MyBoolField_) {
    MyBoolField = MyBoolField_;
    __isset.MyBoolField = true;
    return MyBoolField;
  }

  ::std::int64_t get_MyIntField() const {
    return MyIntField;
  }

  [[deprecated("Use `FOO.MyIntField_ref() = BAR;` instead of `FOO.set_MyIntField(BAR);`")]]
  ::std::int64_t& set_MyIntField(::std::int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  const ::std::string& get_MyStringField() const& {
    return MyStringField;
  }

  ::std::string get_MyStringField() && {
    return std::move(MyStringField);
  }

  template <typename T_MyStruct_MyStringField_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyStringField_ref() = BAR;` instead of `FOO.set_MyStringField(BAR);`")]]
  ::std::string& set_MyStringField(T_MyStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField = std::forward<T_MyStruct_MyStringField_struct_setter>(MyStringField_);
    __isset.MyStringField = true;
    return MyStringField;
  }

  const ::std::string& get_MyStringField2() const& {
    return MyStringField2;
  }

  ::std::string get_MyStringField2() && {
    return std::move(MyStringField2);
  }

  template <typename T_MyStruct_MyStringField2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyStringField2_ref() = BAR;` instead of `FOO.set_MyStringField2(BAR);`")]]
  ::std::string& set_MyStringField2(T_MyStruct_MyStringField2_struct_setter&& MyStringField2_) {
    MyStringField2 = std::forward<T_MyStruct_MyStringField2_struct_setter>(MyStringField2_);
    __isset.MyStringField2 = true;
    return MyStringField2;
  }

  const ::std::string& get_MyBinaryField() const& {
    return MyBinaryField;
  }

  ::std::string get_MyBinaryField() && {
    return std::move(MyBinaryField);
  }

  template <typename T_MyStruct_MyBinaryField_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField_ref() = BAR;` instead of `FOO.set_MyBinaryField(BAR);`")]]
  ::std::string& set_MyBinaryField(T_MyStruct_MyBinaryField_struct_setter&& MyBinaryField_) {
    MyBinaryField = std::forward<T_MyStruct_MyBinaryField_struct_setter>(MyBinaryField_);
    __isset.MyBinaryField = true;
    return MyBinaryField;
  }

  const ::std::string* get_MyBinaryField2() const& {
    return MyBinaryField2_ref() ? std::addressof(MyBinaryField2) : nullptr;
  }

  ::std::string* get_MyBinaryField2() & {
    return MyBinaryField2_ref() ? std::addressof(MyBinaryField2) : nullptr;
  }
  ::std::string* get_MyBinaryField2() && = delete;

  template <typename T_MyStruct_MyBinaryField2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField2_ref() = BAR;` instead of `FOO.set_MyBinaryField2(BAR);`")]]
  ::std::string& set_MyBinaryField2(T_MyStruct_MyBinaryField2_struct_setter&& MyBinaryField2_) {
    MyBinaryField2 = std::forward<T_MyStruct_MyBinaryField2_struct_setter>(MyBinaryField2_);
    __isset.MyBinaryField2 = true;
    return MyBinaryField2;
  }

  const ::std::string& get_MyBinaryField3() const& {
    return MyBinaryField3;
  }

  ::std::string get_MyBinaryField3() && {
    return std::move(MyBinaryField3);
  }

  template <typename T_MyStruct_MyBinaryField3_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField3_ref() = BAR;` instead of `FOO.set_MyBinaryField3(BAR);`")]]
  ::std::string& set_MyBinaryField3(T_MyStruct_MyBinaryField3_struct_setter&& MyBinaryField3_) {
    MyBinaryField3 = std::forward<T_MyStruct_MyBinaryField3_struct_setter>(MyBinaryField3_);
    return MyBinaryField3;
  }
  const ::std::vector<::std::string>& get_MyBinaryListField4() const&;
  ::std::vector<::std::string> get_MyBinaryListField4() &&;

  template <typename T_MyStruct_MyBinaryListField4_struct_setter = ::std::vector<::std::string>>
  [[deprecated("Use `FOO.MyBinaryListField4_ref() = BAR;` instead of `FOO.set_MyBinaryListField4(BAR);`")]]
  ::std::vector<::std::string>& set_MyBinaryListField4(T_MyStruct_MyBinaryListField4_struct_setter&& MyBinaryListField4_) {
    MyBinaryListField4 = std::forward<T_MyStruct_MyBinaryListField4_struct_setter>(MyBinaryListField4_);
    __isset.MyBinaryListField4 = true;
    return MyBinaryListField4;
  }
  const ::std::map<::some::valid::ns::MyEnumA, ::std::string>& get_MyMapEnumAndInt() const&;
  ::std::map<::some::valid::ns::MyEnumA, ::std::string> get_MyMapEnumAndInt() &&;

  template <typename T_MyStruct_MyMapEnumAndInt_struct_setter = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  [[deprecated("Use `FOO.MyMapEnumAndInt_ref() = BAR;` instead of `FOO.set_MyMapEnumAndInt(BAR);`")]]
  ::std::map<::some::valid::ns::MyEnumA, ::std::string>& set_MyMapEnumAndInt(T_MyStruct_MyMapEnumAndInt_struct_setter&& MyMapEnumAndInt_) {
    MyMapEnumAndInt = std::forward<T_MyStruct_MyMapEnumAndInt_struct_setter>(MyMapEnumAndInt_);
    __isset.MyMapEnumAndInt = true;
    return MyMapEnumAndInt;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyStruct>;
  friend void swap(MyStruct& a, MyStruct& b);
};

template <class Protocol_>
uint32_t MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class SimpleUnion  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SimpleUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 7,
    stringValue = 2,
  } ;

  SimpleUnion()
      : type_(Type::__EMPTY__) {}

  SimpleUnion(SimpleUnion&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  SimpleUnion(const SimpleUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  SimpleUnion& operator=(SimpleUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  SimpleUnion& operator=(const SimpleUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  virtual ~SimpleUnion() {
    __clear();
  }

  union storage_type {
    ::std::int64_t intValue;
    ::std::string stringValue;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const SimpleUnion&) const;
  bool operator<(const SimpleUnion&) const;

  ::std::int64_t& set_intValue(::std::int64_t t = ::std::int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) ::std::int64_t(t);
    return value_.intValue;
  }

  ::std::string& set_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(t);
    return value_.stringValue;
  }

  ::std::string& set_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  ::std::int64_t const& get_intValue() const {
    if (type_ != Type::intValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.intValue;
  }

  ::std::string const& get_stringValue() const {
    if (type_ != Type::stringValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.stringValue;
  }

  ::std::int64_t& mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  ::std::string& mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  ::std::int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  ::std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {std::move(value_.intValue), type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {std::move(value_.intValue), type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {std::move(value_.stringValue), type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {std::move(value_.stringValue), type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SimpleUnion>;
  friend void swap(SimpleUnion& a, SimpleUnion& b);
};

template <class Protocol_>
uint32_t SimpleUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class ComplexUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ComplexUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 1,
    opt_intValue = 201,
    stringValue = 3,
    opt_stringValue = 203,
    intValue2 = 4,
    intValue3 = 6,
    doubelValue = 7,
    boolValue = 8,
    union_list = 9,
    union_set = 10,
    union_map = 11,
    opt_union_map = 211,
    enum_field = 12,
    enum_container = 13,
    a_struct = 14,
    a_set_struct = 15,
    a_union = 16,
    opt_a_union = 216,
    a_union_list = 17,
    a_union_typedef = 18,
    a_union_typedef_list = 19,
    MyBinaryField = 20,
    MyBinaryField2 = 21,
    MyBinaryListField4 = 23,
    ref_field = 24,
    ref_field2 = 25,
    excp_field = 26,
  } ;

  ComplexUnion()
      : type_(Type::__EMPTY__) {}

  ComplexUnion(ComplexUnion&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ComplexUnion(const ComplexUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ComplexUnion& operator=(ComplexUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ComplexUnion& operator=(const ComplexUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ComplexUnion() {
    __clear();
  }
  union storage_type {
    ::std::int64_t intValue;
    ::std::int64_t opt_intValue;
    ::std::string stringValue;
    ::std::string opt_stringValue;
    ::std::int16_t intValue2;
    ::std::int32_t intValue3;
    double doubelValue;
    bool boolValue;
    ::std::vector<::std::int32_t> union_list;
    ::std::set<::std::int64_t> union_set;
    ::std::map<::std::string, ::std::int32_t> union_map;
    ::std::map<::std::string, ::std::int32_t> opt_union_map;
    ::some::valid::ns::MyEnumA enum_field;
    ::std::vector<::some::valid::ns::MyEnumA> enum_container;
    ::some::valid::ns::MyStruct a_struct;
    ::std::set<::some::valid::ns::MyStruct> a_set_struct;
    ::some::valid::ns::SimpleUnion a_union;
    ::some::valid::ns::SimpleUnion opt_a_union;
    ::std::vector<::some::valid::ns::SimpleUnion> a_union_list;
    ::some::valid::ns::unionTypeDef a_union_typedef;
    ::std::vector<::some::valid::ns::unionTypeDef> a_union_typedef_list;
    ::std::string MyBinaryField;
    ::std::string MyBinaryField2;
    ::std::vector<::std::string> MyBinaryListField4;
    ::std::unique_ptr<::some::valid::ns::MyStruct> ref_field;
    ::std::shared_ptr<const ::some::valid::ns::MyStruct> ref_field2;
    ::some::valid::ns::AnException excp_field;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const ComplexUnion&) const;
  bool operator<(const ComplexUnion&) const;

  ::std::int64_t& set_intValue(::std::int64_t t = ::std::int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) ::std::int64_t(t);
    return value_.intValue;
  }

  ::std::int64_t& set_opt_intValue(::std::int64_t t = ::std::int64_t()) {
    __clear();
    type_ = Type::opt_intValue;
    ::new (std::addressof(value_.opt_intValue)) ::std::int64_t(t);
    return value_.opt_intValue;
  }

  ::std::string& set_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(t);
    return value_.stringValue;
  }

  ::std::string& set_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  ::std::string& set_opt_stringValue(::std::string const &t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(t);
    return value_.opt_stringValue;
  }

  ::std::string& set_opt_stringValue(::std::string&& t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(std::move(t));
    return value_.opt_stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_opt_stringValue(T&&... t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.opt_stringValue;
  }

  ::std::int16_t& set_intValue2(::std::int16_t t = ::std::int16_t()) {
    __clear();
    type_ = Type::intValue2;
    ::new (std::addressof(value_.intValue2)) ::std::int16_t(t);
    return value_.intValue2;
  }

  ::std::int32_t& set_intValue3(::std::int32_t t = ::std::int32_t()) {
    __clear();
    type_ = Type::intValue3;
    ::new (std::addressof(value_.intValue3)) ::std::int32_t(t);
    return value_.intValue3;
  }

  double& set_doubelValue(double t = double()) {
    __clear();
    type_ = Type::doubelValue;
    ::new (std::addressof(value_.doubelValue)) double(t);
    return value_.doubelValue;
  }

  bool& set_boolValue(bool t = bool()) {
    __clear();
    type_ = Type::boolValue;
    ::new (std::addressof(value_.boolValue)) bool(t);
    return value_.boolValue;
  }

  ::std::vector<::std::int32_t>& set_union_list(::std::vector<::std::int32_t> const &t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<::std::int32_t>(t);
    return value_.union_list;
  }

  ::std::vector<::std::int32_t>& set_union_list(::std::vector<::std::int32_t>&& t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<::std::int32_t>(std::move(t));
    return value_.union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::int32_t>, T...>> ::std::vector<::std::int32_t>& set_union_list(T&&... t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) ::std::vector<::std::int32_t>(std::forward<T>(t)...);
    return value_.union_list;
  }

  ::std::set<::std::int64_t>& set_union_set(::std::set<::std::int64_t> const &t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<::std::int64_t>(t);
    return value_.union_set;
  }

  ::std::set<::std::int64_t>& set_union_set(::std::set<::std::int64_t>&& t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<::std::int64_t>(std::move(t));
    return value_.union_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set<::std::int64_t>, T...>> ::std::set<::std::int64_t>& set_union_set(T&&... t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) ::std::set<::std::int64_t>(std::forward<T>(t)...);
    return value_.union_set;
  }

  ::std::map<::std::string, ::std::int32_t>& set_union_map(::std::map<::std::string, ::std::int32_t> const &t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, ::std::int32_t>(t);
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t>& set_union_map(::std::map<::std::string, ::std::int32_t>&& t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, ::std::int32_t>(std::move(t));
    return value_.union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, ::std::int32_t>, T...>> ::std::map<::std::string, ::std::int32_t>& set_union_map(T&&... t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, ::std::int32_t>(std::forward<T>(t)...);
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(::std::map<::std::string, ::std::int32_t> const &t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, ::std::int32_t>(t);
    return value_.opt_union_map;
  }

  ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(::std::map<::std::string, ::std::int32_t>&& t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, ::std::int32_t>(std::move(t));
    return value_.opt_union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, ::std::int32_t>, T...>> ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(T&&... t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, ::std::int32_t>(std::forward<T>(t)...);
    return value_.opt_union_map;
  }

  ::some::valid::ns::MyEnumA& set_enum_field(::some::valid::ns::MyEnumA t = ::some::valid::ns::MyEnumA()) {
    __clear();
    type_ = Type::enum_field;
    ::new (std::addressof(value_.enum_field)) ::some::valid::ns::MyEnumA(t);
    return value_.enum_field;
  }

  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(::std::vector<::some::valid::ns::MyEnumA> const &t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector<::some::valid::ns::MyEnumA>(t);
    return value_.enum_container;
  }

  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(::std::vector<::some::valid::ns::MyEnumA>&& t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector<::some::valid::ns::MyEnumA>(std::move(t));
    return value_.enum_container;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::MyEnumA>, T...>> ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(T&&... t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) ::std::vector<::some::valid::ns::MyEnumA>(std::forward<T>(t)...);
    return value_.enum_container;
  }

  ::some::valid::ns::MyStruct& set_a_struct(::some::valid::ns::MyStruct const &t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct)) ::some::valid::ns::MyStruct(t);
    return value_.a_struct;
  }

  ::some::valid::ns::MyStruct& set_a_struct(::some::valid::ns::MyStruct&& t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct)) ::some::valid::ns::MyStruct(std::move(t));
    return value_.a_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::some::valid::ns::MyStruct& set_a_struct(T&&... t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct)) ::some::valid::ns::MyStruct(std::forward<T>(t)...);
    return value_.a_struct;
  }

  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(::std::set<::some::valid::ns::MyStruct> const &t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set<::some::valid::ns::MyStruct>(t);
    return value_.a_set_struct;
  }

  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(::std::set<::some::valid::ns::MyStruct>&& t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set<::some::valid::ns::MyStruct>(std::move(t));
    return value_.a_set_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set<::some::valid::ns::MyStruct>, T...>> ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(T&&... t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) ::std::set<::some::valid::ns::MyStruct>(std::forward<T>(t)...);
    return value_.a_set_struct;
  }

  ::some::valid::ns::SimpleUnion& set_a_union(::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union)) ::some::valid::ns::SimpleUnion(t);
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion& set_a_union(::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union)) ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::SimpleUnion, T...>> ::some::valid::ns::SimpleUnion& set_a_union(T&&... t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union)) ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion& set_opt_a_union(::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union)) ::some::valid::ns::SimpleUnion(t);
    return value_.opt_a_union;
  }

  ::some::valid::ns::SimpleUnion& set_opt_a_union(::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union)) ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.opt_a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::SimpleUnion, T...>> ::some::valid::ns::SimpleUnion& set_opt_a_union(T&&... t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union)) ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.opt_a_union;
  }

  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector<::some::valid::ns::SimpleUnion> const &t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector<::some::valid::ns::SimpleUnion>(t);
    return value_.a_union_list;
  }

  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector<::some::valid::ns::SimpleUnion>&& t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector<::some::valid::ns::SimpleUnion>(std::move(t));
    return value_.a_union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::SimpleUnion>, T...>> ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(T&&... t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) ::std::vector<::some::valid::ns::SimpleUnion>(std::forward<T>(t)...);
    return value_.a_union_list;
  }

  ::some::valid::ns::unionTypeDef& set_a_union_typedef(::some::valid::ns::unionTypeDef const &t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef)) ::some::valid::ns::unionTypeDef(t);
    return value_.a_union_typedef;
  }

  ::some::valid::ns::unionTypeDef& set_a_union_typedef(::some::valid::ns::unionTypeDef&& t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef)) ::some::valid::ns::unionTypeDef(std::move(t));
    return value_.a_union_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::unionTypeDef, T...>> ::some::valid::ns::unionTypeDef& set_a_union_typedef(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef)) ::some::valid::ns::unionTypeDef(std::forward<T>(t)...);
    return value_.a_union_typedef;
  }

  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector<::some::valid::ns::unionTypeDef> const &t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector<::some::valid::ns::unionTypeDef>(t);
    return value_.a_union_typedef_list;
  }

  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector<::some::valid::ns::unionTypeDef>&& t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector<::some::valid::ns::unionTypeDef>(std::move(t));
    return value_.a_union_typedef_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::unionTypeDef>, T...>> ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector<::some::valid::ns::unionTypeDef>(std::forward<T>(t)...);
    return value_.a_union_typedef_list;
  }

  ::std::string& set_MyBinaryField(::std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(t);
    return value_.MyBinaryField;
  }

  ::std::string& set_MyBinaryField(::std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(std::move(t));
    return value_.MyBinaryField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField;
  }

  ::std::string& set_MyBinaryField2(::std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(t);
    return value_.MyBinaryField2;
  }

  ::std::string& set_MyBinaryField2(::std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(std::move(t));
    return value_.MyBinaryField2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField2(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string> const &t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(t);
    return value_.MyBinaryListField4;
  }

  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string>&& t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(std::move(t));
    return value_.MyBinaryListField4;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::string>, T...>> ::std::vector<::std::string>& set_MyBinaryListField4(T&&... t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(std::forward<T>(t)...);
    return value_.MyBinaryListField4;
  }
  ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(::some::valid::ns::MyStruct const &t);
  ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), ::std::unique_ptr<::some::valid::ns::MyStruct>, void>;
    __clear();
    type_ = Type::ref_field;
    ::new (std::addressof(value_.ref_field)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field;
  }
  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(::some::valid::ns::MyStruct const &t);
  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), ::std::shared_ptr<const ::some::valid::ns::MyStruct>, void>;
    __clear();
    type_ = Type::ref_field2;
    ::new (std::addressof(value_.ref_field2)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field2;
  }

  ::some::valid::ns::AnException& set_excp_field(::some::valid::ns::AnException const &t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field)) ::some::valid::ns::AnException(t);
    return value_.excp_field;
  }

  ::some::valid::ns::AnException& set_excp_field(::some::valid::ns::AnException&& t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field)) ::some::valid::ns::AnException(std::move(t));
    return value_.excp_field;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::AnException, T...>> ::some::valid::ns::AnException& set_excp_field(T&&... t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field)) ::some::valid::ns::AnException(std::forward<T>(t)...);
    return value_.excp_field;
  }

  ::std::int64_t const& get_intValue() const {
    if (type_ != Type::intValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.intValue;
  }

  ::std::int64_t const& get_opt_intValue() const {
    if (type_ != Type::opt_intValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.opt_intValue;
  }

  ::std::string const& get_stringValue() const {
    if (type_ != Type::stringValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.stringValue;
  }

  ::std::string const& get_opt_stringValue() const {
    if (type_ != Type::opt_stringValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.opt_stringValue;
  }

  ::std::int16_t const& get_intValue2() const {
    if (type_ != Type::intValue2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.intValue2;
  }

  ::std::int32_t const& get_intValue3() const {
    if (type_ != Type::intValue3) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.intValue3;
  }

  double const& get_doubelValue() const {
    if (type_ != Type::doubelValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.doubelValue;
  }

  bool const& get_boolValue() const {
    if (type_ != Type::boolValue) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.boolValue;
  }

  ::std::vector<::std::int32_t> const& get_union_list() const {
    if (type_ != Type::union_list) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.union_list;
  }

  ::std::set<::std::int64_t> const& get_union_set() const {
    if (type_ != Type::union_set) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.union_set;
  }

  ::std::map<::std::string, ::std::int32_t> const& get_union_map() const {
    if (type_ != Type::union_map) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t> const& get_opt_union_map() const {
    if (type_ != Type::opt_union_map) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.opt_union_map;
  }

  ::some::valid::ns::MyEnumA const& get_enum_field() const {
    if (type_ != Type::enum_field) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.enum_field;
  }

  ::std::vector<::some::valid::ns::MyEnumA> const& get_enum_container() const {
    if (type_ != Type::enum_container) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.enum_container;
  }

  ::some::valid::ns::MyStruct const& get_a_struct() const {
    if (type_ != Type::a_struct) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_struct;
  }

  ::std::set<::some::valid::ns::MyStruct> const& get_a_set_struct() const {
    if (type_ != Type::a_set_struct) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_set_struct;
  }

  ::some::valid::ns::SimpleUnion const& get_a_union() const {
    if (type_ != Type::a_union) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion const& get_opt_a_union() const {
    if (type_ != Type::opt_a_union) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.opt_a_union;
  }

  ::std::vector<::some::valid::ns::SimpleUnion> const& get_a_union_list() const {
    if (type_ != Type::a_union_list) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_union_list;
  }

  ::some::valid::ns::unionTypeDef const& get_a_union_typedef() const {
    if (type_ != Type::a_union_typedef) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_union_typedef;
  }

  ::std::vector<::some::valid::ns::unionTypeDef> const& get_a_union_typedef_list() const {
    if (type_ != Type::a_union_typedef_list) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.a_union_typedef_list;
  }

  ::std::string const& get_MyBinaryField() const {
    if (type_ != Type::MyBinaryField) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.MyBinaryField;
  }

  ::std::string const& get_MyBinaryField2() const {
    if (type_ != Type::MyBinaryField2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string> const& get_MyBinaryListField4() const {
    if (type_ != Type::MyBinaryListField4) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.MyBinaryListField4;
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct> const& get_ref_field() const {
    if (type_ != Type::ref_field) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ref_field;
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct> const& get_ref_field2() const {
    if (type_ != Type::ref_field2) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.ref_field2;
  }

  ::some::valid::ns::AnException const& get_excp_field() const {
    if (type_ != Type::excp_field) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.excp_field;
  }

  ::std::int64_t& mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  ::std::int64_t& mutable_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return value_.opt_intValue;
  }

  ::std::string& mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  ::std::string& mutable_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  ::std::int16_t& mutable_intValue2() {
    assert(type_ == Type::intValue2);
    return value_.intValue2;
  }

  ::std::int32_t& mutable_intValue3() {
    assert(type_ == Type::intValue3);
    return value_.intValue3;
  }

  double& mutable_doubelValue() {
    assert(type_ == Type::doubelValue);
    return value_.doubelValue;
  }

  bool& mutable_boolValue() {
    assert(type_ == Type::boolValue);
    return value_.boolValue;
  }

  ::std::vector<::std::int32_t>& mutable_union_list() {
    assert(type_ == Type::union_list);
    return value_.union_list;
  }

  ::std::set<::std::int64_t>& mutable_union_set() {
    assert(type_ == Type::union_set);
    return value_.union_set;
  }

  ::std::map<::std::string, ::std::int32_t>& mutable_union_map() {
    assert(type_ == Type::union_map);
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t>& mutable_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return value_.opt_union_map;
  }

  ::some::valid::ns::MyEnumA& mutable_enum_field() {
    assert(type_ == Type::enum_field);
    return value_.enum_field;
  }

  ::std::vector<::some::valid::ns::MyEnumA>& mutable_enum_container() {
    assert(type_ == Type::enum_container);
    return value_.enum_container;
  }

  ::some::valid::ns::MyStruct& mutable_a_struct() {
    assert(type_ == Type::a_struct);
    return value_.a_struct;
  }

  ::std::set<::some::valid::ns::MyStruct>& mutable_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return value_.a_set_struct;
  }

  ::some::valid::ns::SimpleUnion& mutable_a_union() {
    assert(type_ == Type::a_union);
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion& mutable_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return value_.opt_a_union;
  }

  ::std::vector<::some::valid::ns::SimpleUnion>& mutable_a_union_list() {
    assert(type_ == Type::a_union_list);
    return value_.a_union_list;
  }

  ::some::valid::ns::unionTypeDef& mutable_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  ::std::vector<::some::valid::ns::unionTypeDef>& mutable_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  ::std::string& mutable_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  ::std::string& mutable_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string>& mutable_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct>& mutable_ref_field() {
    assert(type_ == Type::ref_field);
    return value_.ref_field;
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& mutable_ref_field2() {
    assert(type_ == Type::ref_field2);
    return value_.ref_field2;
  }

  ::some::valid::ns::AnException& mutable_excp_field() {
    assert(type_ == Type::excp_field);
    return value_.excp_field;
  }

  ::std::int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  ::std::int64_t move_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return std::move(value_.opt_intValue);
  }

  ::std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  ::std::string move_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return std::move(value_.opt_stringValue);
  }

  ::std::int16_t move_intValue2() {
    assert(type_ == Type::intValue2);
    return std::move(value_.intValue2);
  }

  ::std::int32_t move_intValue3() {
    assert(type_ == Type::intValue3);
    return std::move(value_.intValue3);
  }

  double move_doubelValue() {
    assert(type_ == Type::doubelValue);
    return std::move(value_.doubelValue);
  }

  bool move_boolValue() {
    assert(type_ == Type::boolValue);
    return std::move(value_.boolValue);
  }

  ::std::vector<::std::int32_t> move_union_list() {
    assert(type_ == Type::union_list);
    return std::move(value_.union_list);
  }

  ::std::set<::std::int64_t> move_union_set() {
    assert(type_ == Type::union_set);
    return std::move(value_.union_set);
  }

  ::std::map<::std::string, ::std::int32_t> move_union_map() {
    assert(type_ == Type::union_map);
    return std::move(value_.union_map);
  }

  ::std::map<::std::string, ::std::int32_t> move_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return std::move(value_.opt_union_map);
  }

  ::some::valid::ns::MyEnumA move_enum_field() {
    assert(type_ == Type::enum_field);
    return std::move(value_.enum_field);
  }

  ::std::vector<::some::valid::ns::MyEnumA> move_enum_container() {
    assert(type_ == Type::enum_container);
    return std::move(value_.enum_container);
  }

  ::some::valid::ns::MyStruct move_a_struct() {
    assert(type_ == Type::a_struct);
    return std::move(value_.a_struct);
  }

  ::std::set<::some::valid::ns::MyStruct> move_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return std::move(value_.a_set_struct);
  }

  ::some::valid::ns::SimpleUnion move_a_union() {
    assert(type_ == Type::a_union);
    return std::move(value_.a_union);
  }

  ::some::valid::ns::SimpleUnion move_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return std::move(value_.opt_a_union);
  }

  ::std::vector<::some::valid::ns::SimpleUnion> move_a_union_list() {
    assert(type_ == Type::a_union_list);
    return std::move(value_.a_union_list);
  }

  ::some::valid::ns::unionTypeDef move_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return std::move(value_.a_union_typedef);
  }

  ::std::vector<::some::valid::ns::unionTypeDef> move_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return std::move(value_.a_union_typedef_list);
  }

  ::std::string move_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return std::move(value_.MyBinaryField);
  }

  ::std::string move_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return std::move(value_.MyBinaryField2);
  }

  ::std::vector<::std::string> move_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return std::move(value_.MyBinaryListField4);
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct> move_ref_field() {
    assert(type_ == Type::ref_field);
    return std::move(value_.ref_field);
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct> move_ref_field2() {
    assert(type_ == Type::ref_field2);
    return std::move(value_.ref_field2);
  }

  ::some::valid::ns::AnException move_excp_field() {
    assert(type_ == Type::excp_field);
    return std::move(value_.excp_field);
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {std::move(value_.intValue), type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {std::move(value_.intValue), type_, intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_intValue_ref() const& {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_intValue_ref() const&& {
    return {std::move(value_.opt_intValue), type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_intValue_ref() & {
    return {value_.opt_intValue, type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_intValue_ref() && {
    return {std::move(value_.opt_intValue), type_, opt_intValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {std::move(value_.stringValue), type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {std::move(value_.stringValue), type_, stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_stringValue_ref() const& {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_stringValue_ref() const&& {
    return {std::move(value_.opt_stringValue), type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_stringValue_ref() & {
    return {value_.opt_stringValue, type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_stringValue_ref() && {
    return {std::move(value_.opt_stringValue), type_, opt_stringValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue2_ref() const& {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue2_ref() const&& {
    return {std::move(value_.intValue2), type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue2_ref() & {
    return {value_.intValue2, type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue2_ref() && {
    return {std::move(value_.intValue2), type_, intValue2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue3_ref() const& {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue3_ref() const&& {
    return {std::move(value_.intValue3), type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue3_ref() & {
    return {value_.intValue3, type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue3_ref() && {
    return {std::move(value_.intValue3), type_, intValue3, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubelValue_ref() const& {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubelValue_ref() const&& {
    return {std::move(value_.doubelValue), type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubelValue_ref() & {
    return {value_.doubelValue, type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubelValue_ref() && {
    return {std::move(value_.doubelValue), type_, doubelValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> boolValue_ref() const& {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> boolValue_ref() const&& {
    return {std::move(value_.boolValue), type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> boolValue_ref() & {
    return {value_.boolValue, type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> boolValue_ref() && {
    return {std::move(value_.boolValue), type_, boolValue, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_list_ref() const& {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_list_ref() const&& {
    return {std::move(value_.union_list), type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_list_ref() & {
    return {value_.union_list, type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_list_ref() && {
    return {std::move(value_.union_list), type_, union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_set_ref() const& {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_set_ref() const&& {
    return {std::move(value_.union_set), type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_set_ref() & {
    return {value_.union_set, type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_set_ref() && {
    return {std::move(value_.union_set), type_, union_set, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_map_ref() const& {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_map_ref() const&& {
    return {std::move(value_.union_map), type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_map_ref() & {
    return {value_.union_map, type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_map_ref() && {
    return {std::move(value_.union_map), type_, union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_union_map_ref() const& {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_union_map_ref() const&& {
    return {std::move(value_.opt_union_map), type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_union_map_ref() & {
    return {value_.opt_union_map, type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_union_map_ref() && {
    return {std::move(value_.opt_union_map), type_, opt_union_map, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_field_ref() const& {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_field_ref() const&& {
    return {std::move(value_.enum_field), type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_field_ref() & {
    return {value_.enum_field, type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_field_ref() && {
    return {std::move(value_.enum_field), type_, enum_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_container_ref() const& {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_container_ref() const&& {
    return {std::move(value_.enum_container), type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_container_ref() & {
    return {value_.enum_container, type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_container_ref() && {
    return {std::move(value_.enum_container), type_, enum_container, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_struct_ref() const& {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_struct_ref() const&& {
    return {std::move(value_.a_struct), type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_struct_ref() & {
    return {value_.a_struct, type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_struct_ref() && {
    return {std::move(value_.a_struct), type_, a_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_set_struct_ref() const& {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_set_struct_ref() const&& {
    return {std::move(value_.a_set_struct), type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_set_struct_ref() & {
    return {value_.a_set_struct, type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_set_struct_ref() && {
    return {std::move(value_.a_set_struct), type_, a_set_struct, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_ref() const& {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_ref() const&& {
    return {std::move(value_.a_union), type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_ref() & {
    return {value_.a_union, type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_ref() && {
    return {std::move(value_.a_union), type_, a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_a_union_ref() const& {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_a_union_ref() const&& {
    return {std::move(value_.opt_a_union), type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_a_union_ref() & {
    return {value_.opt_a_union, type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_a_union_ref() && {
    return {std::move(value_.opt_a_union), type_, opt_a_union, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_list_ref() const& {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_list_ref() const&& {
    return {std::move(value_.a_union_list), type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_list_ref() & {
    return {value_.a_union_list, type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_list_ref() && {
    return {std::move(value_.a_union_list), type_, a_union_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_ref() const& {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_ref() const&& {
    return {std::move(value_.a_union_typedef), type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_ref() & {
    return {value_.a_union_typedef, type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_ref() && {
    return {std::move(value_.a_union_typedef), type_, a_union_typedef, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_list_ref() const& {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {std::move(value_.a_union_typedef_list), type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_list_ref() & {
    return {value_.a_union_typedef_list, type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_list_ref() && {
    return {std::move(value_.a_union_typedef_list), type_, a_union_typedef_list, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField_ref() const& {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField_ref() const&& {
    return {std::move(value_.MyBinaryField), type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField_ref() & {
    return {value_.MyBinaryField, type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField_ref() && {
    return {std::move(value_.MyBinaryField), type_, MyBinaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField2_ref() const& {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {std::move(value_.MyBinaryField2), type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField2_ref() & {
    return {value_.MyBinaryField2, type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField2_ref() && {
    return {std::move(value_.MyBinaryField2), type_, MyBinaryField2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryListField4_ref() const& {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {std::move(value_.MyBinaryListField4), type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryListField4_ref() & {
    return {value_.MyBinaryListField4, type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryListField4_ref() && {
    return {std::move(value_.MyBinaryListField4), type_, MyBinaryListField4, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field_ref() const& {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field_ref() const&& {
    return {std::move(value_.ref_field), type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field_ref() & {
    return {value_.ref_field, type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field_ref() && {
    return {std::move(value_.ref_field), type_, ref_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field2_ref() const& {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field2_ref() const&& {
    return {std::move(value_.ref_field2), type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field2_ref() & {
    return {value_.ref_field2, type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field2_ref() && {
    return {std::move(value_.ref_field2), type_, ref_field2, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> excp_field_ref() const& {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> excp_field_ref() const&& {
    return {std::move(value_.excp_field), type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> excp_field_ref() & {
    return {value_.excp_field, type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> excp_field_ref() && {
    return {std::move(value_.excp_field), type_, excp_field, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexUnion>;
  friend void swap(ComplexUnion& a, ComplexUnion& b);
};

template <class Protocol_>
uint32_t ComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class FOLLY_EXPORT AnException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = AnException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnException();
  explicit AnException(std::string __message);

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnException(apache::thrift::FragileConstructor, ::std::int32_t code__arg, ::std::int32_t req_code__arg, ::std::string message2__arg, ::std::string req_message__arg, ::std::vector<::std::int32_t> exception_list__arg, ::std::set<::std::int64_t> exception_set__arg, ::std::map<::std::string, ::std::int32_t> exception_map__arg, ::std::map<::std::string, ::std::int32_t> req_exception_map__arg, ::some::valid::ns::MyEnumA enum_field__arg, ::std::vector<::some::valid::ns::MyEnumA> enum_container__arg, ::some::valid::ns::MyStruct a_struct__arg, ::std::set<::some::valid::ns::MyStruct> a_set_struct__arg, ::std::vector<::some::valid::ns::SimpleUnion> a_union_list__arg, ::some::valid::ns::unionTypeDef union_typedef__arg, ::std::vector<::some::valid::ns::unionTypeDef> a_union_typedef_list__arg);

  AnException(AnException&&) noexcept;

  AnException(const AnException& src);


  AnException& operator=(AnException&&) noexcept;
  AnException& operator=(const AnException& src);
  void __clear();

  ~AnException() override;

 private:
  ::std::int32_t code;
 public:
  ::std::int32_t req_code;
 private:
  ::std::string message2;
 public:
  ::std::string req_message;
 private:
  ::std::vector<::std::int32_t> exception_list;
 private:
  ::std::set<::std::int64_t> exception_set;
 private:
  ::std::map<::std::string, ::std::int32_t> exception_map;
 public:
  ::std::map<::std::string, ::std::int32_t> req_exception_map;
 private:
  ::some::valid::ns::MyEnumA enum_field;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> enum_container;
 private:
  ::some::valid::ns::MyStruct a_struct;
 private:
  ::std::set<::some::valid::ns::MyStruct> a_set_struct;
 private:
  ::std::vector<::some::valid::ns::SimpleUnion> a_union_list;
 private:
  ::some::valid::ns::unionTypeDef union_typedef;
 private:
  ::std::vector<::some::valid::ns::unionTypeDef> a_union_typedef_list;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool message2;
    bool exception_list;
    bool exception_set;
    bool exception_map;
    bool enum_field;
    bool enum_container;
    bool a_struct;
    bool a_set_struct;
    bool a_union_list;
    bool union_typedef;
    bool a_union_typedef_list;
  } __isset = {};

 public:

  bool operator==(const AnException&) const;
  bool operator<(const AnException&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message2_ref() const& {
    return {this->message2, __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message2_ref() const&& {
    return {std::move(this->message2), __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message2_ref() & {
    return {this->message2, __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message2_ref() && {
    return {std::move(this->message2), __isset.message2};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_message_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_message_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_message)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_message_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_message_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_message)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_list_ref() const& {
    return {this->exception_list, __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_list_ref() const&& {
    return {std::move(this->exception_list), __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_list_ref() & {
    return {this->exception_list, __isset.exception_list};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_list_ref() && {
    return {std::move(this->exception_list), __isset.exception_list};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_set_ref() const& {
    return {this->exception_set, __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_set_ref() const&& {
    return {std::move(this->exception_set), __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_set_ref() & {
    return {this->exception_set, __isset.exception_set};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_set_ref() && {
    return {std::move(this->exception_set), __isset.exception_set};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_map_ref() const& {
    return {this->exception_map, __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_map_ref() const&& {
    return {std::move(this->exception_map), __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_map_ref() & {
    return {this->exception_map, __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_map_ref() && {
    return {std::move(this->exception_map), __isset.exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_exception_map_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_exception_map_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_exception_map)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_exception_map_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_exception_map_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_exception_map)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_field_ref() const& {
    return {this->enum_field, __isset.enum_field};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_field_ref() const&& {
    return {std::move(this->enum_field), __isset.enum_field};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_field_ref() & {
    return {this->enum_field, __isset.enum_field};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_field_ref() && {
    return {std::move(this->enum_field), __isset.enum_field};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_container_ref() const& {
    return {this->enum_container, __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_container_ref() const&& {
    return {std::move(this->enum_container), __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_container_ref() & {
    return {this->enum_container, __isset.enum_container};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_container_ref() && {
    return {std::move(this->enum_container), __isset.enum_container};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_struct_ref() const& {
    return {this->a_struct, __isset.a_struct};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_struct_ref() const&& {
    return {std::move(this->a_struct), __isset.a_struct};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_struct_ref() & {
    return {this->a_struct, __isset.a_struct};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_struct_ref() && {
    return {std::move(this->a_struct), __isset.a_struct};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_set_struct_ref() const& {
    return {this->a_set_struct, __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_set_struct_ref() const&& {
    return {std::move(this->a_set_struct), __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_set_struct_ref() & {
    return {this->a_set_struct, __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_set_struct_ref() && {
    return {std::move(this->a_set_struct), __isset.a_set_struct};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_list_ref() const& {
    return {this->a_union_list, __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_list_ref() const&& {
    return {std::move(this->a_union_list), __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_list_ref() & {
    return {this->a_union_list, __isset.a_union_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_list_ref() && {
    return {std::move(this->a_union_list), __isset.a_union_list};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> union_typedef_ref() const& {
    return {this->union_typedef, __isset.union_typedef};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> union_typedef_ref() const&& {
    return {std::move(this->union_typedef), __isset.union_typedef};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> union_typedef_ref() & {
    return {this->union_typedef, __isset.union_typedef};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> union_typedef_ref() && {
    return {std::move(this->union_typedef), __isset.union_typedef};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_typedef_list_ref() const& {
    return {this->a_union_typedef_list, __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {std::move(this->a_union_typedef_list), __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_typedef_list_ref() & {
    return {this->a_union_typedef_list, __isset.a_union_typedef_list};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_typedef_list_ref() && {
    return {std::move(this->a_union_typedef_list), __isset.a_union_typedef_list};
  }

  ::std::int32_t get_code() const {
    return code;
  }

  [[deprecated("Use `FOO.code_ref() = BAR;` instead of `FOO.set_code(BAR);`")]]
  ::std::int32_t& set_code(::std::int32_t code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  ::std::int32_t get_req_code() const {
    return req_code;
  }

  [[deprecated("Use `FOO.req_code_ref() = BAR;` instead of `FOO.set_req_code(BAR);`")]]
  ::std::int32_t& set_req_code(::std::int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const ::std::string& get_message2() const& {
    return message2;
  }

  ::std::string get_message2() && {
    return std::move(message2);
  }

  template <typename T_AnException_message2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.message2_ref() = BAR;` instead of `FOO.set_message2(BAR);`")]]
  ::std::string& set_message2(T_AnException_message2_struct_setter&& message2_) {
    message2 = std::forward<T_AnException_message2_struct_setter>(message2_);
    __isset.message2 = true;
    return message2;
  }

  const ::std::string& get_req_message() const& {
    return req_message;
  }

  ::std::string get_req_message() && {
    return std::move(req_message);
  }

  template <typename T_AnException_req_message_struct_setter = ::std::string>
  [[deprecated("Use `FOO.req_message_ref() = BAR;` instead of `FOO.set_req_message(BAR);`")]]
  ::std::string& set_req_message(T_AnException_req_message_struct_setter&& req_message_) {
    req_message = std::forward<T_AnException_req_message_struct_setter>(req_message_);
    return req_message;
  }
  const ::std::vector<::std::int32_t>& get_exception_list() const&;
  ::std::vector<::std::int32_t> get_exception_list() &&;

  template <typename T_AnException_exception_list_struct_setter = ::std::vector<::std::int32_t>>
  [[deprecated("Use `FOO.exception_list_ref() = BAR;` instead of `FOO.set_exception_list(BAR);`")]]
  ::std::vector<::std::int32_t>& set_exception_list(T_AnException_exception_list_struct_setter&& exception_list_) {
    exception_list = std::forward<T_AnException_exception_list_struct_setter>(exception_list_);
    __isset.exception_list = true;
    return exception_list;
  }
  const ::std::set<::std::int64_t>& get_exception_set() const&;
  ::std::set<::std::int64_t> get_exception_set() &&;

  template <typename T_AnException_exception_set_struct_setter = ::std::set<::std::int64_t>>
  [[deprecated("Use `FOO.exception_set_ref() = BAR;` instead of `FOO.set_exception_set(BAR);`")]]
  ::std::set<::std::int64_t>& set_exception_set(T_AnException_exception_set_struct_setter&& exception_set_) {
    exception_set = std::forward<T_AnException_exception_set_struct_setter>(exception_set_);
    __isset.exception_set = true;
    return exception_set;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_exception_map() const&;
  ::std::map<::std::string, ::std::int32_t> get_exception_map() &&;

  template <typename T_AnException_exception_map_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.exception_map_ref() = BAR;` instead of `FOO.set_exception_map(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_exception_map(T_AnException_exception_map_struct_setter&& exception_map_) {
    exception_map = std::forward<T_AnException_exception_map_struct_setter>(exception_map_);
    __isset.exception_map = true;
    return exception_map;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_req_exception_map() const&;
  ::std::map<::std::string, ::std::int32_t> get_req_exception_map() &&;

  template <typename T_AnException_req_exception_map_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.req_exception_map_ref() = BAR;` instead of `FOO.set_req_exception_map(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_req_exception_map(T_AnException_req_exception_map_struct_setter&& req_exception_map_) {
    req_exception_map = std::forward<T_AnException_req_exception_map_struct_setter>(req_exception_map_);
    return req_exception_map;
  }

  ::some::valid::ns::MyEnumA get_enum_field() const {
    return enum_field;
  }

  [[deprecated("Use `FOO.enum_field_ref() = BAR;` instead of `FOO.set_enum_field(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_enum_field(::some::valid::ns::MyEnumA enum_field_) {
    enum_field = enum_field_;
    __isset.enum_field = true;
    return enum_field;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_enum_container() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_enum_container() &&;

  template <typename T_AnException_enum_container_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.enum_container_ref() = BAR;` instead of `FOO.set_enum_container(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(T_AnException_enum_container_struct_setter&& enum_container_) {
    enum_container = std::forward<T_AnException_enum_container_struct_setter>(enum_container_);
    __isset.enum_container = true;
    return enum_container;
  }
  const ::some::valid::ns::MyStruct& get_a_struct() const&;
  ::some::valid::ns::MyStruct get_a_struct() &&;

  template <typename T_AnException_a_struct_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.a_struct_ref() = BAR;` instead of `FOO.set_a_struct(BAR);`")]]
  ::some::valid::ns::MyStruct& set_a_struct(T_AnException_a_struct_struct_setter&& a_struct_) {
    a_struct = std::forward<T_AnException_a_struct_struct_setter>(a_struct_);
    __isset.a_struct = true;
    return a_struct;
  }
  const ::std::set<::some::valid::ns::MyStruct>& get_a_set_struct() const&;
  ::std::set<::some::valid::ns::MyStruct> get_a_set_struct() &&;

  template <typename T_AnException_a_set_struct_struct_setter = ::std::set<::some::valid::ns::MyStruct>>
  [[deprecated("Use `FOO.a_set_struct_ref() = BAR;` instead of `FOO.set_a_set_struct(BAR);`")]]
  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(T_AnException_a_set_struct_struct_setter&& a_set_struct_) {
    a_set_struct = std::forward<T_AnException_a_set_struct_struct_setter>(a_set_struct_);
    __isset.a_set_struct = true;
    return a_set_struct;
  }
  const ::std::vector<::some::valid::ns::SimpleUnion>& get_a_union_list() const&;
  ::std::vector<::some::valid::ns::SimpleUnion> get_a_union_list() &&;

  template <typename T_AnException_a_union_list_struct_setter = ::std::vector<::some::valid::ns::SimpleUnion>>
  [[deprecated("Use `FOO.a_union_list_ref() = BAR;` instead of `FOO.set_a_union_list(BAR);`")]]
  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(T_AnException_a_union_list_struct_setter&& a_union_list_) {
    a_union_list = std::forward<T_AnException_a_union_list_struct_setter>(a_union_list_);
    __isset.a_union_list = true;
    return a_union_list;
  }
  const ::some::valid::ns::unionTypeDef& get_union_typedef() const&;
  ::some::valid::ns::unionTypeDef get_union_typedef() &&;

  template <typename T_AnException_union_typedef_struct_setter = ::some::valid::ns::unionTypeDef>
  [[deprecated("Use `FOO.union_typedef_ref() = BAR;` instead of `FOO.set_union_typedef(BAR);`")]]
  ::some::valid::ns::unionTypeDef& set_union_typedef(T_AnException_union_typedef_struct_setter&& union_typedef_) {
    union_typedef = std::forward<T_AnException_union_typedef_struct_setter>(union_typedef_);
    __isset.union_typedef = true;
    return union_typedef;
  }
  const ::std::vector<::some::valid::ns::unionTypeDef>& get_a_union_typedef_list() const&;
  ::std::vector<::some::valid::ns::unionTypeDef> get_a_union_typedef_list() &&;

  template <typename T_AnException_a_union_typedef_list_struct_setter = ::std::vector<::some::valid::ns::unionTypeDef>>
  [[deprecated("Use `FOO.a_union_typedef_list_ref() = BAR;` instead of `FOO.set_a_union_typedef_list(BAR);`")]]
  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T_AnException_a_union_typedef_list_struct_setter&& a_union_typedef_list_) {
    a_union_typedef_list = std::forward<T_AnException_a_union_typedef_list_struct_setter>(a_union_typedef_list_);
    __isset.a_union_typedef_list = true;
    return a_union_typedef_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return message2.c_str();
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnException>;
  friend void swap(AnException& a, AnException& b);
};

template <class Protocol_>
uint32_t AnException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class FOLLY_EXPORT AnotherException : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = AnotherException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnotherException();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnotherException(apache::thrift::FragileConstructor, ::std::int32_t code__arg, ::std::int32_t req_code__arg, ::std::string message__arg);

  AnotherException(AnotherException&&) noexcept;

  AnotherException(const AnotherException& src);


  AnotherException& operator=(AnotherException&&) noexcept;
  AnotherException& operator=(const AnotherException& src);
  void __clear();

  virtual ~AnotherException();

 private:
  ::std::int32_t code;
 public:
  ::std::int32_t req_code;
 private:
  ::std::string message;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool code;
    bool message;
  } __isset = {};

 public:

  bool operator==(const AnotherException&) const;
  bool operator<(const AnotherException&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_code)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  ::std::int32_t get_code() const {
    return code;
  }

  [[deprecated("Use `FOO.code_ref() = BAR;` instead of `FOO.set_code(BAR);`")]]
  ::std::int32_t& set_code(::std::int32_t code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  ::std::int32_t get_req_code() const {
    return req_code;
  }

  [[deprecated("Use `FOO.req_code_ref() = BAR;` instead of `FOO.set_req_code(BAR);`")]]
  ::std::int32_t& set_req_code(::std::int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_AnotherException_message_struct_setter = ::std::string>
  [[deprecated("Use `FOO.message_ref() = BAR;` instead of `FOO.set_message(BAR);`")]]
  ::std::string& set_message(T_AnotherException_message_struct_setter&& message_) {
    message = std::forward<T_AnotherException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::some::valid::ns::AnotherException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnotherException>;
  friend void swap(AnotherException& a, AnotherException& b);
};

template <class Protocol_>
uint32_t AnotherException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class containerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = containerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  containerStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  containerStruct(apache::thrift::FragileConstructor, bool fieldA__arg, bool req_fieldA__arg, bool opt_fieldA__arg, ::std::map<::std::string, bool> fieldB__arg, ::std::map<::std::string, bool> req_fieldB__arg, ::std::map<::std::string, bool> opt_fieldB__arg, ::std::set<::std::int32_t> fieldC__arg, ::std::set<::std::int32_t> req_fieldC__arg, ::std::set<::std::int32_t> opt_fieldC__arg, ::std::string fieldD__arg, ::std::string fieldE__arg, ::std::string req_fieldE__arg, ::std::string opt_fieldE__arg, ::std::vector<::std::vector<::std::int32_t>> fieldF__arg, ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> fieldG__arg, ::std::vector<::std::set<::std::int32_t>> fieldH__arg, bool fieldI__arg, ::std::map<::std::string, ::std::vector<::std::int32_t>> fieldJ__arg, ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> fieldK__arg, ::std::set<::std::set<::std::set<bool>>> fieldL__arg, ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM__arg, ::some::valid::ns::simpleTypeDef fieldN__arg, ::some::valid::ns::complexStructTypeDef fieldO__arg, ::std::vector<::some::valid::ns::mostComplexTypeDef> fieldP__arg, ::some::valid::ns::MyEnumA fieldQ__arg, ::some::valid::ns::MyEnumA fieldR__arg, ::some::valid::ns::MyEnumA req_fieldR__arg, ::some::valid::ns::MyEnumA opt_fieldR__arg, ::some::valid::ns::MyEnumA fieldS__arg, ::std::vector<::some::valid::ns::MyEnumA> fieldT__arg, ::std::vector<::some::valid::ns::MyEnumA> fieldU__arg, ::some::valid::ns::MyStruct fieldV__arg, ::some::valid::ns::MyStruct req_fieldV__arg, ::some::valid::ns::MyStruct opt_fieldV__arg, ::std::set<::some::valid::ns::MyStruct> fieldW__arg, ::some::valid::ns::ComplexUnion fieldX__arg, ::some::valid::ns::ComplexUnion req_fieldX__arg, ::some::valid::ns::ComplexUnion opt_fieldX__arg, ::std::vector<::some::valid::ns::ComplexUnion> fieldY__arg, ::some::valid::ns::unionTypeDef fieldZ__arg, ::std::vector<::some::valid::ns::unionTypeDef> fieldAA__arg, ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> fieldAB__arg, ::some::valid::ns::MyEnumB fieldAC__arg, ::a::different::ns::AnEnum fieldAD__arg, ::std::map<::std::string, ::std::int32_t> fieldAE__arg, ::some::valid::ns::IndirectionD fieldSD__arg);

  containerStruct(containerStruct&&) = default;


  containerStruct& operator=(containerStruct&&) = default;
  void __clear();

  ~containerStruct();

 private:
  bool fieldA;
 public:
  bool req_fieldA;
 private:
  bool opt_fieldA;
 private:
  ::std::map<::std::string, bool> fieldB;
 public:
  ::std::map<::std::string, bool> req_fieldB;
 private:
  ::std::map<::std::string, bool> opt_fieldB;
 private:
  ::std::set<::std::int32_t> fieldC;
 public:
  ::std::set<::std::int32_t> req_fieldC;
 private:
  ::std::set<::std::int32_t> opt_fieldC;
 private:
  ::std::string fieldD;
 private:
  ::std::string fieldE;
 public:
  ::std::string req_fieldE;
 private:
  ::std::string opt_fieldE;
 private:
  ::std::vector<::std::vector<::std::int32_t>> fieldF;
 private:
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> fieldG;
 private:
  ::std::vector<::std::set<::std::int32_t>> fieldH;
 private:
  bool fieldI;
 private:
  ::std::map<::std::string, ::std::vector<::std::int32_t>> fieldJ;
 private:
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> fieldK;
 private:
  ::std::set<::std::set<::std::set<bool>>> fieldL;
 private:
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM;
 private:
  ::some::valid::ns::simpleTypeDef fieldN;
 private:
  ::some::valid::ns::complexStructTypeDef fieldO;
 private:
  ::std::vector<::some::valid::ns::mostComplexTypeDef> fieldP;
 private:
  ::some::valid::ns::MyEnumA fieldQ;
 private:
  ::some::valid::ns::MyEnumA fieldR;
 public:
  ::some::valid::ns::MyEnumA req_fieldR;
 private:
  ::some::valid::ns::MyEnumA opt_fieldR;
 private:
  ::some::valid::ns::MyEnumA fieldS;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> fieldT;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> fieldU;
 private:
  ::some::valid::ns::MyStruct fieldV;
 public:
  ::some::valid::ns::MyStruct req_fieldV;
 private:
  ::some::valid::ns::MyStruct opt_fieldV;
 private:
  ::std::set<::some::valid::ns::MyStruct> fieldW;
 private:
  ::some::valid::ns::ComplexUnion fieldX;
 public:
  ::some::valid::ns::ComplexUnion req_fieldX;
 private:
  ::some::valid::ns::ComplexUnion opt_fieldX;
 private:
  ::std::vector<::some::valid::ns::ComplexUnion> fieldY;
 private:
  ::some::valid::ns::unionTypeDef fieldZ;
 private:
  ::std::vector<::some::valid::ns::unionTypeDef> fieldAA;
 private:
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> fieldAB;
 private:
  ::some::valid::ns::MyEnumB fieldAC;
 private:
  ::a::different::ns::AnEnum fieldAD;
 private:
  ::std::map<::std::string, ::std::int32_t> fieldAE;
 private:
  ::some::valid::ns::IndirectionD fieldSD;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool fieldA;
    bool opt_fieldA;
    bool fieldB;
    bool opt_fieldB;
    bool fieldC;
    bool opt_fieldC;
    bool fieldD;
    bool fieldE;
    bool opt_fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
    bool opt_fieldR;
    bool fieldS;
    bool fieldT;
    bool fieldU;
    bool fieldV;
    bool opt_fieldV;
    bool fieldW;
    bool fieldX;
    bool opt_fieldX;
    bool fieldY;
    bool fieldZ;
    bool fieldAA;
    bool fieldAB;
    bool fieldAC;
    bool fieldAD;
    bool fieldAE;
    bool fieldSD;
  } __isset = {};

 public:

  bool operator==(const containerStruct&) const;
  bool operator<(const containerStruct&) const;

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldA_ref() const& {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldA_ref() const&& {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldA_ref() & {
    return {this->fieldA, __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldA_ref() && {
    return {std::move(this->fieldA), __isset.fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldA_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldA_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldA)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldA_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldA_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldA)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldA_ref() const& {
    return {this->opt_fieldA, __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldA_ref() const&& {
    return {std::move(this->opt_fieldA), __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldA_ref() & {
    return {this->opt_fieldA, __isset.opt_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldA_ref() && {
    return {std::move(this->opt_fieldA), __isset.opt_fieldA};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldB_ref() const& {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldB_ref() const&& {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldB_ref() & {
    return {this->fieldB, __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldB_ref() && {
    return {std::move(this->fieldB), __isset.fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldB_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldB_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldB)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldB_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldB_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldB)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldB_ref() const& {
    return {this->opt_fieldB, __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldB_ref() const&& {
    return {std::move(this->opt_fieldB), __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldB_ref() & {
    return {this->opt_fieldB, __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldB_ref() && {
    return {std::move(this->opt_fieldB), __isset.opt_fieldB};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldC_ref() const& {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldC_ref() const&& {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldC_ref() & {
    return {this->fieldC, __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldC_ref() && {
    return {std::move(this->fieldC), __isset.fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldC_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldC_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldC)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldC_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldC_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldC)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldC_ref() const& {
    return {this->opt_fieldC, __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldC_ref() const&& {
    return {std::move(this->opt_fieldC), __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldC_ref() & {
    return {this->opt_fieldC, __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldC_ref() && {
    return {std::move(this->opt_fieldC), __isset.opt_fieldC};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldD_ref() const& {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldD_ref() const&& {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldD_ref() & {
    return {this->fieldD, __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldD_ref() && {
    return {std::move(this->fieldD), __isset.fieldD};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldE_ref() const& {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldE_ref() const&& {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldE_ref() & {
    return {this->fieldE, __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldE_ref() && {
    return {std::move(this->fieldE), __isset.fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldE_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldE_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldE)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldE_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldE_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldE)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldE_ref() const& {
    return {this->opt_fieldE, __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldE_ref() const&& {
    return {std::move(this->opt_fieldE), __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldE_ref() & {
    return {this->opt_fieldE, __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldE_ref() && {
    return {std::move(this->opt_fieldE), __isset.opt_fieldE};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldF_ref() const& {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldF_ref() const&& {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldF_ref() & {
    return {this->fieldF, __isset.fieldF};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldF_ref() && {
    return {std::move(this->fieldF), __isset.fieldF};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldG_ref() const& {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldG_ref() const&& {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldG_ref() & {
    return {this->fieldG, __isset.fieldG};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldG_ref() && {
    return {std::move(this->fieldG), __isset.fieldG};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldH_ref() const& {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldH_ref() const&& {
    return {std::move(this->fieldH), __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldH_ref() & {
    return {this->fieldH, __isset.fieldH};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldH_ref() && {
    return {std::move(this->fieldH), __isset.fieldH};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldI_ref() const& {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldI_ref() const&& {
    return {std::move(this->fieldI), __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldI_ref() & {
    return {this->fieldI, __isset.fieldI};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldI_ref() && {
    return {std::move(this->fieldI), __isset.fieldI};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldJ_ref() const& {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldJ_ref() const&& {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldJ_ref() & {
    return {this->fieldJ, __isset.fieldJ};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldJ_ref() && {
    return {std::move(this->fieldJ), __isset.fieldJ};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldK_ref() const& {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldK_ref() const&& {
    return {std::move(this->fieldK), __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldK_ref() & {
    return {this->fieldK, __isset.fieldK};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldK_ref() && {
    return {std::move(this->fieldK), __isset.fieldK};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldL_ref() const& {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldL_ref() const&& {
    return {std::move(this->fieldL), __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldL_ref() & {
    return {this->fieldL, __isset.fieldL};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldL_ref() && {
    return {std::move(this->fieldL), __isset.fieldL};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldM_ref() const& {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldM_ref() const&& {
    return {std::move(this->fieldM), __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldM_ref() & {
    return {this->fieldM, __isset.fieldM};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldM_ref() && {
    return {std::move(this->fieldM), __isset.fieldM};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldN_ref() const& {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldN_ref() const&& {
    return {std::move(this->fieldN), __isset.fieldN};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldN_ref() & {
    return {this->fieldN, __isset.fieldN};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldN_ref() && {
    return {std::move(this->fieldN), __isset.fieldN};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldO_ref() const& {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldO_ref() const&& {
    return {std::move(this->fieldO), __isset.fieldO};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldO_ref() & {
    return {this->fieldO, __isset.fieldO};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldO_ref() && {
    return {std::move(this->fieldO), __isset.fieldO};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldP_ref() const& {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldP_ref() const&& {
    return {std::move(this->fieldP), __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldP_ref() & {
    return {this->fieldP, __isset.fieldP};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldP_ref() && {
    return {std::move(this->fieldP), __isset.fieldP};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldQ_ref() const& {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldQ_ref() const&& {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldQ_ref() & {
    return {this->fieldQ, __isset.fieldQ};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldQ_ref() && {
    return {std::move(this->fieldQ), __isset.fieldQ};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldR_ref() const& {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldR_ref() const&& {
    return {std::move(this->fieldR), __isset.fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldR_ref() & {
    return {this->fieldR, __isset.fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldR_ref() && {
    return {std::move(this->fieldR), __isset.fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldR_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldR_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldR)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldR_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldR_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldR)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldR_ref() const& {
    return {this->opt_fieldR, __isset.opt_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldR_ref() const&& {
    return {std::move(this->opt_fieldR), __isset.opt_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldR_ref() & {
    return {this->opt_fieldR, __isset.opt_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldR_ref() && {
    return {std::move(this->opt_fieldR), __isset.opt_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldS_ref() const& {
    return {this->fieldS, __isset.fieldS};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldS_ref() const&& {
    return {std::move(this->fieldS), __isset.fieldS};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldS_ref() & {
    return {this->fieldS, __isset.fieldS};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldS_ref() && {
    return {std::move(this->fieldS), __isset.fieldS};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldT_ref() const& {
    return {this->fieldT, __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldT_ref() const&& {
    return {std::move(this->fieldT), __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldT_ref() & {
    return {this->fieldT, __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldT_ref() && {
    return {std::move(this->fieldT), __isset.fieldT};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldU_ref() const& {
    return {this->fieldU, __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldU_ref() const&& {
    return {std::move(this->fieldU), __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldU_ref() & {
    return {this->fieldU, __isset.fieldU};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldU_ref() && {
    return {std::move(this->fieldU), __isset.fieldU};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldV_ref() const& {
    return {this->fieldV, __isset.fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldV_ref() const&& {
    return {std::move(this->fieldV), __isset.fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldV_ref() & {
    return {this->fieldV, __isset.fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldV_ref() && {
    return {std::move(this->fieldV), __isset.fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldV_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldV_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldV)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldV_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldV_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldV)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldV_ref() const& {
    return {this->opt_fieldV, __isset.opt_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldV_ref() const&& {
    return {std::move(this->opt_fieldV), __isset.opt_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldV_ref() & {
    return {this->opt_fieldV, __isset.opt_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldV_ref() && {
    return {std::move(this->opt_fieldV), __isset.opt_fieldV};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldW_ref() const& {
    return {this->fieldW, __isset.fieldW};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldW_ref() const&& {
    return {std::move(this->fieldW), __isset.fieldW};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldW_ref() & {
    return {this->fieldW, __isset.fieldW};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldW_ref() && {
    return {std::move(this->fieldW), __isset.fieldW};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldX_ref() const& {
    return {this->fieldX, __isset.fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldX_ref() const&& {
    return {std::move(this->fieldX), __isset.fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldX_ref() & {
    return {this->fieldX, __isset.fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldX_ref() && {
    return {std::move(this->fieldX), __isset.fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldX_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldX_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->req_fieldX)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldX_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldX_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->req_fieldX)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldX_ref() const& {
    return {this->opt_fieldX, __isset.opt_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldX_ref() const&& {
    return {std::move(this->opt_fieldX), __isset.opt_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldX_ref() & {
    return {this->opt_fieldX, __isset.opt_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldX_ref() && {
    return {std::move(this->opt_fieldX), __isset.opt_fieldX};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldY_ref() const& {
    return {this->fieldY, __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldY_ref() const&& {
    return {std::move(this->fieldY), __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldY_ref() & {
    return {this->fieldY, __isset.fieldY};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldY_ref() && {
    return {std::move(this->fieldY), __isset.fieldY};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldZ_ref() const& {
    return {this->fieldZ, __isset.fieldZ};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldZ_ref() const&& {
    return {std::move(this->fieldZ), __isset.fieldZ};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldZ_ref() & {
    return {this->fieldZ, __isset.fieldZ};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldZ_ref() && {
    return {std::move(this->fieldZ), __isset.fieldZ};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAA_ref() const& {
    return {this->fieldAA, __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAA_ref() const&& {
    return {std::move(this->fieldAA), __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAA_ref() & {
    return {this->fieldAA, __isset.fieldAA};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAA_ref() && {
    return {std::move(this->fieldAA), __isset.fieldAA};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAB_ref() const& {
    return {this->fieldAB, __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAB_ref() const&& {
    return {std::move(this->fieldAB), __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAB_ref() & {
    return {this->fieldAB, __isset.fieldAB};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAB_ref() && {
    return {std::move(this->fieldAB), __isset.fieldAB};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAC_ref() const& {
    return {this->fieldAC, __isset.fieldAC};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAC_ref() const&& {
    return {std::move(this->fieldAC), __isset.fieldAC};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAC_ref() & {
    return {this->fieldAC, __isset.fieldAC};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAC_ref() && {
    return {std::move(this->fieldAC), __isset.fieldAC};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAD_ref() const& {
    return {this->fieldAD, __isset.fieldAD};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAD_ref() const&& {
    return {std::move(this->fieldAD), __isset.fieldAD};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAD_ref() & {
    return {this->fieldAD, __isset.fieldAD};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAD_ref() && {
    return {std::move(this->fieldAD), __isset.fieldAD};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAE_ref() const& {
    return {this->fieldAE, __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAE_ref() const&& {
    return {std::move(this->fieldAE), __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAE_ref() & {
    return {this->fieldAE, __isset.fieldAE};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAE_ref() && {
    return {std::move(this->fieldAE), __isset.fieldAE};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldSD_ref() const& {
    return {this->fieldSD, __isset.fieldSD};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldSD_ref() const&& {
    return {std::move(this->fieldSD), __isset.fieldSD};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldSD_ref() & {
    return {this->fieldSD, __isset.fieldSD};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldSD_ref() && {
    return {std::move(this->fieldSD), __isset.fieldSD};
  }

  bool get_fieldA() const {
    return fieldA;
  }

  [[deprecated("Use `FOO.fieldA_ref() = BAR;` instead of `FOO.set_fieldA(BAR);`")]]
  bool& set_fieldA(bool fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  bool get_req_fieldA() const {
    return req_fieldA;
  }

  [[deprecated("Use `FOO.req_fieldA_ref() = BAR;` instead of `FOO.set_req_fieldA(BAR);`")]]
  bool& set_req_fieldA(bool req_fieldA_) {
    req_fieldA = req_fieldA_;
    return req_fieldA;
  }

  const bool* get_opt_fieldA() const& {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }

  bool* get_opt_fieldA() & {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }
  bool* get_opt_fieldA() && = delete;

  [[deprecated("Use `FOO.opt_fieldA_ref() = BAR;` instead of `FOO.set_opt_fieldA(BAR);`")]]
  bool& set_opt_fieldA(bool opt_fieldA_) {
    opt_fieldA = opt_fieldA_;
    __isset.opt_fieldA = true;
    return opt_fieldA;
  }
  const ::std::map<::std::string, bool>& get_fieldB() const&;
  ::std::map<::std::string, bool> get_fieldB() &&;

  template <typename T_containerStruct_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.fieldB_ref() = BAR;` instead of `FOO.set_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_fieldB(T_containerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_containerStruct_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }
  const ::std::map<::std::string, bool>& get_req_fieldB() const&;
  ::std::map<::std::string, bool> get_req_fieldB() &&;

  template <typename T_containerStruct_req_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.req_fieldB_ref() = BAR;` instead of `FOO.set_req_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_req_fieldB(T_containerStruct_req_fieldB_struct_setter&& req_fieldB_) {
    req_fieldB = std::forward<T_containerStruct_req_fieldB_struct_setter>(req_fieldB_);
    return req_fieldB;
  }
  const ::std::map<::std::string, bool>* get_opt_fieldB() const&;
  ::std::map<::std::string, bool>* get_opt_fieldB() &;
  ::std::map<::std::string, bool>* get_opt_fieldB() && = delete;

  template <typename T_containerStruct_opt_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.opt_fieldB_ref() = BAR;` instead of `FOO.set_opt_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_opt_fieldB(T_containerStruct_opt_fieldB_struct_setter&& opt_fieldB_) {
    opt_fieldB = std::forward<T_containerStruct_opt_fieldB_struct_setter>(opt_fieldB_);
    __isset.opt_fieldB = true;
    return opt_fieldB;
  }
  const ::std::set<::std::int32_t>& get_fieldC() const&;
  ::std::set<::std::int32_t> get_fieldC() &&;

  template <typename T_containerStruct_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.fieldC_ref() = BAR;` instead of `FOO.set_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_fieldC(T_containerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC = std::forward<T_containerStruct_fieldC_struct_setter>(fieldC_);
    __isset.fieldC = true;
    return fieldC;
  }
  const ::std::set<::std::int32_t>& get_req_fieldC() const&;
  ::std::set<::std::int32_t> get_req_fieldC() &&;

  template <typename T_containerStruct_req_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.req_fieldC_ref() = BAR;` instead of `FOO.set_req_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_req_fieldC(T_containerStruct_req_fieldC_struct_setter&& req_fieldC_) {
    req_fieldC = std::forward<T_containerStruct_req_fieldC_struct_setter>(req_fieldC_);
    return req_fieldC;
  }
  const ::std::set<::std::int32_t>* get_opt_fieldC() const&;
  ::std::set<::std::int32_t>* get_opt_fieldC() &;
  ::std::set<::std::int32_t>* get_opt_fieldC() && = delete;

  template <typename T_containerStruct_opt_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.opt_fieldC_ref() = BAR;` instead of `FOO.set_opt_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_opt_fieldC(T_containerStruct_opt_fieldC_struct_setter&& opt_fieldC_) {
    opt_fieldC = std::forward<T_containerStruct_opt_fieldC_struct_setter>(opt_fieldC_);
    __isset.opt_fieldC = true;
    return opt_fieldC;
  }

  const ::std::string& get_fieldD() const& {
    return fieldD;
  }

  ::std::string get_fieldD() && {
    return std::move(fieldD);
  }

  template <typename T_containerStruct_fieldD_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldD_ref() = BAR;` instead of `FOO.set_fieldD(BAR);`")]]
  ::std::string& set_fieldD(T_containerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD = std::forward<T_containerStruct_fieldD_struct_setter>(fieldD_);
    __isset.fieldD = true;
    return fieldD;
  }

  const ::std::string& get_fieldE() const& {
    return fieldE;
  }

  ::std::string get_fieldE() && {
    return std::move(fieldE);
  }

  template <typename T_containerStruct_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldE_ref() = BAR;` instead of `FOO.set_fieldE(BAR);`")]]
  ::std::string& set_fieldE(T_containerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_containerStruct_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }

  const ::std::string& get_req_fieldE() const& {
    return req_fieldE;
  }

  ::std::string get_req_fieldE() && {
    return std::move(req_fieldE);
  }

  template <typename T_containerStruct_req_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.req_fieldE_ref() = BAR;` instead of `FOO.set_req_fieldE(BAR);`")]]
  ::std::string& set_req_fieldE(T_containerStruct_req_fieldE_struct_setter&& req_fieldE_) {
    req_fieldE = std::forward<T_containerStruct_req_fieldE_struct_setter>(req_fieldE_);
    return req_fieldE;
  }

  const ::std::string* get_opt_fieldE() const& {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }

  ::std::string* get_opt_fieldE() & {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }
  ::std::string* get_opt_fieldE() && = delete;

  template <typename T_containerStruct_opt_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.opt_fieldE_ref() = BAR;` instead of `FOO.set_opt_fieldE(BAR);`")]]
  ::std::string& set_opt_fieldE(T_containerStruct_opt_fieldE_struct_setter&& opt_fieldE_) {
    opt_fieldE = std::forward<T_containerStruct_opt_fieldE_struct_setter>(opt_fieldE_);
    __isset.opt_fieldE = true;
    return opt_fieldE;
  }
  const ::std::vector<::std::vector<::std::int32_t>>& get_fieldF() const&;
  ::std::vector<::std::vector<::std::int32_t>> get_fieldF() &&;

  template <typename T_containerStruct_fieldF_struct_setter = ::std::vector<::std::vector<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldF_ref() = BAR;` instead of `FOO.set_fieldF(BAR);`")]]
  ::std::vector<::std::vector<::std::int32_t>>& set_fieldF(T_containerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_containerStruct_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>& get_fieldG() const&;
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> get_fieldG() &&;

  template <typename T_containerStruct_fieldG_struct_setter = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  [[deprecated("Use `FOO.fieldG_ref() = BAR;` instead of `FOO.set_fieldG(BAR);`")]]
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>& set_fieldG(T_containerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_containerStruct_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const ::std::vector<::std::set<::std::int32_t>>& get_fieldH() const&;
  ::std::vector<::std::set<::std::int32_t>> get_fieldH() &&;

  template <typename T_containerStruct_fieldH_struct_setter = ::std::vector<::std::set<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldH_ref() = BAR;` instead of `FOO.set_fieldH(BAR);`")]]
  ::std::vector<::std::set<::std::int32_t>>& set_fieldH(T_containerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_containerStruct_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }

  bool get_fieldI() const {
    return fieldI;
  }

  [[deprecated("Use `FOO.fieldI_ref() = BAR;` instead of `FOO.set_fieldI(BAR);`")]]
  bool& set_fieldI(bool fieldI_) {
    fieldI = fieldI_;
    __isset.fieldI = true;
    return fieldI;
  }
  const ::std::map<::std::string, ::std::vector<::std::int32_t>>& get_fieldJ() const&;
  ::std::map<::std::string, ::std::vector<::std::int32_t>> get_fieldJ() &&;

  template <typename T_containerStruct_fieldJ_struct_setter = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldJ_ref() = BAR;` instead of `FOO.set_fieldJ(BAR);`")]]
  ::std::map<::std::string, ::std::vector<::std::int32_t>>& set_fieldJ(T_containerStruct_fieldJ_struct_setter&& fieldJ_) {
    fieldJ = std::forward<T_containerStruct_fieldJ_struct_setter>(fieldJ_);
    __isset.fieldJ = true;
    return fieldJ;
  }
  const ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>& get_fieldK() const&;
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> get_fieldK() &&;

  template <typename T_containerStruct_fieldK_struct_setter = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  [[deprecated("Use `FOO.fieldK_ref() = BAR;` instead of `FOO.set_fieldK(BAR);`")]]
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>& set_fieldK(T_containerStruct_fieldK_struct_setter&& fieldK_) {
    fieldK = std::forward<T_containerStruct_fieldK_struct_setter>(fieldK_);
    __isset.fieldK = true;
    return fieldK;
  }
  const ::std::set<::std::set<::std::set<bool>>>& get_fieldL() const&;
  ::std::set<::std::set<::std::set<bool>>> get_fieldL() &&;

  template <typename T_containerStruct_fieldL_struct_setter = ::std::set<::std::set<::std::set<bool>>>>
  [[deprecated("Use `FOO.fieldL_ref() = BAR;` instead of `FOO.set_fieldL(BAR);`")]]
  ::std::set<::std::set<::std::set<bool>>>& set_fieldL(T_containerStruct_fieldL_struct_setter&& fieldL_) {
    fieldL = std::forward<T_containerStruct_fieldL_struct_setter>(fieldL_);
    __isset.fieldL = true;
    return fieldL;
  }
  const ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& get_fieldM() const&;
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> get_fieldM() &&;

  template <typename T_containerStruct_fieldM_struct_setter = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  [[deprecated("Use `FOO.fieldM_ref() = BAR;` instead of `FOO.set_fieldM(BAR);`")]]
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& set_fieldM(T_containerStruct_fieldM_struct_setter&& fieldM_) {
    fieldM = std::forward<T_containerStruct_fieldM_struct_setter>(fieldM_);
    __isset.fieldM = true;
    return fieldM;
  }

  ::some::valid::ns::simpleTypeDef get_fieldN() const {
    return fieldN;
  }

  [[deprecated("Use `FOO.fieldN_ref() = BAR;` instead of `FOO.set_fieldN(BAR);`")]]
  ::some::valid::ns::simpleTypeDef& set_fieldN(::some::valid::ns::simpleTypeDef fieldN_) {
    fieldN = fieldN_;
    __isset.fieldN = true;
    return fieldN;
  }
  const ::some::valid::ns::complexStructTypeDef& get_fieldO() const&;
  ::some::valid::ns::complexStructTypeDef get_fieldO() &&;

  template <typename T_containerStruct_fieldO_struct_setter = ::some::valid::ns::complexStructTypeDef>
  [[deprecated("Use `FOO.fieldO_ref() = BAR;` instead of `FOO.set_fieldO(BAR);`")]]
  ::some::valid::ns::complexStructTypeDef& set_fieldO(T_containerStruct_fieldO_struct_setter&& fieldO_) {
    fieldO = std::forward<T_containerStruct_fieldO_struct_setter>(fieldO_);
    __isset.fieldO = true;
    return fieldO;
  }
  const ::std::vector<::some::valid::ns::mostComplexTypeDef>& get_fieldP() const&;
  ::std::vector<::some::valid::ns::mostComplexTypeDef> get_fieldP() &&;

  template <typename T_containerStruct_fieldP_struct_setter = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  [[deprecated("Use `FOO.fieldP_ref() = BAR;` instead of `FOO.set_fieldP(BAR);`")]]
  ::std::vector<::some::valid::ns::mostComplexTypeDef>& set_fieldP(T_containerStruct_fieldP_struct_setter&& fieldP_) {
    fieldP = std::forward<T_containerStruct_fieldP_struct_setter>(fieldP_);
    __isset.fieldP = true;
    return fieldP;
  }

  ::some::valid::ns::MyEnumA get_fieldQ() const {
    return fieldQ;
  }

  [[deprecated("Use `FOO.fieldQ_ref() = BAR;` instead of `FOO.set_fieldQ(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldQ(::some::valid::ns::MyEnumA fieldQ_) {
    fieldQ = fieldQ_;
    __isset.fieldQ = true;
    return fieldQ;
  }

  ::some::valid::ns::MyEnumA get_fieldR() const {
    return fieldR;
  }

  [[deprecated("Use `FOO.fieldR_ref() = BAR;` instead of `FOO.set_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldR(::some::valid::ns::MyEnumA fieldR_) {
    fieldR = fieldR_;
    __isset.fieldR = true;
    return fieldR;
  }

  ::some::valid::ns::MyEnumA get_req_fieldR() const {
    return req_fieldR;
  }

  [[deprecated("Use `FOO.req_fieldR_ref() = BAR;` instead of `FOO.set_req_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_req_fieldR(::some::valid::ns::MyEnumA req_fieldR_) {
    req_fieldR = req_fieldR_;
    return req_fieldR;
  }

  const ::some::valid::ns::MyEnumA* get_opt_fieldR() const& {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }

  ::some::valid::ns::MyEnumA* get_opt_fieldR() & {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }
  ::some::valid::ns::MyEnumA* get_opt_fieldR() && = delete;

  [[deprecated("Use `FOO.opt_fieldR_ref() = BAR;` instead of `FOO.set_opt_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_opt_fieldR(::some::valid::ns::MyEnumA opt_fieldR_) {
    opt_fieldR = opt_fieldR_;
    __isset.opt_fieldR = true;
    return opt_fieldR;
  }

  ::some::valid::ns::MyEnumA get_fieldS() const {
    return fieldS;
  }

  [[deprecated("Use `FOO.fieldS_ref() = BAR;` instead of `FOO.set_fieldS(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldS(::some::valid::ns::MyEnumA fieldS_) {
    fieldS = fieldS_;
    __isset.fieldS = true;
    return fieldS;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_fieldT() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_fieldT() &&;

  template <typename T_containerStruct_fieldT_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.fieldT_ref() = BAR;` instead of `FOO.set_fieldT(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_fieldT(T_containerStruct_fieldT_struct_setter&& fieldT_) {
    fieldT = std::forward<T_containerStruct_fieldT_struct_setter>(fieldT_);
    __isset.fieldT = true;
    return fieldT;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_fieldU() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_fieldU() &&;

  template <typename T_containerStruct_fieldU_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.fieldU_ref() = BAR;` instead of `FOO.set_fieldU(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_fieldU(T_containerStruct_fieldU_struct_setter&& fieldU_) {
    fieldU = std::forward<T_containerStruct_fieldU_struct_setter>(fieldU_);
    __isset.fieldU = true;
    return fieldU;
  }
  const ::some::valid::ns::MyStruct& get_fieldV() const&;
  ::some::valid::ns::MyStruct get_fieldV() &&;

  template <typename T_containerStruct_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.fieldV_ref() = BAR;` instead of `FOO.set_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_fieldV(T_containerStruct_fieldV_struct_setter&& fieldV_) {
    fieldV = std::forward<T_containerStruct_fieldV_struct_setter>(fieldV_);
    __isset.fieldV = true;
    return fieldV;
  }
  const ::some::valid::ns::MyStruct& get_req_fieldV() const&;
  ::some::valid::ns::MyStruct get_req_fieldV() &&;

  template <typename T_containerStruct_req_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.req_fieldV_ref() = BAR;` instead of `FOO.set_req_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_req_fieldV(T_containerStruct_req_fieldV_struct_setter&& req_fieldV_) {
    req_fieldV = std::forward<T_containerStruct_req_fieldV_struct_setter>(req_fieldV_);
    return req_fieldV;
  }
  const ::some::valid::ns::MyStruct* get_opt_fieldV() const&;
  ::some::valid::ns::MyStruct* get_opt_fieldV() &;
  ::some::valid::ns::MyStruct* get_opt_fieldV() && = delete;

  template <typename T_containerStruct_opt_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.opt_fieldV_ref() = BAR;` instead of `FOO.set_opt_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_opt_fieldV(T_containerStruct_opt_fieldV_struct_setter&& opt_fieldV_) {
    opt_fieldV = std::forward<T_containerStruct_opt_fieldV_struct_setter>(opt_fieldV_);
    __isset.opt_fieldV = true;
    return opt_fieldV;
  }
  const ::std::set<::some::valid::ns::MyStruct>& get_fieldW() const&;
  ::std::set<::some::valid::ns::MyStruct> get_fieldW() &&;

  template <typename T_containerStruct_fieldW_struct_setter = ::std::set<::some::valid::ns::MyStruct>>
  [[deprecated("Use `FOO.fieldW_ref() = BAR;` instead of `FOO.set_fieldW(BAR);`")]]
  ::std::set<::some::valid::ns::MyStruct>& set_fieldW(T_containerStruct_fieldW_struct_setter&& fieldW_) {
    fieldW = std::forward<T_containerStruct_fieldW_struct_setter>(fieldW_);
    __isset.fieldW = true;
    return fieldW;
  }
  const ::some::valid::ns::ComplexUnion& get_fieldX() const&;
  ::some::valid::ns::ComplexUnion get_fieldX() &&;

  template <typename T_containerStruct_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.fieldX_ref() = BAR;` instead of `FOO.set_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_fieldX(T_containerStruct_fieldX_struct_setter&& fieldX_) {
    fieldX = std::forward<T_containerStruct_fieldX_struct_setter>(fieldX_);
    __isset.fieldX = true;
    return fieldX;
  }
  const ::some::valid::ns::ComplexUnion& get_req_fieldX() const&;
  ::some::valid::ns::ComplexUnion get_req_fieldX() &&;

  template <typename T_containerStruct_req_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.req_fieldX_ref() = BAR;` instead of `FOO.set_req_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_req_fieldX(T_containerStruct_req_fieldX_struct_setter&& req_fieldX_) {
    req_fieldX = std::forward<T_containerStruct_req_fieldX_struct_setter>(req_fieldX_);
    return req_fieldX;
  }
  const ::some::valid::ns::ComplexUnion* get_opt_fieldX() const&;
  ::some::valid::ns::ComplexUnion* get_opt_fieldX() &;
  ::some::valid::ns::ComplexUnion* get_opt_fieldX() && = delete;

  template <typename T_containerStruct_opt_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.opt_fieldX_ref() = BAR;` instead of `FOO.set_opt_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_opt_fieldX(T_containerStruct_opt_fieldX_struct_setter&& opt_fieldX_) {
    opt_fieldX = std::forward<T_containerStruct_opt_fieldX_struct_setter>(opt_fieldX_);
    __isset.opt_fieldX = true;
    return opt_fieldX;
  }
  const ::std::vector<::some::valid::ns::ComplexUnion>& get_fieldY() const&;
  ::std::vector<::some::valid::ns::ComplexUnion> get_fieldY() &&;

  template <typename T_containerStruct_fieldY_struct_setter = ::std::vector<::some::valid::ns::ComplexUnion>>
  [[deprecated("Use `FOO.fieldY_ref() = BAR;` instead of `FOO.set_fieldY(BAR);`")]]
  ::std::vector<::some::valid::ns::ComplexUnion>& set_fieldY(T_containerStruct_fieldY_struct_setter&& fieldY_) {
    fieldY = std::forward<T_containerStruct_fieldY_struct_setter>(fieldY_);
    __isset.fieldY = true;
    return fieldY;
  }
  const ::some::valid::ns::unionTypeDef& get_fieldZ() const&;
  ::some::valid::ns::unionTypeDef get_fieldZ() &&;

  template <typename T_containerStruct_fieldZ_struct_setter = ::some::valid::ns::unionTypeDef>
  [[deprecated("Use `FOO.fieldZ_ref() = BAR;` instead of `FOO.set_fieldZ(BAR);`")]]
  ::some::valid::ns::unionTypeDef& set_fieldZ(T_containerStruct_fieldZ_struct_setter&& fieldZ_) {
    fieldZ = std::forward<T_containerStruct_fieldZ_struct_setter>(fieldZ_);
    __isset.fieldZ = true;
    return fieldZ;
  }
  const ::std::vector<::some::valid::ns::unionTypeDef>& get_fieldAA() const&;
  ::std::vector<::some::valid::ns::unionTypeDef> get_fieldAA() &&;

  template <typename T_containerStruct_fieldAA_struct_setter = ::std::vector<::some::valid::ns::unionTypeDef>>
  [[deprecated("Use `FOO.fieldAA_ref() = BAR;` instead of `FOO.set_fieldAA(BAR);`")]]
  ::std::vector<::some::valid::ns::unionTypeDef>& set_fieldAA(T_containerStruct_fieldAA_struct_setter&& fieldAA_) {
    fieldAA = std::forward<T_containerStruct_fieldAA_struct_setter>(fieldAA_);
    __isset.fieldAA = true;
    return fieldAA;
  }
  const ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>& get_fieldAB() const&;
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> get_fieldAB() &&;

  template <typename T_containerStruct_fieldAB_struct_setter = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  [[deprecated("Use `FOO.fieldAB_ref() = BAR;` instead of `FOO.set_fieldAB(BAR);`")]]
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>& set_fieldAB(T_containerStruct_fieldAB_struct_setter&& fieldAB_) {
    fieldAB = std::forward<T_containerStruct_fieldAB_struct_setter>(fieldAB_);
    __isset.fieldAB = true;
    return fieldAB;
  }

  ::some::valid::ns::MyEnumB get_fieldAC() const {
    return fieldAC;
  }

  [[deprecated("Use `FOO.fieldAC_ref() = BAR;` instead of `FOO.set_fieldAC(BAR);`")]]
  ::some::valid::ns::MyEnumB& set_fieldAC(::some::valid::ns::MyEnumB fieldAC_) {
    fieldAC = fieldAC_;
    __isset.fieldAC = true;
    return fieldAC;
  }

  ::a::different::ns::AnEnum get_fieldAD() const {
    return fieldAD;
  }

  [[deprecated("Use `FOO.fieldAD_ref() = BAR;` instead of `FOO.set_fieldAD(BAR);`")]]
  ::a::different::ns::AnEnum& set_fieldAD(::a::different::ns::AnEnum fieldAD_) {
    fieldAD = fieldAD_;
    __isset.fieldAD = true;
    return fieldAD;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_fieldAE() const&;
  ::std::map<::std::string, ::std::int32_t> get_fieldAE() &&;

  template <typename T_containerStruct_fieldAE_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.fieldAE_ref() = BAR;` instead of `FOO.set_fieldAE(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_fieldAE(T_containerStruct_fieldAE_struct_setter&& fieldAE_) {
    fieldAE = std::forward<T_containerStruct_fieldAE_struct_setter>(fieldAE_);
    __isset.fieldAE = true;
    return fieldAE;
  }

  const ::some::valid::ns::IndirectionD& get_fieldSD() const& {
    return fieldSD;
  }

  ::some::valid::ns::IndirectionD get_fieldSD() && {
    return std::move(fieldSD);
  }

  template <typename T_containerStruct_fieldSD_struct_setter = ::some::valid::ns::IndirectionD>
  [[deprecated("Use `FOO.fieldSD_ref() = BAR;` instead of `FOO.set_fieldSD(BAR);`")]]
  ::some::valid::ns::IndirectionD& set_fieldSD(T_containerStruct_fieldSD_struct_setter&& fieldSD_) {
    fieldSD = std::forward<T_containerStruct_fieldSD_struct_setter>(fieldSD_);
    __isset.fieldSD = true;
    return fieldSD;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<containerStruct>;
  friend void swap(containerStruct& a, containerStruct& b);
};

template <class Protocol_>
uint32_t containerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class MyIncludedStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = MyIncludedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyIncludedStruct() :
      MyIncludedInt(42LL),
      ARefField(std::make_unique<::some::valid::ns::AStruct>()) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyIncludedStruct(apache::thrift::FragileConstructor, ::a::different::ns::IncludedInt64 MyIncludedInt__arg, ::some::valid::ns::AStruct MyIncludedStruct__arg, ::std::unique_ptr<::some::valid::ns::AStruct> ARefField__arg, ::some::valid::ns::AStruct ARequiredField__arg);

  MyIncludedStruct(MyIncludedStruct&&) noexcept;
  MyIncludedStruct(const MyIncludedStruct& src);


  MyIncludedStruct& operator=(MyIncludedStruct&&) noexcept;
  MyIncludedStruct& operator=(const MyIncludedStruct& src);
  void __clear();
 private:
  ::a::different::ns::IncludedInt64 MyIncludedInt;
 private:
  ::some::valid::ns::AStruct MyIncludedStruct;
 public:
  ::std::unique_ptr<::some::valid::ns::AStruct> ARefField;
 public:
  ::some::valid::ns::AStruct ARequiredField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool MyIncludedInt;
    bool MyIncludedStruct;
  } __isset = {};

 public:

  bool operator==(const MyIncludedStruct&) const;
  bool operator<(const MyIncludedStruct&) const;

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedInt_ref() const& {
    return {this->MyIncludedInt, __isset.MyIncludedInt};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedInt_ref() const&& {
    return {std::move(this->MyIncludedInt), __isset.MyIncludedInt};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedInt_ref() & {
    return {this->MyIncludedInt, __isset.MyIncludedInt};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedInt_ref() && {
    return {std::move(this->MyIncludedInt), __isset.MyIncludedInt};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedStruct_ref() const& {
    return {this->MyIncludedStruct, __isset.MyIncludedStruct};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedStruct_ref() const&& {
    return {std::move(this->MyIncludedStruct), __isset.MyIncludedStruct};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedStruct_ref() & {
    return {this->MyIncludedStruct, __isset.MyIncludedStruct};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedStruct_ref() && {
    return {std::move(this->MyIncludedStruct), __isset.MyIncludedStruct};
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T& ARefField_ref() & { return ARefField; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T& ARefField_ref() const& { return ARefField; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T&& ARefField_ref() && { return std::move(ARefField); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T&& ARefField_ref() const&& { return std::move(ARefField); }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> ARequiredField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> ARequiredField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->ARequiredField)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> ARequiredField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> ARequiredField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->ARequiredField)};
  }

  ::a::different::ns::IncludedInt64 get_MyIncludedInt() const {
    return MyIncludedInt;
  }

  [[deprecated("Use `FOO.MyIncludedInt_ref() = BAR;` instead of `FOO.set_MyIncludedInt(BAR);`")]]
  ::a::different::ns::IncludedInt64& set_MyIncludedInt(::a::different::ns::IncludedInt64 MyIncludedInt_) {
    MyIncludedInt = MyIncludedInt_;
    __isset.MyIncludedInt = true;
    return MyIncludedInt;
  }
  const ::some::valid::ns::AStruct& get_MyIncludedStruct() const&;
  ::some::valid::ns::AStruct get_MyIncludedStruct() &&;

  template <typename T_MyIncludedStruct_MyIncludedStruct_struct_setter = ::some::valid::ns::AStruct>
  [[deprecated("Use `FOO.MyIncludedStruct_ref() = BAR;` instead of `FOO.set_MyIncludedStruct(BAR);`")]]
  ::some::valid::ns::AStruct& set_MyIncludedStruct(T_MyIncludedStruct_MyIncludedStruct_struct_setter&& MyIncludedStruct_) {
    MyIncludedStruct = std::forward<T_MyIncludedStruct_MyIncludedStruct_struct_setter>(MyIncludedStruct_);
    __isset.MyIncludedStruct = true;
    return MyIncludedStruct;
  }
  const ::some::valid::ns::AStruct& get_ARequiredField() const&;
  ::some::valid::ns::AStruct get_ARequiredField() &&;

  template <typename T_MyIncludedStruct_ARequiredField_struct_setter = ::some::valid::ns::AStruct>
  [[deprecated("Use `FOO.ARequiredField_ref() = BAR;` instead of `FOO.set_ARequiredField(BAR);`")]]
  ::some::valid::ns::AStruct& set_ARequiredField(T_MyIncludedStruct_ARequiredField_struct_setter&& ARequiredField_) {
    ARequiredField = std::forward<T_MyIncludedStruct_ARequiredField_struct_setter>(ARequiredField_);
    return ARequiredField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyIncludedStruct>;
  friend void swap(MyIncludedStruct& a, MyIncludedStruct& b);
};

template <class Protocol_>
uint32_t MyIncludedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class AnnotatedStruct  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AnnotatedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnnotatedStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnnotatedStruct(apache::thrift::FragileConstructor, ::some::valid::ns::containerStruct no_annotation__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> cpp2_unique_ref__arg, ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp2_unique_ref__arg, ::std::unique_ptr<::std::vector<::std::string>> req_container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp2_unique_ref__arg, ::std::unique_ptr<::std::set<::std::int32_t>> opt_container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> ref_type_unique__arg, ::std::shared_ptr<::some::valid::ns::containerStruct> ref_type_shared__arg, ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>> ref_type_const__arg, ::std::shared_ptr<::some::valid::ns::containerStruct> req_ref_type_shared__arg, ::std::shared_ptr<const ::some::valid::ns::containerStruct> req_ref_type_const__arg, ::std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique__arg, ::std::shared_ptr<const ::some::valid::ns::containerStruct> opt_ref_type_const__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_ref_type_unique__arg, ::std::shared_ptr<::std::set<::std::int32_t>> opt_ref_type_shared__arg, ::some::valid::ns::CppFakeI32 base_type__arg, ::some::valid::ns::FollySmallVectorI64 list_type__arg, ::some::valid::ns::SortedVectorSetString set_type__arg, ::some::valid::ns::FakeMap map_type__arg, ::some::valid::ns::UnorderedMapStruct map_struct_type__arg, ::some::valid::ns::IOBuf iobuf_type__arg, ::some::valid::ns::IOBufPtr iobuf_ptr__arg, std::list<::std::int32_t> list_i32_template__arg, std::deque<::std::string> list_string_template__arg, folly::sorted_vector_set<::std::string> set_template__arg, folly::sorted_vector_map<::std::int64_t, ::std::string> map_template__arg, ::some::valid::ns::std_list typedef_list_template__arg, ::some::valid::ns::std_deque typedef_deque_template__arg, ::some::valid::ns::folly_set typedef_set_template__arg, ::some::valid::ns::folly_map typedef_map_template__arg, ::some::valid::ns::IndirectionA indirection_a__arg, ::std::vector<::some::valid::ns::IndirectionB> indirection_b__arg, ::std::set<::some::valid::ns::IndirectionC> indirection_c__arg, ::some::valid::ns::IOBuf iobuf_type_val__arg, ::some::valid::ns::IOBufPtr iobuf_ptr_val__arg, ::some::valid::ns::containerStruct struct_struct__arg);

  AnnotatedStruct(AnnotatedStruct&&) = default;


  AnnotatedStruct& operator=(AnnotatedStruct&&) = default;
  void __clear();

  virtual ~AnnotatedStruct();

 private:
  ::some::valid::ns::containerStruct no_annotation;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> cpp_unique_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> cpp2_unique_ref;
 public:
  ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> container_with_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp_unique_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp2_unique_ref;
 public:
  ::std::unique_ptr<::std::vector<::std::string>> req_container_with_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp_unique_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp2_unique_ref;
 public:
  ::std::unique_ptr<::std::set<::std::int32_t>> opt_container_with_ref;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> ref_type_unique;
 public:
  ::std::shared_ptr<::some::valid::ns::containerStruct> ref_type_shared;
 public:
  ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>> ref_type_const;
 public:
  ::std::shared_ptr<::some::valid::ns::containerStruct> req_ref_type_shared;
 public:
  ::std::shared_ptr<const ::some::valid::ns::containerStruct> req_ref_type_const;
 public:
  ::std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique;
 public:
  ::std::shared_ptr<const ::some::valid::ns::containerStruct> opt_ref_type_const;
 public:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_ref_type_unique;
 public:
  ::std::shared_ptr<::std::set<::std::int32_t>> opt_ref_type_shared;
 private:
  ::some::valid::ns::CppFakeI32 base_type;
 private:
  ::some::valid::ns::FollySmallVectorI64 list_type;
 private:
  ::some::valid::ns::SortedVectorSetString set_type;
 private:
  ::some::valid::ns::FakeMap map_type;
 private:
  ::some::valid::ns::UnorderedMapStruct map_struct_type;
 private:
  ::some::valid::ns::IOBuf iobuf_type;
 public:
  ::some::valid::ns::IOBufPtr iobuf_ptr;
 private:
  std::list<::std::int32_t> list_i32_template;
 private:
  std::deque<::std::string> list_string_template;
 private:
  folly::sorted_vector_set<::std::string> set_template;
 private:
  folly::sorted_vector_map<::std::int64_t, ::std::string> map_template;
 private:
  ::some::valid::ns::std_list typedef_list_template;
 private:
  ::some::valid::ns::std_deque typedef_deque_template;
 private:
  ::some::valid::ns::folly_set typedef_set_template;
 private:
  ::some::valid::ns::folly_map typedef_map_template;
 private:
  ::some::valid::ns::IndirectionA indirection_a;
 private:
  ::std::vector<::some::valid::ns::IndirectionB> indirection_b;
 private:
  ::std::set<::some::valid::ns::IndirectionC> indirection_c;
 private:
  ::some::valid::ns::IOBuf iobuf_type_val;
 public:
  ::some::valid::ns::IOBufPtr iobuf_ptr_val;
 private:
  ::some::valid::ns::containerStruct struct_struct;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool no_annotation;
    bool base_type;
    bool list_type;
    bool set_type;
    bool map_type;
    bool map_struct_type;
    bool iobuf_type;
    bool iobuf_ptr;
    bool list_i32_template;
    bool list_string_template;
    bool set_template;
    bool map_template;
    bool typedef_list_template;
    bool typedef_deque_template;
    bool typedef_set_template;
    bool typedef_map_template;
    bool indirection_a;
    bool indirection_b;
    bool indirection_c;
    bool iobuf_type_val;
    bool iobuf_ptr_val;
    bool struct_struct;
  } __isset = {};

 public:

  bool operator==(const AnnotatedStruct&) const;
  bool operator<(const AnnotatedStruct&) const;

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> no_annotation_ref() const& {
    return {this->no_annotation, __isset.no_annotation};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> no_annotation_ref() const&& {
    return {std::move(this->no_annotation), __isset.no_annotation};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> no_annotation_ref() & {
    return {this->no_annotation, __isset.no_annotation};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> no_annotation_ref() && {
    return {std::move(this->no_annotation), __isset.no_annotation};
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp_unique_ref_ref() & { return cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp_unique_ref_ref() const& { return cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp_unique_ref_ref() && { return std::move(cpp_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp_unique_ref_ref() const&& { return std::move(cpp_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp2_unique_ref_ref() & { return cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp2_unique_ref_ref() const& { return cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp2_unique_ref_ref() && { return std::move(cpp2_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp2_unique_ref_ref() const&& { return std::move(cpp2_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& container_with_ref_ref() & { return container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& container_with_ref_ref() const& { return container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& container_with_ref_ref() && { return std::move(container_with_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& container_with_ref_ref() const&& { return std::move(container_with_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp_unique_ref_ref() & { return req_cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp_unique_ref_ref() const& { return req_cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp_unique_ref_ref() && { return std::move(req_cpp_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp_unique_ref_ref() const&& { return std::move(req_cpp_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp2_unique_ref_ref() & { return req_cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp2_unique_ref_ref() const& { return req_cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp2_unique_ref_ref() && { return std::move(req_cpp2_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp2_unique_ref_ref() const&& { return std::move(req_cpp2_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_container_with_ref_ref() & { return req_container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_container_with_ref_ref() const& { return req_container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_container_with_ref_ref() && { return std::move(req_container_with_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_container_with_ref_ref() const&& { return std::move(req_container_with_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp_unique_ref_ref() & { return opt_cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp_unique_ref_ref() const& { return opt_cpp_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp_unique_ref_ref() && { return std::move(opt_cpp_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp_unique_ref_ref() const&& { return std::move(opt_cpp_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp2_unique_ref_ref() & { return opt_cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp2_unique_ref_ref() const& { return opt_cpp2_unique_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp2_unique_ref_ref() && { return std::move(opt_cpp2_unique_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp2_unique_ref_ref() const&& { return std::move(opt_cpp2_unique_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T& opt_container_with_ref_ref() & { return opt_container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T& opt_container_with_ref_ref() const& { return opt_container_with_ref; }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T&& opt_container_with_ref_ref() && { return std::move(opt_container_with_ref); }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T&& opt_container_with_ref_ref() const&& { return std::move(opt_container_with_ref); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_unique_ref() & { return ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_unique_ref() const& { return ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_unique_ref() && { return std::move(ref_type_unique); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_unique_ref() const&& { return std::move(ref_type_unique); }
  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_shared_ref() & { return ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_shared_ref() const& { return ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_shared_ref() && { return std::move(ref_type_shared); }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_shared_ref() const&& { return std::move(ref_type_shared); }
  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& ref_type_const_ref() & { return ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& ref_type_const_ref() const& { return ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& ref_type_const_ref() && { return std::move(ref_type_const); }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& ref_type_const_ref() const&& { return std::move(ref_type_const); }
  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_shared_ref() & { return req_ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_shared_ref() const& { return req_ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_shared_ref() && { return std::move(req_ref_type_shared); }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_shared_ref() const&& { return std::move(req_ref_type_shared); }
  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_const_ref() & { return req_ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_const_ref() const& { return req_ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_const_ref() && { return std::move(req_ref_type_const); }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_const_ref() const&& { return std::move(req_ref_type_const); }
  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_ref_type_unique_ref() & { return req_ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_ref_type_unique_ref() const& { return req_ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_ref_type_unique_ref() && { return std::move(req_ref_type_unique); }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_ref_type_unique_ref() const&& { return std::move(req_ref_type_unique); }
  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_const_ref() & { return opt_ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_const_ref() const& { return opt_ref_type_const; }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_const_ref() && { return std::move(opt_ref_type_const); }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_const_ref() const&& { return std::move(opt_ref_type_const); }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_unique_ref() & { return opt_ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_unique_ref() const& { return opt_ref_type_unique; }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_unique_ref() && { return std::move(opt_ref_type_unique); }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_unique_ref() const&& { return std::move(opt_ref_type_unique); }
  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T& opt_ref_type_shared_ref() & { return opt_ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T& opt_ref_type_shared_ref() const& { return opt_ref_type_shared; }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T&& opt_ref_type_shared_ref() && { return std::move(opt_ref_type_shared); }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T&& opt_ref_type_shared_ref() const&& { return std::move(opt_ref_type_shared); }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> base_type_ref() const& {
    return {this->base_type, __isset.base_type};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> base_type_ref() const&& {
    return {std::move(this->base_type), __isset.base_type};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> base_type_ref() & {
    return {this->base_type, __isset.base_type};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> base_type_ref() && {
    return {std::move(this->base_type), __isset.base_type};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_type_ref() const& {
    return {this->list_type, __isset.list_type};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_type_ref() const&& {
    return {std::move(this->list_type), __isset.list_type};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_type_ref() & {
    return {this->list_type, __isset.list_type};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_type_ref() && {
    return {std::move(this->list_type), __isset.list_type};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_type_ref() const& {
    return {this->set_type, __isset.set_type};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_type_ref() const&& {
    return {std::move(this->set_type), __isset.set_type};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_type_ref() & {
    return {this->set_type, __isset.set_type};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_type_ref() && {
    return {std::move(this->set_type), __isset.set_type};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_type_ref() const& {
    return {this->map_type, __isset.map_type};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_type_ref() const&& {
    return {std::move(this->map_type), __isset.map_type};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_type_ref() & {
    return {this->map_type, __isset.map_type};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_type_ref() && {
    return {std::move(this->map_type), __isset.map_type};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_struct_type_ref() const& {
    return {this->map_struct_type, __isset.map_struct_type};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_struct_type_ref() const&& {
    return {std::move(this->map_struct_type), __isset.map_struct_type};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_struct_type_ref() & {
    return {this->map_struct_type, __isset.map_struct_type};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_struct_type_ref() && {
    return {std::move(this->map_struct_type), __isset.map_struct_type};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_ref() const& {
    return {this->iobuf_type, __isset.iobuf_type};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_ref() const&& {
    return {std::move(this->iobuf_type), __isset.iobuf_type};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_ref() & {
    return {this->iobuf_type, __isset.iobuf_type};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_ref() && {
    return {std::move(this->iobuf_type), __isset.iobuf_type};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_ref() const& {
    return {this->iobuf_ptr, __isset.iobuf_ptr};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_ref() const&& {
    return {std::move(this->iobuf_ptr), __isset.iobuf_ptr};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_ref() & {
    return {this->iobuf_ptr, __isset.iobuf_ptr};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_ref() && {
    return {std::move(this->iobuf_ptr), __isset.iobuf_ptr};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_i32_template_ref() const& {
    return {this->list_i32_template, __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_i32_template_ref() const&& {
    return {std::move(this->list_i32_template), __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_i32_template_ref() & {
    return {this->list_i32_template, __isset.list_i32_template};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_i32_template_ref() && {
    return {std::move(this->list_i32_template), __isset.list_i32_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_string_template_ref() const& {
    return {this->list_string_template, __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_string_template_ref() const&& {
    return {std::move(this->list_string_template), __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_string_template_ref() & {
    return {this->list_string_template, __isset.list_string_template};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_string_template_ref() && {
    return {std::move(this->list_string_template), __isset.list_string_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_template_ref() const& {
    return {this->set_template, __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_template_ref() const&& {
    return {std::move(this->set_template), __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_template_ref() & {
    return {this->set_template, __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_template_ref() && {
    return {std::move(this->set_template), __isset.set_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_template_ref() const& {
    return {this->map_template, __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_template_ref() const&& {
    return {std::move(this->map_template), __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_template_ref() & {
    return {this->map_template, __isset.map_template};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_template_ref() && {
    return {std::move(this->map_template), __isset.map_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_list_template_ref() const& {
    return {this->typedef_list_template, __isset.typedef_list_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_list_template_ref() const&& {
    return {std::move(this->typedef_list_template), __isset.typedef_list_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_list_template_ref() & {
    return {this->typedef_list_template, __isset.typedef_list_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_list_template_ref() && {
    return {std::move(this->typedef_list_template), __isset.typedef_list_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_deque_template_ref() const& {
    return {this->typedef_deque_template, __isset.typedef_deque_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_deque_template_ref() const&& {
    return {std::move(this->typedef_deque_template), __isset.typedef_deque_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_deque_template_ref() & {
    return {this->typedef_deque_template, __isset.typedef_deque_template};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_deque_template_ref() && {
    return {std::move(this->typedef_deque_template), __isset.typedef_deque_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_set_template_ref() const& {
    return {this->typedef_set_template, __isset.typedef_set_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_set_template_ref() const&& {
    return {std::move(this->typedef_set_template), __isset.typedef_set_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_set_template_ref() & {
    return {this->typedef_set_template, __isset.typedef_set_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_set_template_ref() && {
    return {std::move(this->typedef_set_template), __isset.typedef_set_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_map_template_ref() const& {
    return {this->typedef_map_template, __isset.typedef_map_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_map_template_ref() const&& {
    return {std::move(this->typedef_map_template), __isset.typedef_map_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_map_template_ref() & {
    return {this->typedef_map_template, __isset.typedef_map_template};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_map_template_ref() && {
    return {std::move(this->typedef_map_template), __isset.typedef_map_template};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_a_ref() const& {
    return {this->indirection_a, __isset.indirection_a};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_a_ref() const&& {
    return {std::move(this->indirection_a), __isset.indirection_a};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_a_ref() & {
    return {this->indirection_a, __isset.indirection_a};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_a_ref() && {
    return {std::move(this->indirection_a), __isset.indirection_a};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_b_ref() const& {
    return {this->indirection_b, __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_b_ref() const&& {
    return {std::move(this->indirection_b), __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_b_ref() & {
    return {this->indirection_b, __isset.indirection_b};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_b_ref() && {
    return {std::move(this->indirection_b), __isset.indirection_b};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_c_ref() const& {
    return {this->indirection_c, __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_c_ref() const&& {
    return {std::move(this->indirection_c), __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_c_ref() & {
    return {this->indirection_c, __isset.indirection_c};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_c_ref() && {
    return {std::move(this->indirection_c), __isset.indirection_c};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_val_ref() const& {
    return {this->iobuf_type_val, __isset.iobuf_type_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_val_ref() const&& {
    return {std::move(this->iobuf_type_val), __isset.iobuf_type_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_val_ref() & {
    return {this->iobuf_type_val, __isset.iobuf_type_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_val_ref() && {
    return {std::move(this->iobuf_type_val), __isset.iobuf_type_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_val_ref() const& {
    return {this->iobuf_ptr_val, __isset.iobuf_ptr_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_val_ref() const&& {
    return {std::move(this->iobuf_ptr_val), __isset.iobuf_ptr_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_val_ref() & {
    return {this->iobuf_ptr_val, __isset.iobuf_ptr_val};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_val_ref() && {
    return {std::move(this->iobuf_ptr_val), __isset.iobuf_ptr_val};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> struct_struct_ref() const& {
    return {this->struct_struct, __isset.struct_struct};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> struct_struct_ref() const&& {
    return {std::move(this->struct_struct), __isset.struct_struct};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> struct_struct_ref() & {
    return {this->struct_struct, __isset.struct_struct};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> struct_struct_ref() && {
    return {std::move(this->struct_struct), __isset.struct_struct};
  }
  const ::some::valid::ns::containerStruct& get_no_annotation() const&;
  ::some::valid::ns::containerStruct get_no_annotation() &&;

  template <typename T_AnnotatedStruct_no_annotation_struct_setter = ::some::valid::ns::containerStruct>
  [[deprecated("Use `FOO.no_annotation_ref() = BAR;` instead of `FOO.set_no_annotation(BAR);`")]]
  ::some::valid::ns::containerStruct& set_no_annotation(T_AnnotatedStruct_no_annotation_struct_setter&& no_annotation_) {
    no_annotation = std::forward<T_AnnotatedStruct_no_annotation_struct_setter>(no_annotation_);
    __isset.no_annotation = true;
    return no_annotation;
  }

  ::some::valid::ns::CppFakeI32 get_base_type() const {
    return base_type;
  }

  [[deprecated("Use `FOO.base_type_ref() = BAR;` instead of `FOO.set_base_type(BAR);`")]]
  ::some::valid::ns::CppFakeI32& set_base_type(::some::valid::ns::CppFakeI32 base_type_) {
    base_type = base_type_;
    __isset.base_type = true;
    return base_type;
  }
  const ::some::valid::ns::FollySmallVectorI64& get_list_type() const&;
  ::some::valid::ns::FollySmallVectorI64 get_list_type() &&;

  template <typename T_AnnotatedStruct_list_type_struct_setter = ::some::valid::ns::FollySmallVectorI64>
  [[deprecated("Use `FOO.list_type_ref() = BAR;` instead of `FOO.set_list_type(BAR);`")]]
  ::some::valid::ns::FollySmallVectorI64& set_list_type(T_AnnotatedStruct_list_type_struct_setter&& list_type_) {
    list_type = std::forward<T_AnnotatedStruct_list_type_struct_setter>(list_type_);
    __isset.list_type = true;
    return list_type;
  }
  const ::some::valid::ns::SortedVectorSetString& get_set_type() const&;
  ::some::valid::ns::SortedVectorSetString get_set_type() &&;

  template <typename T_AnnotatedStruct_set_type_struct_setter = ::some::valid::ns::SortedVectorSetString>
  [[deprecated("Use `FOO.set_type_ref() = BAR;` instead of `FOO.set_set_type(BAR);`")]]
  ::some::valid::ns::SortedVectorSetString& set_set_type(T_AnnotatedStruct_set_type_struct_setter&& set_type_) {
    set_type = std::forward<T_AnnotatedStruct_set_type_struct_setter>(set_type_);
    __isset.set_type = true;
    return set_type;
  }
  const ::some::valid::ns::FakeMap& get_map_type() const&;
  ::some::valid::ns::FakeMap get_map_type() &&;

  template <typename T_AnnotatedStruct_map_type_struct_setter = ::some::valid::ns::FakeMap>
  [[deprecated("Use `FOO.map_type_ref() = BAR;` instead of `FOO.set_map_type(BAR);`")]]
  ::some::valid::ns::FakeMap& set_map_type(T_AnnotatedStruct_map_type_struct_setter&& map_type_) {
    map_type = std::forward<T_AnnotatedStruct_map_type_struct_setter>(map_type_);
    __isset.map_type = true;
    return map_type;
  }
  const ::some::valid::ns::UnorderedMapStruct& get_map_struct_type() const&;
  ::some::valid::ns::UnorderedMapStruct get_map_struct_type() &&;

  template <typename T_AnnotatedStruct_map_struct_type_struct_setter = ::some::valid::ns::UnorderedMapStruct>
  [[deprecated("Use `FOO.map_struct_type_ref() = BAR;` instead of `FOO.set_map_struct_type(BAR);`")]]
  ::some::valid::ns::UnorderedMapStruct& set_map_struct_type(T_AnnotatedStruct_map_struct_type_struct_setter&& map_struct_type_) {
    map_struct_type = std::forward<T_AnnotatedStruct_map_struct_type_struct_setter>(map_struct_type_);
    __isset.map_struct_type = true;
    return map_struct_type;
  }

  const ::some::valid::ns::IOBuf& get_iobuf_type() const& {
    return iobuf_type;
  }

  ::some::valid::ns::IOBuf get_iobuf_type() && {
    return std::move(iobuf_type);
  }

  template <typename T_AnnotatedStruct_iobuf_type_struct_setter = ::some::valid::ns::IOBuf>
  [[deprecated("Use `FOO.iobuf_type_ref() = BAR;` instead of `FOO.set_iobuf_type(BAR);`")]]
  ::some::valid::ns::IOBuf& set_iobuf_type(T_AnnotatedStruct_iobuf_type_struct_setter&& iobuf_type_) {
    iobuf_type = std::forward<T_AnnotatedStruct_iobuf_type_struct_setter>(iobuf_type_);
    __isset.iobuf_type = true;
    return iobuf_type;
  }

  const ::some::valid::ns::IOBufPtr& get_iobuf_ptr() const& {
    return iobuf_ptr;
  }

  ::some::valid::ns::IOBufPtr get_iobuf_ptr() && {
    return std::move(iobuf_ptr);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_struct_setter = ::some::valid::ns::IOBufPtr>
  [[deprecated("Use `FOO.iobuf_ptr_ref() = BAR;` instead of `FOO.set_iobuf_ptr(BAR);`")]]
  ::some::valid::ns::IOBufPtr& set_iobuf_ptr(T_AnnotatedStruct_iobuf_ptr_struct_setter&& iobuf_ptr_) {
    iobuf_ptr = std::forward<T_AnnotatedStruct_iobuf_ptr_struct_setter>(iobuf_ptr_);
    __isset.iobuf_ptr = true;
    return iobuf_ptr;
  }
  const std::list<::std::int32_t>& get_list_i32_template() const&;
  std::list<::std::int32_t> get_list_i32_template() &&;

  template <typename T_AnnotatedStruct_list_i32_template_struct_setter = std::list<::std::int32_t>>
  [[deprecated("Use `FOO.list_i32_template_ref() = BAR;` instead of `FOO.set_list_i32_template(BAR);`")]]
  std::list<::std::int32_t>& set_list_i32_template(T_AnnotatedStruct_list_i32_template_struct_setter&& list_i32_template_) {
    list_i32_template = std::forward<T_AnnotatedStruct_list_i32_template_struct_setter>(list_i32_template_);
    __isset.list_i32_template = true;
    return list_i32_template;
  }
  const std::deque<::std::string>& get_list_string_template() const&;
  std::deque<::std::string> get_list_string_template() &&;

  template <typename T_AnnotatedStruct_list_string_template_struct_setter = std::deque<::std::string>>
  [[deprecated("Use `FOO.list_string_template_ref() = BAR;` instead of `FOO.set_list_string_template(BAR);`")]]
  std::deque<::std::string>& set_list_string_template(T_AnnotatedStruct_list_string_template_struct_setter&& list_string_template_) {
    list_string_template = std::forward<T_AnnotatedStruct_list_string_template_struct_setter>(list_string_template_);
    __isset.list_string_template = true;
    return list_string_template;
  }
  const folly::sorted_vector_set<::std::string>& get_set_template() const&;
  folly::sorted_vector_set<::std::string> get_set_template() &&;

  template <typename T_AnnotatedStruct_set_template_struct_setter = folly::sorted_vector_set<::std::string>>
  [[deprecated("Use `FOO.set_template_ref() = BAR;` instead of `FOO.set_set_template(BAR);`")]]
  folly::sorted_vector_set<::std::string>& set_set_template(T_AnnotatedStruct_set_template_struct_setter&& set_template_) {
    set_template = std::forward<T_AnnotatedStruct_set_template_struct_setter>(set_template_);
    __isset.set_template = true;
    return set_template;
  }
  const folly::sorted_vector_map<::std::int64_t, ::std::string>& get_map_template() const&;
  folly::sorted_vector_map<::std::int64_t, ::std::string> get_map_template() &&;

  template <typename T_AnnotatedStruct_map_template_struct_setter = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  [[deprecated("Use `FOO.map_template_ref() = BAR;` instead of `FOO.set_map_template(BAR);`")]]
  folly::sorted_vector_map<::std::int64_t, ::std::string>& set_map_template(T_AnnotatedStruct_map_template_struct_setter&& map_template_) {
    map_template = std::forward<T_AnnotatedStruct_map_template_struct_setter>(map_template_);
    __isset.map_template = true;
    return map_template;
  }
  const ::some::valid::ns::std_list& get_typedef_list_template() const&;
  ::some::valid::ns::std_list get_typedef_list_template() &&;

  template <typename T_AnnotatedStruct_typedef_list_template_struct_setter = ::some::valid::ns::std_list>
  [[deprecated("Use `FOO.typedef_list_template_ref() = BAR;` instead of `FOO.set_typedef_list_template(BAR);`")]]
  ::some::valid::ns::std_list& set_typedef_list_template(T_AnnotatedStruct_typedef_list_template_struct_setter&& typedef_list_template_) {
    typedef_list_template = std::forward<T_AnnotatedStruct_typedef_list_template_struct_setter>(typedef_list_template_);
    __isset.typedef_list_template = true;
    return typedef_list_template;
  }
  const ::some::valid::ns::std_deque& get_typedef_deque_template() const&;
  ::some::valid::ns::std_deque get_typedef_deque_template() &&;

  template <typename T_AnnotatedStruct_typedef_deque_template_struct_setter = ::some::valid::ns::std_deque>
  [[deprecated("Use `FOO.typedef_deque_template_ref() = BAR;` instead of `FOO.set_typedef_deque_template(BAR);`")]]
  ::some::valid::ns::std_deque& set_typedef_deque_template(T_AnnotatedStruct_typedef_deque_template_struct_setter&& typedef_deque_template_) {
    typedef_deque_template = std::forward<T_AnnotatedStruct_typedef_deque_template_struct_setter>(typedef_deque_template_);
    __isset.typedef_deque_template = true;
    return typedef_deque_template;
  }
  const ::some::valid::ns::folly_set& get_typedef_set_template() const&;
  ::some::valid::ns::folly_set get_typedef_set_template() &&;

  template <typename T_AnnotatedStruct_typedef_set_template_struct_setter = ::some::valid::ns::folly_set>
  [[deprecated("Use `FOO.typedef_set_template_ref() = BAR;` instead of `FOO.set_typedef_set_template(BAR);`")]]
  ::some::valid::ns::folly_set& set_typedef_set_template(T_AnnotatedStruct_typedef_set_template_struct_setter&& typedef_set_template_) {
    typedef_set_template = std::forward<T_AnnotatedStruct_typedef_set_template_struct_setter>(typedef_set_template_);
    __isset.typedef_set_template = true;
    return typedef_set_template;
  }
  const ::some::valid::ns::folly_map& get_typedef_map_template() const&;
  ::some::valid::ns::folly_map get_typedef_map_template() &&;

  template <typename T_AnnotatedStruct_typedef_map_template_struct_setter = ::some::valid::ns::folly_map>
  [[deprecated("Use `FOO.typedef_map_template_ref() = BAR;` instead of `FOO.set_typedef_map_template(BAR);`")]]
  ::some::valid::ns::folly_map& set_typedef_map_template(T_AnnotatedStruct_typedef_map_template_struct_setter&& typedef_map_template_) {
    typedef_map_template = std::forward<T_AnnotatedStruct_typedef_map_template_struct_setter>(typedef_map_template_);
    __isset.typedef_map_template = true;
    return typedef_map_template;
  }

  ::some::valid::ns::IndirectionA get_indirection_a() const {
    return indirection_a;
  }

  [[deprecated("Use `FOO.indirection_a_ref() = BAR;` instead of `FOO.set_indirection_a(BAR);`")]]
  ::some::valid::ns::IndirectionA& set_indirection_a(::some::valid::ns::IndirectionA indirection_a_) {
    indirection_a = indirection_a_;
    __isset.indirection_a = true;
    return indirection_a;
  }
  const ::std::vector<::some::valid::ns::IndirectionB>& get_indirection_b() const&;
  ::std::vector<::some::valid::ns::IndirectionB> get_indirection_b() &&;

  template <typename T_AnnotatedStruct_indirection_b_struct_setter = ::std::vector<::some::valid::ns::IndirectionB>>
  [[deprecated("Use `FOO.indirection_b_ref() = BAR;` instead of `FOO.set_indirection_b(BAR);`")]]
  ::std::vector<::some::valid::ns::IndirectionB>& set_indirection_b(T_AnnotatedStruct_indirection_b_struct_setter&& indirection_b_) {
    indirection_b = std::forward<T_AnnotatedStruct_indirection_b_struct_setter>(indirection_b_);
    __isset.indirection_b = true;
    return indirection_b;
  }
  const ::std::set<::some::valid::ns::IndirectionC>& get_indirection_c() const&;
  ::std::set<::some::valid::ns::IndirectionC> get_indirection_c() &&;

  template <typename T_AnnotatedStruct_indirection_c_struct_setter = ::std::set<::some::valid::ns::IndirectionC>>
  [[deprecated("Use `FOO.indirection_c_ref() = BAR;` instead of `FOO.set_indirection_c(BAR);`")]]
  ::std::set<::some::valid::ns::IndirectionC>& set_indirection_c(T_AnnotatedStruct_indirection_c_struct_setter&& indirection_c_) {
    indirection_c = std::forward<T_AnnotatedStruct_indirection_c_struct_setter>(indirection_c_);
    __isset.indirection_c = true;
    return indirection_c;
  }

  const ::some::valid::ns::IOBuf& get_iobuf_type_val() const& {
    return iobuf_type_val;
  }

  ::some::valid::ns::IOBuf get_iobuf_type_val() && {
    return std::move(iobuf_type_val);
  }

  template <typename T_AnnotatedStruct_iobuf_type_val_struct_setter = ::some::valid::ns::IOBuf>
  [[deprecated("Use `FOO.iobuf_type_val_ref() = BAR;` instead of `FOO.set_iobuf_type_val(BAR);`")]]
  ::some::valid::ns::IOBuf& set_iobuf_type_val(T_AnnotatedStruct_iobuf_type_val_struct_setter&& iobuf_type_val_) {
    iobuf_type_val = std::forward<T_AnnotatedStruct_iobuf_type_val_struct_setter>(iobuf_type_val_);
    __isset.iobuf_type_val = true;
    return iobuf_type_val;
  }

  const ::some::valid::ns::IOBufPtr& get_iobuf_ptr_val() const& {
    return iobuf_ptr_val;
  }

  ::some::valid::ns::IOBufPtr get_iobuf_ptr_val() && {
    return std::move(iobuf_ptr_val);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_val_struct_setter = ::some::valid::ns::IOBufPtr>
  [[deprecated("Use `FOO.iobuf_ptr_val_ref() = BAR;` instead of `FOO.set_iobuf_ptr_val(BAR);`")]]
  ::some::valid::ns::IOBufPtr& set_iobuf_ptr_val(T_AnnotatedStruct_iobuf_ptr_val_struct_setter&& iobuf_ptr_val_) {
    iobuf_ptr_val = std::forward<T_AnnotatedStruct_iobuf_ptr_val_struct_setter>(iobuf_ptr_val_);
    __isset.iobuf_ptr_val = true;
    return iobuf_ptr_val;
  }
  const ::some::valid::ns::containerStruct& get_struct_struct() const&;
  ::some::valid::ns::containerStruct get_struct_struct() &&;

  template <typename T_AnnotatedStruct_struct_struct_struct_setter = ::some::valid::ns::containerStruct>
  [[deprecated("Use `FOO.struct_struct_ref() = BAR;` instead of `FOO.set_struct_struct(BAR);`")]]
  ::some::valid::ns::containerStruct& set_struct_struct(T_AnnotatedStruct_struct_struct_struct_setter&& struct_struct_) {
    struct_struct = std::forward<T_AnnotatedStruct_struct_struct_struct_setter>(struct_struct_);
    __isset.struct_struct = true;
    return struct_struct;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnnotatedStruct>;
  friend void swap(AnnotatedStruct& a, AnnotatedStruct& b);
};

template <class Protocol_>
uint32_t AnnotatedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class ComplexContainerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ComplexContainerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ComplexContainerStruct() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexContainerStruct(apache::thrift::FragileConstructor, ::std::map<::std::string, ::some::valid::ns::IOBuf> map_of_iobufs__arg, ::std::map<::std::string, ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs__arg);

  ComplexContainerStruct(ComplexContainerStruct&&) noexcept;
  ComplexContainerStruct(const ComplexContainerStruct& src);


  ComplexContainerStruct& operator=(ComplexContainerStruct&&) noexcept;
  ComplexContainerStruct& operator=(const ComplexContainerStruct& src);
  void __clear();
 private:
  ::std::map<::std::string, ::some::valid::ns::IOBuf> map_of_iobufs;
 private:
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool map_of_iobufs;
    bool map_of_iobuf_ptrs;
  } __isset = {};

 public:

  bool operator==(const ComplexContainerStruct&) const;
  bool operator<(const ComplexContainerStruct&) const;

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobufs_ref() const& {
    return {this->map_of_iobufs, __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobufs_ref() const&& {
    return {std::move(this->map_of_iobufs), __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobufs_ref() & {
    return {this->map_of_iobufs, __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobufs_ref() && {
    return {std::move(this->map_of_iobufs), __isset.map_of_iobufs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobuf_ptrs_ref() const& {
    return {this->map_of_iobuf_ptrs, __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobuf_ptrs_ref() const&& {
    return {std::move(this->map_of_iobuf_ptrs), __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobuf_ptrs_ref() & {
    return {this->map_of_iobuf_ptrs, __isset.map_of_iobuf_ptrs};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobuf_ptrs_ref() && {
    return {std::move(this->map_of_iobuf_ptrs), __isset.map_of_iobuf_ptrs};
  }
  const ::std::map<::std::string, ::some::valid::ns::IOBuf>& get_map_of_iobufs() const&;
  ::std::map<::std::string, ::some::valid::ns::IOBuf> get_map_of_iobufs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobufs_struct_setter = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  [[deprecated("Use `FOO.map_of_iobufs_ref() = BAR;` instead of `FOO.set_map_of_iobufs(BAR);`")]]
  ::std::map<::std::string, ::some::valid::ns::IOBuf>& set_map_of_iobufs(T_ComplexContainerStruct_map_of_iobufs_struct_setter&& map_of_iobufs_) {
    map_of_iobufs = std::forward<T_ComplexContainerStruct_map_of_iobufs_struct_setter>(map_of_iobufs_);
    __isset.map_of_iobufs = true;
    return map_of_iobufs;
  }
  const ::std::map<::std::string, ::some::valid::ns::IOBufPtr>& get_map_of_iobuf_ptrs() const&;
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr> get_map_of_iobuf_ptrs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  [[deprecated("Use `FOO.map_of_iobuf_ptrs_ref() = BAR;` instead of `FOO.set_map_of_iobuf_ptrs(BAR);`")]]
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr>& set_map_of_iobuf_ptrs(T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter&& map_of_iobuf_ptrs_) {
    map_of_iobuf_ptrs = std::forward<T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter>(map_of_iobuf_ptrs_);
    __isset.map_of_iobuf_ptrs = true;
    return map_of_iobuf_ptrs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexContainerStruct>;
  friend void swap(ComplexContainerStruct& a, ComplexContainerStruct& b);
};

template <class Protocol_>
uint32_t ComplexContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class FloatStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FloatStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FloatStruct() :
      floatField(0),
      doubleField(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FloatStruct(apache::thrift::FragileConstructor, float floatField__arg, double doubleField__arg);

  FloatStruct(FloatStruct&&) = default;

  FloatStruct(const FloatStruct&) = default;


  FloatStruct& operator=(FloatStruct&&) = default;

  FloatStruct& operator=(const FloatStruct&) = default;
  void __clear();
 private:
  float floatField;
 private:
  double doubleField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool floatField;
    bool doubleField;
  } __isset = {};

 public:

  bool operator==(const FloatStruct&) const;
  bool operator<(const FloatStruct&) const;

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> floatField_ref() const& {
    return {this->floatField, __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> floatField_ref() const&& {
    return {std::move(this->floatField), __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> floatField_ref() & {
    return {this->floatField, __isset.floatField};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> floatField_ref() && {
    return {std::move(this->floatField), __isset.floatField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> doubleField_ref() const& {
    return {this->doubleField, __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> doubleField_ref() const&& {
    return {std::move(this->doubleField), __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> doubleField_ref() & {
    return {this->doubleField, __isset.doubleField};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> doubleField_ref() && {
    return {std::move(this->doubleField), __isset.doubleField};
  }

  float get_floatField() const {
    return floatField;
  }

  [[deprecated("Use `FOO.floatField_ref() = BAR;` instead of `FOO.set_floatField(BAR);`")]]
  float& set_floatField(float floatField_) {
    floatField = floatField_;
    __isset.floatField = true;
    return floatField;
  }

  double get_doubleField() const {
    return doubleField;
  }

  [[deprecated("Use `FOO.doubleField_ref() = BAR;` instead of `FOO.set_doubleField(BAR);`")]]
  double& set_doubleField(double doubleField_) {
    doubleField = doubleField_;
    __isset.doubleField = true;
    return doubleField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FloatStruct>;
  friend void swap(FloatStruct& a, FloatStruct& b);
};

template <class Protocol_>
uint32_t FloatStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class FloatUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FloatUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    floatSide = 1,
    doubleSide = 2,
  } ;

  FloatUnion()
      : type_(Type::__EMPTY__) {}

  FloatUnion(FloatUnion&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  FloatUnion(const FloatUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  FloatUnion& operator=(FloatUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  FloatUnion& operator=(const FloatUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~FloatUnion() {
    __clear();
  }
  union storage_type {
    float floatSide;
    double doubleSide;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const FloatUnion&) const;
  bool operator<(const FloatUnion&) const;

  float& set_floatSide(float t = float()) {
    __clear();
    type_ = Type::floatSide;
    ::new (std::addressof(value_.floatSide)) float(t);
    return value_.floatSide;
  }

  double& set_doubleSide(double t = double()) {
    __clear();
    type_ = Type::doubleSide;
    ::new (std::addressof(value_.doubleSide)) double(t);
    return value_.doubleSide;
  }

  float const& get_floatSide() const {
    if (type_ != Type::floatSide) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.floatSide;
  }

  double const& get_doubleSide() const {
    if (type_ != Type::doubleSide) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.doubleSide;
  }

  float& mutable_floatSide() {
    assert(type_ == Type::floatSide);
    return value_.floatSide;
  }

  double& mutable_doubleSide() {
    assert(type_ == Type::doubleSide);
    return value_.doubleSide;
  }

  float move_floatSide() {
    assert(type_ == Type::floatSide);
    return std::move(value_.floatSide);
  }

  double move_doubleSide() {
    assert(type_ == Type::doubleSide);
    return std::move(value_.doubleSide);
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> floatSide_ref() const& {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> floatSide_ref() const&& {
    return {std::move(value_.floatSide), type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> floatSide_ref() & {
    return {value_.floatSide, type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> floatSide_ref() && {
    return {std::move(value_.floatSide), type_, floatSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubleSide_ref() const& {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubleSide_ref() const&& {
    return {std::move(value_.doubleSide), type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubleSide_ref() & {
    return {value_.doubleSide, type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubleSide_ref() && {
    return {std::move(value_.doubleSide), type_, doubleSide, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FloatUnion>;
  friend void swap(FloatUnion& a, FloatUnion& b);
};

template <class Protocol_>
uint32_t FloatUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class AllRequiredNoExceptMoveCtrStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = AllRequiredNoExceptMoveCtrStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AllRequiredNoExceptMoveCtrStruct() :
      intField(0) {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AllRequiredNoExceptMoveCtrStruct(apache::thrift::FragileConstructor, ::std::int64_t intField__arg);

  AllRequiredNoExceptMoveCtrStruct(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct(const AllRequiredNoExceptMoveCtrStruct&) = default;


  AllRequiredNoExceptMoveCtrStruct& operator=(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct& operator=(const AllRequiredNoExceptMoveCtrStruct&) = default;
  void __clear();
 public:
  ::std::int64_t intField;

 private:

 public:

  bool operator==(const AllRequiredNoExceptMoveCtrStruct&) const;
  bool operator<(const AllRequiredNoExceptMoveCtrStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> intField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> intField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->intField)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> intField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> intField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->intField)};
  }

  ::std::int64_t get_intField() const {
    return intField;
  }

  [[deprecated("Use `FOO.intField_ref() = BAR;` instead of `FOO.set_intField(BAR);`")]]
  ::std::int64_t& set_intField(::std::int64_t intField_) {
    intField = intField_;
    return intField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AllRequiredNoExceptMoveCtrStruct>;
  friend void swap(AllRequiredNoExceptMoveCtrStruct& a, AllRequiredNoExceptMoveCtrStruct& b);
};

template <class Protocol_>
uint32_t AllRequiredNoExceptMoveCtrStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // some::valid::ns
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::some::valid::ns::SimpleUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::SimpleUnion::Type> {
  using type = ::some::valid::ns::SimpleUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::some::valid::ns::ComplexUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::ComplexUnion::Type> {
  using type = ::some::valid::ns::ComplexUnion::Type;

  static constexpr std::size_t const size = 27;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::some::valid::ns::FloatUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::FloatUnion::Type> {
  using type = ::some::valid::ns::FloatUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
