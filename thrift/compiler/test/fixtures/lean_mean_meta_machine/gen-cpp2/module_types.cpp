/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/lean_mean_meta_machine/gen-cpp2/module_types.h"

#include "thrift/compiler/test/fixtures/lean_mean_meta_machine/gen-cpp2/module_types.tcc"

#include <algorithm>

#include <folly/Indestructible.h>

#include "thrift/compiler/test/fixtures/lean_mean_meta_machine/gen-cpp2/module_data.h"



#include "thrift/compiler/test/fixtures/lean_mean_meta_machine/gen-cpp2/module_fatal.h"
namespace test_cpp2 { namespace cpp_reflection {

const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = _enum1_EnumMapFactory::makeValuesToNamesMap();
const _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES = _enum1_EnumMapFactory::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::size = 3;
template <> const folly::Range<const  ::test_cpp2::cpp_reflection::enum1*> TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::values = folly::range( ::test_cpp2::cpp_reflection::_enum1EnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::names = folly::range( ::test_cpp2::cpp_reflection::_enum1EnumDataStorage::names);
template <> const char* TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = _enum2_EnumMapFactory::makeValuesToNamesMap();
const _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES = _enum2_EnumMapFactory::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::size = 3;
template <> const folly::Range<const  ::test_cpp2::cpp_reflection::enum2*> TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::values = folly::range( ::test_cpp2::cpp_reflection::_enum2EnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::names = folly::range( ::test_cpp2::cpp_reflection::_enum2EnumDataStorage::names);
template <> const char* TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = _enum3_EnumMapFactory::makeValuesToNamesMap();
const _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES = _enum3_EnumMapFactory::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::size = 3;
template <> const folly::Range<const  ::test_cpp2::cpp_reflection::enum3*> TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::values = folly::range( ::test_cpp2::cpp_reflection::_enum3EnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::names = folly::range( ::test_cpp2::cpp_reflection::_enum3EnumDataStorage::names);
template <> const char* TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = _enum_with_special_names_EnumMapFactory::makeValuesToNamesMap();
const _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES = _enum_with_special_names_EnumMapFactory::makeNamesToValuesMap();

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const std::size_t TEnumTraits< ::test_cpp2::cpp_reflection::enum_with_special_names>::size = 26;
template <> const folly::Range<const  ::test_cpp2::cpp_reflection::enum_with_special_names*> TEnumTraits< ::test_cpp2::cpp_reflection::enum_with_special_names>::values = folly::range( ::test_cpp2::cpp_reflection::_enum_with_special_namesEnumDataStorage::values);
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp2::cpp_reflection::enum_with_special_names>::names = folly::range( ::test_cpp2::cpp_reflection::_enum_with_special_namesEnumDataStorage::names);
template <> const char* TEnumTraits< ::test_cpp2::cpp_reflection::enum_with_special_names>::findName( ::test_cpp2::cpp_reflection::enum_with_special_names value) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template <> bool TEnumTraits< ::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum_with_special_names* outValue) {
  static auto const map = folly::Indestructible< ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union1::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
    {
      destruct(value_.ui);
      break;
    }
    case Type::ud:
    {
      destruct(value_.ud);
      break;
    }
    case Type::us:
    {
      destruct(value_.us);
      break;
    }
    case Type::ue:
    {
      destruct(value_.ue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
    {
      return value_.ui == rhs.value_.ui;
    }
    case Type::ud:
    {
      return value_.ud == rhs.value_.ud;
    }
    case Type::us:
    {
      return value_.us == rhs.value_.us;
    }
    case Type::ue:
    {
      return value_.ue == rhs.value_.ue;
    }
    default:
    {
      return true;
    }
  }
}

void union1::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "ui") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "ud") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "us") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "ue") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union1::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union2::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
    {
      destruct(value_.ui_2);
      break;
    }
    case Type::ud_2:
    {
      destruct(value_.ud_2);
      break;
    }
    case Type::us_2:
    {
      destruct(value_.us_2);
      break;
    }
    case Type::ue_2:
    {
      destruct(value_.ue_2);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
    {
      return value_.ui_2 == rhs.value_.ui_2;
    }
    case Type::ud_2:
    {
      return value_.ud_2 == rhs.value_.ud_2;
    }
    case Type::us_2:
    {
      return value_.us_2 == rhs.value_.us_2;
    }
    case Type::ue_2:
    {
      return value_.ue_2 == rhs.value_.ue_2;
    }
    default:
    {
      return true;
    }
  }
}

void union2::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "ui_2") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "ud_2") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "us_2") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "ue_2") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union2::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union3::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
    {
      destruct(value_.ui_3);
      break;
    }
    case Type::ud_3:
    {
      destruct(value_.ud_3);
      break;
    }
    case Type::us_3:
    {
      destruct(value_.us_3);
      break;
    }
    case Type::ue_3:
    {
      destruct(value_.ue_3);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
    {
      return value_.ui_3 == rhs.value_.ui_3;
    }
    case Type::ud_3:
    {
      return value_.ud_3 == rhs.value_.ud_3;
    }
    case Type::us_3:
    {
      return value_.us_3 == rhs.value_.us_3;
    }
    case Type::ue_3:
    {
      return value_.ue_3 == rhs.value_.ue_3;
    }
    default:
    {
      return true;
    }
  }
}

void union3::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "ui_3") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "ud_3") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "us_3") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "ue_3") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union3::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

structA::structA(apache::thrift::FragileConstructor, int32_t a__arg, std::string b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg))
 {
  __isset.a = true;
  __isset.b = true;
}

void structA::__clear() {
  // clear all fields
  a = 0;
  b = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool structA::operator==(const structA& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  return true;
}

void structA::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "a") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "b") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

template uint32_t structA::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void unionA::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::i:
    {
      destruct(value_.i);
      break;
    }
    case Type::d:
    {
      destruct(value_.d);
      break;
    }
    case Type::s:
    {
      destruct(value_.s);
      break;
    }
    case Type::e:
    {
      destruct(value_.e);
      break;
    }
    case Type::a:
    {
      destruct(value_.a);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::i:
    {
      return value_.i == rhs.value_.i;
    }
    case Type::d:
    {
      return value_.d == rhs.value_.d;
    }
    case Type::s:
    {
      return value_.s == rhs.value_.s;
    }
    case Type::e:
    {
      return value_.e == rhs.value_.e;
    }
    case Type::a:
    {
      return value_.a == rhs.value_.a;
    }
    default:
    {
      return true;
    }
  }
}

void unionA::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "i") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "d") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "s") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "e") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "a") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t unionA::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

structB::structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
    c(std::move(c__arg)),
    d(std::move(d__arg))
 {
  __isset.c = true;
  __isset.d = true;
}

void structB::__clear() {
  // clear all fields
  c = 0;
  d = 0;
  __isset = {};
}

bool structB::operator==(const structB& rhs) const {
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  return true;
}

void structB::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "c") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "d") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
}

void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

template uint32_t structB::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

structC::structC() :
    a(0),
    c(0),
    d(0),
    e( ::test_cpp2::cpp_reflection::enum1::field0),
    f( ::test_cpp2::cpp_reflection::enum2::field0_2)
 {}

structC::structC(apache::thrift::FragileConstructor, int32_t a__arg, std::string b__arg, double c__arg, bool d__arg,  ::test_cpp2::cpp_reflection::enum1 e__arg,  ::test_cpp2::cpp_reflection::enum2 f__arg,  ::test_cpp2::cpp_reflection::union1 g__arg,  ::test_cpp2::cpp_reflection::unionA h__arg,  ::test_cpp2::cpp_reflection::unionA i__arg, std::vector<int32_t> j__arg, std::vector<int32_t> j1__arg, std::vector< ::test_cpp2::cpp_reflection::enum1> j2__arg, std::vector< ::test_cpp2::cpp_reflection::structA> j3__arg, std::set<int32_t> k__arg, std::set<int32_t> k1__arg, std::set< ::test_cpp2::cpp_reflection::enum2> k2__arg, std::set< ::test_cpp2::cpp_reflection::structB> k3__arg, std::map<int32_t, int32_t> l__arg, std::map<int32_t, int32_t> l1__arg, std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2__arg, std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3__arg, std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1__arg, std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2__arg, std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3__arg, std::map<std::string, int32_t> n1__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> n2__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structB> n3__arg, std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1__arg, std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2__arg, std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    d(std::move(d__arg)),
    e(std::move(e__arg)),
    f(std::move(f__arg)),
    g(std::move(g__arg)),
    h(std::move(h__arg)),
    i(std::move(i__arg)),
    j(std::move(j__arg)),
    j1(std::move(j1__arg)),
    j2(std::move(j2__arg)),
    j3(std::move(j3__arg)),
    k(std::move(k__arg)),
    k1(std::move(k1__arg)),
    k2(std::move(k2__arg)),
    k3(std::move(k3__arg)),
    l(std::move(l__arg)),
    l1(std::move(l1__arg)),
    l2(std::move(l2__arg)),
    l3(std::move(l3__arg)),
    m1(std::move(m1__arg)),
    m2(std::move(m2__arg)),
    m3(std::move(m3__arg)),
    n1(std::move(n1__arg)),
    n2(std::move(n2__arg)),
    n3(std::move(n3__arg)),
    o1(std::move(o1__arg)),
    o2(std::move(o2__arg)),
    o3(std::move(o3__arg))
 {
  __isset.a = true;
  __isset.b = true;
  __isset.c = true;
  __isset.d = true;
  __isset.e = true;
  __isset.f = true;
  __isset.g = true;
  __isset.h = true;
  __isset.i = true;
  __isset.j = true;
  __isset.j1 = true;
  __isset.j2 = true;
  __isset.j3 = true;
  __isset.k = true;
  __isset.k1 = true;
  __isset.k2 = true;
  __isset.k3 = true;
  __isset.l = true;
  __isset.l1 = true;
  __isset.l2 = true;
  __isset.l3 = true;
  __isset.m1 = true;
  __isset.m2 = true;
  __isset.m3 = true;
  __isset.n1 = true;
  __isset.n2 = true;
  __isset.n3 = true;
  __isset.o1 = true;
  __isset.o2 = true;
  __isset.o3 = true;
}

void structC::__clear() {
  // clear all fields
  a = 0;
  b = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  c = 0;
  d = 0;
  e =  ::test_cpp2::cpp_reflection::enum1::field0;
  f =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&g);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&h);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&i);
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset = {};
}

structC::~structC() {}

bool structC::operator==(const structC& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  if (!((e == rhs.e))) {
    return false;
  }
  if (!((f == rhs.f))) {
    return false;
  }
  if (!((g == rhs.g))) {
    return false;
  }
  if (!((h == rhs.h))) {
    return false;
  }
  if (!((i == rhs.i))) {
    return false;
  }
  if (!((j == rhs.j))) {
    return false;
  }
  if (!((j1 == rhs.j1))) {
    return false;
  }
  if (!((j2 == rhs.j2))) {
    return false;
  }
  if (!((j3 == rhs.j3))) {
    return false;
  }
  if (!((k == rhs.k))) {
    return false;
  }
  if (!((k1 == rhs.k1))) {
    return false;
  }
  if (!((k2 == rhs.k2))) {
    return false;
  }
  if (!((k3 == rhs.k3))) {
    return false;
  }
  if (!((l == rhs.l))) {
    return false;
  }
  if (!((l1 == rhs.l1))) {
    return false;
  }
  if (!((l2 == rhs.l2))) {
    return false;
  }
  if (!((l3 == rhs.l3))) {
    return false;
  }
  if (!((m1 == rhs.m1))) {
    return false;
  }
  if (!((m2 == rhs.m2))) {
    return false;
  }
  if (!((m3 == rhs.m3))) {
    return false;
  }
  if (!((n1 == rhs.n1))) {
    return false;
  }
  if (!((n2 == rhs.n2))) {
    return false;
  }
  if (!((n3 == rhs.n3))) {
    return false;
  }
  if (!((o1 == rhs.o1))) {
    return false;
  }
  if (!((o2 == rhs.o2))) {
    return false;
  }
  if (!((o3 == rhs.o3))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return g;
}

 ::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(g);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return h;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(h);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return i;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(i);
}

const std::vector<int32_t>& structC::get_j() const& {
  return j;
}

std::vector<int32_t> structC::get_j() && {
  return std::move(j);
}

const std::vector<int32_t>& structC::get_j1() const& {
  return j1;
}

std::vector<int32_t> structC::get_j1() && {
  return std::move(j1);
}

const std::vector< ::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return j2;
}

std::vector< ::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(j2);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return j3;
}

std::vector< ::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(j3);
}

const std::set<int32_t>& structC::get_k() const& {
  return k;
}

std::set<int32_t> structC::get_k() && {
  return std::move(k);
}

const std::set<int32_t>& structC::get_k1() const& {
  return k1;
}

std::set<int32_t> structC::get_k1() && {
  return std::move(k1);
}

const std::set< ::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return k2;
}

std::set< ::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(k2);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return k3;
}

std::set< ::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(k3);
}

const std::map<int32_t, int32_t>& structC::get_l() const& {
  return l;
}

std::map<int32_t, int32_t> structC::get_l() && {
  return std::move(l);
}

const std::map<int32_t, int32_t>& structC::get_l1() const& {
  return l1;
}

std::map<int32_t, int32_t> structC::get_l1() && {
  return std::move(l1);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return l2;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(l2);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return l3;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(l3);
}

const std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& structC::get_m1() const& {
  return m1;
}

std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> structC::get_m1() && {
  return std::move(m1);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return m2;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(m2);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return m3;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(m3);
}

const std::map<std::string, int32_t>& structC::get_n1() const& {
  return n1;
}

std::map<std::string, int32_t> structC::get_n1() && {
  return std::move(n1);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return n2;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(n2);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return n3;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(n3);
}

const std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& structC::get_o1() const& {
  return o1;
}

std::map< ::test_cpp2::cpp_reflection::structA, int32_t> structC::get_o1() && {
  return std::move(o1);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return o2;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(o2);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return o3;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(o3);
}

void structC::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "a") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "b") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "c") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_DOUBLE;
  }
  else if (_fname == "d") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_BOOL;
  }
  else if (_fname == "e") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "f") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "g") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "h") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "i") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "j") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "j1") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "j2") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "j3") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "k") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "k1") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "k2") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "k3") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "l") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "l1") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "l2") {
    fid = 20;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "l3") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "m1") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "m2") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "m3") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "n1") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "n2") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "n3") {
    fid = 27;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "o1") {
    fid = 28;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "o2") {
    fid = 29;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "o3") {
    fid = 30;
    _ftype = apache::thrift::protocol::T_MAP;
  }
}

void swap(structC& a, structC& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

template uint32_t structC::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct1::struct1() :
    field0(0),
    field2( ::test_cpp2::cpp_reflection::enum1::field0),
    field3( ::test_cpp2::cpp_reflection::enum2::field0_2)
 {}

struct1::struct1(apache::thrift::FragileConstructor, int32_t field0__arg, std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::enum2 field3__arg,  ::test_cpp2::cpp_reflection::union1 field4__arg,  ::test_cpp2::cpp_reflection::union2 field5__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)),
    field4(std::move(field4__arg)),
    field5(std::move(field5__arg))
 {
  __isset.field1 = true;
  __isset.field2 = true;
  __isset.field4 = true;
  __isset.field5 = true;
}

void struct1::__clear() {
  // clear all fields
  field0 = 0;
  field1 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  field3 =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&field4);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&field5);
  __isset = {};
}

struct1::~struct1() {}

bool struct1::operator==(const struct1& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!((field3 == rhs.field3))) {
    return false;
  }
  if (__isset.field4 != rhs.__isset.field4) {
    return false;
  }
  else if (__isset.field4 && !((field4 == rhs.field4))) {
    return false;
  }
  if (!((field5 == rhs.field5))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

 ::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

const  ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return field5;
}

 ::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(field5);
}

void struct1::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "field0") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "field1") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "field2") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "field3") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "field4") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "field5") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

template uint32_t struct1::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct2::struct2() :
    fieldA(0),
    fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
    fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2)
 {}

struct2::struct2(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg))
 {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
}

void struct2::__clear() {
  // clear all fields
  fieldA = 0;
  fieldB = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  __isset = {};
}

struct2::~struct2() {}

bool struct2::operator==(const struct2& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(fieldG);
}

void struct2::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "fieldA") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldB") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "fieldC") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldD") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldE") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldF") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldG") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

template uint32_t struct2::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct3::struct3() :
    fieldA(0),
    fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
    fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2)
 {}

struct3::struct3(apache::thrift::FragileConstructor, int32_t fieldA__arg, std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg,  ::test_cpp2::cpp_reflection::union2 fieldH__arg, std::vector<int32_t> fieldI__arg, std::vector<std::string> fieldJ__arg, std::vector<std::string> fieldK__arg, std::vector< ::test_cpp2::cpp_reflection::structA> fieldL__arg, std::set<int32_t> fieldM__arg, std::set<std::string> fieldN__arg, std::set<std::string> fieldO__arg, std::set< ::test_cpp2::cpp_reflection::structB> fieldP__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ__arg, std::map<std::string,  ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)),
    fieldH(std::move(fieldH__arg)),
    fieldI(std::move(fieldI__arg)),
    fieldJ(std::move(fieldJ__arg)),
    fieldK(std::move(fieldK__arg)),
    fieldL(std::move(fieldL__arg)),
    fieldM(std::move(fieldM__arg)),
    fieldN(std::move(fieldN__arg)),
    fieldO(std::move(fieldO__arg)),
    fieldP(std::move(fieldP__arg)),
    fieldQ(std::move(fieldQ__arg)),
    fieldR(std::move(fieldR__arg))
 {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
  __isset.fieldH = true;
  __isset.fieldI = true;
  __isset.fieldJ = true;
  __isset.fieldK = true;
  __isset.fieldL = true;
  __isset.fieldM = true;
  __isset.fieldN = true;
  __isset.fieldO = true;
  __isset.fieldP = true;
  __isset.fieldQ = true;
  __isset.fieldR = true;
}

void struct3::__clear() {
  // clear all fields
  fieldA = 0;
  fieldB = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldH);
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset = {};
}

struct3::~struct3() {}

bool struct3::operator==(const struct3& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  if (!((fieldH == rhs.fieldH))) {
    return false;
  }
  if (!((fieldI == rhs.fieldI))) {
    return false;
  }
  if (!((fieldJ == rhs.fieldJ))) {
    return false;
  }
  if (!((fieldK == rhs.fieldK))) {
    return false;
  }
  if (!((fieldL == rhs.fieldL))) {
    return false;
  }
  if (!((fieldM == rhs.fieldM))) {
    return false;
  }
  if (!((fieldN == rhs.fieldN))) {
    return false;
  }
  if (!((fieldO == rhs.fieldO))) {
    return false;
  }
  if (!((fieldP == rhs.fieldP))) {
    return false;
  }
  if (!((fieldQ == rhs.fieldQ))) {
    return false;
  }
  if (!((fieldR == rhs.fieldR))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(fieldG);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return fieldH;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(fieldH);
}

const std::vector<int32_t>& struct3::get_fieldI() const& {
  return fieldI;
}

std::vector<int32_t> struct3::get_fieldI() && {
  return std::move(fieldI);
}

const std::vector<std::string>& struct3::get_fieldJ() const& {
  return fieldJ;
}

std::vector<std::string> struct3::get_fieldJ() && {
  return std::move(fieldJ);
}

const std::vector<std::string>& struct3::get_fieldK() const& {
  return fieldK;
}

std::vector<std::string> struct3::get_fieldK() && {
  return std::move(fieldK);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return fieldL;
}

std::vector< ::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(fieldL);
}

const std::set<int32_t>& struct3::get_fieldM() const& {
  return fieldM;
}

std::set<int32_t> struct3::get_fieldM() && {
  return std::move(fieldM);
}

const std::set<std::string>& struct3::get_fieldN() const& {
  return fieldN;
}

std::set<std::string> struct3::get_fieldN() && {
  return std::move(fieldN);
}

const std::set<std::string>& struct3::get_fieldO() const& {
  return fieldO;
}

std::set<std::string> struct3::get_fieldO() && {
  return std::move(fieldO);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return fieldP;
}

std::set< ::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(fieldP);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return fieldQ;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(fieldQ);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return fieldR;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(fieldR);
}

void struct3::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "fieldA") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldB") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "fieldC") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldD") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "fieldE") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldF") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldG") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldH") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
  else if (_fname == "fieldI") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldJ") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldK") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldL") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_LIST;
  }
  else if (_fname == "fieldM") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldN") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldO") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldP") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_SET;
  }
  else if (_fname == "fieldQ") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_MAP;
  }
  else if (_fname == "fieldR") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_MAP;
  }
}

void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

template uint32_t struct3::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct4::struct4(apache::thrift::FragileConstructor, int32_t field0__arg, std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg, std::unique_ptr< ::test_cpp2::cpp_reflection::structA> field3__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg))
 {
  __isset.field1 = true;
  __isset.field2 = true;
}

struct4::struct4(const struct4& src) {
  field0 = src.field0;
  field1 = src.field1;
  __isset.field1 = src.__isset.field1;
  field2 = src.field2;
  __isset.field2 = src.__isset.field2;
  if (src.field3) field3.reset(new  ::test_cpp2::cpp_reflection::structA(*src.field3));
}

struct4& struct4::operator=(const struct4& src) {
  struct4 tmp(src);
  swap(*this, tmp);
  return *this;
}

void struct4::__clear() {
  // clear all fields
  field0 = 0;
  field1 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  if (field3) ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::structA>::clear(field3.get());
  __isset = {};
}

bool struct4::operator==(const struct4& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!(((field3 && rhs.field3 && *field3 == *rhs.field3) ||(!field3 && !rhs.field3)))) {
    return false;
  }
  return true;
}

void struct4::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "field0") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "field1") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_STRING;
  }
  else if (_fname == "field2") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "field3") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_STRUCT;
  }
}

void swap(struct4& a, struct4& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.__isset, b.__isset);
}

template uint32_t struct4::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct_binary::struct_binary(apache::thrift::FragileConstructor, std::string bi__arg) :
    bi(std::move(bi__arg))
 {
  __isset.bi = true;
}

void struct_binary::__clear() {
  // clear all fields
  bi = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  __isset = {};
}

bool struct_binary::operator==(const struct_binary& rhs) const {
  if (!(apache::thrift::StringTraits<std::string>::isEqual(bi, rhs.bi))) {
    return false;
  }
  return true;
}

void struct_binary::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "bi") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_STRING;
  }
}

void swap(struct_binary& a, struct_binary& b) {
  using ::std::swap;
  swap(a.bi, b.bi);
  swap(a.__isset, b.__isset);
}

template uint32_t struct_binary::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union_with_special_names::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::get:
    {
      destruct(value_.get);
      break;
    }
    case Type::getter:
    {
      destruct(value_.getter);
      break;
    }
    case Type::lists:
    {
      destruct(value_.lists);
      break;
    }
    case Type::maps:
    {
      destruct(value_.maps);
      break;
    }
    case Type::name:
    {
      destruct(value_.name);
      break;
    }
    case Type::name_to_value:
    {
      destruct(value_.name_to_value);
      break;
    }
    case Type::names:
    {
      destruct(value_.names);
      break;
    }
    case Type::prefix_tree:
    {
      destruct(value_.prefix_tree);
      break;
    }
    case Type::sets:
    {
      destruct(value_.sets);
      break;
    }
    case Type::setter:
    {
      destruct(value_.setter);
      break;
    }
    case Type::str:
    {
      destruct(value_.str);
      break;
    }
    case Type::strings:
    {
      destruct(value_.strings);
      break;
    }
    case Type::type:
    {
      destruct(value_.type);
      break;
    }
    case Type::value:
    {
      destruct(value_.value);
      break;
    }
    case Type::value_to_name:
    {
      destruct(value_.value_to_name);
      break;
    }
    case Type::values:
    {
      destruct(value_.values);
      break;
    }
    case Type::id:
    {
      destruct(value_.id);
      break;
    }
    case Type::ids:
    {
      destruct(value_.ids);
      break;
    }
    case Type::descriptor:
    {
      destruct(value_.descriptor);
      break;
    }
    case Type::descriptors:
    {
      destruct(value_.descriptors);
      break;
    }
    case Type::key:
    {
      destruct(value_.key);
      break;
    }
    case Type::keys:
    {
      destruct(value_.keys);
      break;
    }
    case Type::annotation:
    {
      destruct(value_.annotation);
      break;
    }
    case Type::annotations:
    {
      destruct(value_.annotations);
      break;
    }
    case Type::member:
    {
      destruct(value_.member);
      break;
    }
    case Type::members:
    {
      destruct(value_.members);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::get:
    {
      return value_.get == rhs.value_.get;
    }
    case Type::getter:
    {
      return value_.getter == rhs.value_.getter;
    }
    case Type::lists:
    {
      return value_.lists == rhs.value_.lists;
    }
    case Type::maps:
    {
      return value_.maps == rhs.value_.maps;
    }
    case Type::name:
    {
      return value_.name == rhs.value_.name;
    }
    case Type::name_to_value:
    {
      return value_.name_to_value == rhs.value_.name_to_value;
    }
    case Type::names:
    {
      return value_.names == rhs.value_.names;
    }
    case Type::prefix_tree:
    {
      return value_.prefix_tree == rhs.value_.prefix_tree;
    }
    case Type::sets:
    {
      return value_.sets == rhs.value_.sets;
    }
    case Type::setter:
    {
      return value_.setter == rhs.value_.setter;
    }
    case Type::str:
    {
      return value_.str == rhs.value_.str;
    }
    case Type::strings:
    {
      return value_.strings == rhs.value_.strings;
    }
    case Type::type:
    {
      return value_.type == rhs.value_.type;
    }
    case Type::value:
    {
      return value_.value == rhs.value_.value;
    }
    case Type::value_to_name:
    {
      return value_.value_to_name == rhs.value_.value_to_name;
    }
    case Type::values:
    {
      return value_.values == rhs.value_.values;
    }
    case Type::id:
    {
      return value_.id == rhs.value_.id;
    }
    case Type::ids:
    {
      return value_.ids == rhs.value_.ids;
    }
    case Type::descriptor:
    {
      return value_.descriptor == rhs.value_.descriptor;
    }
    case Type::descriptors:
    {
      return value_.descriptors == rhs.value_.descriptors;
    }
    case Type::key:
    {
      return value_.key == rhs.value_.key;
    }
    case Type::keys:
    {
      return value_.keys == rhs.value_.keys;
    }
    case Type::annotation:
    {
      return value_.annotation == rhs.value_.annotation;
    }
    case Type::annotations:
    {
      return value_.annotations == rhs.value_.annotations;
    }
    case Type::member:
    {
      return value_.member == rhs.value_.member;
    }
    case Type::members:
    {
      return value_.members == rhs.value_.members;
    }
    default:
    {
      return true;
    }
  }
}

void union_with_special_names::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "get") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "getter") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "lists") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "maps") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "name") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "name_to_value") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "names") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "prefix_tree") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "sets") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "setter") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "str") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "strings") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "type") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "value") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "value_to_name") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "values") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "id") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "ids") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "descriptor") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "descriptors") {
    fid = 20;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "key") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "keys") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "annotation") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "annotations") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "member") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "members") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template uint32_t union_with_special_names::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

struct_with_special_names::struct_with_special_names(apache::thrift::FragileConstructor, int32_t get__arg, int32_t getter__arg, int32_t lists__arg, int32_t maps__arg, int32_t name__arg, int32_t name_to_value__arg, int32_t names__arg, int32_t prefix_tree__arg, int32_t sets__arg, int32_t setter__arg, int32_t str__arg, int32_t strings__arg, int32_t type__arg, int32_t value__arg, int32_t value_to_name__arg, int32_t values__arg, int32_t id__arg, int32_t ids__arg, int32_t descriptor__arg, int32_t descriptors__arg, int32_t key__arg, int32_t keys__arg, int32_t annotation__arg, int32_t annotations__arg, int32_t member__arg, int32_t members__arg) :
    get(std::move(get__arg)),
    getter(std::move(getter__arg)),
    lists(std::move(lists__arg)),
    maps(std::move(maps__arg)),
    name(std::move(name__arg)),
    name_to_value(std::move(name_to_value__arg)),
    names(std::move(names__arg)),
    prefix_tree(std::move(prefix_tree__arg)),
    sets(std::move(sets__arg)),
    setter(std::move(setter__arg)),
    str(std::move(str__arg)),
    strings(std::move(strings__arg)),
    type(std::move(type__arg)),
    value(std::move(value__arg)),
    value_to_name(std::move(value_to_name__arg)),
    values(std::move(values__arg)),
    id(std::move(id__arg)),
    ids(std::move(ids__arg)),
    descriptor(std::move(descriptor__arg)),
    descriptors(std::move(descriptors__arg)),
    key(std::move(key__arg)),
    keys(std::move(keys__arg)),
    annotation(std::move(annotation__arg)),
    annotations(std::move(annotations__arg)),
    member(std::move(member__arg)),
    members(std::move(members__arg))
 {
  __isset.get = true;
  __isset.getter = true;
  __isset.lists = true;
  __isset.maps = true;
  __isset.name = true;
  __isset.name_to_value = true;
  __isset.names = true;
  __isset.prefix_tree = true;
  __isset.sets = true;
  __isset.setter = true;
  __isset.str = true;
  __isset.strings = true;
  __isset.type = true;
  __isset.value = true;
  __isset.value_to_name = true;
  __isset.values = true;
  __isset.id = true;
  __isset.ids = true;
  __isset.descriptor = true;
  __isset.descriptors = true;
  __isset.key = true;
  __isset.keys = true;
  __isset.annotation = true;
  __isset.annotations = true;
  __isset.member = true;
  __isset.members = true;
}

void struct_with_special_names::__clear() {
  // clear all fields
  get = 0;
  getter = 0;
  lists = 0;
  maps = 0;
  name = 0;
  name_to_value = 0;
  names = 0;
  prefix_tree = 0;
  sets = 0;
  setter = 0;
  str = 0;
  strings = 0;
  type = 0;
  value = 0;
  value_to_name = 0;
  values = 0;
  id = 0;
  ids = 0;
  descriptor = 0;
  descriptors = 0;
  key = 0;
  keys = 0;
  annotation = 0;
  annotations = 0;
  member = 0;
  members = 0;
  __isset = {};
}

bool struct_with_special_names::operator==(const struct_with_special_names& rhs) const {
  if (!((get == rhs.get))) {
    return false;
  }
  if (!((getter == rhs.getter))) {
    return false;
  }
  if (!((lists == rhs.lists))) {
    return false;
  }
  if (!((maps == rhs.maps))) {
    return false;
  }
  if (!((name == rhs.name))) {
    return false;
  }
  if (!((name_to_value == rhs.name_to_value))) {
    return false;
  }
  if (!((names == rhs.names))) {
    return false;
  }
  if (!((prefix_tree == rhs.prefix_tree))) {
    return false;
  }
  if (!((sets == rhs.sets))) {
    return false;
  }
  if (!((setter == rhs.setter))) {
    return false;
  }
  if (!((str == rhs.str))) {
    return false;
  }
  if (!((strings == rhs.strings))) {
    return false;
  }
  if (!((type == rhs.type))) {
    return false;
  }
  if (!((value == rhs.value))) {
    return false;
  }
  if (!((value_to_name == rhs.value_to_name))) {
    return false;
  }
  if (!((values == rhs.values))) {
    return false;
  }
  if (!((id == rhs.id))) {
    return false;
  }
  if (!((ids == rhs.ids))) {
    return false;
  }
  if (!((descriptor == rhs.descriptor))) {
    return false;
  }
  if (!((descriptors == rhs.descriptors))) {
    return false;
  }
  if (!((key == rhs.key))) {
    return false;
  }
  if (!((keys == rhs.keys))) {
    return false;
  }
  if (!((annotation == rhs.annotation))) {
    return false;
  }
  if (!((annotations == rhs.annotations))) {
    return false;
  }
  if (!((member == rhs.member))) {
    return false;
  }
  if (!((members == rhs.members))) {
    return false;
  }
  return true;
}

void struct_with_special_names::translateFieldName(FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid, FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "get") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "getter") {
    fid = 2;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "lists") {
    fid = 3;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "maps") {
    fid = 4;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "name") {
    fid = 5;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "name_to_value") {
    fid = 6;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "names") {
    fid = 7;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "prefix_tree") {
    fid = 8;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "sets") {
    fid = 9;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "setter") {
    fid = 10;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "str") {
    fid = 11;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "strings") {
    fid = 12;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "type") {
    fid = 13;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "value") {
    fid = 14;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "value_to_name") {
    fid = 15;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "values") {
    fid = 16;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "id") {
    fid = 17;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "ids") {
    fid = 18;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "descriptor") {
    fid = 19;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "descriptors") {
    fid = 20;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "key") {
    fid = 21;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "keys") {
    fid = 22;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "annotation") {
    fid = 23;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "annotations") {
    fid = 24;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "member") {
    fid = 25;
    _ftype = apache::thrift::protocol::T_I32;
  }
  else if (_fname == "members") {
    fid = 26;
    _ftype = apache::thrift::protocol::T_I32;
  }
}

void swap(struct_with_special_names& a, struct_with_special_names& b) {
  using ::std::swap;
  swap(a.get, b.get);
  swap(a.getter, b.getter);
  swap(a.lists, b.lists);
  swap(a.maps, b.maps);
  swap(a.name, b.name);
  swap(a.name_to_value, b.name_to_value);
  swap(a.names, b.names);
  swap(a.prefix_tree, b.prefix_tree);
  swap(a.sets, b.sets);
  swap(a.setter, b.setter);
  swap(a.str, b.str);
  swap(a.strings, b.strings);
  swap(a.type, b.type);
  swap(a.value, b.value);
  swap(a.value_to_name, b.value_to_name);
  swap(a.values, b.values);
  swap(a.id, b.id);
  swap(a.ids, b.ids);
  swap(a.descriptor, b.descriptor);
  swap(a.descriptors, b.descriptors);
  swap(a.key, b.key);
  swap(a.keys, b.keys);
  swap(a.annotation, b.annotation);
  swap(a.annotations, b.annotations);
  swap(a.member, b.member);
  swap(a.members, b.members);
  swap(a.__isset, b.__isset);
}

template uint32_t struct_with_special_names::read<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::read<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection
