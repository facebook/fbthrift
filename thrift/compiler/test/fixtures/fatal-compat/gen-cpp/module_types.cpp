/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_types.h"

#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>

namespace test_cpp1 { namespace cpp_reflection {

const int _kenum1Values[] = {
  field0,
  field1,
  field2
};

const char* const _kenum1Names[] = {
  "field0",
  "field1",
  "field2"
};

const std::map<int, const char*> _enum1_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findName( ::test_cpp1::cpp_reflection::enum1 value) {
return findName( ::test_cpp1::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum1* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum1_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum2Values[] = {
  field0_2,
  field1_2,
  field2_2
};

const char* const _kenum2Names[] = {
  "field0_2",
  "field1_2",
  "field2_2"
};

const std::map<int, const char*> _enum2_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findName( ::test_cpp1::cpp_reflection::enum2 value) {
return findName( ::test_cpp1::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum2* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum2_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum3Values[] = {
  field0_3,
  field1_3,
  field2_3
};

const char* const _kenum3Names[] = {
  "field0_3",
  "field1_3",
  "field2_3"
};

const std::map<int, const char*> _enum3_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findName( ::test_cpp1::cpp_reflection::enum3 value) {
return findName( ::test_cpp1::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum3* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum3_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
  void union1::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union1");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui"] != nullptr) {
      set_ui();
      int64_t _tmp0 = (int64_t)parsed["ui"].asInt();
      if (imaxabs(_tmp0) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui = (int32_t)_tmp0;
      }
      return;
    }
    if (parsed["ud"] != nullptr) {
      set_ud();
      this->value_.ud = parsed["ud"].asDouble();
      return;
    }
    if (parsed["us"] != nullptr) {
      set_us();
      this->value_.us = parsed["us"].asString();
      return;
    }
    if (parsed["ue"] != nullptr) {
      set_ue();
      this->value_.ue=(enum1)(int32_t)parsed["ue"].asInt();
      return;
    }
  }
  void union1::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union1::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui();
          xfer += iprot->readI32(this->value_.ui);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud();
          xfer += iprot->readDouble(this->value_.ud);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us();
          xfer += iprot->readString(this->value_.us);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue();
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->value_.ue = (enum1)ecast2;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union1");
  switch (type_) {
    case Type::ui: {
      xfer += oprot->writeFieldBegin("ui", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud: {
      xfer += oprot->writeFieldBegin("ud", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us: {
      xfer += oprot->writeFieldBegin("us", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue: {
      xfer += oprot->writeFieldBegin("ue", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union2::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union2");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_2"] != nullptr) {
      set_ui_2();
      int64_t _tmp3 = (int64_t)parsed["ui_2"].asInt();
      if (imaxabs(_tmp3) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_2 = (int32_t)_tmp3;
      }
      return;
    }
    if (parsed["ud_2"] != nullptr) {
      set_ud_2();
      this->value_.ud_2 = parsed["ud_2"].asDouble();
      return;
    }
    if (parsed["us_2"] != nullptr) {
      set_us_2();
      this->value_.us_2 = parsed["us_2"].asString();
      return;
    }
    if (parsed["ue_2"] != nullptr) {
      set_ue_2();
      this->value_.ue_2=(enum1)(int32_t)parsed["ue_2"].asInt();
      return;
    }
  }
  void union2::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union2::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_2();
          xfer += iprot->readI32(this->value_.ui_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_2();
          xfer += iprot->readDouble(this->value_.ud_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_2();
          xfer += iprot->readString(this->value_.us_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_2();
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->value_.ue_2 = (enum1)ecast5;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union2");
  switch (type_) {
    case Type::ui_2: {
      xfer += oprot->writeFieldBegin("ui_2", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_2: {
      xfer += oprot->writeFieldBegin("ud_2", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_2: {
      xfer += oprot->writeFieldBegin("us_2", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_2: {
      xfer += oprot->writeFieldBegin("ue_2", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union3::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union3");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_3"] != nullptr) {
      set_ui_3();
      int64_t _tmp6 = (int64_t)parsed["ui_3"].asInt();
      if (imaxabs(_tmp6) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_3 = (int32_t)_tmp6;
      }
      return;
    }
    if (parsed["ud_3"] != nullptr) {
      set_ud_3();
      this->value_.ud_3 = parsed["ud_3"].asDouble();
      return;
    }
    if (parsed["us_3"] != nullptr) {
      set_us_3();
      this->value_.us_3 = parsed["us_3"].asString();
      return;
    }
    if (parsed["ue_3"] != nullptr) {
      set_ue_3();
      this->value_.ue_3=(enum1)(int32_t)parsed["ue_3"].asInt();
      return;
    }
  }
  void union3::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union3::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_3();
          xfer += iprot->readI32(this->value_.ui_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_3();
          xfer += iprot->readDouble(this->value_.ud_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_3();
          xfer += iprot->readString(this->value_.us_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_3();
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->value_.ue_3 = (enum1)ecast8;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union3");
  switch (type_) {
    case Type::ui_3: {
      xfer += oprot->writeFieldBegin("ui_3", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_3: {
      xfer += oprot->writeFieldBegin("ud_3", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_3: {
      xfer += oprot->writeFieldBegin("us_3", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_3: {
      xfer += oprot->writeFieldBegin("ue_3", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structA::_reflection_id;
void structA::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(schema);
}

bool structA::operator == (const structA & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  return true;
}

void structA::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp10 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp10) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp10;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
}
void structA::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structA::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(*schema);
    iprot->setNextStructType(structA::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structA::__clear() {
  a = 0;
  b = "";
  __isset.__clear();
}
uint32_t structA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structA");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structA &a, structA &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

void merge(const structA& from, structA& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

void merge(structA&& from, structA& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

  void unionA::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse unionA");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["i"] != nullptr) {
      set_i();
      int64_t _tmp11 = (int64_t)parsed["i"].asInt();
      if (imaxabs(_tmp11) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.i = (int32_t)_tmp11;
      }
      return;
    }
    if (parsed["d"] != nullptr) {
      set_d();
      this->value_.d = parsed["d"].asDouble();
      return;
    }
    if (parsed["s"] != nullptr) {
      set_s();
      this->value_.s = parsed["s"].asString();
      return;
    }
    if (parsed["e"] != nullptr) {
      set_e();
      this->value_.e=(enum1)(int32_t)parsed["e"].asInt();
      return;
    }
    if (parsed["a"] != nullptr) {
      set_a();
      this->value_.a.readFromJson(folly::toJson(parsed["a"]).c_str());
      return;
    }
  }
  void unionA::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t unionA::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_s();
          xfer += iprot->readString(this->value_.s);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_e();
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->value_.e = (enum1)ecast13;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 5: {
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          set_a();
          xfer += this->value_.a.read(iprot);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t unionA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("unionA");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::s: {
      xfer += oprot->writeFieldBegin("s", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.s);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::e: {
      xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.e);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::a: {
      xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_STRUCT, 5);
      xfer += this->value_.a.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structB::_reflection_id;
void structB::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(schema);
}

bool structB::operator == (const structB & rhs) const {
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  return true;
}

void structB::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
}
void structB::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structB::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(*schema);
    iprot->setNextStructType(structB::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}
uint32_t structB::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structB");
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structB &a, structB &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

void merge(const structB& from, structB& to) {
  using apache::thrift::merge;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

void merge(structB&& from, structB& to) {
  using apache::thrift::merge;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

const uint64_t structC::_reflection_id;
void structC::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(schema);
}

bool structC::operator == (const structC & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  if (!(this->e == rhs.e))
    return false;
  if (!(this->f == rhs.f))
    return false;
  if (!(this->g == rhs.g))
    return false;
  if (!(this->h == rhs.h))
    return false;
  if (!(this->i == rhs.i))
    return false;
  if (!(this->j == rhs.j))
    return false;
  if (!(this->j1 == rhs.j1))
    return false;
  if (!(this->j2 == rhs.j2))
    return false;
  if (!(this->j3 == rhs.j3))
    return false;
  if (!(this->k == rhs.k))
    return false;
  if (!(this->k1 == rhs.k1))
    return false;
  if (!(this->k2 == rhs.k2))
    return false;
  if (!(this->k3 == rhs.k3))
    return false;
  if (!(this->l == rhs.l))
    return false;
  if (!(this->l1 == rhs.l1))
    return false;
  if (!(this->l2 == rhs.l2))
    return false;
  if (!(this->l3 == rhs.l3))
    return false;
  if (!(this->m1 == rhs.m1))
    return false;
  if (!(this->m2 == rhs.m2))
    return false;
  if (!(this->m3 == rhs.m3))
    return false;
  if (!(this->n1 == rhs.n1))
    return false;
  if (!(this->n2 == rhs.n2))
    return false;
  if (!(this->n3 == rhs.n3))
    return false;
  if (!(this->o1 == rhs.o1))
    return false;
  if (!(this->o2 == rhs.o2))
    return false;
  if (!(this->o3 == rhs.o3))
    return false;
  return true;
}

void structC::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp16 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp16) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp16;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
  if (parsed["e"] != nullptr) {
    this->e=(enum1)(int32_t)parsed["e"].asInt();
    this->__isset.e = true;
  } else {
    this->__isset.e = false;
  }
  if (parsed["f"] != nullptr) {
    this->f=(enum2)(int32_t)parsed["f"].asInt();
    this->__isset.f = true;
  } else {
    this->__isset.f = false;
  }
  if (parsed["g"] != nullptr) {
    this->g.readFromJson(folly::toJson(parsed["g"]).c_str());
    this->__isset.g = true;
  } else {
    this->__isset.g = false;
  }
  if (parsed["h"] != nullptr) {
    this->h.readFromJson(folly::toJson(parsed["h"]).c_str());
    this->__isset.h = true;
  } else {
    this->__isset.h = false;
  }
  if (parsed["i"] != nullptr) {
    this->i.readFromJson(folly::toJson(parsed["i"]).c_str());
    this->__isset.i = true;
  } else {
    this->__isset.i = false;
  }
  if (parsed["j"] != nullptr) {
    folly::dynamic _json21 = parsed["j"];
    this->j.clear();
    uint32_t _size19 = _json21.size();
    this->j.resize(_size19);
    for (uint32_t _i20 = 0; _i20 < _size19; ++_i20)
    {
      int64_t _tmp23 = (int64_t)_json21[_i20].asInt();
      if (imaxabs(_tmp23) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j[_i20] = (int32_t)_tmp23;
      }
    }
    this->__isset.j = true;
  } else {
    this->__isset.j = false;
  }
  if (parsed["j1"] != nullptr) {
    folly::dynamic _json26 = parsed["j1"];
    this->j1.clear();
    uint32_t _size24 = _json26.size();
    this->j1.resize(_size24);
    for (uint32_t _i25 = 0; _i25 < _size24; ++_i25)
    {
      int64_t _tmp28 = (int64_t)_json26[_i25].asInt();
      if (imaxabs(_tmp28) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j1[_i25] = (int32_t)_tmp28;
      }
    }
    this->__isset.j1 = true;
  } else {
    this->__isset.j1 = false;
  }
  if (parsed["j2"] != nullptr) {
    folly::dynamic _json31 = parsed["j2"];
    this->j2.clear();
    uint32_t _size29 = _json31.size();
    this->j2.resize(_size29);
    for (uint32_t _i30 = 0; _i30 < _size29; ++_i30)
    {
      this->j2[_i30]=(enum1)(int32_t)_json31[_i30].asInt();
    }
    this->__isset.j2 = true;
  } else {
    this->__isset.j2 = false;
  }
  if (parsed["j3"] != nullptr) {
    folly::dynamic _json36 = parsed["j3"];
    this->j3.clear();
    uint32_t _size34 = _json36.size();
    this->j3.resize(_size34);
    for (uint32_t _i35 = 0; _i35 < _size34; ++_i35)
    {
      this->j3[_i35].readFromJson(folly::toJson(_json36[_i35]).c_str());
    }
    this->__isset.j3 = true;
  } else {
    this->__isset.j3 = false;
  }
  if (parsed["k"] != nullptr) {
    folly::dynamic _json40 = parsed["k"];
    this->k.clear();
    uint32_t _size38 = _json40.size();
    for (uint32_t _i39 = 0; _i39 < _size38; ++_i39)
    {
      int32_t _elem42;
      int64_t _tmp43 = (int64_t)_json40[_i39].asInt();
      if (imaxabs(_tmp43) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem42 = (int32_t)_tmp43;
      }
      this->k.insert(_elem42);
    }
    this->__isset.k = true;
  } else {
    this->__isset.k = false;
  }
  if (parsed["k1"] != nullptr) {
    folly::dynamic _json46 = parsed["k1"];
    this->k1.clear();
    uint32_t _size44 = _json46.size();
    for (uint32_t _i45 = 0; _i45 < _size44; ++_i45)
    {
      int32_t _elem48;
      int64_t _tmp49 = (int64_t)_json46[_i45].asInt();
      if (imaxabs(_tmp49) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem48 = (int32_t)_tmp49;
      }
      this->k1.insert(_elem48);
    }
    this->__isset.k1 = true;
  } else {
    this->__isset.k1 = false;
  }
  if (parsed["k2"] != nullptr) {
    folly::dynamic _json52 = parsed["k2"];
    this->k2.clear();
    uint32_t _size50 = _json52.size();
    for (uint32_t _i51 = 0; _i51 < _size50; ++_i51)
    {
      enum2 _elem54;
      _elem54=(enum2)(int32_t)_json52[_i51].asInt();
      this->k2.insert(_elem54);
    }
    this->__isset.k2 = true;
  } else {
    this->__isset.k2 = false;
  }
  if (parsed["k3"] != nullptr) {
    folly::dynamic _json58 = parsed["k3"];
    this->k3.clear();
    uint32_t _size56 = _json58.size();
    for (uint32_t _i57 = 0; _i57 < _size56; ++_i57)
    {
      structB _elem60;
      _elem60.readFromJson(folly::toJson(_json58[_i57]).c_str());
      this->k3.insert(_elem60);
    }
    this->__isset.k3 = true;
  } else {
    this->__isset.k3 = false;
  }
  if (parsed["l"] != nullptr) {
    folly::dynamic _json63 = parsed["l"];
    this->l.clear();
    for (folly::dynamic::const_item_iterator _iter65 = _json63.items().begin(); _iter65 != _json63.items().end(); _iter65++)    {
      int32_t _key66;
      int32_t _val67;
      try {
        _key66 = folly::to<int32_t>((_iter65)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp68 = (int64_t)_iter65->second.asInt();
      if (imaxabs(_tmp68) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val67 = (int32_t)_tmp68;
      }
      this->l[_key66] = _val67;
    }
    this->__isset.l = true;
  } else {
    this->__isset.l = false;
  }
  if (parsed["l1"] != nullptr) {
    folly::dynamic _json71 = parsed["l1"];
    this->l1.clear();
    for (folly::dynamic::const_item_iterator _iter73 = _json71.items().begin(); _iter73 != _json71.items().end(); _iter73++)    {
      int32_t _key74;
      int32_t _val75;
      try {
        _key74 = folly::to<int32_t>((_iter73)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp76 = (int64_t)_iter73->second.asInt();
      if (imaxabs(_tmp76) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val75 = (int32_t)_tmp76;
      }
      this->l1[_key74] = _val75;
    }
    this->__isset.l1 = true;
  } else {
    this->__isset.l1 = false;
  }
  if (parsed["l2"] != nullptr) {
    folly::dynamic _json79 = parsed["l2"];
    this->l2.clear();
    for (folly::dynamic::const_item_iterator _iter81 = _json79.items().begin(); _iter81 != _json79.items().end(); _iter81++)    {
      int32_t _key82;
      enum1 _val83;
      try {
        _key82 = folly::to<int32_t>((_iter81)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val83=(enum1)(int32_t)_iter81->second.asInt();
      this->l2[_key82] = _val83;
    }
    this->__isset.l2 = true;
  } else {
    this->__isset.l2 = false;
  }
  if (parsed["l3"] != nullptr) {
    folly::dynamic _json87 = parsed["l3"];
    this->l3.clear();
    for (folly::dynamic::const_item_iterator _iter89 = _json87.items().begin(); _iter89 != _json87.items().end(); _iter89++)    {
      int32_t _key90;
      structB _val91;
      try {
        _key90 = folly::to<int32_t>((_iter89)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val91.readFromJson(folly::toJson(_iter89->second).c_str());
      this->l3[_key90] = _val91;
    }
    this->__isset.l3 = true;
  } else {
    this->__isset.l3 = false;
  }
  if (parsed["m1"] != nullptr) {
    folly::dynamic _json94 = parsed["m1"];
    this->m1.clear();
    for (folly::dynamic::const_item_iterator _iter96 = _json94.items().begin(); _iter96 != _json94.items().end(); _iter96++)    {
      enum1 _key97;
      int32_t _val98;
      try {
        _key97 = (enum1)folly::to<int>((_iter96)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp99 = (int64_t)_iter96->second.asInt();
      if (imaxabs(_tmp99) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val98 = (int32_t)_tmp99;
      }
      this->m1[_key97] = _val98;
    }
    this->__isset.m1 = true;
  } else {
    this->__isset.m1 = false;
  }
  if (parsed["m2"] != nullptr) {
    folly::dynamic _json102 = parsed["m2"];
    this->m2.clear();
    for (folly::dynamic::const_item_iterator _iter104 = _json102.items().begin(); _iter104 != _json102.items().end(); _iter104++)    {
      enum1 _key105;
      enum2 _val106;
      try {
        _key105 = (enum1)folly::to<int>((_iter104)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val106=(enum2)(int32_t)_iter104->second.asInt();
      this->m2[_key105] = _val106;
    }
    this->__isset.m2 = true;
  } else {
    this->__isset.m2 = false;
  }
  if (parsed["m3"] != nullptr) {
    folly::dynamic _json110 = parsed["m3"];
    this->m3.clear();
    for (folly::dynamic::const_item_iterator _iter112 = _json110.items().begin(); _iter112 != _json110.items().end(); _iter112++)    {
      enum1 _key113;
      structB _val114;
      try {
        _key113 = (enum1)folly::to<int>((_iter112)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val114.readFromJson(folly::toJson(_iter112->second).c_str());
      this->m3[_key113] = _val114;
    }
    this->__isset.m3 = true;
  } else {
    this->__isset.m3 = false;
  }
  if (parsed["n1"] != nullptr) {
    folly::dynamic _json117 = parsed["n1"];
    this->n1.clear();
    for (folly::dynamic::const_item_iterator _iter119 = _json117.items().begin(); _iter119 != _json117.items().end(); _iter119++)    {
      std::string _key120;
      int32_t _val121;
      _key120 = (_iter119)->first.asString();
      int64_t _tmp122 = (int64_t)_iter119->second.asInt();
      if (imaxabs(_tmp122) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val121 = (int32_t)_tmp122;
      }
      this->n1[_key120] = _val121;
    }
    this->__isset.n1 = true;
  } else {
    this->__isset.n1 = false;
  }
  if (parsed["n2"] != nullptr) {
    folly::dynamic _json125 = parsed["n2"];
    this->n2.clear();
    for (folly::dynamic::const_item_iterator _iter127 = _json125.items().begin(); _iter127 != _json125.items().end(); _iter127++)    {
      std::string _key128;
      enum1 _val129;
      _key128 = (_iter127)->first.asString();
      _val129=(enum1)(int32_t)_iter127->second.asInt();
      this->n2[_key128] = _val129;
    }
    this->__isset.n2 = true;
  } else {
    this->__isset.n2 = false;
  }
  if (parsed["n3"] != nullptr) {
    folly::dynamic _json133 = parsed["n3"];
    this->n3.clear();
    for (folly::dynamic::const_item_iterator _iter135 = _json133.items().begin(); _iter135 != _json133.items().end(); _iter135++)    {
      std::string _key136;
      structB _val137;
      _key136 = (_iter135)->first.asString();
      _val137.readFromJson(folly::toJson(_iter135->second).c_str());
      this->n3[_key136] = _val137;
    }
    this->__isset.n3 = true;
  } else {
    this->__isset.n3 = false;
  }
  if (parsed["o1"] != nullptr) {
    this->__isset.o1 = true;
  } else {
    this->__isset.o1 = false;
  }
  if (parsed["o2"] != nullptr) {
    this->__isset.o2 = true;
  } else {
    this->__isset.o2 = false;
  }
  if (parsed["o3"] != nullptr) {
    this->__isset.o3 = true;
  } else {
    this->__isset.o3 = false;
  }
}
void structC::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structC::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(*schema);
    iprot->setNextStructType(structC::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->e = (enum1)ecast150;
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->f = (enum2)ecast151;
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->g.read(iprot);
          this->__isset.g = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->h.read(iprot);
          this->__isset.h = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->i.read(iprot);
          this->__isset.i = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j.clear();
            uint32_t _size152;
            bool _sizeUnknown153;
            apache::thrift::protocol::TType _etype156;
            xfer += iprot->readListBegin(_etype156, _size152, _sizeUnknown153);
            if (!_sizeUnknown153) {
              this->j.resize(_size152);
              uint32_t _i158;
              for (_i158 = 0; _i158 < _size152; ++_i158)
              {
                xfer += iprot->readI32(this->j[_i158]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem159;
                xfer += iprot->readI32(_elem159);
                this->j.push_back(_elem159);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j1.clear();
            uint32_t _size160;
            bool _sizeUnknown161;
            apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size160, _sizeUnknown161);
            if (!_sizeUnknown161) {
              this->j1.resize(_size160);
              uint32_t _i166;
              for (_i166 = 0; _i166 < _size160; ++_i166)
              {
                xfer += iprot->readI32(this->j1[_i166]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem167;
                xfer += iprot->readI32(_elem167);
                this->j1.push_back(_elem167);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j2.clear();
            uint32_t _size168;
            bool _sizeUnknown169;
            apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size168, _sizeUnknown169);
            if (!_sizeUnknown169) {
              this->j2.resize(_size168);
              uint32_t _i174;
              for (_i174 = 0; _i174 < _size168; ++_i174)
              {
                int32_t ecast175;
                xfer += iprot->readI32(ecast175);
                this->j2[_i174] = (enum1)ecast175;
              }
            } else {
              while (iprot->peekList())
              {
                enum1 _elem176;
                int32_t ecast177;
                xfer += iprot->readI32(ecast177);
                _elem176 = (enum1)ecast177;
                this->j2.push_back(_elem176);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j3.clear();
            uint32_t _size178;
            bool _sizeUnknown179;
            apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size178, _sizeUnknown179);
            if (!_sizeUnknown179) {
              this->j3.resize(_size178);
              uint32_t _i184;
              for (_i184 = 0; _i184 < _size178; ++_i184)
              {
                xfer += this->j3[_i184].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem185;
                xfer += _elem185.read(iprot);
                this->j3.push_back(_elem185);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k.clear();
            uint32_t _size186;
            bool _sizeUnknown187;
            apache::thrift::protocol::TType _etype190;
            xfer += iprot->readSetBegin(_etype190, _size186, _sizeUnknown187);
            if (!_sizeUnknown187) {
              uint32_t _i192;
              for (_i192 = 0; _i192 < _size186; ++_i192)
              {
                int32_t _elem193;
                xfer += iprot->readI32(_elem193);
                this->k.insert(_elem193);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem194;
                xfer += iprot->readI32(_elem194);
                this->k.insert(_elem194);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k1.clear();
            uint32_t _size195;
            bool _sizeUnknown196;
            apache::thrift::protocol::TType _etype199;
            xfer += iprot->readSetBegin(_etype199, _size195, _sizeUnknown196);
            if (!_sizeUnknown196) {
              uint32_t _i201;
              for (_i201 = 0; _i201 < _size195; ++_i201)
              {
                int32_t _elem202;
                xfer += iprot->readI32(_elem202);
                this->k1.insert(_elem202);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem203;
                xfer += iprot->readI32(_elem203);
                this->k1.insert(_elem203);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k2.clear();
            uint32_t _size204;
            bool _sizeUnknown205;
            apache::thrift::protocol::TType _etype208;
            xfer += iprot->readSetBegin(_etype208, _size204, _sizeUnknown205);
            if (!_sizeUnknown205) {
              uint32_t _i210;
              for (_i210 = 0; _i210 < _size204; ++_i210)
              {
                enum2 _elem211;
                int32_t ecast212;
                xfer += iprot->readI32(ecast212);
                _elem211 = (enum2)ecast212;
                this->k2.insert(_elem211);
              }
            } else {
              while (iprot->peekSet())
              {
                enum2 _elem213;
                int32_t ecast214;
                xfer += iprot->readI32(ecast214);
                _elem213 = (enum2)ecast214;
                this->k2.insert(_elem213);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k3.clear();
            uint32_t _size215;
            bool _sizeUnknown216;
            apache::thrift::protocol::TType _etype219;
            xfer += iprot->readSetBegin(_etype219, _size215, _sizeUnknown216);
            if (!_sizeUnknown216) {
              uint32_t _i221;
              for (_i221 = 0; _i221 < _size215; ++_i221)
              {
                structB _elem222;
                xfer += _elem222.read(iprot);
                this->k3.insert(_elem222);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem223;
                xfer += _elem223.read(iprot);
                this->k3.insert(_elem223);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l.clear();
            uint32_t _size224;
            bool _sizeUnknown225;
            apache::thrift::protocol::TType _ktype226;
            apache::thrift::protocol::TType _vtype227;
            xfer += iprot->readMapBegin(_ktype226, _vtype227, _size224, _sizeUnknown225);
            if (!_sizeUnknown225) {
              uint32_t _i230;
              for (_i230 = 0; _i230 < _size224; ++_i230)
              {
                int32_t _key231;
                xfer += iprot->readI32(_key231);
                int32_t& _val232 = this->l[_key231];
                xfer += iprot->readI32(_val232);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key233;
                xfer += iprot->readI32(_key233);
                int32_t& _val234 = this->l[_key233];
                xfer += iprot->readI32(_val234);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l1.clear();
            uint32_t _size235;
            bool _sizeUnknown236;
            apache::thrift::protocol::TType _ktype237;
            apache::thrift::protocol::TType _vtype238;
            xfer += iprot->readMapBegin(_ktype237, _vtype238, _size235, _sizeUnknown236);
            if (!_sizeUnknown236) {
              uint32_t _i241;
              for (_i241 = 0; _i241 < _size235; ++_i241)
              {
                int32_t _key242;
                xfer += iprot->readI32(_key242);
                int32_t& _val243 = this->l1[_key242];
                xfer += iprot->readI32(_val243);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key244;
                xfer += iprot->readI32(_key244);
                int32_t& _val245 = this->l1[_key244];
                xfer += iprot->readI32(_val245);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l2.clear();
            uint32_t _size246;
            bool _sizeUnknown247;
            apache::thrift::protocol::TType _ktype248;
            apache::thrift::protocol::TType _vtype249;
            xfer += iprot->readMapBegin(_ktype248, _vtype249, _size246, _sizeUnknown247);
            if (!_sizeUnknown247) {
              uint32_t _i252;
              for (_i252 = 0; _i252 < _size246; ++_i252)
              {
                int32_t _key253;
                xfer += iprot->readI32(_key253);
                enum1& _val254 = this->l2[_key253];
                int32_t ecast255;
                xfer += iprot->readI32(ecast255);
                _val254 = (enum1)ecast255;
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key256;
                xfer += iprot->readI32(_key256);
                enum1& _val257 = this->l2[_key256];
                int32_t ecast258;
                xfer += iprot->readI32(ecast258);
                _val257 = (enum1)ecast258;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l3.clear();
            uint32_t _size259;
            bool _sizeUnknown260;
            apache::thrift::protocol::TType _ktype261;
            apache::thrift::protocol::TType _vtype262;
            xfer += iprot->readMapBegin(_ktype261, _vtype262, _size259, _sizeUnknown260);
            if (!_sizeUnknown260) {
              uint32_t _i265;
              for (_i265 = 0; _i265 < _size259; ++_i265)
              {
                int32_t _key266;
                xfer += iprot->readI32(_key266);
                structB& _val267 = this->l3[_key266];
                xfer += _val267.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key268;
                xfer += iprot->readI32(_key268);
                structB& _val269 = this->l3[_key268];
                xfer += _val269.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m1.clear();
            uint32_t _size270;
            bool _sizeUnknown271;
            apache::thrift::protocol::TType _ktype272;
            apache::thrift::protocol::TType _vtype273;
            xfer += iprot->readMapBegin(_ktype272, _vtype273, _size270, _sizeUnknown271);
            if (!_sizeUnknown271) {
              uint32_t _i276;
              for (_i276 = 0; _i276 < _size270; ++_i276)
              {
                enum1 _key277;
                int32_t ecast279;
                xfer += iprot->readI32(ecast279);
                _key277 = (enum1)ecast279;
                int32_t& _val278 = this->m1[_key277];
                xfer += iprot->readI32(_val278);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key280;
                int32_t ecast282;
                xfer += iprot->readI32(ecast282);
                _key280 = (enum1)ecast282;
                int32_t& _val281 = this->m1[_key280];
                xfer += iprot->readI32(_val281);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m2.clear();
            uint32_t _size283;
            bool _sizeUnknown284;
            apache::thrift::protocol::TType _ktype285;
            apache::thrift::protocol::TType _vtype286;
            xfer += iprot->readMapBegin(_ktype285, _vtype286, _size283, _sizeUnknown284);
            if (!_sizeUnknown284) {
              uint32_t _i289;
              for (_i289 = 0; _i289 < _size283; ++_i289)
              {
                enum1 _key290;
                int32_t ecast292;
                xfer += iprot->readI32(ecast292);
                _key290 = (enum1)ecast292;
                enum2& _val291 = this->m2[_key290];
                int32_t ecast293;
                xfer += iprot->readI32(ecast293);
                _val291 = (enum2)ecast293;
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key294;
                int32_t ecast296;
                xfer += iprot->readI32(ecast296);
                _key294 = (enum1)ecast296;
                enum2& _val295 = this->m2[_key294];
                int32_t ecast297;
                xfer += iprot->readI32(ecast297);
                _val295 = (enum2)ecast297;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m3.clear();
            uint32_t _size298;
            bool _sizeUnknown299;
            apache::thrift::protocol::TType _ktype300;
            apache::thrift::protocol::TType _vtype301;
            xfer += iprot->readMapBegin(_ktype300, _vtype301, _size298, _sizeUnknown299);
            if (!_sizeUnknown299) {
              uint32_t _i304;
              for (_i304 = 0; _i304 < _size298; ++_i304)
              {
                enum1 _key305;
                int32_t ecast307;
                xfer += iprot->readI32(ecast307);
                _key305 = (enum1)ecast307;
                structB& _val306 = this->m3[_key305];
                xfer += _val306.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key308;
                int32_t ecast310;
                xfer += iprot->readI32(ecast310);
                _key308 = (enum1)ecast310;
                structB& _val309 = this->m3[_key308];
                xfer += _val309.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n1.clear();
            uint32_t _size311;
            bool _sizeUnknown312;
            apache::thrift::protocol::TType _ktype313;
            apache::thrift::protocol::TType _vtype314;
            xfer += iprot->readMapBegin(_ktype313, _vtype314, _size311, _sizeUnknown312);
            if (!_sizeUnknown312) {
              uint32_t _i317;
              for (_i317 = 0; _i317 < _size311; ++_i317)
              {
                std::string _key318;
                xfer += iprot->readString(_key318);
                int32_t& _val319 = this->n1[_key318];
                xfer += iprot->readI32(_val319);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key320;
                xfer += iprot->readString(_key320);
                int32_t& _val321 = this->n1[_key320];
                xfer += iprot->readI32(_val321);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n2.clear();
            uint32_t _size322;
            bool _sizeUnknown323;
            apache::thrift::protocol::TType _ktype324;
            apache::thrift::protocol::TType _vtype325;
            xfer += iprot->readMapBegin(_ktype324, _vtype325, _size322, _sizeUnknown323);
            if (!_sizeUnknown323) {
              uint32_t _i328;
              for (_i328 = 0; _i328 < _size322; ++_i328)
              {
                std::string _key329;
                xfer += iprot->readString(_key329);
                enum1& _val330 = this->n2[_key329];
                int32_t ecast331;
                xfer += iprot->readI32(ecast331);
                _val330 = (enum1)ecast331;
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key332;
                xfer += iprot->readString(_key332);
                enum1& _val333 = this->n2[_key332];
                int32_t ecast334;
                xfer += iprot->readI32(ecast334);
                _val333 = (enum1)ecast334;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n3.clear();
            uint32_t _size335;
            bool _sizeUnknown336;
            apache::thrift::protocol::TType _ktype337;
            apache::thrift::protocol::TType _vtype338;
            xfer += iprot->readMapBegin(_ktype337, _vtype338, _size335, _sizeUnknown336);
            if (!_sizeUnknown336) {
              uint32_t _i341;
              for (_i341 = 0; _i341 < _size335; ++_i341)
              {
                std::string _key342;
                xfer += iprot->readString(_key342);
                structB& _val343 = this->n3[_key342];
                xfer += _val343.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key344;
                xfer += iprot->readString(_key344);
                structB& _val345 = this->n3[_key344];
                xfer += _val345.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o1.clear();
            uint32_t _size346;
            bool _sizeUnknown347;
            apache::thrift::protocol::TType _ktype348;
            apache::thrift::protocol::TType _vtype349;
            xfer += iprot->readMapBegin(_ktype348, _vtype349, _size346, _sizeUnknown347);
            if (!_sizeUnknown347) {
              uint32_t _i352;
              for (_i352 = 0; _i352 < _size346; ++_i352)
              {
                structA _key353;
                xfer += _key353.read(iprot);
                int32_t& _val354 = this->o1[_key353];
                xfer += iprot->readI32(_val354);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key355;
                xfer += _key355.read(iprot);
                int32_t& _val356 = this->o1[_key355];
                xfer += iprot->readI32(_val356);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o2.clear();
            uint32_t _size357;
            bool _sizeUnknown358;
            apache::thrift::protocol::TType _ktype359;
            apache::thrift::protocol::TType _vtype360;
            xfer += iprot->readMapBegin(_ktype359, _vtype360, _size357, _sizeUnknown358);
            if (!_sizeUnknown358) {
              uint32_t _i363;
              for (_i363 = 0; _i363 < _size357; ++_i363)
              {
                structA _key364;
                xfer += _key364.read(iprot);
                enum1& _val365 = this->o2[_key364];
                int32_t ecast366;
                xfer += iprot->readI32(ecast366);
                _val365 = (enum1)ecast366;
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key367;
                xfer += _key367.read(iprot);
                enum1& _val368 = this->o2[_key367];
                int32_t ecast369;
                xfer += iprot->readI32(ecast369);
                _val368 = (enum1)ecast369;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o3.clear();
            uint32_t _size370;
            bool _sizeUnknown371;
            apache::thrift::protocol::TType _ktype372;
            apache::thrift::protocol::TType _vtype373;
            xfer += iprot->readMapBegin(_ktype372, _vtype373, _size370, _sizeUnknown371);
            if (!_sizeUnknown371) {
              uint32_t _i376;
              for (_i376 = 0; _i376 < _size370; ++_i376)
              {
                structA _key377;
                xfer += _key377.read(iprot);
                structB& _val378 = this->o3[_key377];
                xfer += _val378.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key379;
                xfer += _key379.read(iprot);
                structB& _val380 = this->o3[_key379];
                xfer += _val380.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structC::__clear() {
  a = 0;
  b = "";
  c = 0;
  d = 0;
  e = static_cast<enum1>(0);
  f = static_cast<enum2>(0);
  g.__clear();
  h.__clear();
  i.__clear();
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}
uint32_t structC::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structC");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->e);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->f);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("g", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->g.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("h", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->h.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->i.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j.size());
    std::vector<int32_t> ::const_iterator _iter381;
    for (_iter381 = this->j.begin(); _iter381 != this->j.end(); ++_iter381)
    {
      xfer += oprot->writeI32((*_iter381));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j1", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j1.size());
    std::vector<int32_t> ::const_iterator _iter382;
    for (_iter382 = this->j1.begin(); _iter382 != this->j1.end(); ++_iter382)
    {
      xfer += oprot->writeI32((*_iter382));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j2", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j2.size());
    std::vector<enum1> ::const_iterator _iter383;
    for (_iter383 = this->j2.begin(); _iter383 != this->j2.end(); ++_iter383)
    {
      xfer += oprot->writeI32((int32_t)(*_iter383));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j3", apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->j3.size());
    std::vector<structA> ::const_iterator _iter384;
    for (_iter384 = this->j3.begin(); _iter384 != this->j3.end(); ++_iter384)
    {
      xfer += (*_iter384).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k.size());
    std::set<int32_t> ::const_iterator _iter385;
    for (_iter385 = this->k.begin(); _iter385 != this->k.end(); ++_iter385)
    {
      xfer += oprot->writeI32((*_iter385));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k1", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k1.size());
    std::set<int32_t> ::const_iterator _iter386;
    for (_iter386 = this->k1.begin(); _iter386 != this->k1.end(); ++_iter386)
    {
      xfer += oprot->writeI32((*_iter386));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k2", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k2.size());
    std::set<enum2> ::const_iterator _iter387;
    for (_iter387 = this->k2.begin(); _iter387 != this->k2.end(); ++_iter387)
    {
      xfer += oprot->writeI32((int32_t)(*_iter387));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k3", apache::thrift::protocol::T_SET, 17);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->k3.size());
    std::set<structB> ::const_iterator _iter388;
    for (_iter388 = this->k3.begin(); _iter388 != this->k3.end(); ++_iter388)
    {
      xfer += (*_iter388).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l.size());
    std::map<int32_t, int32_t> ::const_iterator _iter389;
    for (_iter389 = this->l.begin(); _iter389 != this->l.end(); ++_iter389)
    {
      xfer += oprot->writeI32(_iter389->first);
      xfer += oprot->writeI32(_iter389->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l1", apache::thrift::protocol::T_MAP, 19);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l1.size());
    std::map<int32_t, int32_t> ::const_iterator _iter390;
    for (_iter390 = this->l1.begin(); _iter390 != this->l1.end(); ++_iter390)
    {
      xfer += oprot->writeI32(_iter390->first);
      xfer += oprot->writeI32(_iter390->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l2", apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l2.size());
    std::map<int32_t, enum1> ::const_iterator _iter391;
    for (_iter391 = this->l2.begin(); _iter391 != this->l2.end(); ++_iter391)
    {
      xfer += oprot->writeI32(_iter391->first);
      xfer += oprot->writeI32((int32_t)_iter391->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l3", apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->l3.size());
    std::map<int32_t, structB> ::const_iterator _iter392;
    for (_iter392 = this->l3.begin(); _iter392 != this->l3.end(); ++_iter392)
    {
      xfer += oprot->writeI32(_iter392->first);
      xfer += _iter392->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m1", apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m1.size());
    std::map<enum1, int32_t> ::const_iterator _iter393;
    for (_iter393 = this->m1.begin(); _iter393 != this->m1.end(); ++_iter393)
    {
      xfer += oprot->writeI32((int32_t)_iter393->first);
      xfer += oprot->writeI32(_iter393->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m2", apache::thrift::protocol::T_MAP, 23);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m2.size());
    std::map<enum1, enum2> ::const_iterator _iter394;
    for (_iter394 = this->m2.begin(); _iter394 != this->m2.end(); ++_iter394)
    {
      xfer += oprot->writeI32((int32_t)_iter394->first);
      xfer += oprot->writeI32((int32_t)_iter394->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m3", apache::thrift::protocol::T_MAP, 24);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->m3.size());
    std::map<enum1, structB> ::const_iterator _iter395;
    for (_iter395 = this->m3.begin(); _iter395 != this->m3.end(); ++_iter395)
    {
      xfer += oprot->writeI32((int32_t)_iter395->first);
      xfer += _iter395->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n1", apache::thrift::protocol::T_MAP, 25);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n1.size());
    std::map<std::string, int32_t> ::const_iterator _iter396;
    for (_iter396 = this->n1.begin(); _iter396 != this->n1.end(); ++_iter396)
    {
      xfer += oprot->writeString(_iter396->first);
      xfer += oprot->writeI32(_iter396->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n2", apache::thrift::protocol::T_MAP, 26);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n2.size());
    std::map<std::string, enum1> ::const_iterator _iter397;
    for (_iter397 = this->n2.begin(); _iter397 != this->n2.end(); ++_iter397)
    {
      xfer += oprot->writeString(_iter397->first);
      xfer += oprot->writeI32((int32_t)_iter397->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n3", apache::thrift::protocol::T_MAP, 27);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->n3.size());
    std::map<std::string, structB> ::const_iterator _iter398;
    for (_iter398 = this->n3.begin(); _iter398 != this->n3.end(); ++_iter398)
    {
      xfer += oprot->writeString(_iter398->first);
      xfer += _iter398->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o1", apache::thrift::protocol::T_MAP, 28);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o1.size());
    std::map<structA, int32_t> ::const_iterator _iter399;
    for (_iter399 = this->o1.begin(); _iter399 != this->o1.end(); ++_iter399)
    {
      xfer += _iter399->first.write(oprot);
      xfer += oprot->writeI32(_iter399->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o2", apache::thrift::protocol::T_MAP, 29);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o2.size());
    std::map<structA, enum1> ::const_iterator _iter400;
    for (_iter400 = this->o2.begin(); _iter400 != this->o2.end(); ++_iter400)
    {
      xfer += _iter400->first.write(oprot);
      xfer += oprot->writeI32((int32_t)_iter400->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o3", apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_STRUCT, this->o3.size());
    std::map<structA, structB> ::const_iterator _iter401;
    for (_iter401 = this->o3.begin(); _iter401 != this->o3.end(); ++_iter401)
    {
      xfer += _iter401->first.write(oprot);
      xfer += _iter401->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structC &a, structC &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

void merge(const structC& from, structC& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(from.e, to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(from.f, to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(from.g, to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(from.h, to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(from.i, to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(from.j, to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(from.j1, to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(from.j2, to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(from.j3, to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(from.k, to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(from.k1, to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(from.k2, to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(from.k3, to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(from.l, to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(from.l1, to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(from.l2, to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(from.l3, to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(from.m1, to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(from.m2, to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(from.m3, to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(from.n1, to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(from.n2, to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(from.n3, to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(from.o1, to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(from.o2, to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(from.o3, to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

void merge(structC&& from, structC& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(std::move(from.e), to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(std::move(from.f), to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(std::move(from.g), to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(std::move(from.h), to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(std::move(from.i), to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(std::move(from.j), to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(std::move(from.j1), to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(std::move(from.j2), to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(std::move(from.j3), to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(std::move(from.k), to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(std::move(from.k1), to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(std::move(from.k2), to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(std::move(from.k3), to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(std::move(from.l), to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(std::move(from.l1), to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(std::move(from.l2), to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(std::move(from.l3), to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(std::move(from.m1), to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(std::move(from.m2), to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(std::move(from.m3), to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(std::move(from.n1), to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(std::move(from.n2), to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(std::move(from.n3), to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(std::move(from.o1), to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(std::move(from.o2), to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(std::move(from.o3), to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

const uint64_t struct1::_reflection_id;
void struct1::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(schema);
}

bool struct1::operator == (const struct1 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  if (__isset.field4 != rhs.__isset.field4)
    return false;
  else if (__isset.field4 && !(field4 == rhs.field4))
    return false;
  if (!(this->field5 == rhs.field5))
    return false;
  return true;
}

void struct1::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["field0"] != nullptr) {
    int64_t _tmp403 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp403) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp403;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3=(enum2)(int32_t)parsed["field3"].asInt();
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field4"] != nullptr) {
    this->field4.readFromJson(folly::toJson(parsed["field4"]).c_str());
    this->__isset.field4 = true;
  } else {
    this->__isset.field4 = false;
  }
  if (parsed["field5"] != nullptr) {
    this->field5.readFromJson(folly::toJson(parsed["field5"]).c_str());
    this->__isset.field5 = true;
  } else {
    this->__isset.field5 = false;
  }
}
void struct1::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct1::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(*schema);
    iprot->setNextStructType(struct1::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;
  bool isset_field3 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast406;
          xfer += iprot->readI32(ecast406);
          this->field2 = (enum1)ecast406;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast407;
          xfer += iprot->readI32(ecast407);
          this->field3 = (enum2)ecast407;
          isset_field3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field4.read(iprot);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field5.read(iprot);
          this->__isset.field5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct1");
  if (!isset_field3)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field3' was not found in serialized data! Struct: struct1");
  return xfer;
}

void struct1::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3 = static_cast<enum2>(0);
  field4.__clear();
  field5.__clear();
  __isset.__clear();
}
uint32_t struct1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct1");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->field3);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field4) {
    xfer += oprot->writeFieldBegin("field4", apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->field4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field5", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->field5.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct1 &a, struct1 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

void merge(const struct1& from, struct1& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  merge(from.field2, to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(from.field3, to.field3);
  if (from.__isset.field4) {
    merge(from.field4, to.field4);
    to.__isset.field4 = true;
  }
  merge(from.field5, to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

void merge(struct1&& from, struct1& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  merge(std::move(from.field2), to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(std::move(from.field3), to.field3);
  if (from.__isset.field4) {
    merge(std::move(from.field4), to.field4);
    to.__isset.field4 = true;
  }
  merge(std::move(from.field5), to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

const uint64_t struct2::_reflection_id;
void struct2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(schema);
}

bool struct2::operator == (const struct2 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  return true;
}

void struct2::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp409 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp409) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp409;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
}
void struct2::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(*schema);
    iprot->setNextStructType(struct2::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast412;
          xfer += iprot->readI32(ecast412);
          this->fieldC = (enum1)ecast412;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast413;
          xfer += iprot->readI32(ecast413);
          this->fieldD = (enum2)ecast413;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct2::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  __isset.__clear();
}
uint32_t struct2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct2");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct2 &a, struct2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

void merge(const struct2& from, struct2& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

void merge(struct2&& from, struct2& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

const uint64_t struct3::_reflection_id;
void struct3::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(schema);
}

bool struct3::operator == (const struct3 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  if (!(this->fieldH == rhs.fieldH))
    return false;
  if (!(this->fieldI == rhs.fieldI))
    return false;
  if (!(this->fieldJ == rhs.fieldJ))
    return false;
  if (!(this->fieldK == rhs.fieldK))
    return false;
  if (!(this->fieldL == rhs.fieldL))
    return false;
  if (!(this->fieldM == rhs.fieldM))
    return false;
  if (!(this->fieldN == rhs.fieldN))
    return false;
  if (!(this->fieldO == rhs.fieldO))
    return false;
  if (!(this->fieldP == rhs.fieldP))
    return false;
  if (!(this->fieldQ == rhs.fieldQ))
    return false;
  if (!(this->fieldR == rhs.fieldR))
    return false;
  return true;
}

void struct3::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp415 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp415) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp415;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
  if (parsed["fieldH"] != nullptr) {
    this->fieldH.readFromJson(folly::toJson(parsed["fieldH"]).c_str());
    this->__isset.fieldH = true;
  } else {
    this->__isset.fieldH = false;
  }
  if (parsed["fieldI"] != nullptr) {
    folly::dynamic _json420 = parsed["fieldI"];
    this->fieldI.clear();
    uint32_t _size418 = _json420.size();
    this->fieldI.resize(_size418);
    for (uint32_t _i419 = 0; _i419 < _size418; ++_i419)
    {
      int64_t _tmp422 = (int64_t)_json420[_i419].asInt();
      if (imaxabs(_tmp422) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->fieldI[_i419] = (int32_t)_tmp422;
      }
    }
    this->__isset.fieldI = true;
  } else {
    this->__isset.fieldI = false;
  }
  if (parsed["fieldJ"] != nullptr) {
    folly::dynamic _json425 = parsed["fieldJ"];
    this->fieldJ.clear();
    uint32_t _size423 = _json425.size();
    this->fieldJ.resize(_size423);
    for (uint32_t _i424 = 0; _i424 < _size423; ++_i424)
    {
      this->fieldJ[_i424] = _json425[_i424].asString();
    }
    this->__isset.fieldJ = true;
  } else {
    this->__isset.fieldJ = false;
  }
  if (parsed["fieldK"] != nullptr) {
    folly::dynamic _json429 = parsed["fieldK"];
    this->fieldK.clear();
    uint32_t _size427 = _json429.size();
    this->fieldK.resize(_size427);
    for (uint32_t _i428 = 0; _i428 < _size427; ++_i428)
    {
      this->fieldK[_i428] = _json429[_i428].asString();
    }
    this->__isset.fieldK = true;
  } else {
    this->__isset.fieldK = false;
  }
  if (parsed["fieldL"] != nullptr) {
    folly::dynamic _json433 = parsed["fieldL"];
    this->fieldL.clear();
    uint32_t _size431 = _json433.size();
    this->fieldL.resize(_size431);
    for (uint32_t _i432 = 0; _i432 < _size431; ++_i432)
    {
      this->fieldL[_i432].readFromJson(folly::toJson(_json433[_i432]).c_str());
    }
    this->__isset.fieldL = true;
  } else {
    this->__isset.fieldL = false;
  }
  if (parsed["fieldM"] != nullptr) {
    folly::dynamic _json437 = parsed["fieldM"];
    this->fieldM.clear();
    uint32_t _size435 = _json437.size();
    for (uint32_t _i436 = 0; _i436 < _size435; ++_i436)
    {
      int32_t _elem439;
      int64_t _tmp440 = (int64_t)_json437[_i436].asInt();
      if (imaxabs(_tmp440) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem439 = (int32_t)_tmp440;
      }
      this->fieldM.insert(_elem439);
    }
    this->__isset.fieldM = true;
  } else {
    this->__isset.fieldM = false;
  }
  if (parsed["fieldN"] != nullptr) {
    folly::dynamic _json443 = parsed["fieldN"];
    this->fieldN.clear();
    uint32_t _size441 = _json443.size();
    for (uint32_t _i442 = 0; _i442 < _size441; ++_i442)
    {
      std::string _elem445;
      _elem445 = _json443[_i442].asString();
      this->fieldN.insert(_elem445);
    }
    this->__isset.fieldN = true;
  } else {
    this->__isset.fieldN = false;
  }
  if (parsed["fieldO"] != nullptr) {
    folly::dynamic _json448 = parsed["fieldO"];
    this->fieldO.clear();
    uint32_t _size446 = _json448.size();
    for (uint32_t _i447 = 0; _i447 < _size446; ++_i447)
    {
      std::string _elem450;
      _elem450 = _json448[_i447].asString();
      this->fieldO.insert(_elem450);
    }
    this->__isset.fieldO = true;
  } else {
    this->__isset.fieldO = false;
  }
  if (parsed["fieldP"] != nullptr) {
    folly::dynamic _json453 = parsed["fieldP"];
    this->fieldP.clear();
    uint32_t _size451 = _json453.size();
    for (uint32_t _i452 = 0; _i452 < _size451; ++_i452)
    {
      structB _elem455;
      _elem455.readFromJson(folly::toJson(_json453[_i452]).c_str());
      this->fieldP.insert(_elem455);
    }
    this->__isset.fieldP = true;
  } else {
    this->__isset.fieldP = false;
  }
  if (parsed["fieldQ"] != nullptr) {
    folly::dynamic _json458 = parsed["fieldQ"];
    this->fieldQ.clear();
    for (folly::dynamic::const_item_iterator _iter460 = _json458.items().begin(); _iter460 != _json458.items().end(); _iter460++)    {
      std::string _key461;
      structA _val462;
      _key461 = (_iter460)->first.asString();
      _val462.readFromJson(folly::toJson(_iter460->second).c_str());
      this->fieldQ[_key461] = _val462;
    }
    this->__isset.fieldQ = true;
  } else {
    this->__isset.fieldQ = false;
  }
  if (parsed["fieldR"] != nullptr) {
    folly::dynamic _json465 = parsed["fieldR"];
    this->fieldR.clear();
    for (folly::dynamic::const_item_iterator _iter467 = _json465.items().begin(); _iter467 != _json465.items().end(); _iter467++)    {
      std::string _key468;
      structB _val469;
      _key468 = (_iter467)->first.asString();
      _val469.readFromJson(folly::toJson(_iter467->second).c_str());
      this->fieldR[_key468] = _val469;
    }
    this->__isset.fieldR = true;
  } else {
    this->__isset.fieldR = false;
  }
}
void struct3::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct3::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(*schema);
    iprot->setNextStructType(struct3::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast470;
          xfer += iprot->readI32(ecast470);
          this->fieldC = (enum1)ecast470;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast471;
          xfer += iprot->readI32(ecast471);
          this->fieldD = (enum2)ecast471;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldH.read(iprot);
          this->__isset.fieldH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldI.clear();
            uint32_t _size472;
            bool _sizeUnknown473;
            apache::thrift::protocol::TType _etype476;
            xfer += iprot->readListBegin(_etype476, _size472, _sizeUnknown473);
            if (!_sizeUnknown473) {
              this->fieldI.resize(_size472);
              uint32_t _i478;
              for (_i478 = 0; _i478 < _size472; ++_i478)
              {
                xfer += iprot->readI32(this->fieldI[_i478]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem479;
                xfer += iprot->readI32(_elem479);
                this->fieldI.push_back(_elem479);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldJ.clear();
            uint32_t _size480;
            bool _sizeUnknown481;
            apache::thrift::protocol::TType _etype484;
            xfer += iprot->readListBegin(_etype484, _size480, _sizeUnknown481);
            if (!_sizeUnknown481) {
              this->fieldJ.resize(_size480);
              uint32_t _i486;
              for (_i486 = 0; _i486 < _size480; ++_i486)
              {
                xfer += iprot->readString(this->fieldJ[_i486]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem487;
                xfer += iprot->readString(_elem487);
                this->fieldJ.push_back(_elem487);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldJ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldK.clear();
            uint32_t _size488;
            bool _sizeUnknown489;
            apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size488, _sizeUnknown489);
            if (!_sizeUnknown489) {
              this->fieldK.resize(_size488);
              uint32_t _i494;
              for (_i494 = 0; _i494 < _size488; ++_i494)
              {
                xfer += iprot->readString(this->fieldK[_i494]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem495;
                xfer += iprot->readString(_elem495);
                this->fieldK.push_back(_elem495);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldL.clear();
            uint32_t _size496;
            bool _sizeUnknown497;
            apache::thrift::protocol::TType _etype500;
            xfer += iprot->readListBegin(_etype500, _size496, _sizeUnknown497);
            if (!_sizeUnknown497) {
              this->fieldL.resize(_size496);
              uint32_t _i502;
              for (_i502 = 0; _i502 < _size496; ++_i502)
              {
                xfer += this->fieldL[_i502].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem503;
                xfer += _elem503.read(iprot);
                this->fieldL.push_back(_elem503);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldM.clear();
            uint32_t _size504;
            bool _sizeUnknown505;
            apache::thrift::protocol::TType _etype508;
            xfer += iprot->readSetBegin(_etype508, _size504, _sizeUnknown505);
            if (!_sizeUnknown505) {
              uint32_t _i510;
              for (_i510 = 0; _i510 < _size504; ++_i510)
              {
                int32_t _elem511;
                xfer += iprot->readI32(_elem511);
                this->fieldM.insert(_elem511);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem512;
                xfer += iprot->readI32(_elem512);
                this->fieldM.insert(_elem512);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldM = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldN.clear();
            uint32_t _size513;
            bool _sizeUnknown514;
            apache::thrift::protocol::TType _etype517;
            xfer += iprot->readSetBegin(_etype517, _size513, _sizeUnknown514);
            if (!_sizeUnknown514) {
              uint32_t _i519;
              for (_i519 = 0; _i519 < _size513; ++_i519)
              {
                std::string _elem520;
                xfer += iprot->readString(_elem520);
                this->fieldN.insert(_elem520);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem521;
                xfer += iprot->readString(_elem521);
                this->fieldN.insert(_elem521);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldO.clear();
            uint32_t _size522;
            bool _sizeUnknown523;
            apache::thrift::protocol::TType _etype526;
            xfer += iprot->readSetBegin(_etype526, _size522, _sizeUnknown523);
            if (!_sizeUnknown523) {
              uint32_t _i528;
              for (_i528 = 0; _i528 < _size522; ++_i528)
              {
                std::string _elem529;
                xfer += iprot->readString(_elem529);
                this->fieldO.insert(_elem529);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem530;
                xfer += iprot->readString(_elem530);
                this->fieldO.insert(_elem530);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldO = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldP.clear();
            uint32_t _size531;
            bool _sizeUnknown532;
            apache::thrift::protocol::TType _etype535;
            xfer += iprot->readSetBegin(_etype535, _size531, _sizeUnknown532);
            if (!_sizeUnknown532) {
              uint32_t _i537;
              for (_i537 = 0; _i537 < _size531; ++_i537)
              {
                structB _elem538;
                xfer += _elem538.read(iprot);
                this->fieldP.insert(_elem538);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem539;
                xfer += _elem539.read(iprot);
                this->fieldP.insert(_elem539);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldQ.clear();
            uint32_t _size540;
            bool _sizeUnknown541;
            apache::thrift::protocol::TType _ktype542;
            apache::thrift::protocol::TType _vtype543;
            xfer += iprot->readMapBegin(_ktype542, _vtype543, _size540, _sizeUnknown541);
            if (!_sizeUnknown541) {
              uint32_t _i546;
              for (_i546 = 0; _i546 < _size540; ++_i546)
              {
                std::string _key547;
                xfer += iprot->readString(_key547);
                structA& _val548 = this->fieldQ[_key547];
                xfer += _val548.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key549;
                xfer += iprot->readString(_key549);
                structA& _val550 = this->fieldQ[_key549];
                xfer += _val550.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldQ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldR.clear();
            uint32_t _size551;
            bool _sizeUnknown552;
            apache::thrift::protocol::TType _ktype553;
            apache::thrift::protocol::TType _vtype554;
            xfer += iprot->readMapBegin(_ktype553, _vtype554, _size551, _sizeUnknown552);
            if (!_sizeUnknown552) {
              uint32_t _i557;
              for (_i557 = 0; _i557 < _size551; ++_i557)
              {
                std::string _key558;
                xfer += iprot->readString(_key558);
                structB& _val559 = this->fieldR[_key558];
                xfer += _val559.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key560;
                xfer += iprot->readString(_key560);
                structB& _val561 = this->fieldR[_key560];
                xfer += _val561.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct3::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  fieldH.__clear();
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}
uint32_t struct3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct3");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldH", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->fieldH.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldI", apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->fieldI.size());
    std::vector<int32_t> ::const_iterator _iter562;
    for (_iter562 = this->fieldI.begin(); _iter562 != this->fieldI.end(); ++_iter562)
    {
      xfer += oprot->writeI32((*_iter562));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldJ", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldJ.size());
    std::vector<std::string> ::const_iterator _iter563;
    for (_iter563 = this->fieldJ.begin(); _iter563 != this->fieldJ.end(); ++_iter563)
    {
      xfer += oprot->writeString((*_iter563));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldK", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldK.size());
    std::vector<std::string> ::const_iterator _iter564;
    for (_iter564 = this->fieldK.begin(); _iter564 != this->fieldK.end(); ++_iter564)
    {
      xfer += oprot->writeString((*_iter564));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldL", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->fieldL.size());
    std::vector<structA> ::const_iterator _iter565;
    for (_iter565 = this->fieldL.begin(); _iter565 != this->fieldL.end(); ++_iter565)
    {
      xfer += (*_iter565).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldM", apache::thrift::protocol::T_SET, 13);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->fieldM.size());
    std::set<int32_t> ::const_iterator _iter566;
    for (_iter566 = this->fieldM.begin(); _iter566 != this->fieldM.end(); ++_iter566)
    {
      xfer += oprot->writeI32((*_iter566));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldN", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldN.size());
    std::set<std::string> ::const_iterator _iter567;
    for (_iter567 = this->fieldN.begin(); _iter567 != this->fieldN.end(); ++_iter567)
    {
      xfer += oprot->writeString((*_iter567));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldO", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldO.size());
    std::set<std::string> ::const_iterator _iter568;
    for (_iter568 = this->fieldO.begin(); _iter568 != this->fieldO.end(); ++_iter568)
    {
      xfer += oprot->writeString((*_iter568));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldP", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->fieldP.size());
    std::set<structB> ::const_iterator _iter569;
    for (_iter569 = this->fieldP.begin(); _iter569 != this->fieldP.end(); ++_iter569)
    {
      xfer += (*_iter569).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldQ", apache::thrift::protocol::T_MAP, 17);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldQ.size());
    std::map<std::string, structA> ::const_iterator _iter570;
    for (_iter570 = this->fieldQ.begin(); _iter570 != this->fieldQ.end(); ++_iter570)
    {
      xfer += oprot->writeString(_iter570->first);
      xfer += _iter570->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldR", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldR.size());
    std::map<std::string, structB> ::const_iterator _iter571;
    for (_iter571 = this->fieldR.begin(); _iter571 != this->fieldR.end(); ++_iter571)
    {
      xfer += oprot->writeString(_iter571->first);
      xfer += _iter571->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct3 &a, struct3 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

void merge(const struct3& from, struct3& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(from.fieldH, to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(from.fieldI, to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(from.fieldJ, to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(from.fieldK, to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(from.fieldL, to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(from.fieldM, to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(from.fieldN, to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(from.fieldO, to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(from.fieldP, to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(from.fieldQ, to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(from.fieldR, to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

void merge(struct3&& from, struct3& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(std::move(from.fieldH), to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(std::move(from.fieldI), to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(std::move(from.fieldJ), to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(std::move(from.fieldK), to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(std::move(from.fieldL), to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(std::move(from.fieldM), to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(std::move(from.fieldN), to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(std::move(from.fieldO), to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(std::move(from.fieldP), to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(std::move(from.fieldQ), to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(std::move(from.fieldR), to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

}} // namespace
