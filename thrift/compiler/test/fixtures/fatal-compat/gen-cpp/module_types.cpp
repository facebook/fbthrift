/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_types.h"
#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_data.h"

#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>

#include <folly/Indestructible.h>

namespace test_cpp1 { namespace cpp_reflection {

const typename _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = _enum1_EnumMapFactory::makeValuesToNamesMap();

const typename _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES = _enum1_EnumMapFactory::makeNamesToValuesMap();

}} // namespace
namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::test_cpp1::cpp_reflection::enum1>::size = 3;
template <>const folly::Range<const  ::test_cpp1::cpp_reflection::enum1*> TEnumTraits< ::test_cpp1::cpp_reflection::enum1>::values = folly::range( ::test_cpp1::cpp_reflection::_enum1EnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp1::cpp_reflection::enum1>::names = folly::range( ::test_cpp1::cpp_reflection::_enum1EnumDataStorage::names);

template<>
const char* TEnumTraits< ::test_cpp1::cpp_reflection::enum1>::findName( ::test_cpp1::cpp_reflection::enum1 value) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum1_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp1::cpp_reflection::_enum1_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::test_cpp1::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum1* out) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum1_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp1::cpp_reflection::_enum1_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift

namespace test_cpp1 { namespace cpp_reflection {
const typename _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = _enum2_EnumMapFactory::makeValuesToNamesMap();

const typename _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES = _enum2_EnumMapFactory::makeNamesToValuesMap();

}} // namespace
namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::test_cpp1::cpp_reflection::enum2>::size = 3;
template <>const folly::Range<const  ::test_cpp1::cpp_reflection::enum2*> TEnumTraits< ::test_cpp1::cpp_reflection::enum2>::values = folly::range( ::test_cpp1::cpp_reflection::_enum2EnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp1::cpp_reflection::enum2>::names = folly::range( ::test_cpp1::cpp_reflection::_enum2EnumDataStorage::names);

template<>
const char* TEnumTraits< ::test_cpp1::cpp_reflection::enum2>::findName( ::test_cpp1::cpp_reflection::enum2 value) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum2_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp1::cpp_reflection::_enum2_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::test_cpp1::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum2* out) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum2_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp1::cpp_reflection::_enum2_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift

namespace test_cpp1 { namespace cpp_reflection {
const typename _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = _enum3_EnumMapFactory::makeValuesToNamesMap();

const typename _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES = _enum3_EnumMapFactory::makeNamesToValuesMap();

}} // namespace
namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::test_cpp1::cpp_reflection::enum3>::size = 3;
template <>const folly::Range<const  ::test_cpp1::cpp_reflection::enum3*> TEnumTraits< ::test_cpp1::cpp_reflection::enum3>::values = folly::range( ::test_cpp1::cpp_reflection::_enum3EnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp1::cpp_reflection::enum3>::names = folly::range( ::test_cpp1::cpp_reflection::_enum3EnumDataStorage::names);

template<>
const char* TEnumTraits< ::test_cpp1::cpp_reflection::enum3>::findName( ::test_cpp1::cpp_reflection::enum3 value) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum3_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp1::cpp_reflection::_enum3_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::test_cpp1::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum3* out) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum3_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp1::cpp_reflection::_enum3_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift

namespace test_cpp1 { namespace cpp_reflection {
const typename _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = _enum_with_special_names_EnumMapFactory::makeValuesToNamesMap();

const typename _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES = _enum_with_special_names_EnumMapFactory::makeNamesToValuesMap();

}} // namespace
namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names>::size = 26;
template <>const folly::Range<const  ::test_cpp1::cpp_reflection::enum_with_special_names*> TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names>::values = folly::range( ::test_cpp1::cpp_reflection::_enum_with_special_namesEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names>::names = folly::range( ::test_cpp1::cpp_reflection::_enum_with_special_namesEnumDataStorage::names);

template<>
const char* TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names>::findName( ::test_cpp1::cpp_reflection::enum_with_special_names value) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum_with_special_names_EnumMapFactory::ValuesToNamesMapType>{ ::test_cpp1::cpp_reflection::_enum_with_special_names_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::test_cpp1::cpp_reflection::enum_with_special_names>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum_with_special_names* out) {
  static const auto map = folly::Indestructible< ::test_cpp1::cpp_reflection::_enum_with_special_names_EnumMapFactory::NamesToValuesMapType>{ ::test_cpp1::cpp_reflection::_enum_with_special_names_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift

namespace test_cpp1 { namespace cpp_reflection {
  void union1::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union1");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui"] != nullptr) {
      set_ui();
      int64_t _tmp0 = (int64_t)parsed["ui"].asInt();
      if (imaxabs(_tmp0) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui = (int32_t)_tmp0;
      }
      return;
    }
    if (parsed["ud"] != nullptr) {
      set_ud();
      this->value_.ud = parsed["ud"].asDouble();
      return;
    }
    if (parsed["us"] != nullptr) {
      set_us();
      this->value_.us = parsed["us"].asString();
      return;
    }
    if (parsed["ue"] != nullptr) {
      set_ue();
      this->value_.ue=(enum1)(int32_t)parsed["ue"].asInt();
      return;
    }
  }
  void union1::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union1::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ui();
          xfer += iprot->readI32(this->value_.ui);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud();
          xfer += iprot->readDouble(this->value_.ud);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_STRING) {
          set_us();
          xfer += iprot->readString(this->value_.us);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ue();
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->value_.ue = (enum1)ecast2;
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union1");
  switch (type_) {
    case Type::ui: {
      xfer += oprot->writeFieldBegin("ui", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud: {
      xfer += oprot->writeFieldBegin("ud", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us: {
      xfer += oprot->writeFieldBegin("us", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue: {
      xfer += oprot->writeFieldBegin("ue", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union2::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union2");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_2"] != nullptr) {
      set_ui_2();
      int64_t _tmp3 = (int64_t)parsed["ui_2"].asInt();
      if (imaxabs(_tmp3) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_2 = (int32_t)_tmp3;
      }
      return;
    }
    if (parsed["ud_2"] != nullptr) {
      set_ud_2();
      this->value_.ud_2 = parsed["ud_2"].asDouble();
      return;
    }
    if (parsed["us_2"] != nullptr) {
      set_us_2();
      this->value_.us_2 = parsed["us_2"].asString();
      return;
    }
    if (parsed["ue_2"] != nullptr) {
      set_ue_2();
      this->value_.ue_2=(enum1)(int32_t)parsed["ue_2"].asInt();
      return;
    }
  }
  void union2::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union2::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ui_2();
          xfer += iprot->readI32(this->value_.ui_2);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_2();
          xfer += iprot->readDouble(this->value_.ud_2);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_STRING) {
          set_us_2();
          xfer += iprot->readString(this->value_.us_2);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ue_2();
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->value_.ue_2 = (enum1)ecast5;
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union2");
  switch (type_) {
    case Type::ui_2: {
      xfer += oprot->writeFieldBegin("ui_2", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_2: {
      xfer += oprot->writeFieldBegin("ud_2", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_2: {
      xfer += oprot->writeFieldBegin("us_2", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_2: {
      xfer += oprot->writeFieldBegin("ue_2", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union3::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union3");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_3"] != nullptr) {
      set_ui_3();
      int64_t _tmp6 = (int64_t)parsed["ui_3"].asInt();
      if (imaxabs(_tmp6) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_3 = (int32_t)_tmp6;
      }
      return;
    }
    if (parsed["ud_3"] != nullptr) {
      set_ud_3();
      this->value_.ud_3 = parsed["ud_3"].asDouble();
      return;
    }
    if (parsed["us_3"] != nullptr) {
      set_us_3();
      this->value_.us_3 = parsed["us_3"].asString();
      return;
    }
    if (parsed["ue_3"] != nullptr) {
      set_ue_3();
      this->value_.ue_3=(enum1)(int32_t)parsed["ue_3"].asInt();
      return;
    }
  }
  void union3::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union3::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ui_3();
          xfer += iprot->readI32(this->value_.ui_3);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_3();
          xfer += iprot->readDouble(this->value_.ud_3);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_STRING) {
          set_us_3();
          xfer += iprot->readString(this->value_.us_3);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ue_3();
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->value_.ue_3 = (enum1)ecast8;
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union3");
  switch (type_) {
    case Type::ui_3: {
      xfer += oprot->writeFieldBegin("ui_3", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_3: {
      xfer += oprot->writeFieldBegin("ud_3", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_3: {
      xfer += oprot->writeFieldBegin("us_3", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_3: {
      xfer += oprot->writeFieldBegin("ue_3", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structA::_reflection_id;
void structA::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(schema);
}

bool structA::operator == (const structA & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  return true;
}

void structA::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["a"] != nullptr) {
    int64_t _tmp10 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp10) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp10;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
}
void structA::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t structA::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(*schema);
    iprot->setNextStructType(structA::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structA::__clear() {
  a = 0;
  b = "";
  __isset.__clear();
}
uint32_t structA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structA");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structA &a, structA &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

void merge(const structA& from, structA& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

void merge(structA&& from, structA& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

  void unionA::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse unionA");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["i"] != nullptr) {
      set_i();
      int64_t _tmp11 = (int64_t)parsed["i"].asInt();
      if (imaxabs(_tmp11) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.i = (int32_t)_tmp11;
      }
      return;
    }
    if (parsed["d"] != nullptr) {
      set_d();
      this->value_.d = parsed["d"].asDouble();
      return;
    }
    if (parsed["s"] != nullptr) {
      set_s();
      this->value_.s = parsed["s"].asString();
      return;
    }
    if (parsed["e"] != nullptr) {
      set_e();
      this->value_.e=(enum1)(int32_t)parsed["e"].asInt();
      return;
    }
    if (parsed["a"] != nullptr) {
      set_a();
      this->value_.a.readFromJson(folly::toJson(parsed["a"]).c_str(), opts);
      return;
    }
  }
  void unionA::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t unionA::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_STRING) {
          set_s();
          xfer += iprot->readString(this->value_.s);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_e();
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->value_.e = (enum1)ecast13;
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 5: {
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          set_a();
          xfer += this->value_.a.read(iprot);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t unionA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("unionA");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::s: {
      xfer += oprot->writeFieldBegin("s", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.s);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::e: {
      xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.e);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::a: {
      xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_STRUCT, 5);
      xfer += this->value_.a.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structB::_reflection_id;
void structB::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(schema);
}

bool structB::operator == (const structB & rhs) const {
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  return true;
}

void structB::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
}
void structB::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t structB::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(*schema);
    iprot->setNextStructType(structB::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}
uint32_t structB::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structB");
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structB &a, structB &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

void merge(const structB& from, structB& to) {
  using apache::thrift::merge;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

void merge(structB&& from, structB& to) {
  using apache::thrift::merge;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

const uint64_t structC::_reflection_id;
void structC::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(schema);
}

bool structC::operator == (const structC & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  if (!(this->e == rhs.e))
    return false;
  if (!(this->f == rhs.f))
    return false;
  if (!(this->g == rhs.g))
    return false;
  if (!(this->h == rhs.h))
    return false;
  if (!(this->i == rhs.i))
    return false;
  if (!(this->j == rhs.j))
    return false;
  if (!(this->j1 == rhs.j1))
    return false;
  if (!(this->j2 == rhs.j2))
    return false;
  if (!(this->j3 == rhs.j3))
    return false;
  if (!(this->k == rhs.k))
    return false;
  if (!(this->k1 == rhs.k1))
    return false;
  if (!(this->k2 == rhs.k2))
    return false;
  if (!(this->k3 == rhs.k3))
    return false;
  if (!(this->l == rhs.l))
    return false;
  if (!(this->l1 == rhs.l1))
    return false;
  if (!(this->l2 == rhs.l2))
    return false;
  if (!(this->l3 == rhs.l3))
    return false;
  if (!(this->m1 == rhs.m1))
    return false;
  if (!(this->m2 == rhs.m2))
    return false;
  if (!(this->m3 == rhs.m3))
    return false;
  if (!(this->n1 == rhs.n1))
    return false;
  if (!(this->n2 == rhs.n2))
    return false;
  if (!(this->n3 == rhs.n3))
    return false;
  if (!(this->o1 == rhs.o1))
    return false;
  if (!(this->o2 == rhs.o2))
    return false;
  if (!(this->o3 == rhs.o3))
    return false;
  return true;
}

void structC::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["a"] != nullptr) {
    int64_t _tmp16 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp16) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp16;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
  if (parsed["e"] != nullptr) {
    this->e=(enum1)(int32_t)parsed["e"].asInt();
    this->__isset.e = true;
  } else {
    this->__isset.e = false;
  }
  if (parsed["f"] != nullptr) {
    this->f=(enum2)(int32_t)parsed["f"].asInt();
    this->__isset.f = true;
  } else {
    this->__isset.f = false;
  }
  if (parsed["g"] != nullptr) {
    this->g.readFromJson(folly::toJson(parsed["g"]).c_str(), opts);
    this->__isset.g = true;
  } else {
    this->__isset.g = false;
  }
  if (parsed["h"] != nullptr) {
    this->h.readFromJson(folly::toJson(parsed["h"]).c_str(), opts);
    this->__isset.h = true;
  } else {
    this->__isset.h = false;
  }
  if (parsed["i"] != nullptr) {
    this->i.readFromJson(folly::toJson(parsed["i"]).c_str(), opts);
    this->__isset.i = true;
  } else {
    this->__isset.i = false;
  }
  if (parsed["j"] != nullptr) {
    folly::dynamic _json21 = parsed["j"];
    this->j.clear();
    uint32_t _size19 = _json21.size();
    this->j.resize(_size19);
    for (uint32_t _i20 = 0; _i20 < _size19; ++_i20)
    {
      int64_t _tmp23 = (int64_t)_json21[_i20].asInt();
      if (imaxabs(_tmp23) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j[_i20] = (int32_t)_tmp23;
      }
    }
    this->__isset.j = true;
  } else {
    this->__isset.j = false;
  }
  if (parsed["j1"] != nullptr) {
    folly::dynamic _json26 = parsed["j1"];
    this->j1.clear();
    uint32_t _size24 = _json26.size();
    this->j1.resize(_size24);
    for (uint32_t _i25 = 0; _i25 < _size24; ++_i25)
    {
      int64_t _tmp28 = (int64_t)_json26[_i25].asInt();
      if (imaxabs(_tmp28) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j1[_i25] = (int32_t)_tmp28;
      }
    }
    this->__isset.j1 = true;
  } else {
    this->__isset.j1 = false;
  }
  if (parsed["j2"] != nullptr) {
    folly::dynamic _json31 = parsed["j2"];
    this->j2.clear();
    uint32_t _size29 = _json31.size();
    this->j2.resize(_size29);
    for (uint32_t _i30 = 0; _i30 < _size29; ++_i30)
    {
      this->j2[_i30]=(enum1)(int32_t)_json31[_i30].asInt();
    }
    this->__isset.j2 = true;
  } else {
    this->__isset.j2 = false;
  }
  if (parsed["j3"] != nullptr) {
    folly::dynamic _json36 = parsed["j3"];
    this->j3.clear();
    uint32_t _size34 = _json36.size();
    this->j3.resize(_size34);
    for (uint32_t _i35 = 0; _i35 < _size34; ++_i35)
    {
      this->j3[_i35].readFromJson(folly::toJson(_json36[_i35]).c_str(), opts);
    }
    this->__isset.j3 = true;
  } else {
    this->__isset.j3 = false;
  }
  if (parsed["k"] != nullptr) {
    folly::dynamic _json40 = parsed["k"];
    this->k.clear();
    uint32_t _size38 = _json40.size();
    for (uint32_t _i39 = 0; _i39 < _size38; ++_i39)
    {
      int32_t _elem42;
      int64_t _tmp43 = (int64_t)_json40[_i39].asInt();
      if (imaxabs(_tmp43) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem42 = (int32_t)_tmp43;
      }
      this->k.insert(_elem42);
    }
    this->__isset.k = true;
  } else {
    this->__isset.k = false;
  }
  if (parsed["k1"] != nullptr) {
    folly::dynamic _json46 = parsed["k1"];
    this->k1.clear();
    uint32_t _size44 = _json46.size();
    for (uint32_t _i45 = 0; _i45 < _size44; ++_i45)
    {
      int32_t _elem48;
      int64_t _tmp49 = (int64_t)_json46[_i45].asInt();
      if (imaxabs(_tmp49) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem48 = (int32_t)_tmp49;
      }
      this->k1.insert(_elem48);
    }
    this->__isset.k1 = true;
  } else {
    this->__isset.k1 = false;
  }
  if (parsed["k2"] != nullptr) {
    folly::dynamic _json52 = parsed["k2"];
    this->k2.clear();
    uint32_t _size50 = _json52.size();
    for (uint32_t _i51 = 0; _i51 < _size50; ++_i51)
    {
      enum2 _elem54;
      _elem54=(enum2)(int32_t)_json52[_i51].asInt();
      this->k2.insert(_elem54);
    }
    this->__isset.k2 = true;
  } else {
    this->__isset.k2 = false;
  }
  if (parsed["k3"] != nullptr) {
    folly::dynamic _json58 = parsed["k3"];
    this->k3.clear();
    uint32_t _size56 = _json58.size();
    for (uint32_t _i57 = 0; _i57 < _size56; ++_i57)
    {
      structB _elem60;
      _elem60.readFromJson(folly::toJson(_json58[_i57]).c_str(), opts);
      this->k3.insert(_elem60);
    }
    this->__isset.k3 = true;
  } else {
    this->__isset.k3 = false;
  }
  if (parsed["l"] != nullptr) {
    folly::dynamic _json63 = parsed["l"];
    this->l.clear();
    for (folly::dynamic::const_item_iterator _iter65 = _json63.items().begin(); _iter65 != _json63.items().end(); _iter65++)    {
      int32_t _key66;
      int32_t _val67;
      try {
        _key66 = folly::to<int32_t>((_iter65)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp68 = (int64_t)_iter65->second.asInt();
      if (imaxabs(_tmp68) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val67 = (int32_t)_tmp68;
      }
      this->l[_key66] = _val67;
    }
    this->__isset.l = true;
  } else {
    this->__isset.l = false;
  }
  if (parsed["l1"] != nullptr) {
    folly::dynamic _json71 = parsed["l1"];
    this->l1.clear();
    for (folly::dynamic::const_item_iterator _iter73 = _json71.items().begin(); _iter73 != _json71.items().end(); _iter73++)    {
      int32_t _key74;
      int32_t _val75;
      try {
        _key74 = folly::to<int32_t>((_iter73)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp76 = (int64_t)_iter73->second.asInt();
      if (imaxabs(_tmp76) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val75 = (int32_t)_tmp76;
      }
      this->l1[_key74] = _val75;
    }
    this->__isset.l1 = true;
  } else {
    this->__isset.l1 = false;
  }
  if (parsed["l2"] != nullptr) {
    folly::dynamic _json79 = parsed["l2"];
    this->l2.clear();
    for (folly::dynamic::const_item_iterator _iter81 = _json79.items().begin(); _iter81 != _json79.items().end(); _iter81++)    {
      int32_t _key82;
      enum1 _val83;
      try {
        _key82 = folly::to<int32_t>((_iter81)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val83=(enum1)(int32_t)_iter81->second.asInt();
      this->l2[_key82] = _val83;
    }
    this->__isset.l2 = true;
  } else {
    this->__isset.l2 = false;
  }
  if (parsed["l3"] != nullptr) {
    folly::dynamic _json87 = parsed["l3"];
    this->l3.clear();
    for (folly::dynamic::const_item_iterator _iter89 = _json87.items().begin(); _iter89 != _json87.items().end(); _iter89++)    {
      int32_t _key90;
      structB _val91;
      try {
        _key90 = folly::to<int32_t>((_iter89)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val91.readFromJson(folly::toJson(_iter89->second).c_str(), opts);
      this->l3[_key90] = _val91;
    }
    this->__isset.l3 = true;
  } else {
    this->__isset.l3 = false;
  }
  if (parsed["m1"] != nullptr) {
    folly::dynamic _json94 = parsed["m1"];
    this->m1.clear();
    for (folly::dynamic::const_item_iterator _iter96 = _json94.items().begin(); _iter96 != _json94.items().end(); _iter96++)    {
      enum1 _key97;
      int32_t _val98;
      try {
        _key97 = (enum1)folly::to<int>((_iter96)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp99 = (int64_t)_iter96->second.asInt();
      if (imaxabs(_tmp99) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val98 = (int32_t)_tmp99;
      }
      this->m1[_key97] = _val98;
    }
    this->__isset.m1 = true;
  } else {
    this->__isset.m1 = false;
  }
  if (parsed["m2"] != nullptr) {
    folly::dynamic _json102 = parsed["m2"];
    this->m2.clear();
    for (folly::dynamic::const_item_iterator _iter104 = _json102.items().begin(); _iter104 != _json102.items().end(); _iter104++)    {
      enum1 _key105;
      enum2 _val106;
      try {
        _key105 = (enum1)folly::to<int>((_iter104)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val106=(enum2)(int32_t)_iter104->second.asInt();
      this->m2[_key105] = _val106;
    }
    this->__isset.m2 = true;
  } else {
    this->__isset.m2 = false;
  }
  if (parsed["m3"] != nullptr) {
    folly::dynamic _json110 = parsed["m3"];
    this->m3.clear();
    for (folly::dynamic::const_item_iterator _iter112 = _json110.items().begin(); _iter112 != _json110.items().end(); _iter112++)    {
      enum1 _key113;
      structB _val114;
      try {
        _key113 = (enum1)folly::to<int>((_iter112)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val114.readFromJson(folly::toJson(_iter112->second).c_str(), opts);
      this->m3[_key113] = _val114;
    }
    this->__isset.m3 = true;
  } else {
    this->__isset.m3 = false;
  }
  if (parsed["n1"] != nullptr) {
    folly::dynamic _json117 = parsed["n1"];
    this->n1.clear();
    for (folly::dynamic::const_item_iterator _iter119 = _json117.items().begin(); _iter119 != _json117.items().end(); _iter119++)    {
      std::string _key120;
      int32_t _val121;
      _key120 = (_iter119)->first.asString();
      int64_t _tmp122 = (int64_t)_iter119->second.asInt();
      if (imaxabs(_tmp122) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val121 = (int32_t)_tmp122;
      }
      this->n1[_key120] = _val121;
    }
    this->__isset.n1 = true;
  } else {
    this->__isset.n1 = false;
  }
  if (parsed["n2"] != nullptr) {
    folly::dynamic _json125 = parsed["n2"];
    this->n2.clear();
    for (folly::dynamic::const_item_iterator _iter127 = _json125.items().begin(); _iter127 != _json125.items().end(); _iter127++)    {
      std::string _key128;
      enum1 _val129;
      _key128 = (_iter127)->first.asString();
      _val129=(enum1)(int32_t)_iter127->second.asInt();
      this->n2[_key128] = _val129;
    }
    this->__isset.n2 = true;
  } else {
    this->__isset.n2 = false;
  }
  if (parsed["n3"] != nullptr) {
    folly::dynamic _json133 = parsed["n3"];
    this->n3.clear();
    for (folly::dynamic::const_item_iterator _iter135 = _json133.items().begin(); _iter135 != _json133.items().end(); _iter135++)    {
      std::string _key136;
      structB _val137;
      _key136 = (_iter135)->first.asString();
      _val137.readFromJson(folly::toJson(_iter135->second).c_str(), opts);
      this->n3[_key136] = _val137;
    }
    this->__isset.n3 = true;
  } else {
    this->__isset.n3 = false;
  }
  if (parsed["o1"] != nullptr) {
    this->__isset.o1 = true;
  } else {
    this->__isset.o1 = false;
  }
  if (parsed["o2"] != nullptr) {
    this->__isset.o2 = true;
  } else {
    this->__isset.o2 = false;
  }
  if (parsed["o3"] != nullptr) {
    this->__isset.o3 = true;
  } else {
    this->__isset.o3 = false;
  }
}
void structC::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t structC::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(*schema);
    iprot->setNextStructType(structC::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast150;
          xfer += iprot->readI32(ecast150);
          this->e = (enum1)ecast150;
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->f = (enum2)ecast151;
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 7:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->g.read(iprot);
          this->__isset.g = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 8:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->h.read(iprot);
          this->__isset.h = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 9:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->i.read(iprot);
          this->__isset.i = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 10:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j.clear();
            uint32_t _size152;
            bool _sizeUnknown153;
            apache::thrift::protocol::TType _etype156;
            xfer += iprot->readListBegin(_etype156, _size152, _sizeUnknown153);
            if (!_sizeUnknown153) {
              this->j.resize(_size152);
              uint32_t _i158;
              for (_i158 = 0; _i158 < _size152; ++_i158)
              {
                xfer += iprot->readI32(this->j[_i158]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem159;
                xfer += iprot->readI32(_elem159);
                this->j.push_back(_elem159);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 11:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j1.clear();
            uint32_t _size160;
            bool _sizeUnknown161;
            apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size160, _sizeUnknown161);
            if (!_sizeUnknown161) {
              this->j1.resize(_size160);
              uint32_t _i166;
              for (_i166 = 0; _i166 < _size160; ++_i166)
              {
                xfer += iprot->readI32(this->j1[_i166]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem167;
                xfer += iprot->readI32(_elem167);
                this->j1.push_back(_elem167);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 12:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j2.clear();
            uint32_t _size168;
            bool _sizeUnknown169;
            apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size168, _sizeUnknown169);
            if (!_sizeUnknown169) {
              this->j2.resize(_size168);
              uint32_t _i174;
              for (_i174 = 0; _i174 < _size168; ++_i174)
              {
                int32_t ecast175;
                xfer += iprot->readI32(ecast175);
                this->j2[_i174] = (enum1)ecast175;
              }
            } else {
              while (iprot->peekList())
              {
                enum1 _elem176;
                int32_t ecast177;
                xfer += iprot->readI32(ecast177);
                _elem176 = (enum1)ecast177;
                this->j2.push_back(_elem176);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 13:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j3.clear();
            uint32_t _size178;
            bool _sizeUnknown179;
            apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size178, _sizeUnknown179);
            if (!_sizeUnknown179) {
              this->j3.resize(_size178);
              uint32_t _i184;
              for (_i184 = 0; _i184 < _size178; ++_i184)
              {
                xfer += this->j3[_i184].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem185;
                xfer += _elem185.read(iprot);
                this->j3.push_back(_elem185);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 14:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->k.clear();
            uint32_t _size186;
            bool _sizeUnknown187;
            apache::thrift::protocol::TType _etype190;
            xfer += iprot->readSetBegin(_etype190, _size186, _sizeUnknown187);
            if (!_sizeUnknown187) {
              uint32_t _i192;
              for (_i192 = 0; _i192 < _size186; ++_i192)
              {
                int32_t _elem193;
                xfer += iprot->readI32(_elem193);
                this->k.insert(_elem193);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem194;
                xfer += iprot->readI32(_elem194);
                this->k.insert(_elem194);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 15:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->k1.clear();
            uint32_t _size195;
            bool _sizeUnknown196;
            apache::thrift::protocol::TType _etype199;
            xfer += iprot->readSetBegin(_etype199, _size195, _sizeUnknown196);
            if (!_sizeUnknown196) {
              uint32_t _i201;
              for (_i201 = 0; _i201 < _size195; ++_i201)
              {
                int32_t _elem202;
                xfer += iprot->readI32(_elem202);
                this->k1.insert(_elem202);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem203;
                xfer += iprot->readI32(_elem203);
                this->k1.insert(_elem203);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 16:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->k2.clear();
            uint32_t _size204;
            bool _sizeUnknown205;
            apache::thrift::protocol::TType _etype208;
            xfer += iprot->readSetBegin(_etype208, _size204, _sizeUnknown205);
            if (!_sizeUnknown205) {
              uint32_t _i210;
              for (_i210 = 0; _i210 < _size204; ++_i210)
              {
                enum2 _elem211;
                int32_t ecast212;
                xfer += iprot->readI32(ecast212);
                _elem211 = (enum2)ecast212;
                this->k2.insert(_elem211);
              }
            } else {
              while (iprot->peekSet())
              {
                enum2 _elem213;
                int32_t ecast214;
                xfer += iprot->readI32(ecast214);
                _elem213 = (enum2)ecast214;
                this->k2.insert(_elem213);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 17:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->k3.clear();
            uint32_t _size215;
            bool _sizeUnknown216;
            apache::thrift::protocol::TType _etype219;
            xfer += iprot->readSetBegin(_etype219, _size215, _sizeUnknown216);
            if (!_sizeUnknown216) {
              uint32_t _i221;
              for (_i221 = 0; _i221 < _size215; ++_i221)
              {
                structB _elem222;
                xfer += _elem222.read(iprot);
                this->k3.insert(_elem222);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem223;
                xfer += _elem223.read(iprot);
                this->k3.insert(_elem223);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 18:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l.clear();
            uint32_t _size224;
            bool _sizeUnknown225;
            apache::thrift::protocol::TType _ktype226;
            apache::thrift::protocol::TType _vtype227;
            xfer += iprot->readMapBegin(_ktype226, _vtype227, _size224, _sizeUnknown225);
            if (!_sizeUnknown225) {
              uint32_t _i230;
              for (_i230 = 0; _i230 < _size224; ++_i230)
              {
                int32_t _key231;
                xfer += iprot->readI32(_key231);
                int32_t& _val232 = this->l[_key231];
                xfer += iprot->readI32(_val232);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key233;
                xfer += iprot->readI32(_key233);
                int32_t& _val234 = this->l[_key233];
                xfer += iprot->readI32(_val234);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 19:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l1.clear();
            uint32_t _size235;
            bool _sizeUnknown236;
            apache::thrift::protocol::TType _ktype237;
            apache::thrift::protocol::TType _vtype238;
            xfer += iprot->readMapBegin(_ktype237, _vtype238, _size235, _sizeUnknown236);
            if (!_sizeUnknown236) {
              uint32_t _i241;
              for (_i241 = 0; _i241 < _size235; ++_i241)
              {
                int32_t _key242;
                xfer += iprot->readI32(_key242);
                int32_t& _val243 = this->l1[_key242];
                xfer += iprot->readI32(_val243);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key244;
                xfer += iprot->readI32(_key244);
                int32_t& _val245 = this->l1[_key244];
                xfer += iprot->readI32(_val245);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 20:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l2.clear();
            uint32_t _size246;
            bool _sizeUnknown247;
            apache::thrift::protocol::TType _ktype248;
            apache::thrift::protocol::TType _vtype249;
            xfer += iprot->readMapBegin(_ktype248, _vtype249, _size246, _sizeUnknown247);
            if (!_sizeUnknown247) {
              uint32_t _i252;
              for (_i252 = 0; _i252 < _size246; ++_i252)
              {
                int32_t _key253;
                xfer += iprot->readI32(_key253);
                enum1& _val254 = this->l2[_key253];
                int32_t ecast255;
                xfer += iprot->readI32(ecast255);
                _val254 = (enum1)ecast255;
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key256;
                xfer += iprot->readI32(_key256);
                enum1& _val257 = this->l2[_key256];
                int32_t ecast258;
                xfer += iprot->readI32(ecast258);
                _val257 = (enum1)ecast258;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 21:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l3.clear();
            uint32_t _size259;
            bool _sizeUnknown260;
            apache::thrift::protocol::TType _ktype261;
            apache::thrift::protocol::TType _vtype262;
            xfer += iprot->readMapBegin(_ktype261, _vtype262, _size259, _sizeUnknown260);
            if (!_sizeUnknown260) {
              uint32_t _i265;
              for (_i265 = 0; _i265 < _size259; ++_i265)
              {
                int32_t _key266;
                xfer += iprot->readI32(_key266);
                structB& _val267 = this->l3[_key266];
                xfer += _val267.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key268;
                xfer += iprot->readI32(_key268);
                structB& _val269 = this->l3[_key268];
                xfer += _val269.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 22:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m1.clear();
            uint32_t _size270;
            bool _sizeUnknown271;
            apache::thrift::protocol::TType _ktype272;
            apache::thrift::protocol::TType _vtype273;
            xfer += iprot->readMapBegin(_ktype272, _vtype273, _size270, _sizeUnknown271);
            if (!_sizeUnknown271) {
              uint32_t _i276;
              for (_i276 = 0; _i276 < _size270; ++_i276)
              {
                enum1 _key277;
                int32_t ecast279;
                xfer += iprot->readI32(ecast279);
                _key277 = (enum1)ecast279;
                int32_t& _val278 = this->m1[_key277];
                xfer += iprot->readI32(_val278);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key280;
                int32_t ecast282;
                xfer += iprot->readI32(ecast282);
                _key280 = (enum1)ecast282;
                int32_t& _val281 = this->m1[_key280];
                xfer += iprot->readI32(_val281);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 23:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m2.clear();
            uint32_t _size283;
            bool _sizeUnknown284;
            apache::thrift::protocol::TType _ktype285;
            apache::thrift::protocol::TType _vtype286;
            xfer += iprot->readMapBegin(_ktype285, _vtype286, _size283, _sizeUnknown284);
            if (!_sizeUnknown284) {
              uint32_t _i289;
              for (_i289 = 0; _i289 < _size283; ++_i289)
              {
                enum1 _key290;
                int32_t ecast292;
                xfer += iprot->readI32(ecast292);
                _key290 = (enum1)ecast292;
                enum2& _val291 = this->m2[_key290];
                int32_t ecast293;
                xfer += iprot->readI32(ecast293);
                _val291 = (enum2)ecast293;
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key294;
                int32_t ecast296;
                xfer += iprot->readI32(ecast296);
                _key294 = (enum1)ecast296;
                enum2& _val295 = this->m2[_key294];
                int32_t ecast297;
                xfer += iprot->readI32(ecast297);
                _val295 = (enum2)ecast297;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 24:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m3.clear();
            uint32_t _size298;
            bool _sizeUnknown299;
            apache::thrift::protocol::TType _ktype300;
            apache::thrift::protocol::TType _vtype301;
            xfer += iprot->readMapBegin(_ktype300, _vtype301, _size298, _sizeUnknown299);
            if (!_sizeUnknown299) {
              uint32_t _i304;
              for (_i304 = 0; _i304 < _size298; ++_i304)
              {
                enum1 _key305;
                int32_t ecast307;
                xfer += iprot->readI32(ecast307);
                _key305 = (enum1)ecast307;
                structB& _val306 = this->m3[_key305];
                xfer += _val306.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key308;
                int32_t ecast310;
                xfer += iprot->readI32(ecast310);
                _key308 = (enum1)ecast310;
                structB& _val309 = this->m3[_key308];
                xfer += _val309.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 25:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n1.clear();
            uint32_t _size311;
            bool _sizeUnknown312;
            apache::thrift::protocol::TType _ktype313;
            apache::thrift::protocol::TType _vtype314;
            xfer += iprot->readMapBegin(_ktype313, _vtype314, _size311, _sizeUnknown312);
            if (!_sizeUnknown312) {
              uint32_t _i317;
              for (_i317 = 0; _i317 < _size311; ++_i317)
              {
                std::string _key318;
                xfer += iprot->readString(_key318);
                int32_t& _val319 = this->n1[_key318];
                xfer += iprot->readI32(_val319);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key320;
                xfer += iprot->readString(_key320);
                int32_t& _val321 = this->n1[_key320];
                xfer += iprot->readI32(_val321);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 26:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n2.clear();
            uint32_t _size322;
            bool _sizeUnknown323;
            apache::thrift::protocol::TType _ktype324;
            apache::thrift::protocol::TType _vtype325;
            xfer += iprot->readMapBegin(_ktype324, _vtype325, _size322, _sizeUnknown323);
            if (!_sizeUnknown323) {
              uint32_t _i328;
              for (_i328 = 0; _i328 < _size322; ++_i328)
              {
                std::string _key329;
                xfer += iprot->readString(_key329);
                enum1& _val330 = this->n2[_key329];
                int32_t ecast331;
                xfer += iprot->readI32(ecast331);
                _val330 = (enum1)ecast331;
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key332;
                xfer += iprot->readString(_key332);
                enum1& _val333 = this->n2[_key332];
                int32_t ecast334;
                xfer += iprot->readI32(ecast334);
                _val333 = (enum1)ecast334;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 27:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n3.clear();
            uint32_t _size335;
            bool _sizeUnknown336;
            apache::thrift::protocol::TType _ktype337;
            apache::thrift::protocol::TType _vtype338;
            xfer += iprot->readMapBegin(_ktype337, _vtype338, _size335, _sizeUnknown336);
            if (!_sizeUnknown336) {
              uint32_t _i341;
              for (_i341 = 0; _i341 < _size335; ++_i341)
              {
                std::string _key342;
                xfer += iprot->readString(_key342);
                structB& _val343 = this->n3[_key342];
                xfer += _val343.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key344;
                xfer += iprot->readString(_key344);
                structB& _val345 = this->n3[_key344];
                xfer += _val345.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 28:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o1.clear();
            uint32_t _size346;
            bool _sizeUnknown347;
            apache::thrift::protocol::TType _ktype348;
            apache::thrift::protocol::TType _vtype349;
            xfer += iprot->readMapBegin(_ktype348, _vtype349, _size346, _sizeUnknown347);
            if (!_sizeUnknown347) {
              uint32_t _i352;
              for (_i352 = 0; _i352 < _size346; ++_i352)
              {
                structA _key353;
                xfer += _key353.read(iprot);
                int32_t& _val354 = this->o1[_key353];
                xfer += iprot->readI32(_val354);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key355;
                xfer += _key355.read(iprot);
                int32_t& _val356 = this->o1[_key355];
                xfer += iprot->readI32(_val356);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 29:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o2.clear();
            uint32_t _size357;
            bool _sizeUnknown358;
            apache::thrift::protocol::TType _ktype359;
            apache::thrift::protocol::TType _vtype360;
            xfer += iprot->readMapBegin(_ktype359, _vtype360, _size357, _sizeUnknown358);
            if (!_sizeUnknown358) {
              uint32_t _i363;
              for (_i363 = 0; _i363 < _size357; ++_i363)
              {
                structA _key364;
                xfer += _key364.read(iprot);
                enum1& _val365 = this->o2[_key364];
                int32_t ecast366;
                xfer += iprot->readI32(ecast366);
                _val365 = (enum1)ecast366;
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key367;
                xfer += _key367.read(iprot);
                enum1& _val368 = this->o2[_key367];
                int32_t ecast369;
                xfer += iprot->readI32(ecast369);
                _val368 = (enum1)ecast369;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 30:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o3.clear();
            uint32_t _size370;
            bool _sizeUnknown371;
            apache::thrift::protocol::TType _ktype372;
            apache::thrift::protocol::TType _vtype373;
            xfer += iprot->readMapBegin(_ktype372, _vtype373, _size370, _sizeUnknown371);
            if (!_sizeUnknown371) {
              uint32_t _i376;
              for (_i376 = 0; _i376 < _size370; ++_i376)
              {
                structA _key377;
                xfer += _key377.read(iprot);
                structB& _val378 = this->o3[_key377];
                xfer += _val378.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key379;
                xfer += _key379.read(iprot);
                structB& _val380 = this->o3[_key379];
                xfer += _val380.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structC::__clear() {
  a = 0;
  b = "";
  c = 0;
  d = 0;
  e = static_cast<enum1>(0);
  f = static_cast<enum2>(0);
  g.__clear();
  h.__clear();
  i.__clear();
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}
uint32_t structC::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structC");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->e);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->f);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("g", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->g.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("h", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->h.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->i.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j.size());
    std::vector<int32_t> ::const_iterator _iter381;
    for (_iter381 = this->j.begin(); _iter381 != this->j.end(); ++_iter381)
    {
      xfer += oprot->writeI32((*_iter381));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j1", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j1.size());
    std::vector<int32_t> ::const_iterator _iter382;
    for (_iter382 = this->j1.begin(); _iter382 != this->j1.end(); ++_iter382)
    {
      xfer += oprot->writeI32((*_iter382));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j2", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j2.size());
    std::vector<enum1> ::const_iterator _iter383;
    for (_iter383 = this->j2.begin(); _iter383 != this->j2.end(); ++_iter383)
    {
      xfer += oprot->writeI32((int32_t)(*_iter383));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j3", apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->j3.size());
    std::vector<structA> ::const_iterator _iter384;
    for (_iter384 = this->j3.begin(); _iter384 != this->j3.end(); ++_iter384)
    {
      xfer += (*_iter384).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k.size());
    std::set<int32_t> ::const_iterator _iter385;
    for (_iter385 = this->k.begin(); _iter385 != this->k.end(); ++_iter385)
    {
      xfer += oprot->writeI32((*_iter385));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k1", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k1.size());
    std::set<int32_t> ::const_iterator _iter386;
    for (_iter386 = this->k1.begin(); _iter386 != this->k1.end(); ++_iter386)
    {
      xfer += oprot->writeI32((*_iter386));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k2", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k2.size());
    std::set<enum2> ::const_iterator _iter387;
    for (_iter387 = this->k2.begin(); _iter387 != this->k2.end(); ++_iter387)
    {
      xfer += oprot->writeI32((int32_t)(*_iter387));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k3", apache::thrift::protocol::T_SET, 17);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->k3.size());
    std::set<structB> ::const_iterator _iter388;
    for (_iter388 = this->k3.begin(); _iter388 != this->k3.end(); ++_iter388)
    {
      xfer += (*_iter388).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l.size());
    std::map<int32_t, int32_t> ::const_iterator _iter389;
    for (_iter389 = this->l.begin(); _iter389 != this->l.end(); ++_iter389)
    {
      xfer += oprot->writeI32(_iter389->first);
      xfer += oprot->writeI32(_iter389->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l1", apache::thrift::protocol::T_MAP, 19);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l1.size());
    std::map<int32_t, int32_t> ::const_iterator _iter390;
    for (_iter390 = this->l1.begin(); _iter390 != this->l1.end(); ++_iter390)
    {
      xfer += oprot->writeI32(_iter390->first);
      xfer += oprot->writeI32(_iter390->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l2", apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l2.size());
    std::map<int32_t, enum1> ::const_iterator _iter391;
    for (_iter391 = this->l2.begin(); _iter391 != this->l2.end(); ++_iter391)
    {
      xfer += oprot->writeI32(_iter391->first);
      xfer += oprot->writeI32((int32_t)_iter391->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l3", apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->l3.size());
    std::map<int32_t, structB> ::const_iterator _iter392;
    for (_iter392 = this->l3.begin(); _iter392 != this->l3.end(); ++_iter392)
    {
      xfer += oprot->writeI32(_iter392->first);
      xfer += _iter392->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m1", apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m1.size());
    std::map<enum1, int32_t> ::const_iterator _iter393;
    for (_iter393 = this->m1.begin(); _iter393 != this->m1.end(); ++_iter393)
    {
      xfer += oprot->writeI32((int32_t)_iter393->first);
      xfer += oprot->writeI32(_iter393->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m2", apache::thrift::protocol::T_MAP, 23);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m2.size());
    std::map<enum1, enum2> ::const_iterator _iter394;
    for (_iter394 = this->m2.begin(); _iter394 != this->m2.end(); ++_iter394)
    {
      xfer += oprot->writeI32((int32_t)_iter394->first);
      xfer += oprot->writeI32((int32_t)_iter394->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m3", apache::thrift::protocol::T_MAP, 24);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->m3.size());
    std::map<enum1, structB> ::const_iterator _iter395;
    for (_iter395 = this->m3.begin(); _iter395 != this->m3.end(); ++_iter395)
    {
      xfer += oprot->writeI32((int32_t)_iter395->first);
      xfer += _iter395->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n1", apache::thrift::protocol::T_MAP, 25);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n1.size());
    std::map<std::string, int32_t> ::const_iterator _iter396;
    for (_iter396 = this->n1.begin(); _iter396 != this->n1.end(); ++_iter396)
    {
      xfer += oprot->writeString(_iter396->first);
      xfer += oprot->writeI32(_iter396->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n2", apache::thrift::protocol::T_MAP, 26);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n2.size());
    std::map<std::string, enum1> ::const_iterator _iter397;
    for (_iter397 = this->n2.begin(); _iter397 != this->n2.end(); ++_iter397)
    {
      xfer += oprot->writeString(_iter397->first);
      xfer += oprot->writeI32((int32_t)_iter397->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n3", apache::thrift::protocol::T_MAP, 27);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->n3.size());
    std::map<std::string, structB> ::const_iterator _iter398;
    for (_iter398 = this->n3.begin(); _iter398 != this->n3.end(); ++_iter398)
    {
      xfer += oprot->writeString(_iter398->first);
      xfer += _iter398->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o1", apache::thrift::protocol::T_MAP, 28);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o1.size());
    std::map<structA, int32_t> ::const_iterator _iter399;
    for (_iter399 = this->o1.begin(); _iter399 != this->o1.end(); ++_iter399)
    {
      xfer += _iter399->first.write(oprot);
      xfer += oprot->writeI32(_iter399->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o2", apache::thrift::protocol::T_MAP, 29);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o2.size());
    std::map<structA, enum1> ::const_iterator _iter400;
    for (_iter400 = this->o2.begin(); _iter400 != this->o2.end(); ++_iter400)
    {
      xfer += _iter400->first.write(oprot);
      xfer += oprot->writeI32((int32_t)_iter400->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o3", apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_STRUCT, this->o3.size());
    std::map<structA, structB> ::const_iterator _iter401;
    for (_iter401 = this->o3.begin(); _iter401 != this->o3.end(); ++_iter401)
    {
      xfer += _iter401->first.write(oprot);
      xfer += _iter401->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structC &a, structC &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

void merge(const structC& from, structC& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(from.e, to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(from.f, to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(from.g, to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(from.h, to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(from.i, to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(from.j, to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(from.j1, to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(from.j2, to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(from.j3, to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(from.k, to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(from.k1, to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(from.k2, to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(from.k3, to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(from.l, to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(from.l1, to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(from.l2, to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(from.l3, to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(from.m1, to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(from.m2, to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(from.m3, to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(from.n1, to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(from.n2, to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(from.n3, to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(from.o1, to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(from.o2, to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(from.o3, to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

void merge(structC&& from, structC& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(std::move(from.e), to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(std::move(from.f), to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(std::move(from.g), to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(std::move(from.h), to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(std::move(from.i), to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(std::move(from.j), to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(std::move(from.j1), to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(std::move(from.j2), to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(std::move(from.j3), to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(std::move(from.k), to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(std::move(from.k1), to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(std::move(from.k2), to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(std::move(from.k3), to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(std::move(from.l), to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(std::move(from.l1), to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(std::move(from.l2), to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(std::move(from.l3), to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(std::move(from.m1), to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(std::move(from.m2), to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(std::move(from.m3), to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(std::move(from.n1), to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(std::move(from.n2), to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(std::move(from.n3), to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(std::move(from.o1), to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(std::move(from.o2), to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(std::move(from.o3), to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

const uint64_t struct1::_reflection_id;
void struct1::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(schema);
}

bool struct1::operator == (const struct1 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  if (__isset.field4 != rhs.__isset.field4)
    return false;
  else if (__isset.field4 && !(field4 == rhs.field4))
    return false;
  if (!(this->field5 == rhs.field5))
    return false;
  return true;
}

void struct1::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["field0"] != nullptr) {
    int64_t _tmp403 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp403) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp403;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3=(enum2)(int32_t)parsed["field3"].asInt();
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field4"] != nullptr) {
    this->field4.readFromJson(folly::toJson(parsed["field4"]).c_str(), opts);
    this->__isset.field4 = true;
  } else {
    this->__isset.field4 = false;
  }
  if (parsed["field5"] != nullptr) {
    this->field5.readFromJson(folly::toJson(parsed["field5"]).c_str(), opts);
    this->__isset.field5 = true;
  } else {
    this->__isset.field5 = false;
  }
}
void struct1::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct1::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(*schema);
    iprot->setNextStructType(struct1::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;
  bool isset_field3 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast406;
          xfer += iprot->readI32(ecast406);
          this->field2 = (enum1)ecast406;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast407;
          xfer += iprot->readI32(ecast407);
          this->field3 = (enum2)ecast407;
          isset_field3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field4.read(iprot);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field5.read(iprot);
          this->__isset.field5 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct1");
  if (!isset_field3)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field3' was not found in serialized data! Struct: struct1");
  return xfer;
}

void struct1::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3 = static_cast<enum2>(0);
  field4.__clear();
  field5.__clear();
  __isset.__clear();
}
uint32_t struct1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct1");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->field3);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field4) {
    xfer += oprot->writeFieldBegin("field4", apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->field4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field5", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->field5.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct1 &a, struct1 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

void merge(const struct1& from, struct1& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  merge(from.field2, to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(from.field3, to.field3);
  if (from.__isset.field4) {
    merge(from.field4, to.field4);
    to.__isset.field4 = true;
  }
  merge(from.field5, to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

void merge(struct1&& from, struct1& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  merge(std::move(from.field2), to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(std::move(from.field3), to.field3);
  if (from.__isset.field4) {
    merge(std::move(from.field4), to.field4);
    to.__isset.field4 = true;
  }
  merge(std::move(from.field5), to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

const uint64_t struct2::_reflection_id;
void struct2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(schema);
}

bool struct2::operator == (const struct2 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  return true;
}

void struct2::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp409 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp409) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp409;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str(), opts);
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str(), opts);
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str(), opts);
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
}
void struct2::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(*schema);
    iprot->setNextStructType(struct2::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast412;
          xfer += iprot->readI32(ecast412);
          this->fieldC = (enum1)ecast412;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast413;
          xfer += iprot->readI32(ecast413);
          this->fieldD = (enum2)ecast413;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 7:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct2::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  __isset.__clear();
}
uint32_t struct2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct2");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct2 &a, struct2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

void merge(const struct2& from, struct2& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

void merge(struct2&& from, struct2& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

const uint64_t struct3::_reflection_id;
void struct3::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(schema);
}

bool struct3::operator == (const struct3 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  if (!(this->fieldH == rhs.fieldH))
    return false;
  if (!(this->fieldI == rhs.fieldI))
    return false;
  if (!(this->fieldJ == rhs.fieldJ))
    return false;
  if (!(this->fieldK == rhs.fieldK))
    return false;
  if (!(this->fieldL == rhs.fieldL))
    return false;
  if (!(this->fieldM == rhs.fieldM))
    return false;
  if (!(this->fieldN == rhs.fieldN))
    return false;
  if (!(this->fieldO == rhs.fieldO))
    return false;
  if (!(this->fieldP == rhs.fieldP))
    return false;
  if (!(this->fieldQ == rhs.fieldQ))
    return false;
  if (!(this->fieldR == rhs.fieldR))
    return false;
  return true;
}

void struct3::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp415 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp415) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp415;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str(), opts);
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str(), opts);
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str(), opts);
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
  if (parsed["fieldH"] != nullptr) {
    this->fieldH.readFromJson(folly::toJson(parsed["fieldH"]).c_str(), opts);
    this->__isset.fieldH = true;
  } else {
    this->__isset.fieldH = false;
  }
  if (parsed["fieldI"] != nullptr) {
    folly::dynamic _json420 = parsed["fieldI"];
    this->fieldI.clear();
    uint32_t _size418 = _json420.size();
    this->fieldI.resize(_size418);
    for (uint32_t _i419 = 0; _i419 < _size418; ++_i419)
    {
      int64_t _tmp422 = (int64_t)_json420[_i419].asInt();
      if (imaxabs(_tmp422) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->fieldI[_i419] = (int32_t)_tmp422;
      }
    }
    this->__isset.fieldI = true;
  } else {
    this->__isset.fieldI = false;
  }
  if (parsed["fieldJ"] != nullptr) {
    folly::dynamic _json425 = parsed["fieldJ"];
    this->fieldJ.clear();
    uint32_t _size423 = _json425.size();
    this->fieldJ.resize(_size423);
    for (uint32_t _i424 = 0; _i424 < _size423; ++_i424)
    {
      this->fieldJ[_i424] = _json425[_i424].asString();
    }
    this->__isset.fieldJ = true;
  } else {
    this->__isset.fieldJ = false;
  }
  if (parsed["fieldK"] != nullptr) {
    folly::dynamic _json429 = parsed["fieldK"];
    this->fieldK.clear();
    uint32_t _size427 = _json429.size();
    this->fieldK.resize(_size427);
    for (uint32_t _i428 = 0; _i428 < _size427; ++_i428)
    {
      this->fieldK[_i428] = _json429[_i428].asString();
    }
    this->__isset.fieldK = true;
  } else {
    this->__isset.fieldK = false;
  }
  if (parsed["fieldL"] != nullptr) {
    folly::dynamic _json433 = parsed["fieldL"];
    this->fieldL.clear();
    uint32_t _size431 = _json433.size();
    this->fieldL.resize(_size431);
    for (uint32_t _i432 = 0; _i432 < _size431; ++_i432)
    {
      this->fieldL[_i432].readFromJson(folly::toJson(_json433[_i432]).c_str(), opts);
    }
    this->__isset.fieldL = true;
  } else {
    this->__isset.fieldL = false;
  }
  if (parsed["fieldM"] != nullptr) {
    folly::dynamic _json437 = parsed["fieldM"];
    this->fieldM.clear();
    uint32_t _size435 = _json437.size();
    for (uint32_t _i436 = 0; _i436 < _size435; ++_i436)
    {
      int32_t _elem439;
      int64_t _tmp440 = (int64_t)_json437[_i436].asInt();
      if (imaxabs(_tmp440) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem439 = (int32_t)_tmp440;
      }
      this->fieldM.insert(_elem439);
    }
    this->__isset.fieldM = true;
  } else {
    this->__isset.fieldM = false;
  }
  if (parsed["fieldN"] != nullptr) {
    folly::dynamic _json443 = parsed["fieldN"];
    this->fieldN.clear();
    uint32_t _size441 = _json443.size();
    for (uint32_t _i442 = 0; _i442 < _size441; ++_i442)
    {
      std::string _elem445;
      _elem445 = _json443[_i442].asString();
      this->fieldN.insert(_elem445);
    }
    this->__isset.fieldN = true;
  } else {
    this->__isset.fieldN = false;
  }
  if (parsed["fieldO"] != nullptr) {
    folly::dynamic _json448 = parsed["fieldO"];
    this->fieldO.clear();
    uint32_t _size446 = _json448.size();
    for (uint32_t _i447 = 0; _i447 < _size446; ++_i447)
    {
      std::string _elem450;
      _elem450 = _json448[_i447].asString();
      this->fieldO.insert(_elem450);
    }
    this->__isset.fieldO = true;
  } else {
    this->__isset.fieldO = false;
  }
  if (parsed["fieldP"] != nullptr) {
    folly::dynamic _json453 = parsed["fieldP"];
    this->fieldP.clear();
    uint32_t _size451 = _json453.size();
    for (uint32_t _i452 = 0; _i452 < _size451; ++_i452)
    {
      structB _elem455;
      _elem455.readFromJson(folly::toJson(_json453[_i452]).c_str(), opts);
      this->fieldP.insert(_elem455);
    }
    this->__isset.fieldP = true;
  } else {
    this->__isset.fieldP = false;
  }
  if (parsed["fieldQ"] != nullptr) {
    folly::dynamic _json458 = parsed["fieldQ"];
    this->fieldQ.clear();
    for (folly::dynamic::const_item_iterator _iter460 = _json458.items().begin(); _iter460 != _json458.items().end(); _iter460++)    {
      std::string _key461;
      structA _val462;
      _key461 = (_iter460)->first.asString();
      _val462.readFromJson(folly::toJson(_iter460->second).c_str(), opts);
      this->fieldQ[_key461] = _val462;
    }
    this->__isset.fieldQ = true;
  } else {
    this->__isset.fieldQ = false;
  }
  if (parsed["fieldR"] != nullptr) {
    folly::dynamic _json465 = parsed["fieldR"];
    this->fieldR.clear();
    for (folly::dynamic::const_item_iterator _iter467 = _json465.items().begin(); _iter467 != _json465.items().end(); _iter467++)    {
      std::string _key468;
      structB _val469;
      _key468 = (_iter467)->first.asString();
      _val469.readFromJson(folly::toJson(_iter467->second).c_str(), opts);
      this->fieldR[_key468] = _val469;
    }
    this->__isset.fieldR = true;
  } else {
    this->__isset.fieldR = false;
  }
}
void struct3::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct3::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(*schema);
    iprot->setNextStructType(struct3::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast470;
          xfer += iprot->readI32(ecast470);
          this->fieldC = (enum1)ecast470;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast471;
          xfer += iprot->readI32(ecast471);
          this->fieldD = (enum2)ecast471;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 7:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 8:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldH.read(iprot);
          this->__isset.fieldH = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 9:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldI.clear();
            uint32_t _size472;
            bool _sizeUnknown473;
            apache::thrift::protocol::TType _etype476;
            xfer += iprot->readListBegin(_etype476, _size472, _sizeUnknown473);
            if (!_sizeUnknown473) {
              this->fieldI.resize(_size472);
              uint32_t _i478;
              for (_i478 = 0; _i478 < _size472; ++_i478)
              {
                xfer += iprot->readI32(this->fieldI[_i478]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem479;
                xfer += iprot->readI32(_elem479);
                this->fieldI.push_back(_elem479);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldI = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 10:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldJ.clear();
            uint32_t _size480;
            bool _sizeUnknown481;
            apache::thrift::protocol::TType _etype484;
            xfer += iprot->readListBegin(_etype484, _size480, _sizeUnknown481);
            if (!_sizeUnknown481) {
              this->fieldJ.resize(_size480);
              uint32_t _i486;
              for (_i486 = 0; _i486 < _size480; ++_i486)
              {
                xfer += iprot->readString(this->fieldJ[_i486]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem487;
                xfer += iprot->readString(_elem487);
                this->fieldJ.push_back(_elem487);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldJ = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 11:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldK.clear();
            uint32_t _size488;
            bool _sizeUnknown489;
            apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size488, _sizeUnknown489);
            if (!_sizeUnknown489) {
              this->fieldK.resize(_size488);
              uint32_t _i494;
              for (_i494 = 0; _i494 < _size488; ++_i494)
              {
                xfer += iprot->readString(this->fieldK[_i494]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem495;
                xfer += iprot->readString(_elem495);
                this->fieldK.push_back(_elem495);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldK = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 12:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldL.clear();
            uint32_t _size496;
            bool _sizeUnknown497;
            apache::thrift::protocol::TType _etype500;
            xfer += iprot->readListBegin(_etype500, _size496, _sizeUnknown497);
            if (!_sizeUnknown497) {
              this->fieldL.resize(_size496);
              uint32_t _i502;
              for (_i502 = 0; _i502 < _size496; ++_i502)
              {
                xfer += this->fieldL[_i502].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem503;
                xfer += _elem503.read(iprot);
                this->fieldL.push_back(_elem503);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldL = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 13:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldM.clear();
            uint32_t _size504;
            bool _sizeUnknown505;
            apache::thrift::protocol::TType _etype508;
            xfer += iprot->readSetBegin(_etype508, _size504, _sizeUnknown505);
            if (!_sizeUnknown505) {
              uint32_t _i510;
              for (_i510 = 0; _i510 < _size504; ++_i510)
              {
                int32_t _elem511;
                xfer += iprot->readI32(_elem511);
                this->fieldM.insert(_elem511);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem512;
                xfer += iprot->readI32(_elem512);
                this->fieldM.insert(_elem512);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldM = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 14:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldN.clear();
            uint32_t _size513;
            bool _sizeUnknown514;
            apache::thrift::protocol::TType _etype517;
            xfer += iprot->readSetBegin(_etype517, _size513, _sizeUnknown514);
            if (!_sizeUnknown514) {
              uint32_t _i519;
              for (_i519 = 0; _i519 < _size513; ++_i519)
              {
                std::string _elem520;
                xfer += iprot->readString(_elem520);
                this->fieldN.insert(_elem520);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem521;
                xfer += iprot->readString(_elem521);
                this->fieldN.insert(_elem521);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldN = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 15:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldO.clear();
            uint32_t _size522;
            bool _sizeUnknown523;
            apache::thrift::protocol::TType _etype526;
            xfer += iprot->readSetBegin(_etype526, _size522, _sizeUnknown523);
            if (!_sizeUnknown523) {
              uint32_t _i528;
              for (_i528 = 0; _i528 < _size522; ++_i528)
              {
                std::string _elem529;
                xfer += iprot->readString(_elem529);
                this->fieldO.insert(_elem529);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem530;
                xfer += iprot->readString(_elem530);
                this->fieldO.insert(_elem530);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldO = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 16:
        if (_ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldP.clear();
            uint32_t _size531;
            bool _sizeUnknown532;
            apache::thrift::protocol::TType _etype535;
            xfer += iprot->readSetBegin(_etype535, _size531, _sizeUnknown532);
            if (!_sizeUnknown532) {
              uint32_t _i537;
              for (_i537 = 0; _i537 < _size531; ++_i537)
              {
                structB _elem538;
                xfer += _elem538.read(iprot);
                this->fieldP.insert(_elem538);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem539;
                xfer += _elem539.read(iprot);
                this->fieldP.insert(_elem539);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldP = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 17:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldQ.clear();
            uint32_t _size540;
            bool _sizeUnknown541;
            apache::thrift::protocol::TType _ktype542;
            apache::thrift::protocol::TType _vtype543;
            xfer += iprot->readMapBegin(_ktype542, _vtype543, _size540, _sizeUnknown541);
            if (!_sizeUnknown541) {
              uint32_t _i546;
              for (_i546 = 0; _i546 < _size540; ++_i546)
              {
                std::string _key547;
                xfer += iprot->readString(_key547);
                structA& _val548 = this->fieldQ[_key547];
                xfer += _val548.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key549;
                xfer += iprot->readString(_key549);
                structA& _val550 = this->fieldQ[_key549];
                xfer += _val550.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldQ = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 18:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldR.clear();
            uint32_t _size551;
            bool _sizeUnknown552;
            apache::thrift::protocol::TType _ktype553;
            apache::thrift::protocol::TType _vtype554;
            xfer += iprot->readMapBegin(_ktype553, _vtype554, _size551, _sizeUnknown552);
            if (!_sizeUnknown552) {
              uint32_t _i557;
              for (_i557 = 0; _i557 < _size551; ++_i557)
              {
                std::string _key558;
                xfer += iprot->readString(_key558);
                structB& _val559 = this->fieldR[_key558];
                xfer += _val559.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key560;
                xfer += iprot->readString(_key560);
                structB& _val561 = this->fieldR[_key560];
                xfer += _val561.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldR = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct3::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  fieldH.__clear();
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}
uint32_t struct3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct3");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldH", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->fieldH.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldI", apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->fieldI.size());
    std::vector<int32_t> ::const_iterator _iter562;
    for (_iter562 = this->fieldI.begin(); _iter562 != this->fieldI.end(); ++_iter562)
    {
      xfer += oprot->writeI32((*_iter562));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldJ", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldJ.size());
    std::vector<std::string> ::const_iterator _iter563;
    for (_iter563 = this->fieldJ.begin(); _iter563 != this->fieldJ.end(); ++_iter563)
    {
      xfer += oprot->writeString((*_iter563));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldK", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldK.size());
    std::vector<std::string> ::const_iterator _iter564;
    for (_iter564 = this->fieldK.begin(); _iter564 != this->fieldK.end(); ++_iter564)
    {
      xfer += oprot->writeString((*_iter564));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldL", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->fieldL.size());
    std::vector<structA> ::const_iterator _iter565;
    for (_iter565 = this->fieldL.begin(); _iter565 != this->fieldL.end(); ++_iter565)
    {
      xfer += (*_iter565).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldM", apache::thrift::protocol::T_SET, 13);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->fieldM.size());
    std::set<int32_t> ::const_iterator _iter566;
    for (_iter566 = this->fieldM.begin(); _iter566 != this->fieldM.end(); ++_iter566)
    {
      xfer += oprot->writeI32((*_iter566));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldN", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldN.size());
    std::set<std::string> ::const_iterator _iter567;
    for (_iter567 = this->fieldN.begin(); _iter567 != this->fieldN.end(); ++_iter567)
    {
      xfer += oprot->writeString((*_iter567));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldO", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldO.size());
    std::set<std::string> ::const_iterator _iter568;
    for (_iter568 = this->fieldO.begin(); _iter568 != this->fieldO.end(); ++_iter568)
    {
      xfer += oprot->writeString((*_iter568));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldP", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->fieldP.size());
    std::set<structB> ::const_iterator _iter569;
    for (_iter569 = this->fieldP.begin(); _iter569 != this->fieldP.end(); ++_iter569)
    {
      xfer += (*_iter569).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldQ", apache::thrift::protocol::T_MAP, 17);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldQ.size());
    std::map<std::string, structA> ::const_iterator _iter570;
    for (_iter570 = this->fieldQ.begin(); _iter570 != this->fieldQ.end(); ++_iter570)
    {
      xfer += oprot->writeString(_iter570->first);
      xfer += _iter570->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldR", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldR.size());
    std::map<std::string, structB> ::const_iterator _iter571;
    for (_iter571 = this->fieldR.begin(); _iter571 != this->fieldR.end(); ++_iter571)
    {
      xfer += oprot->writeString(_iter571->first);
      xfer += _iter571->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct3 &a, struct3 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

void merge(const struct3& from, struct3& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(from.fieldH, to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(from.fieldI, to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(from.fieldJ, to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(from.fieldK, to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(from.fieldL, to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(from.fieldM, to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(from.fieldN, to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(from.fieldO, to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(from.fieldP, to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(from.fieldQ, to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(from.fieldR, to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

void merge(struct3&& from, struct3& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(std::move(from.fieldH), to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(std::move(from.fieldI), to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(std::move(from.fieldJ), to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(std::move(from.fieldK), to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(std::move(from.fieldL), to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(std::move(from.fieldM), to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(std::move(from.fieldN), to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(std::move(from.fieldO), to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(std::move(from.fieldP), to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(std::move(from.fieldQ), to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(std::move(from.fieldR), to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

const uint64_t struct4::_reflection_id;
void struct4::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_7898252530621438604(schema);
}

bool struct4::operator == (const struct4 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  return true;
}

void struct4::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["field0"] != nullptr) {
    int64_t _tmp573 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp573) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp573;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3.readFromJson(folly::toJson(parsed["field3"]).c_str(), opts);
    this->__isset.field3 = true;
  } else {
    this->__isset.field3 = false;
  }
}
void struct4::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct4::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_7898252530621438604(*schema);
    iprot->setNextStructType(struct4::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast575;
          xfer += iprot->readI32(ecast575);
          this->field2 = (enum1)ecast575;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field3.read(iprot);
          this->__isset.field3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct4");
  return xfer;
}

void struct4::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3.__clear();
  __isset.__clear();
}
uint32_t struct4::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct4");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->field3.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct4 &a, struct4 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.__isset, b.__isset);
}

void merge(const struct4& from, struct4& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  merge(from.field2, to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(from.field3, to.field3);
  to.__isset.field3 = to.__isset.field3 || from.__isset.field3;
}

void merge(struct4&& from, struct4& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  merge(std::move(from.field2), to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(std::move(from.field3), to.field3);
  to.__isset.field3 = to.__isset.field3 || from.__isset.field3;
}

const uint64_t struct5::_reflection_id;
void struct5::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16358384009565610188(schema);
}

bool struct5::operator == (const struct5 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  if (!(this->field4 == rhs.field4))
    return false;
  return true;
}

void struct5::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["field0"] != nullptr) {
    int64_t _tmp577 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp577) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp577;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3.readFromJson(folly::toJson(parsed["field3"]).c_str(), opts);
    this->__isset.field3 = true;
  } else {
    this->__isset.field3 = false;
  }
  if (parsed["field4"] != nullptr) {
    this->field4.readFromJson(folly::toJson(parsed["field4"]).c_str(), opts);
    this->__isset.field4 = true;
  } else {
    this->__isset.field4 = false;
  }
}
void struct5::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct5::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16358384009565610188(*schema);
    iprot->setNextStructType(struct5::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast579;
          xfer += iprot->readI32(ecast579);
          this->field2 = (enum1)ecast579;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field3.read(iprot);
          this->__isset.field3 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field4.read(iprot);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct5");
  return xfer;
}

void struct5::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3.__clear();
  field4.__clear();
  __isset.__clear();
}
uint32_t struct5::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct5");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->field3.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field4", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->field4.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct5 &a, struct5 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.__isset, b.__isset);
}

void merge(const struct5& from, struct5& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  merge(from.field2, to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(from.field3, to.field3);
  to.__isset.field3 = to.__isset.field3 || from.__isset.field3;
  merge(from.field4, to.field4);
  to.__isset.field4 = to.__isset.field4 || from.__isset.field4;
}

void merge(struct5&& from, struct5& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  merge(std::move(from.field2), to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(std::move(from.field3), to.field3);
  to.__isset.field3 = to.__isset.field3 || from.__isset.field3;
  merge(std::move(from.field4), to.field4);
  to.__isset.field4 = to.__isset.field4 || from.__isset.field4;
}

const uint64_t struct_binary::_reflection_id;
void struct_binary::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_6812073435240150444(schema);
}

bool struct_binary::operator == (const struct_binary & rhs) const {
  if (!(this->bi == rhs.bi))
    return false;
  return true;
}

void struct_binary::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["bi"] != nullptr) {
    this->bi = parsed["bi"].asString();
    this->__isset.bi = true;
  } else {
    this->__isset.bi = false;
  }
}
void struct_binary::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct_binary::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_6812073435240150444(*schema);
    iprot->setNextStructType(struct_binary::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bi);
          this->__isset.bi = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct_binary::__clear() {
  bi = "";
  __isset.__clear();
}
uint32_t struct_binary::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct_binary");
  xfer += oprot->writeFieldBegin("bi", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->bi);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct_binary &a, struct_binary &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.bi, b.bi);
  swap(a.__isset, b.__isset);
}

void merge(const struct_binary& from, struct_binary& to) {
  using apache::thrift::merge;
  merge(from.bi, to.bi);
  to.__isset.bi = to.__isset.bi || from.__isset.bi;
}

void merge(struct_binary&& from, struct_binary& to) {
  using apache::thrift::merge;
  merge(std::move(from.bi), to.bi);
  to.__isset.bi = to.__isset.bi || from.__isset.bi;
}

const uint64_t annotated::_reflection_id;
void annotated::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_300598955218934796(schema);
}

bool annotated::operator == (const annotated & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  return true;
}

void annotated::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["a"] != nullptr) {
    int64_t _tmp582 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp582) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp582;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
}
void annotated::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t annotated::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_300598955218934796(*schema);
    iprot->setNextStructType(annotated::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void annotated::__clear() {
  a = 0;
  __isset.__clear();
}
uint32_t annotated::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("annotated");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(annotated &a, annotated &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.__isset, b.__isset);
}

void merge(const annotated& from, annotated& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
}

void merge(annotated&& from, annotated& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
}

  void union_with_special_names::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union_with_special_names");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["get"] != nullptr) {
      set_get();
      int64_t _tmp583 = (int64_t)parsed["get"].asInt();
      if (imaxabs(_tmp583) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.get = (int32_t)_tmp583;
      }
      return;
    }
    if (parsed["getter"] != nullptr) {
      set_getter();
      int64_t _tmp584 = (int64_t)parsed["getter"].asInt();
      if (imaxabs(_tmp584) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.getter = (int32_t)_tmp584;
      }
      return;
    }
    if (parsed["lists"] != nullptr) {
      set_lists();
      int64_t _tmp585 = (int64_t)parsed["lists"].asInt();
      if (imaxabs(_tmp585) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.lists = (int32_t)_tmp585;
      }
      return;
    }
    if (parsed["maps"] != nullptr) {
      set_maps();
      int64_t _tmp586 = (int64_t)parsed["maps"].asInt();
      if (imaxabs(_tmp586) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.maps = (int32_t)_tmp586;
      }
      return;
    }
    if (parsed["name"] != nullptr) {
      set_name();
      int64_t _tmp587 = (int64_t)parsed["name"].asInt();
      if (imaxabs(_tmp587) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.name = (int32_t)_tmp587;
      }
      return;
    }
    if (parsed["name_to_value"] != nullptr) {
      set_name_to_value();
      int64_t _tmp588 = (int64_t)parsed["name_to_value"].asInt();
      if (imaxabs(_tmp588) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.name_to_value = (int32_t)_tmp588;
      }
      return;
    }
    if (parsed["names"] != nullptr) {
      set_names();
      int64_t _tmp589 = (int64_t)parsed["names"].asInt();
      if (imaxabs(_tmp589) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.names = (int32_t)_tmp589;
      }
      return;
    }
    if (parsed["prefix_tree"] != nullptr) {
      set_prefix_tree();
      int64_t _tmp590 = (int64_t)parsed["prefix_tree"].asInt();
      if (imaxabs(_tmp590) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.prefix_tree = (int32_t)_tmp590;
      }
      return;
    }
    if (parsed["sets"] != nullptr) {
      set_sets();
      int64_t _tmp591 = (int64_t)parsed["sets"].asInt();
      if (imaxabs(_tmp591) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.sets = (int32_t)_tmp591;
      }
      return;
    }
    if (parsed["setter"] != nullptr) {
      set_setter();
      int64_t _tmp592 = (int64_t)parsed["setter"].asInt();
      if (imaxabs(_tmp592) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.setter = (int32_t)_tmp592;
      }
      return;
    }
    if (parsed["str"] != nullptr) {
      set_str();
      int64_t _tmp593 = (int64_t)parsed["str"].asInt();
      if (imaxabs(_tmp593) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.str = (int32_t)_tmp593;
      }
      return;
    }
    if (parsed["strings"] != nullptr) {
      set_strings();
      int64_t _tmp594 = (int64_t)parsed["strings"].asInt();
      if (imaxabs(_tmp594) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.strings = (int32_t)_tmp594;
      }
      return;
    }
    if (parsed["type"] != nullptr) {
      set_type();
      int64_t _tmp595 = (int64_t)parsed["type"].asInt();
      if (imaxabs(_tmp595) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.type = (int32_t)_tmp595;
      }
      return;
    }
    if (parsed["value"] != nullptr) {
      set_value();
      int64_t _tmp596 = (int64_t)parsed["value"].asInt();
      if (imaxabs(_tmp596) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.value = (int32_t)_tmp596;
      }
      return;
    }
    if (parsed["value_to_name"] != nullptr) {
      set_value_to_name();
      int64_t _tmp597 = (int64_t)parsed["value_to_name"].asInt();
      if (imaxabs(_tmp597) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.value_to_name = (int32_t)_tmp597;
      }
      return;
    }
    if (parsed["values"] != nullptr) {
      set_values();
      int64_t _tmp598 = (int64_t)parsed["values"].asInt();
      if (imaxabs(_tmp598) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.values = (int32_t)_tmp598;
      }
      return;
    }
    if (parsed["id"] != nullptr) {
      set_id();
      int64_t _tmp599 = (int64_t)parsed["id"].asInt();
      if (imaxabs(_tmp599) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.id = (int32_t)_tmp599;
      }
      return;
    }
    if (parsed["ids"] != nullptr) {
      set_ids();
      int64_t _tmp600 = (int64_t)parsed["ids"].asInt();
      if (imaxabs(_tmp600) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ids = (int32_t)_tmp600;
      }
      return;
    }
    if (parsed["descriptor"] != nullptr) {
      set_descriptor();
      int64_t _tmp601 = (int64_t)parsed["descriptor"].asInt();
      if (imaxabs(_tmp601) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.descriptor = (int32_t)_tmp601;
      }
      return;
    }
    if (parsed["descriptors"] != nullptr) {
      set_descriptors();
      int64_t _tmp602 = (int64_t)parsed["descriptors"].asInt();
      if (imaxabs(_tmp602) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.descriptors = (int32_t)_tmp602;
      }
      return;
    }
    if (parsed["key"] != nullptr) {
      set_key();
      int64_t _tmp603 = (int64_t)parsed["key"].asInt();
      if (imaxabs(_tmp603) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.key = (int32_t)_tmp603;
      }
      return;
    }
    if (parsed["keys"] != nullptr) {
      set_keys();
      int64_t _tmp604 = (int64_t)parsed["keys"].asInt();
      if (imaxabs(_tmp604) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.keys = (int32_t)_tmp604;
      }
      return;
    }
    if (parsed["annotation"] != nullptr) {
      set_annotation();
      int64_t _tmp605 = (int64_t)parsed["annotation"].asInt();
      if (imaxabs(_tmp605) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.annotation = (int32_t)_tmp605;
      }
      return;
    }
    if (parsed["annotations"] != nullptr) {
      set_annotations();
      int64_t _tmp606 = (int64_t)parsed["annotations"].asInt();
      if (imaxabs(_tmp606) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.annotations = (int32_t)_tmp606;
      }
      return;
    }
    if (parsed["member"] != nullptr) {
      set_member();
      int64_t _tmp607 = (int64_t)parsed["member"].asInt();
      if (imaxabs(_tmp607) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.member = (int32_t)_tmp607;
      }
      return;
    }
    if (parsed["members"] != nullptr) {
      set_members();
      int64_t _tmp608 = (int64_t)parsed["members"].asInt();
      if (imaxabs(_tmp608) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.members = (int32_t)_tmp608;
      }
      return;
    }
  }
  void union_with_special_names::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
  {
    readFromJson(jsonText, strlen(jsonText), opts);
  }

uint32_t union_with_special_names::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_get();
          xfer += iprot->readI32(this->value_.get);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_getter();
          xfer += iprot->readI32(this->value_.getter);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_lists();
          xfer += iprot->readI32(this->value_.lists);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_maps();
          xfer += iprot->readI32(this->value_.maps);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 5: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_name();
          xfer += iprot->readI32(this->value_.name);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 6: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_name_to_value();
          xfer += iprot->readI32(this->value_.name_to_value);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 7: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_names();
          xfer += iprot->readI32(this->value_.names);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 8: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_prefix_tree();
          xfer += iprot->readI32(this->value_.prefix_tree);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 9: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_sets();
          xfer += iprot->readI32(this->value_.sets);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 10: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_setter();
          xfer += iprot->readI32(this->value_.setter);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 11: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_str();
          xfer += iprot->readI32(this->value_.str);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 12: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_strings();
          xfer += iprot->readI32(this->value_.strings);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 13: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_type();
          xfer += iprot->readI32(this->value_.type);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 14: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_value();
          xfer += iprot->readI32(this->value_.value);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 15: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_value_to_name();
          xfer += iprot->readI32(this->value_.value_to_name);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 16: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_values();
          xfer += iprot->readI32(this->value_.values);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 17: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_id();
          xfer += iprot->readI32(this->value_.id);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 18: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_ids();
          xfer += iprot->readI32(this->value_.ids);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 19: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_descriptor();
          xfer += iprot->readI32(this->value_.descriptor);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 20: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_descriptors();
          xfer += iprot->readI32(this->value_.descriptors);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 21: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_key();
          xfer += iprot->readI32(this->value_.key);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 22: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_keys();
          xfer += iprot->readI32(this->value_.keys);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 23: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_annotation();
          xfer += iprot->readI32(this->value_.annotation);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 24: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_annotations();
          xfer += iprot->readI32(this->value_.annotations);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 25: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_member();
          xfer += iprot->readI32(this->value_.member);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 26: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_members();
          xfer += iprot->readI32(this->value_.members);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union_with_special_names::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union_with_special_names");
  switch (type_) {
    case Type::get: {
      xfer += oprot->writeFieldBegin("get", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.get);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::getter: {
      xfer += oprot->writeFieldBegin("getter", apache::thrift::protocol::T_I32, 2);
      xfer += oprot->writeI32(this->value_.getter);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::lists: {
      xfer += oprot->writeFieldBegin("lists", apache::thrift::protocol::T_I32, 3);
      xfer += oprot->writeI32(this->value_.lists);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::maps: {
      xfer += oprot->writeFieldBegin("maps", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32(this->value_.maps);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::name: {
      xfer += oprot->writeFieldBegin("name", apache::thrift::protocol::T_I32, 5);
      xfer += oprot->writeI32(this->value_.name);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::name_to_value: {
      xfer += oprot->writeFieldBegin("name_to_value", apache::thrift::protocol::T_I32, 6);
      xfer += oprot->writeI32(this->value_.name_to_value);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::names: {
      xfer += oprot->writeFieldBegin("names", apache::thrift::protocol::T_I32, 7);
      xfer += oprot->writeI32(this->value_.names);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::prefix_tree: {
      xfer += oprot->writeFieldBegin("prefix_tree", apache::thrift::protocol::T_I32, 8);
      xfer += oprot->writeI32(this->value_.prefix_tree);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::sets: {
      xfer += oprot->writeFieldBegin("sets", apache::thrift::protocol::T_I32, 9);
      xfer += oprot->writeI32(this->value_.sets);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::setter: {
      xfer += oprot->writeFieldBegin("setter", apache::thrift::protocol::T_I32, 10);
      xfer += oprot->writeI32(this->value_.setter);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::str: {
      xfer += oprot->writeFieldBegin("str", apache::thrift::protocol::T_I32, 11);
      xfer += oprot->writeI32(this->value_.str);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::strings: {
      xfer += oprot->writeFieldBegin("strings", apache::thrift::protocol::T_I32, 12);
      xfer += oprot->writeI32(this->value_.strings);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::type: {
      xfer += oprot->writeFieldBegin("type", apache::thrift::protocol::T_I32, 13);
      xfer += oprot->writeI32(this->value_.type);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::value: {
      xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_I32, 14);
      xfer += oprot->writeI32(this->value_.value);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::value_to_name: {
      xfer += oprot->writeFieldBegin("value_to_name", apache::thrift::protocol::T_I32, 15);
      xfer += oprot->writeI32(this->value_.value_to_name);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::values: {
      xfer += oprot->writeFieldBegin("values", apache::thrift::protocol::T_I32, 16);
      xfer += oprot->writeI32(this->value_.values);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::id: {
      xfer += oprot->writeFieldBegin("id", apache::thrift::protocol::T_I32, 17);
      xfer += oprot->writeI32(this->value_.id);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ids: {
      xfer += oprot->writeFieldBegin("ids", apache::thrift::protocol::T_I32, 18);
      xfer += oprot->writeI32(this->value_.ids);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::descriptor: {
      xfer += oprot->writeFieldBegin("descriptor", apache::thrift::protocol::T_I32, 19);
      xfer += oprot->writeI32(this->value_.descriptor);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::descriptors: {
      xfer += oprot->writeFieldBegin("descriptors", apache::thrift::protocol::T_I32, 20);
      xfer += oprot->writeI32(this->value_.descriptors);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::key: {
      xfer += oprot->writeFieldBegin("key", apache::thrift::protocol::T_I32, 21);
      xfer += oprot->writeI32(this->value_.key);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::keys: {
      xfer += oprot->writeFieldBegin("keys", apache::thrift::protocol::T_I32, 22);
      xfer += oprot->writeI32(this->value_.keys);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::annotation: {
      xfer += oprot->writeFieldBegin("annotation", apache::thrift::protocol::T_I32, 23);
      xfer += oprot->writeI32(this->value_.annotation);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::annotations: {
      xfer += oprot->writeFieldBegin("annotations", apache::thrift::protocol::T_I32, 24);
      xfer += oprot->writeI32(this->value_.annotations);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::member: {
      xfer += oprot->writeFieldBegin("member", apache::thrift::protocol::T_I32, 25);
      xfer += oprot->writeI32(this->value_.member);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::members: {
      xfer += oprot->writeFieldBegin("members", apache::thrift::protocol::T_I32, 26);
      xfer += oprot->writeI32(this->value_.members);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t struct_with_special_names::_reflection_id;
void struct_with_special_names::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_8634504681174503372(schema);
}

bool struct_with_special_names::operator == (const struct_with_special_names & rhs) const {
  if (!(this->get == rhs.get))
    return false;
  if (!(this->getter == rhs.getter))
    return false;
  if (!(this->lists == rhs.lists))
    return false;
  if (!(this->maps == rhs.maps))
    return false;
  if (!(this->name == rhs.name))
    return false;
  if (!(this->name_to_value == rhs.name_to_value))
    return false;
  if (!(this->names == rhs.names))
    return false;
  if (!(this->prefix_tree == rhs.prefix_tree))
    return false;
  if (!(this->sets == rhs.sets))
    return false;
  if (!(this->setter == rhs.setter))
    return false;
  if (!(this->str == rhs.str))
    return false;
  if (!(this->strings == rhs.strings))
    return false;
  if (!(this->type == rhs.type))
    return false;
  if (!(this->value == rhs.value))
    return false;
  if (!(this->value_to_name == rhs.value_to_name))
    return false;
  if (!(this->values == rhs.values))
    return false;
  if (!(this->id == rhs.id))
    return false;
  if (!(this->ids == rhs.ids))
    return false;
  if (!(this->descriptor == rhs.descriptor))
    return false;
  if (!(this->descriptors == rhs.descriptors))
    return false;
  if (!(this->key == rhs.key))
    return false;
  if (!(this->keys == rhs.keys))
    return false;
  if (!(this->annotation == rhs.annotation))
    return false;
  if (!(this->annotations == rhs.annotations))
    return false;
  if (!(this->member == rhs.member))
    return false;
  if (!(this->members == rhs.members))
    return false;
  return true;
}

void struct_with_special_names::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["get"] != nullptr) {
    int64_t _tmp610 = (int64_t)parsed["get"].asInt();
    if (imaxabs(_tmp610) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->get = (int32_t)_tmp610;
    }
    this->__isset.get = true;
  } else {
    this->__isset.get = false;
  }
  if (parsed["getter"] != nullptr) {
    int64_t _tmp611 = (int64_t)parsed["getter"].asInt();
    if (imaxabs(_tmp611) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->getter = (int32_t)_tmp611;
    }
    this->__isset.getter = true;
  } else {
    this->__isset.getter = false;
  }
  if (parsed["lists"] != nullptr) {
    int64_t _tmp612 = (int64_t)parsed["lists"].asInt();
    if (imaxabs(_tmp612) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->lists = (int32_t)_tmp612;
    }
    this->__isset.lists = true;
  } else {
    this->__isset.lists = false;
  }
  if (parsed["maps"] != nullptr) {
    int64_t _tmp613 = (int64_t)parsed["maps"].asInt();
    if (imaxabs(_tmp613) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->maps = (int32_t)_tmp613;
    }
    this->__isset.maps = true;
  } else {
    this->__isset.maps = false;
  }
  if (parsed["name"] != nullptr) {
    int64_t _tmp614 = (int64_t)parsed["name"].asInt();
    if (imaxabs(_tmp614) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->name = (int32_t)_tmp614;
    }
    this->__isset.name = true;
  } else {
    this->__isset.name = false;
  }
  if (parsed["name_to_value"] != nullptr) {
    int64_t _tmp615 = (int64_t)parsed["name_to_value"].asInt();
    if (imaxabs(_tmp615) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->name_to_value = (int32_t)_tmp615;
    }
    this->__isset.name_to_value = true;
  } else {
    this->__isset.name_to_value = false;
  }
  if (parsed["names"] != nullptr) {
    int64_t _tmp616 = (int64_t)parsed["names"].asInt();
    if (imaxabs(_tmp616) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->names = (int32_t)_tmp616;
    }
    this->__isset.names = true;
  } else {
    this->__isset.names = false;
  }
  if (parsed["prefix_tree"] != nullptr) {
    int64_t _tmp617 = (int64_t)parsed["prefix_tree"].asInt();
    if (imaxabs(_tmp617) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->prefix_tree = (int32_t)_tmp617;
    }
    this->__isset.prefix_tree = true;
  } else {
    this->__isset.prefix_tree = false;
  }
  if (parsed["sets"] != nullptr) {
    int64_t _tmp618 = (int64_t)parsed["sets"].asInt();
    if (imaxabs(_tmp618) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->sets = (int32_t)_tmp618;
    }
    this->__isset.sets = true;
  } else {
    this->__isset.sets = false;
  }
  if (parsed["setter"] != nullptr) {
    int64_t _tmp619 = (int64_t)parsed["setter"].asInt();
    if (imaxabs(_tmp619) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->setter = (int32_t)_tmp619;
    }
    this->__isset.setter = true;
  } else {
    this->__isset.setter = false;
  }
  if (parsed["str"] != nullptr) {
    int64_t _tmp620 = (int64_t)parsed["str"].asInt();
    if (imaxabs(_tmp620) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->str = (int32_t)_tmp620;
    }
    this->__isset.str = true;
  } else {
    this->__isset.str = false;
  }
  if (parsed["strings"] != nullptr) {
    int64_t _tmp621 = (int64_t)parsed["strings"].asInt();
    if (imaxabs(_tmp621) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->strings = (int32_t)_tmp621;
    }
    this->__isset.strings = true;
  } else {
    this->__isset.strings = false;
  }
  if (parsed["type"] != nullptr) {
    int64_t _tmp622 = (int64_t)parsed["type"].asInt();
    if (imaxabs(_tmp622) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->type = (int32_t)_tmp622;
    }
    this->__isset.type = true;
  } else {
    this->__isset.type = false;
  }
  if (parsed["value"] != nullptr) {
    int64_t _tmp623 = (int64_t)parsed["value"].asInt();
    if (imaxabs(_tmp623) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->value = (int32_t)_tmp623;
    }
    this->__isset.value = true;
  } else {
    this->__isset.value = false;
  }
  if (parsed["value_to_name"] != nullptr) {
    int64_t _tmp624 = (int64_t)parsed["value_to_name"].asInt();
    if (imaxabs(_tmp624) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->value_to_name = (int32_t)_tmp624;
    }
    this->__isset.value_to_name = true;
  } else {
    this->__isset.value_to_name = false;
  }
  if (parsed["values"] != nullptr) {
    int64_t _tmp625 = (int64_t)parsed["values"].asInt();
    if (imaxabs(_tmp625) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->values = (int32_t)_tmp625;
    }
    this->__isset.values = true;
  } else {
    this->__isset.values = false;
  }
  if (parsed["id"] != nullptr) {
    int64_t _tmp626 = (int64_t)parsed["id"].asInt();
    if (imaxabs(_tmp626) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->id = (int32_t)_tmp626;
    }
    this->__isset.id = true;
  } else {
    this->__isset.id = false;
  }
  if (parsed["ids"] != nullptr) {
    int64_t _tmp627 = (int64_t)parsed["ids"].asInt();
    if (imaxabs(_tmp627) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->ids = (int32_t)_tmp627;
    }
    this->__isset.ids = true;
  } else {
    this->__isset.ids = false;
  }
  if (parsed["descriptor"] != nullptr) {
    int64_t _tmp628 = (int64_t)parsed["descriptor"].asInt();
    if (imaxabs(_tmp628) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->descriptor = (int32_t)_tmp628;
    }
    this->__isset.descriptor = true;
  } else {
    this->__isset.descriptor = false;
  }
  if (parsed["descriptors"] != nullptr) {
    int64_t _tmp629 = (int64_t)parsed["descriptors"].asInt();
    if (imaxabs(_tmp629) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->descriptors = (int32_t)_tmp629;
    }
    this->__isset.descriptors = true;
  } else {
    this->__isset.descriptors = false;
  }
  if (parsed["key"] != nullptr) {
    int64_t _tmp630 = (int64_t)parsed["key"].asInt();
    if (imaxabs(_tmp630) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->key = (int32_t)_tmp630;
    }
    this->__isset.key = true;
  } else {
    this->__isset.key = false;
  }
  if (parsed["keys"] != nullptr) {
    int64_t _tmp631 = (int64_t)parsed["keys"].asInt();
    if (imaxabs(_tmp631) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->keys = (int32_t)_tmp631;
    }
    this->__isset.keys = true;
  } else {
    this->__isset.keys = false;
  }
  if (parsed["annotation"] != nullptr) {
    int64_t _tmp632 = (int64_t)parsed["annotation"].asInt();
    if (imaxabs(_tmp632) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->annotation = (int32_t)_tmp632;
    }
    this->__isset.annotation = true;
  } else {
    this->__isset.annotation = false;
  }
  if (parsed["annotations"] != nullptr) {
    int64_t _tmp633 = (int64_t)parsed["annotations"].asInt();
    if (imaxabs(_tmp633) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->annotations = (int32_t)_tmp633;
    }
    this->__isset.annotations = true;
  } else {
    this->__isset.annotations = false;
  }
  if (parsed["member"] != nullptr) {
    int64_t _tmp634 = (int64_t)parsed["member"].asInt();
    if (imaxabs(_tmp634) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->member = (int32_t)_tmp634;
    }
    this->__isset.member = true;
  } else {
    this->__isset.member = false;
  }
  if (parsed["members"] != nullptr) {
    int64_t _tmp635 = (int64_t)parsed["members"].asInt();
    if (imaxabs(_tmp635) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->members = (int32_t)_tmp635;
    }
    this->__isset.members = true;
  } else {
    this->__isset.members = false;
  }
}
void struct_with_special_names::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct_with_special_names::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_8634504681174503372(*schema);
    iprot->setNextStructType(struct_with_special_names::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->get);
          this->__isset.get = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->getter);
          this->__isset.getter = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lists);
          this->__isset.lists = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maps);
          this->__isset.maps = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 5:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 6:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->name_to_value);
          this->__isset.name_to_value = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 7:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->names);
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 8:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prefix_tree);
          this->__isset.prefix_tree = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 9:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sets);
          this->__isset.sets = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 10:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->setter);
          this->__isset.setter = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 11:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->str);
          this->__isset.str = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 12:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->strings);
          this->__isset.strings = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 13:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 14:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 15:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value_to_name);
          this->__isset.value_to_name = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 16:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->values);
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 17:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 18:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ids);
          this->__isset.ids = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 19:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->descriptor);
          this->__isset.descriptor = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 20:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->descriptors);
          this->__isset.descriptors = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 21:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 22:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keys);
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 23:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->annotation);
          this->__isset.annotation = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 24:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->annotations);
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 25:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->member);
          this->__isset.member = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 26:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->members);
          this->__isset.members = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct_with_special_names::__clear() {
  get = 0;
  getter = 0;
  lists = 0;
  maps = 0;
  name = 0;
  name_to_value = 0;
  names = 0;
  prefix_tree = 0;
  sets = 0;
  setter = 0;
  str = 0;
  strings = 0;
  type = 0;
  value = 0;
  value_to_name = 0;
  values = 0;
  id = 0;
  ids = 0;
  descriptor = 0;
  descriptors = 0;
  key = 0;
  keys = 0;
  annotation = 0;
  annotations = 0;
  member = 0;
  members = 0;
  __isset.__clear();
}
uint32_t struct_with_special_names::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct_with_special_names");
  xfer += oprot->writeFieldBegin("get", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->get);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("getter", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->getter);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("lists", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lists);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("maps", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->maps);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("name_to_value", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->name_to_value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("names", apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->names);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("prefix_tree", apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->prefix_tree);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("sets", apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->sets);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("setter", apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->setter);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("str", apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->str);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("strings", apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->strings);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("type", apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value", apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("value_to_name", apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->value_to_name);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("values", apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->values);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("id", apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ids", apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->ids);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("descriptor", apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->descriptor);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("descriptors", apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->descriptors);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("key", apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->key);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("keys", apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->keys);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("annotation", apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->annotation);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("annotations", apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->annotations);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("member", apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->member);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("members", apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->members);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct_with_special_names &a, struct_with_special_names &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.get, b.get);
  swap(a.getter, b.getter);
  swap(a.lists, b.lists);
  swap(a.maps, b.maps);
  swap(a.name, b.name);
  swap(a.name_to_value, b.name_to_value);
  swap(a.names, b.names);
  swap(a.prefix_tree, b.prefix_tree);
  swap(a.sets, b.sets);
  swap(a.setter, b.setter);
  swap(a.str, b.str);
  swap(a.strings, b.strings);
  swap(a.type, b.type);
  swap(a.value, b.value);
  swap(a.value_to_name, b.value_to_name);
  swap(a.values, b.values);
  swap(a.id, b.id);
  swap(a.ids, b.ids);
  swap(a.descriptor, b.descriptor);
  swap(a.descriptors, b.descriptors);
  swap(a.key, b.key);
  swap(a.keys, b.keys);
  swap(a.annotation, b.annotation);
  swap(a.annotations, b.annotations);
  swap(a.member, b.member);
  swap(a.members, b.members);
  swap(a.__isset, b.__isset);
}

void merge(const struct_with_special_names& from, struct_with_special_names& to) {
  using apache::thrift::merge;
  merge(from.get, to.get);
  to.__isset.get = to.__isset.get || from.__isset.get;
  merge(from.getter, to.getter);
  to.__isset.getter = to.__isset.getter || from.__isset.getter;
  merge(from.lists, to.lists);
  to.__isset.lists = to.__isset.lists || from.__isset.lists;
  merge(from.maps, to.maps);
  to.__isset.maps = to.__isset.maps || from.__isset.maps;
  merge(from.name, to.name);
  to.__isset.name = to.__isset.name || from.__isset.name;
  merge(from.name_to_value, to.name_to_value);
  to.__isset.name_to_value = to.__isset.name_to_value || from.__isset.name_to_value;
  merge(from.names, to.names);
  to.__isset.names = to.__isset.names || from.__isset.names;
  merge(from.prefix_tree, to.prefix_tree);
  to.__isset.prefix_tree = to.__isset.prefix_tree || from.__isset.prefix_tree;
  merge(from.sets, to.sets);
  to.__isset.sets = to.__isset.sets || from.__isset.sets;
  merge(from.setter, to.setter);
  to.__isset.setter = to.__isset.setter || from.__isset.setter;
  merge(from.str, to.str);
  to.__isset.str = to.__isset.str || from.__isset.str;
  merge(from.strings, to.strings);
  to.__isset.strings = to.__isset.strings || from.__isset.strings;
  merge(from.type, to.type);
  to.__isset.type = to.__isset.type || from.__isset.type;
  merge(from.value, to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(from.value_to_name, to.value_to_name);
  to.__isset.value_to_name = to.__isset.value_to_name || from.__isset.value_to_name;
  merge(from.values, to.values);
  to.__isset.values = to.__isset.values || from.__isset.values;
  merge(from.id, to.id);
  to.__isset.id = to.__isset.id || from.__isset.id;
  merge(from.ids, to.ids);
  to.__isset.ids = to.__isset.ids || from.__isset.ids;
  merge(from.descriptor, to.descriptor);
  to.__isset.descriptor = to.__isset.descriptor || from.__isset.descriptor;
  merge(from.descriptors, to.descriptors);
  to.__isset.descriptors = to.__isset.descriptors || from.__isset.descriptors;
  merge(from.key, to.key);
  to.__isset.key = to.__isset.key || from.__isset.key;
  merge(from.keys, to.keys);
  to.__isset.keys = to.__isset.keys || from.__isset.keys;
  merge(from.annotation, to.annotation);
  to.__isset.annotation = to.__isset.annotation || from.__isset.annotation;
  merge(from.annotations, to.annotations);
  to.__isset.annotations = to.__isset.annotations || from.__isset.annotations;
  merge(from.member, to.member);
  to.__isset.member = to.__isset.member || from.__isset.member;
  merge(from.members, to.members);
  to.__isset.members = to.__isset.members || from.__isset.members;
}

void merge(struct_with_special_names&& from, struct_with_special_names& to) {
  using apache::thrift::merge;
  merge(std::move(from.get), to.get);
  to.__isset.get = to.__isset.get || from.__isset.get;
  merge(std::move(from.getter), to.getter);
  to.__isset.getter = to.__isset.getter || from.__isset.getter;
  merge(std::move(from.lists), to.lists);
  to.__isset.lists = to.__isset.lists || from.__isset.lists;
  merge(std::move(from.maps), to.maps);
  to.__isset.maps = to.__isset.maps || from.__isset.maps;
  merge(std::move(from.name), to.name);
  to.__isset.name = to.__isset.name || from.__isset.name;
  merge(std::move(from.name_to_value), to.name_to_value);
  to.__isset.name_to_value = to.__isset.name_to_value || from.__isset.name_to_value;
  merge(std::move(from.names), to.names);
  to.__isset.names = to.__isset.names || from.__isset.names;
  merge(std::move(from.prefix_tree), to.prefix_tree);
  to.__isset.prefix_tree = to.__isset.prefix_tree || from.__isset.prefix_tree;
  merge(std::move(from.sets), to.sets);
  to.__isset.sets = to.__isset.sets || from.__isset.sets;
  merge(std::move(from.setter), to.setter);
  to.__isset.setter = to.__isset.setter || from.__isset.setter;
  merge(std::move(from.str), to.str);
  to.__isset.str = to.__isset.str || from.__isset.str;
  merge(std::move(from.strings), to.strings);
  to.__isset.strings = to.__isset.strings || from.__isset.strings;
  merge(std::move(from.type), to.type);
  to.__isset.type = to.__isset.type || from.__isset.type;
  merge(std::move(from.value), to.value);
  to.__isset.value = to.__isset.value || from.__isset.value;
  merge(std::move(from.value_to_name), to.value_to_name);
  to.__isset.value_to_name = to.__isset.value_to_name || from.__isset.value_to_name;
  merge(std::move(from.values), to.values);
  to.__isset.values = to.__isset.values || from.__isset.values;
  merge(std::move(from.id), to.id);
  to.__isset.id = to.__isset.id || from.__isset.id;
  merge(std::move(from.ids), to.ids);
  to.__isset.ids = to.__isset.ids || from.__isset.ids;
  merge(std::move(from.descriptor), to.descriptor);
  to.__isset.descriptor = to.__isset.descriptor || from.__isset.descriptor;
  merge(std::move(from.descriptors), to.descriptors);
  to.__isset.descriptors = to.__isset.descriptors || from.__isset.descriptors;
  merge(std::move(from.key), to.key);
  to.__isset.key = to.__isset.key || from.__isset.key;
  merge(std::move(from.keys), to.keys);
  to.__isset.keys = to.__isset.keys || from.__isset.keys;
  merge(std::move(from.annotation), to.annotation);
  to.__isset.annotation = to.__isset.annotation || from.__isset.annotation;
  merge(std::move(from.annotations), to.annotations);
  to.__isset.annotations = to.__isset.annotations || from.__isset.annotations;
  merge(std::move(from.member), to.member);
  to.__isset.member = to.__isset.member || from.__isset.member;
  merge(std::move(from.members), to.members);
  to.__isset.members = to.__isset.members || from.__isset.members;
}

const uint64_t struct_with_indirections::_reflection_id;
void struct_with_indirections::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_1743512479375461036(schema);
}

bool struct_with_indirections::operator == (const struct_with_indirections & rhs) const {
  if (!(this->real == rhs.real))
    return false;
  if (!(this->fake == rhs.fake))
    return false;
  if (!(this->number == rhs.number))
    return false;
  if (!(this->result == rhs.result))
    return false;
  return true;
}

void struct_with_indirections::readFromJson(const char* jsonText, size_t len, const folly::json::serialization_opts& opts)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len), opts);
  if (parsed["real"] != nullptr) {
    int64_t _tmp637 = (int64_t)parsed["real"].asInt();
    if (imaxabs(_tmp637) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->real = (int32_t)_tmp637;
    }
    this->__isset.real = true;
  } else {
    this->__isset.real = false;
  }
  if (parsed["fake"] != nullptr) {
    int64_t _tmp638 = (int64_t)parsed["fake"].asInt();
    if (imaxabs(_tmp638) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fake = (int32_t)_tmp638;
    }
    this->__isset.fake = true;
  } else {
    this->__isset.fake = false;
  }
  if (parsed["number"] != nullptr) {
    int64_t _tmp639 = (int64_t)parsed["number"].asInt();
    if (imaxabs(_tmp639) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->number.number = (int32_t)_tmp639;
    }
    this->__isset.number = true;
  } else {
    this->__isset.number = false;
  }
  if (parsed["result"] != nullptr) {
    int64_t _tmp640 = (int64_t)parsed["result"].asInt();
    if (imaxabs(_tmp640) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->result.foo().result() = (int32_t)_tmp640;
    }
    this->__isset.result = true;
  } else {
    this->__isset.result = false;
  }
}
void struct_with_indirections::readFromJson(const char* jsonText, const folly::json::serialization_opts& opts)
{
  readFromJson(jsonText, strlen(jsonText), opts);
}

uint32_t struct_with_indirections::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_1743512479375461036(*schema);
    iprot->setNextStructType(struct_with_indirections::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->real);
          this->__isset.real = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fake);
          this->__isset.fake = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number.number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result.foo().result());
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct_with_indirections::__clear() {
  real = 0;
  fake = 0;
  number.number = 0;
  result.foo().result() = 0;
  __isset.__clear();
}
uint32_t struct_with_indirections::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct_with_indirections");
  xfer += oprot->writeFieldBegin("real", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->real);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fake", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fake);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("number", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->number.number);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("result", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->result.foo().result());
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct_with_indirections &a, struct_with_indirections &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.real, b.real);
  swap(a.fake, b.fake);
  swap(a.number, b.number);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

void merge(const struct_with_indirections& from, struct_with_indirections& to) {
  using apache::thrift::merge;
  merge(from.real, to.real);
  to.__isset.real = to.__isset.real || from.__isset.real;
  merge(from.fake, to.fake);
  to.__isset.fake = to.__isset.fake || from.__isset.fake;
  merge(from.number, to.number);
  to.__isset.number = to.__isset.number || from.__isset.number;
  merge(from.result, to.result);
  to.__isset.result = to.__isset.result || from.__isset.result;
}

void merge(struct_with_indirections&& from, struct_with_indirections& to) {
  using apache::thrift::merge;
  merge(std::move(from.real), to.real);
  to.__isset.real = to.__isset.real || from.__isset.real;
  merge(std::move(from.fake), to.fake);
  to.__isset.fake = to.__isset.fake || from.__isset.fake;
  merge(std::move(from.number), to.number);
  to.__isset.number = to.__isset.number || from.__isset.number;
  merge(std::move(from.result), to.result);
  to.__isset.result = to.__isset.result || from.__isset.result;
}

}} // namespace
