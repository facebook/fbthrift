/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_types.h"

#include "thrift/compiler/test/fixtures/fatal-compat/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>

namespace test_cpp1 { namespace cpp_reflection {

const int _kenum1Values[] = {
  field0,
  field1,
  field2
};

const char* const _kenum1Names[] = {
  "field0",
  "field1",
  "field2"
};

const std::map<int, const char*> _enum1_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findName( ::test_cpp1::cpp_reflection::enum1 value) {
return findName( ::test_cpp1::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum1* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum1_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum2Values[] = {
  field0_2,
  field1_2,
  field2_2
};

const char* const _kenum2Names[] = {
  "field0_2",
  "field1_2",
  "field2_2"
};

const std::map<int, const char*> _enum2_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findName( ::test_cpp1::cpp_reflection::enum2 value) {
return findName( ::test_cpp1::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum2* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum2_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum3Values[] = {
  field0_3,
  field1_3,
  field2_3
};

const char* const _kenum3Names[] = {
  "field0_3",
  "field1_3",
  "field2_3"
};

const std::map<int, const char*> _enum3_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findName( ::test_cpp1::cpp_reflection::enum3 value) {
return findName( ::test_cpp1::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum3* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum3_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
  void union1::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union1");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui"] != nullptr) {
      set_ui();
      int64_t _tmp0 = (int64_t)parsed["ui"].asInt();
      if (imaxabs(_tmp0) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui = (int32_t)_tmp0;
      }
      return;
    }
    if (parsed["ud"] != nullptr) {
      set_ud();
      this->value_.ud = parsed["ud"].asDouble();
      return;
    }
    if (parsed["us"] != nullptr) {
      set_us();
      this->value_.us = parsed["us"].asString();
      return;
    }
    if (parsed["ue"] != nullptr) {
      set_ue();
      this->value_.ue=(enum1)(int32_t)parsed["ue"].asInt();
      return;
    }
  }
  void union1::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union1::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui();
          xfer += iprot->readI32(this->value_.ui);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud();
          xfer += iprot->readDouble(this->value_.ud);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us();
          xfer += iprot->readString(this->value_.us);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue();
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->value_.ue = (enum1)ecast2;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union1");
  switch (type_) {
    case Type::ui: {
      xfer += oprot->writeFieldBegin("ui", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud: {
      xfer += oprot->writeFieldBegin("ud", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us: {
      xfer += oprot->writeFieldBegin("us", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue: {
      xfer += oprot->writeFieldBegin("ue", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union2::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union2");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_2"] != nullptr) {
      set_ui_2();
      int64_t _tmp3 = (int64_t)parsed["ui_2"].asInt();
      if (imaxabs(_tmp3) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_2 = (int32_t)_tmp3;
      }
      return;
    }
    if (parsed["ud_2"] != nullptr) {
      set_ud_2();
      this->value_.ud_2 = parsed["ud_2"].asDouble();
      return;
    }
    if (parsed["us_2"] != nullptr) {
      set_us_2();
      this->value_.us_2 = parsed["us_2"].asString();
      return;
    }
    if (parsed["ue_2"] != nullptr) {
      set_ue_2();
      this->value_.ue_2=(enum1)(int32_t)parsed["ue_2"].asInt();
      return;
    }
  }
  void union2::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union2::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_2();
          xfer += iprot->readI32(this->value_.ui_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_2();
          xfer += iprot->readDouble(this->value_.ud_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_2();
          xfer += iprot->readString(this->value_.us_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_2();
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->value_.ue_2 = (enum1)ecast5;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union2");
  switch (type_) {
    case Type::ui_2: {
      xfer += oprot->writeFieldBegin("ui_2", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_2: {
      xfer += oprot->writeFieldBegin("ud_2", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_2: {
      xfer += oprot->writeFieldBegin("us_2", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_2: {
      xfer += oprot->writeFieldBegin("ue_2", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union3::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union3");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_3"] != nullptr) {
      set_ui_3();
      int64_t _tmp6 = (int64_t)parsed["ui_3"].asInt();
      if (imaxabs(_tmp6) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_3 = (int32_t)_tmp6;
      }
      return;
    }
    if (parsed["ud_3"] != nullptr) {
      set_ud_3();
      this->value_.ud_3 = parsed["ud_3"].asDouble();
      return;
    }
    if (parsed["us_3"] != nullptr) {
      set_us_3();
      this->value_.us_3 = parsed["us_3"].asString();
      return;
    }
    if (parsed["ue_3"] != nullptr) {
      set_ue_3();
      this->value_.ue_3=(enum1)(int32_t)parsed["ue_3"].asInt();
      return;
    }
  }
  void union3::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union3::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_3();
          xfer += iprot->readI32(this->value_.ui_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_3();
          xfer += iprot->readDouble(this->value_.ud_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_3();
          xfer += iprot->readString(this->value_.us_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_3();
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->value_.ue_3 = (enum1)ecast8;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union3");
  switch (type_) {
    case Type::ui_3: {
      xfer += oprot->writeFieldBegin("ui_3", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_3: {
      xfer += oprot->writeFieldBegin("ud_3", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_3: {
      xfer += oprot->writeFieldBegin("us_3", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_3: {
      xfer += oprot->writeFieldBegin("ue_3", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structA::_reflection_id;
void structA::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(schema);
}

bool structA::operator == (const structA & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  return true;
}

void structA::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp10 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp10) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp10;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
}
void structA::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structA::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(*schema);
    iprot->setNextStructType(structA::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structA::__clear() {
  a = 0;
  b = "";
  __isset.__clear();
}
uint32_t structA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structA");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structA &a, structA &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

void merge(const structA& from, structA& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

void merge(structA&& from, structA& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

  void unionA::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse unionA");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["i"] != nullptr) {
      set_i();
      int64_t _tmp11 = (int64_t)parsed["i"].asInt();
      if (imaxabs(_tmp11) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.i = (int32_t)_tmp11;
      }
      return;
    }
    if (parsed["d"] != nullptr) {
      set_d();
      this->value_.d = parsed["d"].asDouble();
      return;
    }
    if (parsed["s"] != nullptr) {
      set_s();
      this->value_.s = parsed["s"].asString();
      return;
    }
    if (parsed["e"] != nullptr) {
      set_e();
      this->value_.e=(enum1)(int32_t)parsed["e"].asInt();
      return;
    }
    if (parsed["a"] != nullptr) {
      set_a();
      this->value_.a.readFromJson(folly::toJson(parsed["a"]).c_str());
      return;
    }
  }
  void unionA::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t unionA::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_s();
          xfer += iprot->readString(this->value_.s);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_e();
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->value_.e = (enum1)ecast13;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 5: {
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          set_a();
          xfer += this->value_.a.read(iprot);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t unionA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("unionA");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::s: {
      xfer += oprot->writeFieldBegin("s", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.s);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::e: {
      xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.e);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::a: {
      xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_STRUCT, 5);
      xfer += this->value_.a.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structB::_reflection_id;
void structB::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(schema);
}

bool structB::operator == (const structB & rhs) const {
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  return true;
}

void structB::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
}
void structB::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structB::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(*schema);
    iprot->setNextStructType(structB::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}
uint32_t structB::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structB");
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structB &a, structB &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

void merge(const structB& from, structB& to) {
  using apache::thrift::merge;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

void merge(structB&& from, structB& to) {
  using apache::thrift::merge;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

const uint64_t structC::_reflection_id;
void structC::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(schema);
}

bool structC::operator == (const structC & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  if (!(this->e == rhs.e))
    return false;
  if (!(this->f == rhs.f))
    return false;
  if (!(this->g == rhs.g))
    return false;
  if (!(this->h == rhs.h))
    return false;
  if (!(this->i == rhs.i))
    return false;
  if (!(this->j == rhs.j))
    return false;
  if (!(this->j1 == rhs.j1))
    return false;
  if (!(this->j2 == rhs.j2))
    return false;
  if (!(this->j3 == rhs.j3))
    return false;
  if (!(this->k == rhs.k))
    return false;
  if (!(this->k1 == rhs.k1))
    return false;
  if (!(this->k2 == rhs.k2))
    return false;
  if (!(this->k3 == rhs.k3))
    return false;
  if (!(this->l == rhs.l))
    return false;
  if (!(this->l1 == rhs.l1))
    return false;
  if (!(this->l2 == rhs.l2))
    return false;
  if (!(this->l3 == rhs.l3))
    return false;
  if (!(this->m1 == rhs.m1))
    return false;
  if (!(this->m2 == rhs.m2))
    return false;
  if (!(this->m3 == rhs.m3))
    return false;
  if (!(this->n1 == rhs.n1))
    return false;
  if (!(this->n2 == rhs.n2))
    return false;
  if (!(this->n3 == rhs.n3))
    return false;
  if (!(this->o1 == rhs.o1))
    return false;
  if (!(this->o2 == rhs.o2))
    return false;
  if (!(this->o3 == rhs.o3))
    return false;
  return true;
}

void structC::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp16 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp16) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp16;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
  if (parsed["e"] != nullptr) {
    this->e=(enum1)(int32_t)parsed["e"].asInt();
    this->__isset.e = true;
  } else {
    this->__isset.e = false;
  }
  if (parsed["f"] != nullptr) {
    this->f=(enum2)(int32_t)parsed["f"].asInt();
    this->__isset.f = true;
  } else {
    this->__isset.f = false;
  }
  if (parsed["g"] != nullptr) {
    this->g.readFromJson(folly::toJson(parsed["g"]).c_str());
    this->__isset.g = true;
  } else {
    this->__isset.g = false;
  }
  if (parsed["h"] != nullptr) {
    this->h.readFromJson(folly::toJson(parsed["h"]).c_str());
    this->__isset.h = true;
  } else {
    this->__isset.h = false;
  }
  if (parsed["i"] != nullptr) {
    this->i.readFromJson(folly::toJson(parsed["i"]).c_str());
    this->__isset.i = true;
  } else {
    this->__isset.i = false;
  }
  if (parsed["j"] != nullptr) {
    folly::dynamic _json21 = parsed["j"];
    this->j.clear();
    uint32_t _size19 = _json21.size();
    this->j.resize(_size19);
    for (uint32_t _i20 = 0; _i20 < _size19; ++_i20)
    {
      int64_t _tmp22 = (int64_t)_json21[_i20].asInt();
      if (imaxabs(_tmp22) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j[_i20] = (int32_t)_tmp22;
      }
    }
    this->__isset.j = true;
  } else {
    this->__isset.j = false;
  }
  if (parsed["j1"] != nullptr) {
    folly::dynamic _json25 = parsed["j1"];
    this->j1.clear();
    uint32_t _size23 = _json25.size();
    this->j1.resize(_size23);
    for (uint32_t _i24 = 0; _i24 < _size23; ++_i24)
    {
      int64_t _tmp26 = (int64_t)_json25[_i24].asInt();
      if (imaxabs(_tmp26) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j1[_i24] = (int32_t)_tmp26;
      }
    }
    this->__isset.j1 = true;
  } else {
    this->__isset.j1 = false;
  }
  if (parsed["j2"] != nullptr) {
    folly::dynamic _json29 = parsed["j2"];
    this->j2.clear();
    uint32_t _size27 = _json29.size();
    this->j2.resize(_size27);
    for (uint32_t _i28 = 0; _i28 < _size27; ++_i28)
    {
      this->j2[_i28]=(enum1)(int32_t)_json29[_i28].asInt();
    }
    this->__isset.j2 = true;
  } else {
    this->__isset.j2 = false;
  }
  if (parsed["j3"] != nullptr) {
    folly::dynamic _json33 = parsed["j3"];
    this->j3.clear();
    uint32_t _size31 = _json33.size();
    this->j3.resize(_size31);
    for (uint32_t _i32 = 0; _i32 < _size31; ++_i32)
    {
      this->j3[_i32].readFromJson(folly::toJson(_json33[_i32]).c_str());
    }
    this->__isset.j3 = true;
  } else {
    this->__isset.j3 = false;
  }
  if (parsed["k"] != nullptr) {
    folly::dynamic _json36 = parsed["k"];
    this->k.clear();
    uint32_t _size34 = _json36.size();
    for (uint32_t _i35 = 0; _i35 < _size34; ++_i35)
    {
      int32_t _elem37;
      int64_t _tmp38 = (int64_t)_json36[_i35].asInt();
      if (imaxabs(_tmp38) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem37 = (int32_t)_tmp38;
      }
      this->k.insert(_elem37);
    }
    this->__isset.k = true;
  } else {
    this->__isset.k = false;
  }
  if (parsed["k1"] != nullptr) {
    folly::dynamic _json41 = parsed["k1"];
    this->k1.clear();
    uint32_t _size39 = _json41.size();
    for (uint32_t _i40 = 0; _i40 < _size39; ++_i40)
    {
      int32_t _elem42;
      int64_t _tmp43 = (int64_t)_json41[_i40].asInt();
      if (imaxabs(_tmp43) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem42 = (int32_t)_tmp43;
      }
      this->k1.insert(_elem42);
    }
    this->__isset.k1 = true;
  } else {
    this->__isset.k1 = false;
  }
  if (parsed["k2"] != nullptr) {
    folly::dynamic _json46 = parsed["k2"];
    this->k2.clear();
    uint32_t _size44 = _json46.size();
    for (uint32_t _i45 = 0; _i45 < _size44; ++_i45)
    {
      enum2 _elem47;
      _elem47=(enum2)(int32_t)_json46[_i45].asInt();
      this->k2.insert(_elem47);
    }
    this->__isset.k2 = true;
  } else {
    this->__isset.k2 = false;
  }
  if (parsed["k3"] != nullptr) {
    folly::dynamic _json51 = parsed["k3"];
    this->k3.clear();
    uint32_t _size49 = _json51.size();
    for (uint32_t _i50 = 0; _i50 < _size49; ++_i50)
    {
      structB _elem52;
      _elem52.readFromJson(folly::toJson(_json51[_i50]).c_str());
      this->k3.insert(_elem52);
    }
    this->__isset.k3 = true;
  } else {
    this->__isset.k3 = false;
  }
  if (parsed["l"] != nullptr) {
    folly::dynamic _json55 = parsed["l"];
    this->l.clear();
    for (folly::dynamic::const_item_iterator _iter56 = _json55.items().begin(); _iter56 != _json55.items().end(); _iter56++)    {
      int32_t _key57;;
      int32_t _val58;;
      try {
        _key57 = folly::to<int32_t>((_iter56)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp59 = (int64_t)_iter56->second.asInt();
      if (imaxabs(_tmp59) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val58 = (int32_t)_tmp59;
      }
      this->l[_key57] = _val58;
    }
    this->__isset.l = true;
  } else {
    this->__isset.l = false;
  }
  if (parsed["l1"] != nullptr) {
    folly::dynamic _json62 = parsed["l1"];
    this->l1.clear();
    for (folly::dynamic::const_item_iterator _iter63 = _json62.items().begin(); _iter63 != _json62.items().end(); _iter63++)    {
      int32_t _key64;;
      int32_t _val65;;
      try {
        _key64 = folly::to<int32_t>((_iter63)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp66 = (int64_t)_iter63->second.asInt();
      if (imaxabs(_tmp66) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val65 = (int32_t)_tmp66;
      }
      this->l1[_key64] = _val65;
    }
    this->__isset.l1 = true;
  } else {
    this->__isset.l1 = false;
  }
  if (parsed["l2"] != nullptr) {
    folly::dynamic _json69 = parsed["l2"];
    this->l2.clear();
    for (folly::dynamic::const_item_iterator _iter70 = _json69.items().begin(); _iter70 != _json69.items().end(); _iter70++)    {
      int32_t _key71;;
      enum1 _val72;;
      try {
        _key71 = folly::to<int32_t>((_iter70)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val72=(enum1)(int32_t)_iter70->second.asInt();
      this->l2[_key71] = _val72;
    }
    this->__isset.l2 = true;
  } else {
    this->__isset.l2 = false;
  }
  if (parsed["l3"] != nullptr) {
    folly::dynamic _json76 = parsed["l3"];
    this->l3.clear();
    for (folly::dynamic::const_item_iterator _iter77 = _json76.items().begin(); _iter77 != _json76.items().end(); _iter77++)    {
      int32_t _key78;;
      structB _val79;;
      try {
        _key78 = folly::to<int32_t>((_iter77)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val79.readFromJson(folly::toJson(_iter77->second).c_str());
      this->l3[_key78] = _val79;
    }
    this->__isset.l3 = true;
  } else {
    this->__isset.l3 = false;
  }
  if (parsed["m1"] != nullptr) {
    folly::dynamic _json82 = parsed["m1"];
    this->m1.clear();
    for (folly::dynamic::const_item_iterator _iter83 = _json82.items().begin(); _iter83 != _json82.items().end(); _iter83++)    {
      enum1 _key84;;
      int32_t _val85;;
      try {
        _key84 = (enum1)folly::to<int>((_iter83)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp86 = (int64_t)_iter83->second.asInt();
      if (imaxabs(_tmp86) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val85 = (int32_t)_tmp86;
      }
      this->m1[_key84] = _val85;
    }
    this->__isset.m1 = true;
  } else {
    this->__isset.m1 = false;
  }
  if (parsed["m2"] != nullptr) {
    folly::dynamic _json89 = parsed["m2"];
    this->m2.clear();
    for (folly::dynamic::const_item_iterator _iter90 = _json89.items().begin(); _iter90 != _json89.items().end(); _iter90++)    {
      enum1 _key91;;
      enum2 _val92;;
      try {
        _key91 = (enum1)folly::to<int>((_iter90)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val92=(enum2)(int32_t)_iter90->second.asInt();
      this->m2[_key91] = _val92;
    }
    this->__isset.m2 = true;
  } else {
    this->__isset.m2 = false;
  }
  if (parsed["m3"] != nullptr) {
    folly::dynamic _json96 = parsed["m3"];
    this->m3.clear();
    for (folly::dynamic::const_item_iterator _iter97 = _json96.items().begin(); _iter97 != _json96.items().end(); _iter97++)    {
      enum1 _key98;;
      structB _val99;;
      try {
        _key98 = (enum1)folly::to<int>((_iter97)->first.asString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val99.readFromJson(folly::toJson(_iter97->second).c_str());
      this->m3[_key98] = _val99;
    }
    this->__isset.m3 = true;
  } else {
    this->__isset.m3 = false;
  }
  if (parsed["n1"] != nullptr) {
    folly::dynamic _json102 = parsed["n1"];
    this->n1.clear();
    for (folly::dynamic::const_item_iterator _iter103 = _json102.items().begin(); _iter103 != _json102.items().end(); _iter103++)    {
      std::string _key104;;
      int32_t _val105;;
      _key104 = (_iter103)->first.asString();
      int64_t _tmp106 = (int64_t)_iter103->second.asInt();
      if (imaxabs(_tmp106) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val105 = (int32_t)_tmp106;
      }
      this->n1[_key104] = _val105;
    }
    this->__isset.n1 = true;
  } else {
    this->__isset.n1 = false;
  }
  if (parsed["n2"] != nullptr) {
    folly::dynamic _json109 = parsed["n2"];
    this->n2.clear();
    for (folly::dynamic::const_item_iterator _iter110 = _json109.items().begin(); _iter110 != _json109.items().end(); _iter110++)    {
      std::string _key111;;
      enum1 _val112;;
      _key111 = (_iter110)->first.asString();
      _val112=(enum1)(int32_t)_iter110->second.asInt();
      this->n2[_key111] = _val112;
    }
    this->__isset.n2 = true;
  } else {
    this->__isset.n2 = false;
  }
  if (parsed["n3"] != nullptr) {
    folly::dynamic _json116 = parsed["n3"];
    this->n3.clear();
    for (folly::dynamic::const_item_iterator _iter117 = _json116.items().begin(); _iter117 != _json116.items().end(); _iter117++)    {
      std::string _key118;;
      structB _val119;;
      _key118 = (_iter117)->first.asString();
      _val119.readFromJson(folly::toJson(_iter117->second).c_str());
      this->n3[_key118] = _val119;
    }
    this->__isset.n3 = true;
  } else {
    this->__isset.n3 = false;
  }
  if (parsed["o1"] != nullptr) {
    this->__isset.o1 = true;
  } else {
    this->__isset.o1 = false;
  }
  if (parsed["o2"] != nullptr) {
    this->__isset.o2 = true;
  } else {
    this->__isset.o2 = false;
  }
  if (parsed["o3"] != nullptr) {
    this->__isset.o3 = true;
  } else {
    this->__isset.o3 = false;
  }
}
void structC::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structC::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(*schema);
    iprot->setNextStructType(structC::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast129;
          xfer += iprot->readI32(ecast129);
          this->e = (enum1)ecast129;
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->f = (enum2)ecast130;
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->g.read(iprot);
          this->__isset.g = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->h.read(iprot);
          this->__isset.h = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->i.read(iprot);
          this->__isset.i = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j.clear();
            uint32_t _size131;
            bool _sizeUnknown132;
            apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size131, _sizeUnknown132);
            if (!_sizeUnknown132) {
              this->j.resize(_size131);
              uint32_t _i137;
              for (_i137 = 0; _i137 < _size131; ++_i137)
              {
                xfer += iprot->readI32(this->j[_i137]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem138;
                xfer += iprot->readI32(_elem138);
                this->j.push_back(_elem138);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j1.clear();
            uint32_t _size139;
            bool _sizeUnknown140;
            apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size139, _sizeUnknown140);
            if (!_sizeUnknown140) {
              this->j1.resize(_size139);
              uint32_t _i145;
              for (_i145 = 0; _i145 < _size139; ++_i145)
              {
                xfer += iprot->readI32(this->j1[_i145]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem146;
                xfer += iprot->readI32(_elem146);
                this->j1.push_back(_elem146);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j2.clear();
            uint32_t _size147;
            bool _sizeUnknown148;
            apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size147, _sizeUnknown148);
            if (!_sizeUnknown148) {
              this->j2.resize(_size147);
              uint32_t _i153;
              for (_i153 = 0; _i153 < _size147; ++_i153)
              {
                int32_t ecast154;
                xfer += iprot->readI32(ecast154);
                this->j2[_i153] = (enum1)ecast154;
              }
            } else {
              while (iprot->peekList())
              {
                enum1 _elem155;
                int32_t ecast156;
                xfer += iprot->readI32(ecast156);
                _elem155 = (enum1)ecast156;
                this->j2.push_back(_elem155);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j3.clear();
            uint32_t _size157;
            bool _sizeUnknown158;
            apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size157, _sizeUnknown158);
            if (!_sizeUnknown158) {
              this->j3.resize(_size157);
              uint32_t _i163;
              for (_i163 = 0; _i163 < _size157; ++_i163)
              {
                xfer += this->j3[_i163].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem164;
                xfer += _elem164.read(iprot);
                this->j3.push_back(_elem164);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k.clear();
            uint32_t _size165;
            bool _sizeUnknown166;
            apache::thrift::protocol::TType _etype169;
            xfer += iprot->readSetBegin(_etype169, _size165, _sizeUnknown166);
            if (!_sizeUnknown166) {
              uint32_t _i171;
              for (_i171 = 0; _i171 < _size165; ++_i171)
              {
                int32_t _elem172;
                xfer += iprot->readI32(_elem172);
                this->k.insert(_elem172);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem173;
                xfer += iprot->readI32(_elem173);
                this->k.insert(_elem173);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k1.clear();
            uint32_t _size174;
            bool _sizeUnknown175;
            apache::thrift::protocol::TType _etype178;
            xfer += iprot->readSetBegin(_etype178, _size174, _sizeUnknown175);
            if (!_sizeUnknown175) {
              uint32_t _i180;
              for (_i180 = 0; _i180 < _size174; ++_i180)
              {
                int32_t _elem181;
                xfer += iprot->readI32(_elem181);
                this->k1.insert(_elem181);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem182;
                xfer += iprot->readI32(_elem182);
                this->k1.insert(_elem182);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k2.clear();
            uint32_t _size183;
            bool _sizeUnknown184;
            apache::thrift::protocol::TType _etype187;
            xfer += iprot->readSetBegin(_etype187, _size183, _sizeUnknown184);
            if (!_sizeUnknown184) {
              uint32_t _i189;
              for (_i189 = 0; _i189 < _size183; ++_i189)
              {
                enum2 _elem190;
                int32_t ecast191;
                xfer += iprot->readI32(ecast191);
                _elem190 = (enum2)ecast191;
                this->k2.insert(_elem190);
              }
            } else {
              while (iprot->peekSet())
              {
                enum2 _elem192;
                int32_t ecast193;
                xfer += iprot->readI32(ecast193);
                _elem192 = (enum2)ecast193;
                this->k2.insert(_elem192);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k3.clear();
            uint32_t _size194;
            bool _sizeUnknown195;
            apache::thrift::protocol::TType _etype198;
            xfer += iprot->readSetBegin(_etype198, _size194, _sizeUnknown195);
            if (!_sizeUnknown195) {
              uint32_t _i200;
              for (_i200 = 0; _i200 < _size194; ++_i200)
              {
                structB _elem201;
                xfer += _elem201.read(iprot);
                this->k3.insert(_elem201);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem202;
                xfer += _elem202.read(iprot);
                this->k3.insert(_elem202);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l.clear();
            uint32_t _size203;
            bool _sizeUnknown204;
            apache::thrift::protocol::TType _ktype205;
            apache::thrift::protocol::TType _vtype206;
            xfer += iprot->readMapBegin(_ktype205, _vtype206, _size203, _sizeUnknown204);
            if (!_sizeUnknown204) {
              uint32_t _i209;
              for (_i209 = 0; _i209 < _size203; ++_i209)
              {
                int32_t _key210;
                xfer += iprot->readI32(_key210);
                int32_t& _val211 = this->l[_key210];
                xfer += iprot->readI32(_val211);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key212;
                xfer += iprot->readI32(_key212);
                int32_t& _val213 = this->l[_key212];
                xfer += iprot->readI32(_val213);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l1.clear();
            uint32_t _size214;
            bool _sizeUnknown215;
            apache::thrift::protocol::TType _ktype216;
            apache::thrift::protocol::TType _vtype217;
            xfer += iprot->readMapBegin(_ktype216, _vtype217, _size214, _sizeUnknown215);
            if (!_sizeUnknown215) {
              uint32_t _i220;
              for (_i220 = 0; _i220 < _size214; ++_i220)
              {
                int32_t _key221;
                xfer += iprot->readI32(_key221);
                int32_t& _val222 = this->l1[_key221];
                xfer += iprot->readI32(_val222);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key223;
                xfer += iprot->readI32(_key223);
                int32_t& _val224 = this->l1[_key223];
                xfer += iprot->readI32(_val224);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l2.clear();
            uint32_t _size225;
            bool _sizeUnknown226;
            apache::thrift::protocol::TType _ktype227;
            apache::thrift::protocol::TType _vtype228;
            xfer += iprot->readMapBegin(_ktype227, _vtype228, _size225, _sizeUnknown226);
            if (!_sizeUnknown226) {
              uint32_t _i231;
              for (_i231 = 0; _i231 < _size225; ++_i231)
              {
                int32_t _key232;
                xfer += iprot->readI32(_key232);
                enum1& _val233 = this->l2[_key232];
                int32_t ecast234;
                xfer += iprot->readI32(ecast234);
                _val233 = (enum1)ecast234;
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key235;
                xfer += iprot->readI32(_key235);
                enum1& _val236 = this->l2[_key235];
                int32_t ecast237;
                xfer += iprot->readI32(ecast237);
                _val236 = (enum1)ecast237;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l3.clear();
            uint32_t _size238;
            bool _sizeUnknown239;
            apache::thrift::protocol::TType _ktype240;
            apache::thrift::protocol::TType _vtype241;
            xfer += iprot->readMapBegin(_ktype240, _vtype241, _size238, _sizeUnknown239);
            if (!_sizeUnknown239) {
              uint32_t _i244;
              for (_i244 = 0; _i244 < _size238; ++_i244)
              {
                int32_t _key245;
                xfer += iprot->readI32(_key245);
                structB& _val246 = this->l3[_key245];
                xfer += _val246.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key247;
                xfer += iprot->readI32(_key247);
                structB& _val248 = this->l3[_key247];
                xfer += _val248.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m1.clear();
            uint32_t _size249;
            bool _sizeUnknown250;
            apache::thrift::protocol::TType _ktype251;
            apache::thrift::protocol::TType _vtype252;
            xfer += iprot->readMapBegin(_ktype251, _vtype252, _size249, _sizeUnknown250);
            if (!_sizeUnknown250) {
              uint32_t _i255;
              for (_i255 = 0; _i255 < _size249; ++_i255)
              {
                enum1 _key256;
                int32_t ecast258;
                xfer += iprot->readI32(ecast258);
                _key256 = (enum1)ecast258;
                int32_t& _val257 = this->m1[_key256];
                xfer += iprot->readI32(_val257);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key259;
                int32_t ecast261;
                xfer += iprot->readI32(ecast261);
                _key259 = (enum1)ecast261;
                int32_t& _val260 = this->m1[_key259];
                xfer += iprot->readI32(_val260);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m2.clear();
            uint32_t _size262;
            bool _sizeUnknown263;
            apache::thrift::protocol::TType _ktype264;
            apache::thrift::protocol::TType _vtype265;
            xfer += iprot->readMapBegin(_ktype264, _vtype265, _size262, _sizeUnknown263);
            if (!_sizeUnknown263) {
              uint32_t _i268;
              for (_i268 = 0; _i268 < _size262; ++_i268)
              {
                enum1 _key269;
                int32_t ecast271;
                xfer += iprot->readI32(ecast271);
                _key269 = (enum1)ecast271;
                enum2& _val270 = this->m2[_key269];
                int32_t ecast272;
                xfer += iprot->readI32(ecast272);
                _val270 = (enum2)ecast272;
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key273;
                int32_t ecast275;
                xfer += iprot->readI32(ecast275);
                _key273 = (enum1)ecast275;
                enum2& _val274 = this->m2[_key273];
                int32_t ecast276;
                xfer += iprot->readI32(ecast276);
                _val274 = (enum2)ecast276;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m3.clear();
            uint32_t _size277;
            bool _sizeUnknown278;
            apache::thrift::protocol::TType _ktype279;
            apache::thrift::protocol::TType _vtype280;
            xfer += iprot->readMapBegin(_ktype279, _vtype280, _size277, _sizeUnknown278);
            if (!_sizeUnknown278) {
              uint32_t _i283;
              for (_i283 = 0; _i283 < _size277; ++_i283)
              {
                enum1 _key284;
                int32_t ecast286;
                xfer += iprot->readI32(ecast286);
                _key284 = (enum1)ecast286;
                structB& _val285 = this->m3[_key284];
                xfer += _val285.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key287;
                int32_t ecast289;
                xfer += iprot->readI32(ecast289);
                _key287 = (enum1)ecast289;
                structB& _val288 = this->m3[_key287];
                xfer += _val288.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n1.clear();
            uint32_t _size290;
            bool _sizeUnknown291;
            apache::thrift::protocol::TType _ktype292;
            apache::thrift::protocol::TType _vtype293;
            xfer += iprot->readMapBegin(_ktype292, _vtype293, _size290, _sizeUnknown291);
            if (!_sizeUnknown291) {
              uint32_t _i296;
              for (_i296 = 0; _i296 < _size290; ++_i296)
              {
                std::string _key297;
                xfer += iprot->readString(_key297);
                int32_t& _val298 = this->n1[_key297];
                xfer += iprot->readI32(_val298);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key299;
                xfer += iprot->readString(_key299);
                int32_t& _val300 = this->n1[_key299];
                xfer += iprot->readI32(_val300);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n2.clear();
            uint32_t _size301;
            bool _sizeUnknown302;
            apache::thrift::protocol::TType _ktype303;
            apache::thrift::protocol::TType _vtype304;
            xfer += iprot->readMapBegin(_ktype303, _vtype304, _size301, _sizeUnknown302);
            if (!_sizeUnknown302) {
              uint32_t _i307;
              for (_i307 = 0; _i307 < _size301; ++_i307)
              {
                std::string _key308;
                xfer += iprot->readString(_key308);
                enum1& _val309 = this->n2[_key308];
                int32_t ecast310;
                xfer += iprot->readI32(ecast310);
                _val309 = (enum1)ecast310;
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key311;
                xfer += iprot->readString(_key311);
                enum1& _val312 = this->n2[_key311];
                int32_t ecast313;
                xfer += iprot->readI32(ecast313);
                _val312 = (enum1)ecast313;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n3.clear();
            uint32_t _size314;
            bool _sizeUnknown315;
            apache::thrift::protocol::TType _ktype316;
            apache::thrift::protocol::TType _vtype317;
            xfer += iprot->readMapBegin(_ktype316, _vtype317, _size314, _sizeUnknown315);
            if (!_sizeUnknown315) {
              uint32_t _i320;
              for (_i320 = 0; _i320 < _size314; ++_i320)
              {
                std::string _key321;
                xfer += iprot->readString(_key321);
                structB& _val322 = this->n3[_key321];
                xfer += _val322.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key323;
                xfer += iprot->readString(_key323);
                structB& _val324 = this->n3[_key323];
                xfer += _val324.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o1.clear();
            uint32_t _size325;
            bool _sizeUnknown326;
            apache::thrift::protocol::TType _ktype327;
            apache::thrift::protocol::TType _vtype328;
            xfer += iprot->readMapBegin(_ktype327, _vtype328, _size325, _sizeUnknown326);
            if (!_sizeUnknown326) {
              uint32_t _i331;
              for (_i331 = 0; _i331 < _size325; ++_i331)
              {
                structA _key332;
                xfer += _key332.read(iprot);
                int32_t& _val333 = this->o1[_key332];
                xfer += iprot->readI32(_val333);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key334;
                xfer += _key334.read(iprot);
                int32_t& _val335 = this->o1[_key334];
                xfer += iprot->readI32(_val335);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o2.clear();
            uint32_t _size336;
            bool _sizeUnknown337;
            apache::thrift::protocol::TType _ktype338;
            apache::thrift::protocol::TType _vtype339;
            xfer += iprot->readMapBegin(_ktype338, _vtype339, _size336, _sizeUnknown337);
            if (!_sizeUnknown337) {
              uint32_t _i342;
              for (_i342 = 0; _i342 < _size336; ++_i342)
              {
                structA _key343;
                xfer += _key343.read(iprot);
                enum1& _val344 = this->o2[_key343];
                int32_t ecast345;
                xfer += iprot->readI32(ecast345);
                _val344 = (enum1)ecast345;
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key346;
                xfer += _key346.read(iprot);
                enum1& _val347 = this->o2[_key346];
                int32_t ecast348;
                xfer += iprot->readI32(ecast348);
                _val347 = (enum1)ecast348;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o3.clear();
            uint32_t _size349;
            bool _sizeUnknown350;
            apache::thrift::protocol::TType _ktype351;
            apache::thrift::protocol::TType _vtype352;
            xfer += iprot->readMapBegin(_ktype351, _vtype352, _size349, _sizeUnknown350);
            if (!_sizeUnknown350) {
              uint32_t _i355;
              for (_i355 = 0; _i355 < _size349; ++_i355)
              {
                structA _key356;
                xfer += _key356.read(iprot);
                structB& _val357 = this->o3[_key356];
                xfer += _val357.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key358;
                xfer += _key358.read(iprot);
                structB& _val359 = this->o3[_key358];
                xfer += _val359.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structC::__clear() {
  a = 0;
  b = "";
  c = 0;
  d = 0;
  e = static_cast<enum1>(0);
  f = static_cast<enum2>(0);
  g.__clear();
  h.__clear();
  i.__clear();
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}
uint32_t structC::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structC");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->e);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->f);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("g", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->g.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("h", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->h.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->i.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j.size());
    std::vector<int32_t> ::const_iterator _iter360;
    for (_iter360 = this->j.begin(); _iter360 != this->j.end(); ++_iter360)
    {
      xfer += oprot->writeI32((*_iter360));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j1", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j1.size());
    std::vector<int32_t> ::const_iterator _iter361;
    for (_iter361 = this->j1.begin(); _iter361 != this->j1.end(); ++_iter361)
    {
      xfer += oprot->writeI32((*_iter361));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j2", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j2.size());
    std::vector<enum1> ::const_iterator _iter362;
    for (_iter362 = this->j2.begin(); _iter362 != this->j2.end(); ++_iter362)
    {
      xfer += oprot->writeI32((int32_t)(*_iter362));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j3", apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->j3.size());
    std::vector<structA> ::const_iterator _iter363;
    for (_iter363 = this->j3.begin(); _iter363 != this->j3.end(); ++_iter363)
    {
      xfer += (*_iter363).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k.size());
    std::set<int32_t> ::const_iterator _iter364;
    for (_iter364 = this->k.begin(); _iter364 != this->k.end(); ++_iter364)
    {
      xfer += oprot->writeI32((*_iter364));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k1", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k1.size());
    std::set<int32_t> ::const_iterator _iter365;
    for (_iter365 = this->k1.begin(); _iter365 != this->k1.end(); ++_iter365)
    {
      xfer += oprot->writeI32((*_iter365));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k2", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k2.size());
    std::set<enum2> ::const_iterator _iter366;
    for (_iter366 = this->k2.begin(); _iter366 != this->k2.end(); ++_iter366)
    {
      xfer += oprot->writeI32((int32_t)(*_iter366));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k3", apache::thrift::protocol::T_SET, 17);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->k3.size());
    std::set<structB> ::const_iterator _iter367;
    for (_iter367 = this->k3.begin(); _iter367 != this->k3.end(); ++_iter367)
    {
      xfer += (*_iter367).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l.size());
    std::map<int32_t, int32_t> ::const_iterator _iter368;
    for (_iter368 = this->l.begin(); _iter368 != this->l.end(); ++_iter368)
    {
      xfer += oprot->writeI32(_iter368->first);
      xfer += oprot->writeI32(_iter368->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l1", apache::thrift::protocol::T_MAP, 19);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l1.size());
    std::map<int32_t, int32_t> ::const_iterator _iter369;
    for (_iter369 = this->l1.begin(); _iter369 != this->l1.end(); ++_iter369)
    {
      xfer += oprot->writeI32(_iter369->first);
      xfer += oprot->writeI32(_iter369->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l2", apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l2.size());
    std::map<int32_t, enum1> ::const_iterator _iter370;
    for (_iter370 = this->l2.begin(); _iter370 != this->l2.end(); ++_iter370)
    {
      xfer += oprot->writeI32(_iter370->first);
      xfer += oprot->writeI32((int32_t)_iter370->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l3", apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->l3.size());
    std::map<int32_t, structB> ::const_iterator _iter371;
    for (_iter371 = this->l3.begin(); _iter371 != this->l3.end(); ++_iter371)
    {
      xfer += oprot->writeI32(_iter371->first);
      xfer += _iter371->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m1", apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m1.size());
    std::map<enum1, int32_t> ::const_iterator _iter372;
    for (_iter372 = this->m1.begin(); _iter372 != this->m1.end(); ++_iter372)
    {
      xfer += oprot->writeI32((int32_t)_iter372->first);
      xfer += oprot->writeI32(_iter372->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m2", apache::thrift::protocol::T_MAP, 23);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m2.size());
    std::map<enum1, enum2> ::const_iterator _iter373;
    for (_iter373 = this->m2.begin(); _iter373 != this->m2.end(); ++_iter373)
    {
      xfer += oprot->writeI32((int32_t)_iter373->first);
      xfer += oprot->writeI32((int32_t)_iter373->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m3", apache::thrift::protocol::T_MAP, 24);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->m3.size());
    std::map<enum1, structB> ::const_iterator _iter374;
    for (_iter374 = this->m3.begin(); _iter374 != this->m3.end(); ++_iter374)
    {
      xfer += oprot->writeI32((int32_t)_iter374->first);
      xfer += _iter374->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n1", apache::thrift::protocol::T_MAP, 25);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n1.size());
    std::map<std::string, int32_t> ::const_iterator _iter375;
    for (_iter375 = this->n1.begin(); _iter375 != this->n1.end(); ++_iter375)
    {
      xfer += oprot->writeString(_iter375->first);
      xfer += oprot->writeI32(_iter375->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n2", apache::thrift::protocol::T_MAP, 26);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n2.size());
    std::map<std::string, enum1> ::const_iterator _iter376;
    for (_iter376 = this->n2.begin(); _iter376 != this->n2.end(); ++_iter376)
    {
      xfer += oprot->writeString(_iter376->first);
      xfer += oprot->writeI32((int32_t)_iter376->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n3", apache::thrift::protocol::T_MAP, 27);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->n3.size());
    std::map<std::string, structB> ::const_iterator _iter377;
    for (_iter377 = this->n3.begin(); _iter377 != this->n3.end(); ++_iter377)
    {
      xfer += oprot->writeString(_iter377->first);
      xfer += _iter377->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o1", apache::thrift::protocol::T_MAP, 28);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o1.size());
    std::map<structA, int32_t> ::const_iterator _iter378;
    for (_iter378 = this->o1.begin(); _iter378 != this->o1.end(); ++_iter378)
    {
      xfer += _iter378->first.write(oprot);
      xfer += oprot->writeI32(_iter378->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o2", apache::thrift::protocol::T_MAP, 29);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o2.size());
    std::map<structA, enum1> ::const_iterator _iter379;
    for (_iter379 = this->o2.begin(); _iter379 != this->o2.end(); ++_iter379)
    {
      xfer += _iter379->first.write(oprot);
      xfer += oprot->writeI32((int32_t)_iter379->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o3", apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_STRUCT, this->o3.size());
    std::map<structA, structB> ::const_iterator _iter380;
    for (_iter380 = this->o3.begin(); _iter380 != this->o3.end(); ++_iter380)
    {
      xfer += _iter380->first.write(oprot);
      xfer += _iter380->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structC &a, structC &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

void merge(const structC& from, structC& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(from.e, to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(from.f, to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(from.g, to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(from.h, to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(from.i, to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(from.j, to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(from.j1, to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(from.j2, to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(from.j3, to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(from.k, to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(from.k1, to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(from.k2, to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(from.k3, to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(from.l, to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(from.l1, to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(from.l2, to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(from.l3, to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(from.m1, to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(from.m2, to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(from.m3, to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(from.n1, to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(from.n2, to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(from.n3, to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(from.o1, to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(from.o2, to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(from.o3, to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

void merge(structC&& from, structC& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
  merge(std::move(from.e), to.e);
  to.__isset.e = to.__isset.e || from.__isset.e;
  merge(std::move(from.f), to.f);
  to.__isset.f = to.__isset.f || from.__isset.f;
  merge(std::move(from.g), to.g);
  to.__isset.g = to.__isset.g || from.__isset.g;
  merge(std::move(from.h), to.h);
  to.__isset.h = to.__isset.h || from.__isset.h;
  merge(std::move(from.i), to.i);
  to.__isset.i = to.__isset.i || from.__isset.i;
  merge(std::move(from.j), to.j);
  to.__isset.j = to.__isset.j || from.__isset.j;
  merge(std::move(from.j1), to.j1);
  to.__isset.j1 = to.__isset.j1 || from.__isset.j1;
  merge(std::move(from.j2), to.j2);
  to.__isset.j2 = to.__isset.j2 || from.__isset.j2;
  merge(std::move(from.j3), to.j3);
  to.__isset.j3 = to.__isset.j3 || from.__isset.j3;
  merge(std::move(from.k), to.k);
  to.__isset.k = to.__isset.k || from.__isset.k;
  merge(std::move(from.k1), to.k1);
  to.__isset.k1 = to.__isset.k1 || from.__isset.k1;
  merge(std::move(from.k2), to.k2);
  to.__isset.k2 = to.__isset.k2 || from.__isset.k2;
  merge(std::move(from.k3), to.k3);
  to.__isset.k3 = to.__isset.k3 || from.__isset.k3;
  merge(std::move(from.l), to.l);
  to.__isset.l = to.__isset.l || from.__isset.l;
  merge(std::move(from.l1), to.l1);
  to.__isset.l1 = to.__isset.l1 || from.__isset.l1;
  merge(std::move(from.l2), to.l2);
  to.__isset.l2 = to.__isset.l2 || from.__isset.l2;
  merge(std::move(from.l3), to.l3);
  to.__isset.l3 = to.__isset.l3 || from.__isset.l3;
  merge(std::move(from.m1), to.m1);
  to.__isset.m1 = to.__isset.m1 || from.__isset.m1;
  merge(std::move(from.m2), to.m2);
  to.__isset.m2 = to.__isset.m2 || from.__isset.m2;
  merge(std::move(from.m3), to.m3);
  to.__isset.m3 = to.__isset.m3 || from.__isset.m3;
  merge(std::move(from.n1), to.n1);
  to.__isset.n1 = to.__isset.n1 || from.__isset.n1;
  merge(std::move(from.n2), to.n2);
  to.__isset.n2 = to.__isset.n2 || from.__isset.n2;
  merge(std::move(from.n3), to.n3);
  to.__isset.n3 = to.__isset.n3 || from.__isset.n3;
  merge(std::move(from.o1), to.o1);
  to.__isset.o1 = to.__isset.o1 || from.__isset.o1;
  merge(std::move(from.o2), to.o2);
  to.__isset.o2 = to.__isset.o2 || from.__isset.o2;
  merge(std::move(from.o3), to.o3);
  to.__isset.o3 = to.__isset.o3 || from.__isset.o3;
}

const uint64_t struct1::_reflection_id;
void struct1::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(schema);
}

bool struct1::operator == (const struct1 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  if (__isset.field4 != rhs.__isset.field4)
    return false;
  else if (__isset.field4 && !(field4 == rhs.field4))
    return false;
  if (!(this->field5 == rhs.field5))
    return false;
  return true;
}

void struct1::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["field0"] != nullptr) {
    int64_t _tmp382 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp382) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp382;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3=(enum2)(int32_t)parsed["field3"].asInt();
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field4"] != nullptr) {
    this->field4.readFromJson(folly::toJson(parsed["field4"]).c_str());
    this->__isset.field4 = true;
  } else {
    this->__isset.field4 = false;
  }
  if (parsed["field5"] != nullptr) {
    this->field5.readFromJson(folly::toJson(parsed["field5"]).c_str());
    this->__isset.field5 = true;
  } else {
    this->__isset.field5 = false;
  }
}
void struct1::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct1::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(*schema);
    iprot->setNextStructType(struct1::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;
  bool isset_field3 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast385;
          xfer += iprot->readI32(ecast385);
          this->field2 = (enum1)ecast385;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast386;
          xfer += iprot->readI32(ecast386);
          this->field3 = (enum2)ecast386;
          isset_field3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field4.read(iprot);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field5.read(iprot);
          this->__isset.field5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct1");
  if (!isset_field3)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field3' was not found in serialized data! Struct: struct1");
  return xfer;
}

void struct1::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3 = static_cast<enum2>(0);
  field4.__clear();
  field5.__clear();
  __isset.__clear();
}
uint32_t struct1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct1");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->field3);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field4) {
    xfer += oprot->writeFieldBegin("field4", apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->field4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field5", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->field5.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct1 &a, struct1 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

void merge(const struct1& from, struct1& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  merge(from.field2, to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(from.field3, to.field3);
  if (from.__isset.field4) {
    merge(from.field4, to.field4);
    to.__isset.field4 = true;
  }
  merge(from.field5, to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

void merge(struct1&& from, struct1& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  merge(std::move(from.field2), to.field2);
  to.__isset.field2 = to.__isset.field2 || from.__isset.field2;
  merge(std::move(from.field3), to.field3);
  if (from.__isset.field4) {
    merge(std::move(from.field4), to.field4);
    to.__isset.field4 = true;
  }
  merge(std::move(from.field5), to.field5);
  to.__isset.field5 = to.__isset.field5 || from.__isset.field5;
}

const uint64_t struct2::_reflection_id;
void struct2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(schema);
}

bool struct2::operator == (const struct2 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  return true;
}

void struct2::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp388 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp388) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp388;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
}
void struct2::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(*schema);
    iprot->setNextStructType(struct2::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast391;
          xfer += iprot->readI32(ecast391);
          this->fieldC = (enum1)ecast391;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast392;
          xfer += iprot->readI32(ecast392);
          this->fieldD = (enum2)ecast392;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct2::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  __isset.__clear();
}
uint32_t struct2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct2");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct2 &a, struct2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

void merge(const struct2& from, struct2& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

void merge(struct2&& from, struct2& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
}

const uint64_t struct3::_reflection_id;
void struct3::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(schema);
}

bool struct3::operator == (const struct3 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  if (!(this->fieldH == rhs.fieldH))
    return false;
  if (!(this->fieldI == rhs.fieldI))
    return false;
  if (!(this->fieldJ == rhs.fieldJ))
    return false;
  if (!(this->fieldK == rhs.fieldK))
    return false;
  if (!(this->fieldL == rhs.fieldL))
    return false;
  if (!(this->fieldM == rhs.fieldM))
    return false;
  if (!(this->fieldN == rhs.fieldN))
    return false;
  if (!(this->fieldO == rhs.fieldO))
    return false;
  if (!(this->fieldP == rhs.fieldP))
    return false;
  if (!(this->fieldQ == rhs.fieldQ))
    return false;
  if (!(this->fieldR == rhs.fieldR))
    return false;
  return true;
}

void struct3::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp394 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp394) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp394;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
  if (parsed["fieldH"] != nullptr) {
    this->fieldH.readFromJson(folly::toJson(parsed["fieldH"]).c_str());
    this->__isset.fieldH = true;
  } else {
    this->__isset.fieldH = false;
  }
  if (parsed["fieldI"] != nullptr) {
    folly::dynamic _json399 = parsed["fieldI"];
    this->fieldI.clear();
    uint32_t _size397 = _json399.size();
    this->fieldI.resize(_size397);
    for (uint32_t _i398 = 0; _i398 < _size397; ++_i398)
    {
      int64_t _tmp400 = (int64_t)_json399[_i398].asInt();
      if (imaxabs(_tmp400) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->fieldI[_i398] = (int32_t)_tmp400;
      }
    }
    this->__isset.fieldI = true;
  } else {
    this->__isset.fieldI = false;
  }
  if (parsed["fieldJ"] != nullptr) {
    folly::dynamic _json403 = parsed["fieldJ"];
    this->fieldJ.clear();
    uint32_t _size401 = _json403.size();
    this->fieldJ.resize(_size401);
    for (uint32_t _i402 = 0; _i402 < _size401; ++_i402)
    {
      this->fieldJ[_i402] = _json403[_i402].asString();
    }
    this->__isset.fieldJ = true;
  } else {
    this->__isset.fieldJ = false;
  }
  if (parsed["fieldK"] != nullptr) {
    folly::dynamic _json406 = parsed["fieldK"];
    this->fieldK.clear();
    uint32_t _size404 = _json406.size();
    this->fieldK.resize(_size404);
    for (uint32_t _i405 = 0; _i405 < _size404; ++_i405)
    {
      this->fieldK[_i405] = _json406[_i405].asString();
    }
    this->__isset.fieldK = true;
  } else {
    this->__isset.fieldK = false;
  }
  if (parsed["fieldL"] != nullptr) {
    folly::dynamic _json409 = parsed["fieldL"];
    this->fieldL.clear();
    uint32_t _size407 = _json409.size();
    this->fieldL.resize(_size407);
    for (uint32_t _i408 = 0; _i408 < _size407; ++_i408)
    {
      this->fieldL[_i408].readFromJson(folly::toJson(_json409[_i408]).c_str());
    }
    this->__isset.fieldL = true;
  } else {
    this->__isset.fieldL = false;
  }
  if (parsed["fieldM"] != nullptr) {
    folly::dynamic _json412 = parsed["fieldM"];
    this->fieldM.clear();
    uint32_t _size410 = _json412.size();
    for (uint32_t _i411 = 0; _i411 < _size410; ++_i411)
    {
      int32_t _elem413;
      int64_t _tmp414 = (int64_t)_json412[_i411].asInt();
      if (imaxabs(_tmp414) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem413 = (int32_t)_tmp414;
      }
      this->fieldM.insert(_elem413);
    }
    this->__isset.fieldM = true;
  } else {
    this->__isset.fieldM = false;
  }
  if (parsed["fieldN"] != nullptr) {
    folly::dynamic _json417 = parsed["fieldN"];
    this->fieldN.clear();
    uint32_t _size415 = _json417.size();
    for (uint32_t _i416 = 0; _i416 < _size415; ++_i416)
    {
      std::string _elem418;
      _elem418 = _json417[_i416].asString();
      this->fieldN.insert(_elem418);
    }
    this->__isset.fieldN = true;
  } else {
    this->__isset.fieldN = false;
  }
  if (parsed["fieldO"] != nullptr) {
    folly::dynamic _json421 = parsed["fieldO"];
    this->fieldO.clear();
    uint32_t _size419 = _json421.size();
    for (uint32_t _i420 = 0; _i420 < _size419; ++_i420)
    {
      std::string _elem422;
      _elem422 = _json421[_i420].asString();
      this->fieldO.insert(_elem422);
    }
    this->__isset.fieldO = true;
  } else {
    this->__isset.fieldO = false;
  }
  if (parsed["fieldP"] != nullptr) {
    folly::dynamic _json425 = parsed["fieldP"];
    this->fieldP.clear();
    uint32_t _size423 = _json425.size();
    for (uint32_t _i424 = 0; _i424 < _size423; ++_i424)
    {
      structB _elem426;
      _elem426.readFromJson(folly::toJson(_json425[_i424]).c_str());
      this->fieldP.insert(_elem426);
    }
    this->__isset.fieldP = true;
  } else {
    this->__isset.fieldP = false;
  }
  if (parsed["fieldQ"] != nullptr) {
    folly::dynamic _json429 = parsed["fieldQ"];
    this->fieldQ.clear();
    for (folly::dynamic::const_item_iterator _iter430 = _json429.items().begin(); _iter430 != _json429.items().end(); _iter430++)    {
      std::string _key431;;
      structA _val432;;
      _key431 = (_iter430)->first.asString();
      _val432.readFromJson(folly::toJson(_iter430->second).c_str());
      this->fieldQ[_key431] = _val432;
    }
    this->__isset.fieldQ = true;
  } else {
    this->__isset.fieldQ = false;
  }
  if (parsed["fieldR"] != nullptr) {
    folly::dynamic _json435 = parsed["fieldR"];
    this->fieldR.clear();
    for (folly::dynamic::const_item_iterator _iter436 = _json435.items().begin(); _iter436 != _json435.items().end(); _iter436++)    {
      std::string _key437;;
      structB _val438;;
      _key437 = (_iter436)->first.asString();
      _val438.readFromJson(folly::toJson(_iter436->second).c_str());
      this->fieldR[_key437] = _val438;
    }
    this->__isset.fieldR = true;
  } else {
    this->__isset.fieldR = false;
  }
}
void struct3::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct3::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(*schema);
    iprot->setNextStructType(struct3::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast439;
          xfer += iprot->readI32(ecast439);
          this->fieldC = (enum1)ecast439;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast440;
          xfer += iprot->readI32(ecast440);
          this->fieldD = (enum2)ecast440;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldH.read(iprot);
          this->__isset.fieldH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldI.clear();
            uint32_t _size441;
            bool _sizeUnknown442;
            apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size441, _sizeUnknown442);
            if (!_sizeUnknown442) {
              this->fieldI.resize(_size441);
              uint32_t _i447;
              for (_i447 = 0; _i447 < _size441; ++_i447)
              {
                xfer += iprot->readI32(this->fieldI[_i447]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem448;
                xfer += iprot->readI32(_elem448);
                this->fieldI.push_back(_elem448);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldJ.clear();
            uint32_t _size449;
            bool _sizeUnknown450;
            apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size449, _sizeUnknown450);
            if (!_sizeUnknown450) {
              this->fieldJ.resize(_size449);
              uint32_t _i455;
              for (_i455 = 0; _i455 < _size449; ++_i455)
              {
                xfer += iprot->readString(this->fieldJ[_i455]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem456;
                xfer += iprot->readString(_elem456);
                this->fieldJ.push_back(_elem456);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldJ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldK.clear();
            uint32_t _size457;
            bool _sizeUnknown458;
            apache::thrift::protocol::TType _etype461;
            xfer += iprot->readListBegin(_etype461, _size457, _sizeUnknown458);
            if (!_sizeUnknown458) {
              this->fieldK.resize(_size457);
              uint32_t _i463;
              for (_i463 = 0; _i463 < _size457; ++_i463)
              {
                xfer += iprot->readString(this->fieldK[_i463]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem464;
                xfer += iprot->readString(_elem464);
                this->fieldK.push_back(_elem464);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldL.clear();
            uint32_t _size465;
            bool _sizeUnknown466;
            apache::thrift::protocol::TType _etype469;
            xfer += iprot->readListBegin(_etype469, _size465, _sizeUnknown466);
            if (!_sizeUnknown466) {
              this->fieldL.resize(_size465);
              uint32_t _i471;
              for (_i471 = 0; _i471 < _size465; ++_i471)
              {
                xfer += this->fieldL[_i471].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem472;
                xfer += _elem472.read(iprot);
                this->fieldL.push_back(_elem472);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldM.clear();
            uint32_t _size473;
            bool _sizeUnknown474;
            apache::thrift::protocol::TType _etype477;
            xfer += iprot->readSetBegin(_etype477, _size473, _sizeUnknown474);
            if (!_sizeUnknown474) {
              uint32_t _i479;
              for (_i479 = 0; _i479 < _size473; ++_i479)
              {
                int32_t _elem480;
                xfer += iprot->readI32(_elem480);
                this->fieldM.insert(_elem480);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem481;
                xfer += iprot->readI32(_elem481);
                this->fieldM.insert(_elem481);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldM = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldN.clear();
            uint32_t _size482;
            bool _sizeUnknown483;
            apache::thrift::protocol::TType _etype486;
            xfer += iprot->readSetBegin(_etype486, _size482, _sizeUnknown483);
            if (!_sizeUnknown483) {
              uint32_t _i488;
              for (_i488 = 0; _i488 < _size482; ++_i488)
              {
                std::string _elem489;
                xfer += iprot->readString(_elem489);
                this->fieldN.insert(_elem489);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem490;
                xfer += iprot->readString(_elem490);
                this->fieldN.insert(_elem490);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldO.clear();
            uint32_t _size491;
            bool _sizeUnknown492;
            apache::thrift::protocol::TType _etype495;
            xfer += iprot->readSetBegin(_etype495, _size491, _sizeUnknown492);
            if (!_sizeUnknown492) {
              uint32_t _i497;
              for (_i497 = 0; _i497 < _size491; ++_i497)
              {
                std::string _elem498;
                xfer += iprot->readString(_elem498);
                this->fieldO.insert(_elem498);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem499;
                xfer += iprot->readString(_elem499);
                this->fieldO.insert(_elem499);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldO = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldP.clear();
            uint32_t _size500;
            bool _sizeUnknown501;
            apache::thrift::protocol::TType _etype504;
            xfer += iprot->readSetBegin(_etype504, _size500, _sizeUnknown501);
            if (!_sizeUnknown501) {
              uint32_t _i506;
              for (_i506 = 0; _i506 < _size500; ++_i506)
              {
                structB _elem507;
                xfer += _elem507.read(iprot);
                this->fieldP.insert(_elem507);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem508;
                xfer += _elem508.read(iprot);
                this->fieldP.insert(_elem508);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldQ.clear();
            uint32_t _size509;
            bool _sizeUnknown510;
            apache::thrift::protocol::TType _ktype511;
            apache::thrift::protocol::TType _vtype512;
            xfer += iprot->readMapBegin(_ktype511, _vtype512, _size509, _sizeUnknown510);
            if (!_sizeUnknown510) {
              uint32_t _i515;
              for (_i515 = 0; _i515 < _size509; ++_i515)
              {
                std::string _key516;
                xfer += iprot->readString(_key516);
                structA& _val517 = this->fieldQ[_key516];
                xfer += _val517.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key518;
                xfer += iprot->readString(_key518);
                structA& _val519 = this->fieldQ[_key518];
                xfer += _val519.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldQ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldR.clear();
            uint32_t _size520;
            bool _sizeUnknown521;
            apache::thrift::protocol::TType _ktype522;
            apache::thrift::protocol::TType _vtype523;
            xfer += iprot->readMapBegin(_ktype522, _vtype523, _size520, _sizeUnknown521);
            if (!_sizeUnknown521) {
              uint32_t _i526;
              for (_i526 = 0; _i526 < _size520; ++_i526)
              {
                std::string _key527;
                xfer += iprot->readString(_key527);
                structB& _val528 = this->fieldR[_key527];
                xfer += _val528.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key529;
                xfer += iprot->readString(_key529);
                structB& _val530 = this->fieldR[_key529];
                xfer += _val530.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct3::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  fieldH.__clear();
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}
uint32_t struct3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct3");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldH", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->fieldH.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldI", apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->fieldI.size());
    std::vector<int32_t> ::const_iterator _iter531;
    for (_iter531 = this->fieldI.begin(); _iter531 != this->fieldI.end(); ++_iter531)
    {
      xfer += oprot->writeI32((*_iter531));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldJ", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldJ.size());
    std::vector<std::string> ::const_iterator _iter532;
    for (_iter532 = this->fieldJ.begin(); _iter532 != this->fieldJ.end(); ++_iter532)
    {
      xfer += oprot->writeString((*_iter532));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldK", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldK.size());
    std::vector<std::string> ::const_iterator _iter533;
    for (_iter533 = this->fieldK.begin(); _iter533 != this->fieldK.end(); ++_iter533)
    {
      xfer += oprot->writeString((*_iter533));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldL", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->fieldL.size());
    std::vector<structA> ::const_iterator _iter534;
    for (_iter534 = this->fieldL.begin(); _iter534 != this->fieldL.end(); ++_iter534)
    {
      xfer += (*_iter534).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldM", apache::thrift::protocol::T_SET, 13);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->fieldM.size());
    std::set<int32_t> ::const_iterator _iter535;
    for (_iter535 = this->fieldM.begin(); _iter535 != this->fieldM.end(); ++_iter535)
    {
      xfer += oprot->writeI32((*_iter535));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldN", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldN.size());
    std::set<std::string> ::const_iterator _iter536;
    for (_iter536 = this->fieldN.begin(); _iter536 != this->fieldN.end(); ++_iter536)
    {
      xfer += oprot->writeString((*_iter536));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldO", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldO.size());
    std::set<std::string> ::const_iterator _iter537;
    for (_iter537 = this->fieldO.begin(); _iter537 != this->fieldO.end(); ++_iter537)
    {
      xfer += oprot->writeString((*_iter537));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldP", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->fieldP.size());
    std::set<structB> ::const_iterator _iter538;
    for (_iter538 = this->fieldP.begin(); _iter538 != this->fieldP.end(); ++_iter538)
    {
      xfer += (*_iter538).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldQ", apache::thrift::protocol::T_MAP, 17);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldQ.size());
    std::map<std::string, structA> ::const_iterator _iter539;
    for (_iter539 = this->fieldQ.begin(); _iter539 != this->fieldQ.end(); ++_iter539)
    {
      xfer += oprot->writeString(_iter539->first);
      xfer += _iter539->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldR", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldR.size());
    std::map<std::string, structB> ::const_iterator _iter540;
    for (_iter540 = this->fieldR.begin(); _iter540 != this->fieldR.end(); ++_iter540)
    {
      xfer += oprot->writeString(_iter540->first);
      xfer += _iter540->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct3 &a, struct3 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

void merge(const struct3& from, struct3& to) {
  using apache::thrift::merge;
  merge(from.fieldA, to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(from.fieldB, to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(from.fieldC, to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(from.fieldD, to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(from.fieldE, to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(from.fieldF, to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(from.fieldG, to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(from.fieldH, to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(from.fieldI, to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(from.fieldJ, to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(from.fieldK, to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(from.fieldL, to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(from.fieldM, to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(from.fieldN, to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(from.fieldO, to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(from.fieldP, to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(from.fieldQ, to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(from.fieldR, to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

void merge(struct3&& from, struct3& to) {
  using apache::thrift::merge;
  merge(std::move(from.fieldA), to.fieldA);
  to.__isset.fieldA = to.__isset.fieldA || from.__isset.fieldA;
  merge(std::move(from.fieldB), to.fieldB);
  to.__isset.fieldB = to.__isset.fieldB || from.__isset.fieldB;
  merge(std::move(from.fieldC), to.fieldC);
  to.__isset.fieldC = to.__isset.fieldC || from.__isset.fieldC;
  merge(std::move(from.fieldD), to.fieldD);
  to.__isset.fieldD = to.__isset.fieldD || from.__isset.fieldD;
  merge(std::move(from.fieldE), to.fieldE);
  to.__isset.fieldE = to.__isset.fieldE || from.__isset.fieldE;
  merge(std::move(from.fieldF), to.fieldF);
  to.__isset.fieldF = to.__isset.fieldF || from.__isset.fieldF;
  merge(std::move(from.fieldG), to.fieldG);
  to.__isset.fieldG = to.__isset.fieldG || from.__isset.fieldG;
  merge(std::move(from.fieldH), to.fieldH);
  to.__isset.fieldH = to.__isset.fieldH || from.__isset.fieldH;
  merge(std::move(from.fieldI), to.fieldI);
  to.__isset.fieldI = to.__isset.fieldI || from.__isset.fieldI;
  merge(std::move(from.fieldJ), to.fieldJ);
  to.__isset.fieldJ = to.__isset.fieldJ || from.__isset.fieldJ;
  merge(std::move(from.fieldK), to.fieldK);
  to.__isset.fieldK = to.__isset.fieldK || from.__isset.fieldK;
  merge(std::move(from.fieldL), to.fieldL);
  to.__isset.fieldL = to.__isset.fieldL || from.__isset.fieldL;
  merge(std::move(from.fieldM), to.fieldM);
  to.__isset.fieldM = to.__isset.fieldM || from.__isset.fieldM;
  merge(std::move(from.fieldN), to.fieldN);
  to.__isset.fieldN = to.__isset.fieldN || from.__isset.fieldN;
  merge(std::move(from.fieldO), to.fieldO);
  to.__isset.fieldO = to.__isset.fieldO || from.__isset.fieldO;
  merge(std::move(from.fieldP), to.fieldP);
  to.__isset.fieldP = to.__isset.fieldP || from.__isset.fieldP;
  merge(std::move(from.fieldQ), to.fieldQ);
  to.__isset.fieldQ = to.__isset.fieldQ || from.__isset.fieldQ;
  merge(std::move(from.fieldR), to.fieldR);
  to.__isset.fieldR = to.__isset.fieldR || from.__isset.fieldR;
}

}} // namespace
