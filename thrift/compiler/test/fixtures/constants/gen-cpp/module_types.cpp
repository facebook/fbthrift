/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/constants/gen-cpp/module_types.h"
#include "thrift/compiler/test/fixtures/constants/gen-cpp/module_data.h"

#include "thrift/compiler/test/fixtures/constants/gen-cpp/module_reflection.h"

#include <algorithm>
#include <string.h>

#include <folly/Indestructible.h>



const typename _EmptyEnum_EnumMapFactory::ValuesToNamesMapType _EmptyEnum_VALUES_TO_NAMES = _EmptyEnum_EnumMapFactory::makeValuesToNamesMap();

const typename _EmptyEnum_EnumMapFactory::NamesToValuesMapType _EmptyEnum_NAMES_TO_VALUES = _EmptyEnum_EnumMapFactory::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::EmptyEnum>::size = 0;
template <>const folly::Range<const  ::EmptyEnum*> TEnumTraits< ::EmptyEnum>::values = {};
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::EmptyEnum>::names = {};

template<>
const char* TEnumTraits< ::EmptyEnum>::findName( ::EmptyEnum value) {
  static const auto map = folly::Indestructible< ::_EmptyEnum_EnumMapFactory::ValuesToNamesMapType>{ ::_EmptyEnum_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::EmptyEnum>::findValue(const char* name,  ::EmptyEnum* out) {
  static const auto map = folly::Indestructible< ::_EmptyEnum_EnumMapFactory::NamesToValuesMapType>{ ::_EmptyEnum_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift


const typename _City_EnumMapFactory::ValuesToNamesMapType _City_VALUES_TO_NAMES = _City_EnumMapFactory::makeValuesToNamesMap();

const typename _City_EnumMapFactory::NamesToValuesMapType _City_NAMES_TO_VALUES = _City_EnumMapFactory::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::City>::size = 4;
template <>const folly::Range<const  ::City*> TEnumTraits< ::City>::values = folly::range( ::_CityEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::City>::names = folly::range( ::_CityEnumDataStorage::names);

template<>
const char* TEnumTraits< ::City>::findName( ::City value) {
  static const auto map = folly::Indestructible< ::_City_EnumMapFactory::ValuesToNamesMapType>{ ::_City_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::City>::findValue(const char* name,  ::City* out) {
  static const auto map = folly::Indestructible< ::_City_EnumMapFactory::NamesToValuesMapType>{ ::_City_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift


const typename _Company_EnumMapFactory::ValuesToNamesMapType _Company_VALUES_TO_NAMES = _Company_EnumMapFactory::makeValuesToNamesMap();

const typename _Company_EnumMapFactory::NamesToValuesMapType _Company_NAMES_TO_VALUES = _Company_EnumMapFactory::makeNamesToValuesMap();


namespace apache { namespace thrift {
template <>const std::size_t TEnumTraits< ::Company>::size = 4;
template <>const folly::Range<const  ::Company*> TEnumTraits< ::Company>::values = folly::range( ::_CompanyEnumDataStorage::values);
template <>const folly::Range<const folly::StringPiece*> TEnumTraits< ::Company>::names = folly::range( ::_CompanyEnumDataStorage::names);

template<>
const char* TEnumTraits< ::Company>::findName( ::Company value) {
  static const auto map = folly::Indestructible< ::_Company_EnumMapFactory::ValuesToNamesMapType>{ ::_Company_EnumMapFactory::makeValuesToNamesMap()};
  return findName(*map, value);
}

template<>
bool TEnumTraits< ::Company>::findValue(const char* name,  ::Company* out) {
  static const auto map = folly::Indestructible< ::_Company_EnumMapFactory::NamesToValuesMapType>{ ::_Company_EnumMapFactory::makeNamesToValuesMap()};
  return findValue(*map, name, out);
}
}} // apache::thrift


const uint64_t Internship::_reflection_id;
void Internship::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_9022508676980868684(schema);
}

bool Internship::operator == (const Internship & rhs) const {
  if (!(this->weeks == rhs.weeks))
    return false;
  if (!(this->title == rhs.title))
    return false;
  if (__isset.employer != rhs.__isset.employer)
    return false;
  else if (__isset.employer && !(employer == rhs.employer))
    return false;
  return true;
}

uint32_t Internship::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_9022508676980868684(*schema);
    iprot->setNextStructType(Internship::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_weeks = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weeks);
          isset_weeks = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->employer = (Company)ecast1;
          this->__isset.employer = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_weeks)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'weeks' was not found in serialized data! Struct: Internship");
  return xfer;
}

void Internship::__clear() {
  weeks = 0;
  title = "";
  employer = static_cast<Company>(0);
  __isset.__clear();
}
uint32_t Internship::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Internship");
  xfer += oprot->writeFieldBegin("weeks", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->weeks);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("title", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.employer) {
    xfer += oprot->writeFieldBegin("employer", apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->employer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Internship &a, Internship &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.weeks, b.weeks);
  swap(a.title, b.title);
  swap(a.employer, b.employer);
  swap(a.__isset, b.__isset);
}

void merge(const Internship& from, Internship& to) {
  using apache::thrift::merge;
  merge(from.weeks, to.weeks);
  merge(from.title, to.title);
  to.__isset.title = to.__isset.title || from.__isset.title;
  if (from.__isset.employer) {
    merge(from.employer, to.employer);
    to.__isset.employer = true;
  }
}

void merge(Internship&& from, Internship& to) {
  using apache::thrift::merge;
  merge(std::move(from.weeks), to.weeks);
  merge(std::move(from.title), to.title);
  to.__isset.title = to.__isset.title || from.__isset.title;
  if (from.__isset.employer) {
    merge(std::move(from.employer), to.employer);
    to.__isset.employer = true;
  }
}

const uint64_t UnEnumStruct::_reflection_id;
void UnEnumStruct::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_18314195816413397484(schema);
}

bool UnEnumStruct::operator == (const UnEnumStruct & rhs) const {
  if (!(this->city == rhs.city))
    return false;
  return true;
}

uint32_t UnEnumStruct::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_18314195816413397484(*schema);
    iprot->setNextStructType(UnEnumStruct::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->city = (City)ecast3;
          this->__isset.city = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void UnEnumStruct::__clear() {
  city = City(-1);
  __isset.__clear();
}
uint32_t UnEnumStruct::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnEnumStruct");
  xfer += oprot->writeFieldBegin("city", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->city);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnEnumStruct &a, UnEnumStruct &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.city, b.city);
  swap(a.__isset, b.__isset);
}

void merge(const UnEnumStruct& from, UnEnumStruct& to) {
  using apache::thrift::merge;
  merge(from.city, to.city);
  to.__isset.city = to.__isset.city || from.__isset.city;
}

void merge(UnEnumStruct&& from, UnEnumStruct& to) {
  using apache::thrift::merge;
  merge(std::move(from.city), to.city);
  to.__isset.city = to.__isset.city || from.__isset.city;
}

const uint64_t Range::_reflection_id;
void Range::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_7757081658652615948(schema);
}

bool Range::operator == (const Range & rhs) const {
  if (!(this->min == rhs.min))
    return false;
  if (!(this->max == rhs.max))
    return false;
  return true;
}

uint32_t Range::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_7757081658652615948(*schema);
    iprot->setNextStructType(Range::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_min = false;
  bool isset_max = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min);
          isset_min = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_min)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'min' was not found in serialized data! Struct: Range");
  if (!isset_max)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'max' was not found in serialized data! Struct: Range");
  return xfer;
}

void Range::__clear() {
  min = 0;
  max = 0;
}
uint32_t Range::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Range");
  xfer += oprot->writeFieldBegin("min", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->min);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("max", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->max);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Range &a, Range &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.min, b.min);
  swap(a.max, b.max);
}

void merge(const Range& from, Range& to) {
  using apache::thrift::merge;
  merge(from.min, to.min);
  merge(from.max, to.max);
}

void merge(Range&& from, Range& to) {
  using apache::thrift::merge;
  merge(std::move(from.min), to.min);
  merge(std::move(from.max), to.max);
}

const uint64_t struct1::_reflection_id;
void struct1::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_18317194148543753228(schema);
}

bool struct1::operator == (const struct1 & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  return true;
}

uint32_t struct1::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_18317194148543753228(*schema);
    iprot->setNextStructType(struct1::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct1::__clear() {
  a = 1234567;
  b = "<uninitialized>";
  __isset.__clear();
}
uint32_t struct1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct1");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct1 &a, struct1 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

void merge(const struct1& from, struct1& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

void merge(struct1&& from, struct1& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
}

const uint64_t struct2::_reflection_id;
void struct2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_13919930284671800588(schema);
}

bool struct2::operator == (const struct2 & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  return true;
}

uint32_t struct2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_13919930284671800588(*schema);
    iprot->setNextStructType(struct2::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->c.read(iprot);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 4:
        if (_ftype == apache::thrift::protocol::T_LIST) {
          {
            this->d.clear();
            uint32_t _size7;
            bool _sizeUnknown8;
            apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size7, _sizeUnknown8);
            if (!_sizeUnknown8) {
              this->d.resize(_size7);
              uint32_t _i13;
              for (_i13 = 0; _i13 < _size7; ++_i13)
              {
                xfer += iprot->readI32(this->d[_i13]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem14;
                xfer += iprot->readI32(_elem14);
                this->d.push_back(_elem14);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct2::__clear() {
  a = 0;
  b = "";
  c.__clear();
  d.clear();
  __isset.__clear();
}
uint32_t struct2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct2");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->c.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->d.size());
    std::vector<int32_t> ::const_iterator _iter15;
    for (_iter15 = this->d.begin(); _iter15 != this->d.end(); ++_iter15)
    {
      xfer += oprot->writeI32((*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct2 &a, struct2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

void merge(const struct2& from, struct2& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(from.d, to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

void merge(struct2&& from, struct2& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
  merge(std::move(from.d), to.d);
  to.__isset.d = to.__isset.d || from.__isset.d;
}

const uint64_t struct3::_reflection_id;
void struct3::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::module_reflection_::reflectionInitializer_16392874475279945260(schema);
}

bool struct3::operator == (const struct3 & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  return true;
}

uint32_t struct3::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::module_reflection_::reflectionInitializer_16392874475279945260(*schema);
    iprot->setNextStructType(struct3::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 2:
        if (_ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      case 3:
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->c.read(iprot);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void struct3::__clear() {
  a = "";
  b = 0;
  c.__clear();
  __isset.__clear();
}
uint32_t struct3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct3");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->c.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct3 &a, struct3 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.__isset, b.__isset);
}

void merge(const struct3& from, struct3& to) {
  using apache::thrift::merge;
  merge(from.a, to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(from.b, to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(from.c, to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
}

void merge(struct3&& from, struct3& to) {
  using apache::thrift::merge;
  merge(std::move(from.a), to.a);
  to.__isset.a = to.__isset.a || from.__isset.a;
  merge(std::move(from.b), to.b);
  to.__isset.b = to.__isset.b || from.__isset.b;
  merge(std::move(from.c), to.c);
  to.__isset.c = to.__isset.c || from.__isset.c;
}

uint32_t union1::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union1");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

uint32_t union2::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(_fname);
  xfer += iprot->readFieldBegin(_fname, _ftype, fid);
  if (_ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (_ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 2: {
        if (_ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 3: {
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          set_s();
          xfer += this->value_.s.read(iprot);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      case 4: {
        if (_ftype == apache::thrift::protocol::T_STRUCT) {
          set_u();
          xfer += this->value_.u.read(iprot);
        } else {
        xfer += iprot->skip(_ftype);
        }
        break;
      }
      default: xfer += iprot->skip(_ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (UNLIKELY(_ftype != apache::thrift::protocol::T_STOP)) {
      using apache::thrift::protocol::TProtocolException;
      TProtocolException::throwUnionMissingStop();
    }
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union2");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::s: {
      xfer += oprot->writeFieldBegin("s", apache::thrift::protocol::T_STRUCT, 3);
      xfer += this->value_.s.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::u: {
      xfer += oprot->writeFieldBegin("u", apache::thrift::protocol::T_STRUCT, 4);
      xfer += this->value_.u.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


