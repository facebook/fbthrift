// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::consts::*;
pub use self::errors::*;
pub use self::types::*;

pub mod consts {
    pub const myInt: ::std::primitive::i32 = 1337;

    pub const name: &::std::primitive::str = "Mark Zuckerberg";

    lazy_static::lazy_static! {
        pub static ref states: ::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>> = vec![
            {
                let mut map = ::std::collections::BTreeMap::new();
                map.insert("San Diego".to_owned(), 3211000);
                map.insert("Sacramento".to_owned(), 479600);
                map.insert("SF".to_owned(), 837400);
                map
            },
            {
                let mut map = ::std::collections::BTreeMap::new();
                map.insert("New York".to_owned(), 8406000);
                map.insert("Albany".to_owned(), 98400);
                map
            },
        ];
    }

    pub const x: ::std::primitive::f64 = 1.0;

    pub const y: ::std::primitive::f64 = 0.0;

    pub const z: ::std::primitive::f64 = 1000000000.0;

    pub const zeroDoubleValue: ::std::primitive::f64 = 0.0;

    pub const longDoubleValue: ::std::primitive::f64 = 2.59961000990301e-05;

    pub const my_company: crate::types::MyCompany = crate::types::Company::FACEBOOK;

    pub const foo: &::std::primitive::str = "foo";

    pub const bar: crate::types::MyIntIdentifier = 42;

    lazy_static::lazy_static! {
        pub static ref mymap: crate::types::MyMapIdentifier = {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert("keys".to_owned(), "values".to_owned());
            map
        };
    }

    lazy_static::lazy_static! {
        pub static ref instagram: crate::types::Internship = crate::types::Internship {
            weeks: 12,
            title: "Software Engineer".to_owned(),
            employer: ::std::option::Option::Some(crate::types::Company::INSTAGRAM),
        };
    }

    lazy_static::lazy_static! {
        pub static ref partial_const: crate::types::Internship = crate::types::Internship {
            weeks: 8,
            title: "Some Job".to_owned(),
            employer: ::std::default::Default::default(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref kRanges: ::std::vec::Vec<crate::types::Range> = vec![
            crate::types::Range {
                min: 1,
                max: 2,
            },
            crate::types::Range {
                min: 5,
                max: 6,
            },
        ];
    }

    lazy_static::lazy_static! {
        pub static ref internList: ::std::vec::Vec<crate::types::Internship> = vec![
            crate::types::Internship {
                weeks: 12,
                title: "Software Engineer".to_owned(),
                employer: ::std::option::Option::Some(crate::types::Company::INSTAGRAM),
            },
            crate::types::Internship {
                weeks: 10,
                title: "Sales Intern".to_owned(),
                employer: ::std::option::Option::Some(crate::types::Company::FACEBOOK),
            },
        ];
    }

    lazy_static::lazy_static! {
        pub static ref pod_0: crate::types::struct1 = crate::types::struct1 {
            a: 1234567,
            b: "<uninitialized>".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_s_0: crate::types::struct1 = crate::types::struct1 {
            a: 1234567,
            b: "<uninitialized>".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_1: crate::types::struct1 = crate::types::struct1 {
            a: 10,
            b: "foo".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_s_1: crate::types::struct1 = crate::types::struct1 {
            a: 10,
            b: "foo".to_owned(),
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_2: crate::types::struct2 = crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_trailing_commas: crate::types::struct2 = crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_s_2: crate::types::struct2 = crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_3: crate::types::struct3 = crate::types::struct3 {
            a: "abc".to_owned(),
            b: 456,
            c: crate::types::struct2 {
                a: 888,
                b: ::std::default::Default::default(),
                c: crate::types::struct1 {
                    a: 1234567,
                    b: "gaz".to_owned(),
                },
                d: vec![
                    1,
                    2,
                    3,
                ],
            },
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_s_3: crate::types::struct3 = crate::types::struct3 {
            a: "abc".to_owned(),
            b: 456,
            c: crate::types::struct2 {
                a: 888,
                b: ::std::default::Default::default(),
                c: crate::types::struct1 {
                    a: 1234567,
                    b: "gaz".to_owned(),
                },
                d: vec![
                    1,
                    2,
                    3,
                ],
            },
        };
    }

    lazy_static::lazy_static! {
        pub static ref pod_4: crate::types::struct4 = crate::types::struct4 {
            a: 1234,
            b: ::std::option::Option::Some(0.333),
            c: ::std::option::Option::Some(25),
        };
    }

    lazy_static::lazy_static! {
        pub static ref u_1_1: crate::types::union1 = crate::types::union1::i(97);
    }

    lazy_static::lazy_static! {
        pub static ref u_1_2: crate::types::union1 = crate::types::union1::d(5.6);
    }

    lazy_static::lazy_static! {
        pub static ref u_1_3: crate::types::union1 = crate::types::union1::default();
    }

    lazy_static::lazy_static! {
        pub static ref u_2_1: crate::types::union2 = crate::types::union2::i(51);
    }

    lazy_static::lazy_static! {
        pub static ref u_2_2: crate::types::union2 = crate::types::union2::d(6.7);
    }

    lazy_static::lazy_static! {
        pub static ref u_2_3: crate::types::union2 = crate::types::union2::s(crate::types::struct1 {
                a: 8,
                b: "abacabb".to_owned(),
            });
    }

    lazy_static::lazy_static! {
        pub static ref u_2_4: crate::types::union2 = crate::types::union2::u(crate::types::union1::i(43));
    }

    lazy_static::lazy_static! {
        pub static ref u_2_5: crate::types::union2 = crate::types::union2::u(crate::types::union1::d(9.8));
    }

    lazy_static::lazy_static! {
        pub static ref u_2_6: crate::types::union2 = crate::types::union2::u(crate::types::union1::default());
    }

    pub const apostrophe: &::std::primitive::str = "'";

    pub const tripleApostrophe: &::std::primitive::str = "'''";

    pub const quotationMark: &::std::primitive::str = "\"";

    pub const backslash: &::std::primitive::str = "\\\\";

    pub const escaped_a: &::std::primitive::str = "\\x61";

    lazy_static::lazy_static! {
        pub static ref char2ascii: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32> = {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert("'".to_owned(), 39);
            map.insert("\"".to_owned(), 34);
            map.insert("\\\\".to_owned(), 92);
            map.insert("\\x61".to_owned(), 97);
            map
        };
    }

    lazy_static::lazy_static! {
        pub static ref escaped_strings: ::std::vec::Vec<::std::string::String> = vec![
            "\\x61".to_owned(),
            "\\xab".to_owned(),
            "\\x6a".to_owned(),
            "\\xa6".to_owned(),
            "\\x61yyy".to_owned(),
            "\\xabyyy".to_owned(),
            "\\x6ayyy".to_owned(),
            "\\xa6yyy".to_owned(),
            "zzz\\x61".to_owned(),
            "zzz\\xab".to_owned(),
            "zzz\\x6a".to_owned(),
            "zzz\\xa6".to_owned(),
            "zzz\\x61yyy".to_owned(),
            "zzz\\xabyyy".to_owned(),
            "zzz\\x6ayyy".to_owned(),
            "zzz\\xa6yyy".to_owned(),
        ];
    }

    pub const false_c: ::std::primitive::bool = false;

    pub const true_c: ::std::primitive::bool = true;

    pub const zero_byte: ::std::primitive::i8 = 0;

    pub const zero16: ::std::primitive::i16 = 0;

    pub const zero32: ::std::primitive::i32 = 0;

    pub const zero64: ::std::primitive::i64 = 0;

    pub const zero_dot_zero: ::std::primitive::f64 = 0.0;

    pub const empty_string: &::std::primitive::str = "";

    lazy_static::lazy_static! {
        pub static ref empty_int_list: ::std::vec::Vec<::std::primitive::i32> = ::std::vec::Vec::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_list: ::std::vec::Vec<::std::string::String> = ::std::vec::Vec::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_set: ::std::collections::BTreeSet<::std::primitive::i32> = ::std::collections::BTreeSet::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_set: ::std::collections::BTreeSet<::std::string::String> = ::std::collections::BTreeSet::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_int_map: ::std::collections::BTreeMap<::std::primitive::i32, ::std::primitive::i32> = ::std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_int_string_map: ::std::collections::BTreeMap<::std::primitive::i32, ::std::string::String> = ::std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_int_map: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32> = ::std::collections::BTreeMap::new();
    }

    lazy_static::lazy_static! {
        pub static ref empty_string_string_map: ::std::collections::BTreeMap<::std::string::String, ::std::string::String> = ::std::collections::BTreeMap::new();
    }
}

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type MyCompany = crate::types::Company;

    pub type MyStringIdentifier = ::std::string::String;

    pub type MyIntIdentifier = ::std::primitive::i32;

    pub type MyMapIdentifier = ::std::collections::BTreeMap<::std::string::String, ::std::string::String>;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Internship {
        pub weeks: ::std::primitive::i32,
        pub title: ::std::string::String,
        pub employer: ::std::option::Option<crate::types::Company>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Range {
        pub min: ::std::primitive::i32,
        pub max: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct struct1 {
        pub a: ::std::primitive::i32,
        pub b: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct2 {
        pub a: ::std::primitive::i32,
        pub b: ::std::string::String,
        pub c: crate::types::struct1,
        pub d: ::std::vec::Vec<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct3 {
        pub a: ::std::string::String,
        pub b: ::std::primitive::i32,
        pub c: crate::types::struct2,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct4 {
        pub a: ::std::primitive::i32,
        pub b: ::std::option::Option<::std::primitive::f64>,
        pub c: ::std::option::Option<::std::primitive::i8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union1 {
        i(::std::primitive::i32),
        d(::std::primitive::f64),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union2 {
        i(::std::primitive::i32),
        d(::std::primitive::f64),
        s(crate::types::struct1),
        u(crate::types::union1),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EmptyEnum(pub ::std::primitive::i32);

    impl EmptyEnum {

        pub fn variants() -> &'static [&'static str] {
            &[
            ]
        }
    }

    impl ::std::default::Default for EmptyEnum {
        fn default() -> Self {
            EmptyEnum(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EmptyEnum {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "{}", self.0)
        }
    }

    impl ::std::fmt::Debug for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EmptyEnum::{}", self)
        }
    }

    impl ::std::str::FromStr for EmptyEnum {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                _ => ::anyhow::bail!("Unable to parse {} as EmptyEnum", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EmptyEnum {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EmptyEnum::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct City(pub ::std::primitive::i32);

    impl City {
        pub const NYC: Self = City(0i32);
        pub const MPK: Self = City(1i32);
        pub const SEA: Self = City(2i32);
        pub const LON: Self = City(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "NYC",
                "MPK",
                "SEA",
                "LON",
            ]
        }
    }

    impl ::std::default::Default for City {
        fn default() -> Self {
            City(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a City> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a City) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<City> for ::std::primitive::i32 {
        #[inline]
        fn from(x: City) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for City {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for City {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                City::NYC => "NYC",
                City::MPK => "MPK",
                City::SEA => "SEA",
                City::LON => "LON",
                City(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for City {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "City::{}", self)
        }
    }

    impl ::std::str::FromStr for City {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "NYC" => ::std::result::Result::Ok(City::NYC),
                "MPK" => ::std::result::Result::Ok(City::MPK),
                "SEA" => ::std::result::Result::Ok(City::SEA),
                "LON" => ::std::result::Result::Ok(City::LON),
                _ => ::anyhow::bail!("Unable to parse {} as City", string),
            }
        }
    }

    impl ::fbthrift::GetTType for City {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for City
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for City
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(City::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Company(pub ::std::primitive::i32);

    impl Company {
        pub const FACEBOOK: Self = Company(0i32);
        pub const WHATSAPP: Self = Company(1i32);
        pub const OCULUS: Self = Company(2i32);
        pub const INSTAGRAM: Self = Company(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "FACEBOOK",
                "WHATSAPP",
                "OCULUS",
                "INSTAGRAM",
            ]
        }
    }

    impl ::std::default::Default for Company {
        fn default() -> Self {
            Company(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Company> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Company) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Company> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Company) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Company {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Company {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                Company::FACEBOOK => "FACEBOOK",
                Company::WHATSAPP => "WHATSAPP",
                Company::OCULUS => "OCULUS",
                Company::INSTAGRAM => "INSTAGRAM",
                Company(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for Company {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Company::{}", self)
        }
    }

    impl ::std::str::FromStr for Company {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "FACEBOOK" => ::std::result::Result::Ok(Company::FACEBOOK),
                "WHATSAPP" => ::std::result::Result::Ok(Company::WHATSAPP),
                "OCULUS" => ::std::result::Result::Ok(Company::OCULUS),
                "INSTAGRAM" => ::std::result::Result::Ok(Company::INSTAGRAM),
                _ => ::anyhow::bail!("Unable to parse {} as Company", string),
            }
        }
    }

    impl ::fbthrift::GetTType for Company {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Company
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Company
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Company::from(p.read_i32()?))
        }
    }





    impl ::std::default::Default for self::Internship {
        fn default() -> Self {
            Self {
                weeks: ::std::default::Default::default(),
                title: ::std::default::Default::default(),
                employer: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Internship {}
    unsafe impl ::std::marker::Sync for self::Internship {}

    impl ::fbthrift::GetTType for self::Internship {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Internship
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Internship");
            p.write_field_begin("weeks", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.weeks, p);
            p.write_field_end();
            p.write_field_begin("title", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.title, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.employer {
                p.write_field_begin("employer", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Internship
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_weeks = ::std::option::Option::None;
            let mut field_title = ::std::option::Option::None;
            let mut field_employer = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_weeks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_title = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_employer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                weeks: field_weeks.unwrap_or_default(),
                title: field_title.unwrap_or_default(),
                employer: field_employer,
            })
        }
    }


    impl ::std::default::Default for self::Range {
        fn default() -> Self {
            Self {
                min: ::std::default::Default::default(),
                max: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Range {}
    unsafe impl ::std::marker::Sync for self::Range {}

    impl ::fbthrift::GetTType for self::Range {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Range
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Range");
            p.write_field_begin("min", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.min, p);
            p.write_field_end();
            p.write_field_begin("max", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.max, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Range
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_min = ::std::option::Option::None;
            let mut field_max = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_min = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_max = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                min: field_min.unwrap_or_default(),
                max: field_max.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct1 {
        fn default() -> Self {
            Self {
                a: 1234567,
                b: "<uninitialized>".to_owned(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct1 {}
    unsafe impl ::std::marker::Sync for self::struct1 {}

    impl ::fbthrift::GetTType for self::struct1 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct1
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct1");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct1
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_else(|| 1234567),
                b: field_b.unwrap_or_else(|| "<uninitialized>".to_owned()),
            })
        }
    }


    impl ::std::default::Default for self::struct2 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::default::Default::default(),
                c: ::std::default::Default::default(),
                d: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct2 {}
    unsafe impl ::std::marker::Sync for self::struct2 {}

    impl ::fbthrift::GetTType for self::struct2 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct2
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct2");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_begin("d", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.d, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct2
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let mut field_d = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_d = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
                d: field_d.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct3 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::default::Default::default(),
                c: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct3 {}
    unsafe impl ::std::marker::Sync for self::struct3 {}

    impl ::fbthrift::GetTType for self::struct3 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct3
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct3");
            p.write_field_begin("a", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct3
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct4 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::option::Option::None,
                c: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct4 {}
    unsafe impl ::std::marker::Sync for self::struct4 {}

    impl ::fbthrift::GetTType for self::struct4 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct4
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct4");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.b {
                p.write_field_begin("b", ::fbthrift::TType::Double, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.c {
                p.write_field_begin("c", ::fbthrift::TType::Byte, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct4
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b,
                c: field_c,
            })
        }
    }



    impl ::std::default::Default for union1 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for union1 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for union1
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union1");
            match self {
                union1::i(inner) => {
                    p.write_field_begin("i", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::d(inner) => {
                    p.write_field_begin("d", ::fbthrift::TType::Double, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for union1
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union1::i(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union1::d(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union1",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }


    impl ::std::default::Default for union2 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for union2 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for union2
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union2");
            match self {
                union2::i(inner) => {
                    p.write_field_begin("i", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::d(inner) => {
                    p.write_field_begin("d", ::fbthrift::TType::Double, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::s(inner) => {
                    p.write_field_begin("s", ::fbthrift::TType::Struct, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::u(inner) => {
                    p.write_field_begin("u", ::fbthrift::TType::Struct, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for union2
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::i(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::d(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::s(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::u(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union2",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }
}

pub mod errors {
}
