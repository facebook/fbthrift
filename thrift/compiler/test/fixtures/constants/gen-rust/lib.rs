// @generated by Thrift for src/module.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::consts::*;
pub use self::errors::*;
pub use self::types::*;

/// Constant definitions for `module`.
pub mod consts {
    pub const myInt: ::std::primitive::i32 = 1337;

    pub const name: &::std::primitive::str = "Mark Zuckerberg";

    pub const multi_line_string: &::std::primitive::str = "This\nis a\nmulti line string.\n";

    pub static states: ::once_cell::sync::Lazy<::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>> = ::once_cell::sync::Lazy::new(|| vec![
            {
                let mut map = ::std::collections::BTreeMap::new();
                map.insert("San Diego".to_owned(), 3211000);
                map.insert("Sacramento".to_owned(), 479600);
                map.insert("SF".to_owned(), 837400);
                map
            },
            {
                let mut map = ::std::collections::BTreeMap::new();
                map.insert("New York".to_owned(), 8406000);
                map.insert("Albany".to_owned(), 98400);
                map
            },
        ]);

    pub const x: ::std::primitive::f64 = 1.0;

    pub const y: ::std::primitive::f64 = 0.0;

    pub const z: ::std::primitive::f64 = 1000000000.0;

    pub const zeroDoubleValue: ::std::primitive::f64 = 0.0;

    pub const longDoubleValue: ::std::primitive::f64 = 2.59961000990301e-05;

    pub const my_company: crate::types::MyCompany = crate::types::Company::FACEBOOK;

    pub const foo: &::std::primitive::str = "foo";

    pub const bar: crate::types::MyIntIdentifier = 42;

    pub static mymap: ::once_cell::sync::Lazy<crate::types::MyMapIdentifier> = ::once_cell::sync::Lazy::new(|| {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert("keys".to_owned(), "values".to_owned());
            map
        });

    pub static instagram: ::once_cell::sync::Lazy<crate::types::Internship> = ::once_cell::sync::Lazy::new(|| crate::types::Internship {
            weeks: 12,
            title: "Software Engineer".to_owned(),
            employer: ::std::option::Option::Some(crate::types::Company::INSTAGRAM),
            compensation: ::std::option::Option::Some(1200.0),
        });

    pub static partial_const: ::once_cell::sync::Lazy<crate::types::Internship> = ::once_cell::sync::Lazy::new(|| crate::types::Internship {
            weeks: 8,
            title: "Some Job".to_owned(),
            employer: ::std::default::Default::default(),
            compensation: ::std::default::Default::default(),
        });

    pub static kRanges: ::once_cell::sync::Lazy<::std::vec::Vec<crate::types::Range>> = ::once_cell::sync::Lazy::new(|| vec![
            crate::types::Range {
                min: 1,
                max: 2,
            },
            crate::types::Range {
                min: 5,
                max: 6,
            },
        ]);

    pub static internList: ::once_cell::sync::Lazy<::std::vec::Vec<crate::types::Internship>> = ::once_cell::sync::Lazy::new(|| vec![
            crate::types::Internship {
                weeks: 12,
                title: "Software Engineer".to_owned(),
                employer: ::std::option::Option::Some(crate::types::Company::INSTAGRAM),
                compensation: ::std::option::Option::Some(1200.0),
            },
            crate::types::Internship {
                weeks: 10,
                title: "Sales Intern".to_owned(),
                employer: ::std::option::Option::Some(crate::types::Company::FACEBOOK),
                compensation: ::std::option::Option::Some(1000.0),
            },
        ]);

    pub static pod_0: ::once_cell::sync::Lazy<crate::types::struct1> = ::once_cell::sync::Lazy::new(|| crate::types::struct1 {
            a: 1234567,
            b: "<uninitialized>".to_owned(),
        });

    pub static pod_s_0: ::once_cell::sync::Lazy<crate::types::struct1> = ::once_cell::sync::Lazy::new(|| crate::types::struct1 {
            a: 1234567,
            b: "<uninitialized>".to_owned(),
        });

    pub static pod_1: ::once_cell::sync::Lazy<crate::types::struct1> = ::once_cell::sync::Lazy::new(|| crate::types::struct1 {
            a: 10,
            b: "foo".to_owned(),
        });

    pub static pod_s_1: ::once_cell::sync::Lazy<crate::types::struct1> = ::once_cell::sync::Lazy::new(|| crate::types::struct1 {
            a: 10,
            b: "foo".to_owned(),
        });

    pub static pod_2: ::once_cell::sync::Lazy<crate::types::struct2> = ::once_cell::sync::Lazy::new(|| crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        });

    pub static pod_trailing_commas: ::once_cell::sync::Lazy<crate::types::struct2> = ::once_cell::sync::Lazy::new(|| crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        });

    pub static pod_s_2: ::once_cell::sync::Lazy<crate::types::struct2> = ::once_cell::sync::Lazy::new(|| crate::types::struct2 {
            a: 98,
            b: "gaz".to_owned(),
            c: crate::types::struct1 {
                a: 12,
                b: "bar".to_owned(),
            },
            d: vec![
                11,
                22,
                33,
            ],
        });

    pub static pod_3: ::once_cell::sync::Lazy<crate::types::struct3> = ::once_cell::sync::Lazy::new(|| crate::types::struct3 {
            a: "abc".to_owned(),
            b: 456,
            c: crate::types::struct2 {
                a: 888,
                b: ::std::default::Default::default(),
                c: crate::types::struct1 {
                    a: 1234567,
                    b: "gaz".to_owned(),
                },
                d: vec![
                    1,
                    2,
                    3,
                ],
            },
        });

    pub static pod_s_3: ::once_cell::sync::Lazy<crate::types::struct3> = ::once_cell::sync::Lazy::new(|| crate::types::struct3 {
            a: "abc".to_owned(),
            b: 456,
            c: crate::types::struct2 {
                a: 888,
                b: ::std::default::Default::default(),
                c: crate::types::struct1 {
                    a: 1234567,
                    b: "gaz".to_owned(),
                },
                d: vec![
                    1,
                    2,
                    3,
                ],
            },
        });

    pub static pod_4: ::once_cell::sync::Lazy<crate::types::struct4> = ::once_cell::sync::Lazy::new(|| crate::types::struct4 {
            a: 1234,
            b: ::std::option::Option::Some(0.333),
            c: ::std::option::Option::Some(25),
        });

    pub static u_1_1: ::once_cell::sync::Lazy<crate::types::union1> = ::once_cell::sync::Lazy::new(|| crate::types::union1::i(97));

    pub static u_1_2: ::once_cell::sync::Lazy<crate::types::union1> = ::once_cell::sync::Lazy::new(|| crate::types::union1::d(5.6));

    pub static u_1_3: ::once_cell::sync::Lazy<crate::types::union1> = ::once_cell::sync::Lazy::new(|| crate::types::union1::default());

    pub static u_2_1: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::i(51));

    pub static u_2_2: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::d(6.7));

    pub static u_2_3: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::s(crate::types::struct1 {
                a: 8,
                b: "abacabb".to_owned(),
            }));

    pub static u_2_4: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::u(crate::types::union1::i(43)));

    pub static u_2_5: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::u(crate::types::union1::d(9.8)));

    pub static u_2_6: ::once_cell::sync::Lazy<crate::types::union2> = ::once_cell::sync::Lazy::new(|| crate::types::union2::u(crate::types::union1::default()));

    pub const apostrophe: &::std::primitive::str = "'";

    pub const tripleApostrophe: &::std::primitive::str = "'''";

    pub const quotationMark: &::std::primitive::str = "\"";

    pub const backslash: &::std::primitive::str = "\\\\";

    pub const escaped_a: &::std::primitive::str = "\\x61";

    pub static char2ascii: ::once_cell::sync::Lazy<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>> = ::once_cell::sync::Lazy::new(|| {
            let mut map = ::std::collections::BTreeMap::new();
            map.insert("'".to_owned(), 39);
            map.insert("\"".to_owned(), 34);
            map.insert("\\\\".to_owned(), 92);
            map.insert("\\x61".to_owned(), 97);
            map
        });

    pub static escaped_strings: ::once_cell::sync::Lazy<::std::vec::Vec<::std::string::String>> = ::once_cell::sync::Lazy::new(|| vec![
            "\\x61".to_owned(),
            "\\xab".to_owned(),
            "\\x6a".to_owned(),
            "\\xa6".to_owned(),
            "\\x61yyy".to_owned(),
            "\\xabyyy".to_owned(),
            "\\x6ayyy".to_owned(),
            "\\xa6yyy".to_owned(),
            "zzz\\x61".to_owned(),
            "zzz\\xab".to_owned(),
            "zzz\\x6a".to_owned(),
            "zzz\\xa6".to_owned(),
            "zzz\\x61yyy".to_owned(),
            "zzz\\xabyyy".to_owned(),
            "zzz\\x6ayyy".to_owned(),
            "zzz\\xa6yyy".to_owned(),
        ]);

    pub const false_c: ::std::primitive::bool = false;

    pub const true_c: ::std::primitive::bool = true;

    pub const zero_byte: ::std::primitive::i8 = 0;

    pub const zero16: ::std::primitive::i16 = 0;

    pub const zero32: ::std::primitive::i32 = 0;

    pub const zero64: ::std::primitive::i64 = 0;

    pub const zero_dot_zero: ::std::primitive::f64 = 0.0;

    pub const empty_string: &::std::primitive::str = "";

    pub static empty_int_list: ::once_cell::sync::Lazy<::std::vec::Vec<::std::primitive::i32>> = ::once_cell::sync::Lazy::new(|| ::std::vec::Vec::new());

    pub static empty_string_list: ::once_cell::sync::Lazy<::std::vec::Vec<::std::string::String>> = ::once_cell::sync::Lazy::new(|| ::std::vec::Vec::new());

    pub static empty_int_set: ::once_cell::sync::Lazy<::std::collections::BTreeSet<::std::primitive::i32>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeSet::new());

    pub static empty_string_set: ::once_cell::sync::Lazy<::std::collections::BTreeSet<::std::string::String>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeSet::new());

    pub static empty_int_int_map: ::once_cell::sync::Lazy<::std::collections::BTreeMap<::std::primitive::i32, ::std::primitive::i32>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeMap::new());

    pub static empty_int_string_map: ::once_cell::sync::Lazy<::std::collections::BTreeMap<::std::primitive::i32, ::std::string::String>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeMap::new());

    pub static empty_string_int_map: ::once_cell::sync::Lazy<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeMap::new());

    pub static empty_string_string_map: ::once_cell::sync::Lazy<::std::collections::BTreeMap<::std::string::String, ::std::string::String>> = ::once_cell::sync::Lazy::new(|| ::std::collections::BTreeMap::new());
}

/// Thrift type definitions for `module`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type MyCompany = crate::types::Company;

    pub type MyStringIdentifier = ::std::string::String;

    pub type MyIntIdentifier = ::std::primitive::i32;

    pub type MyMapIdentifier = ::std::collections::BTreeMap<::std::string::String, ::std::string::String>;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Internship {
        pub weeks: ::std::primitive::i32,
        pub title: ::std::string::String,
        pub employer: ::std::option::Option<crate::types::Company>,
        pub compensation: ::std::option::Option<::std::primitive::f64>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Range {
        pub min: ::std::primitive::i32,
        pub max: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct struct1 {
        pub a: ::std::primitive::i32,
        pub b: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct2 {
        pub a: ::std::primitive::i32,
        pub b: ::std::string::String,
        pub c: crate::types::struct1,
        pub d: ::std::vec::Vec<::std::primitive::i32>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct3 {
        pub a: ::std::string::String,
        pub b: ::std::primitive::i32,
        pub c: crate::types::struct2,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct struct4 {
        pub a: ::std::primitive::i32,
        pub b: ::std::option::Option<::std::primitive::f64>,
        pub c: ::std::option::Option<::std::primitive::i8>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union1 {
        i(::std::primitive::i32),
        d(::std::primitive::f64),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq)]
    pub enum union2 {
        i(::std::primitive::i32),
        d(::std::primitive::f64),
        s(crate::types::struct1),
        u(crate::types::union1),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct EmptyEnum(pub ::std::primitive::i32);

    impl EmptyEnum {
    }

    impl ::fbthrift::ThriftEnum for EmptyEnum {
        fn enumerate() -> &'static [(EmptyEnum, &'static str)] {
            &[
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
            ]
        }

        fn variant_values() -> &'static [EmptyEnum] {
            &[
            ]
        }
    }

    impl ::std::default::Default for EmptyEnum {
        fn default() -> Self {
            EmptyEnum(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EmptyEnum> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EmptyEnum) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EmptyEnum {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for EmptyEnum {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EmptyEnum::{}", self)
        }
    }

    impl ::std::str::FromStr for EmptyEnum {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "EmptyEnum").map(EmptyEnum)
        }
    }

    impl ::fbthrift::GetTType for EmptyEnum {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EmptyEnum
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EmptyEnum::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct City(pub ::std::primitive::i32);

    impl City {
        pub const NYC: Self = City(0i32);
        pub const MPK: Self = City(1i32);
        pub const SEA: Self = City(2i32);
        pub const LON: Self = City(3i32);
    }

    impl ::fbthrift::ThriftEnum for City {
        fn enumerate() -> &'static [(City, &'static str)] {
            &[
                (City::NYC, "NYC"),
                (City::MPK, "MPK"),
                (City::SEA, "SEA"),
                (City::LON, "LON"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "NYC",
                "MPK",
                "SEA",
                "LON",
            ]
        }

        fn variant_values() -> &'static [City] {
            &[
                City::NYC,
                City::MPK,
                City::SEA,
                City::LON,
            ]
        }
    }

    impl ::std::default::Default for City {
        fn default() -> Self {
            City(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a City> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a City) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<City> for ::std::primitive::i32 {
        #[inline]
        fn from(x: City) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for City {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for City {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("NYC", 0),
                ("MPK", 1),
                ("SEA", 2),
                ("LON", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for City {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "City::{}", self)
        }
    }

    impl ::std::str::FromStr for City {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("LON", 3),
                ("MPK", 1),
                ("NYC", 0),
                ("SEA", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "City").map(City)
        }
    }

    impl ::fbthrift::GetTType for City {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for City
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for City
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(City::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Company(pub ::std::primitive::i32);

    impl Company {
        pub const FACEBOOK: Self = Company(0i32);
        pub const WHATSAPP: Self = Company(1i32);
        pub const OCULUS: Self = Company(2i32);
        pub const INSTAGRAM: Self = Company(3i32);
    }

    impl ::fbthrift::ThriftEnum for Company {
        fn enumerate() -> &'static [(Company, &'static str)] {
            &[
                (Company::FACEBOOK, "FACEBOOK"),
                (Company::WHATSAPP, "WHATSAPP"),
                (Company::OCULUS, "OCULUS"),
                (Company::INSTAGRAM, "INSTAGRAM"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "FACEBOOK",
                "WHATSAPP",
                "OCULUS",
                "INSTAGRAM",
            ]
        }

        fn variant_values() -> &'static [Company] {
            &[
                Company::FACEBOOK,
                Company::WHATSAPP,
                Company::OCULUS,
                Company::INSTAGRAM,
            ]
        }
    }

    impl ::std::default::Default for Company {
        fn default() -> Self {
            Company(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Company> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Company) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Company> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Company) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Company {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Company {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FACEBOOK", 0),
                ("WHATSAPP", 1),
                ("OCULUS", 2),
                ("INSTAGRAM", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for Company {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Company::{}", self)
        }
    }

    impl ::std::str::FromStr for Company {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FACEBOOK", 0),
                ("INSTAGRAM", 3),
                ("OCULUS", 2),
                ("WHATSAPP", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Company").map(Company)
        }
    }

    impl ::fbthrift::GetTType for Company {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Company
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Company
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Company::from(p.read_i32()?))
        }
    }





    impl ::std::default::Default for self::Internship {
        fn default() -> Self {
            Self {
                weeks: ::std::default::Default::default(),
                title: ::std::default::Default::default(),
                employer: ::std::option::Option::None,
                compensation: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Internship {}
    unsafe impl ::std::marker::Sync for self::Internship {}

    impl ::fbthrift::GetTType for self::Internship {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Internship
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Internship");
            p.write_field_begin("weeks", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.weeks, p);
            p.write_field_end();
            p.write_field_begin("title", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.title, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.employer {
                p.write_field_begin("employer", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.compensation {
                p.write_field_begin("compensation", ::fbthrift::TType::Double, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Internship
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("compensation", ::fbthrift::TType::Double, 4),
                ::fbthrift::Field::new("employer", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("title", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("weeks", ::fbthrift::TType::I32, 1),
            ];
            let mut field_weeks = ::std::option::Option::None;
            let mut field_title = ::std::option::Option::None;
            let mut field_employer = ::std::option::Option::None;
            let mut field_compensation = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_weeks = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_title = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_employer = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 4) => field_compensation = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                weeks: field_weeks.unwrap_or_default(),
                title: field_title.unwrap_or_default(),
                employer: field_employer,
                compensation: field_compensation,
            })
        }
    }


    impl ::std::default::Default for self::Range {
        fn default() -> Self {
            Self {
                min: ::std::default::Default::default(),
                max: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Range {}
    unsafe impl ::std::marker::Sync for self::Range {}

    impl ::fbthrift::GetTType for self::Range {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Range
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Range");
            p.write_field_begin("min", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.min, p);
            p.write_field_end();
            p.write_field_begin("max", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.max, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Range
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("max", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("min", ::fbthrift::TType::I32, 1),
            ];
            let mut field_min = ::std::option::Option::None;
            let mut field_max = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_min = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_max = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                min: field_min.unwrap_or_default(),
                max: field_max.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct1 {
        fn default() -> Self {
            Self {
                a: 1234567,
                b: "<uninitialized>".to_owned(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct1 {}
    unsafe impl ::std::marker::Sync for self::struct1 {}

    impl ::fbthrift::GetTType for self::struct1 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct1
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct1");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct1
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("a", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("b", ::fbthrift::TType::String, 2),
            ];
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_else(|| 1234567),
                b: field_b.unwrap_or_else(|| "<uninitialized>".to_owned()),
            })
        }
    }


    impl ::std::default::Default for self::struct2 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::default::Default::default(),
                c: ::std::default::Default::default(),
                d: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct2 {}
    unsafe impl ::std::marker::Sync for self::struct2 {}

    impl ::fbthrift::GetTType for self::struct2 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct2
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct2");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_begin("d", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.d, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct2
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("a", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("b", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("c", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("d", ::fbthrift::TType::List, 4),
            ];
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let mut field_d = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_d = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
                d: field_d.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct3 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::default::Default::default(),
                c: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct3 {}
    unsafe impl ::std::marker::Sync for self::struct3 {}

    impl ::fbthrift::GetTType for self::struct3 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct3
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct3");
            p.write_field_begin("a", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            p.write_field_begin("b", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.b, p);
            p.write_field_end();
            p.write_field_begin("c", ::fbthrift::TType::Struct, 3);
            ::fbthrift::Serialize::write(&self.c, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct3
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("a", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("b", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("c", ::fbthrift::TType::Struct, 3),
            ];
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b.unwrap_or_default(),
                c: field_c.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::struct4 {
        fn default() -> Self {
            Self {
                a: ::std::default::Default::default(),
                b: ::std::option::Option::None,
                c: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::struct4 {}
    unsafe impl ::std::marker::Sync for self::struct4 {}

    impl ::fbthrift::GetTType for self::struct4 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::struct4
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("struct4");
            p.write_field_begin("a", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.a, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.b {
                p.write_field_begin("b", ::fbthrift::TType::Double, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.c {
                p.write_field_begin("c", ::fbthrift::TType::Byte, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::struct4
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("a", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("b", ::fbthrift::TType::Double, 2),
                ::fbthrift::Field::new("c", ::fbthrift::TType::Byte, 3),
            ];
            let mut field_a = ::std::option::Option::None;
            let mut field_b = ::std::option::Option::None;
            let mut field_c = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_a = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 2) => field_b = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Byte, 3) => field_c = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                a: field_a.unwrap_or_default(),
                b: field_b,
                c: field_c,
            })
        }
    }



    impl ::std::default::Default for union1 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for union1 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for union1
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union1");
            match self {
                union1::i(inner) => {
                    p.write_field_begin("i", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::d(inner) => {
                    p.write_field_begin("d", ::fbthrift::TType::Double, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union1::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for union1
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("d", ::fbthrift::TType::Double, 2),
                ::fbthrift::Field::new("i", ::fbthrift::TType::I32, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union1::i(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union1::d(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union1",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }


    impl ::std::default::Default for union2 {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for union2 {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for union2
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("union2");
            match self {
                union2::i(inner) => {
                    p.write_field_begin("i", ::fbthrift::TType::I32, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::d(inner) => {
                    p.write_field_begin("d", ::fbthrift::TType::Double, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::s(inner) => {
                    p.write_field_begin("s", ::fbthrift::TType::Struct, 3);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::u(inner) => {
                    p.write_field_begin("u", ::fbthrift::TType::Struct, 4);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                union2::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for union2
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("d", ::fbthrift::TType::Double, 2),
                ::fbthrift::Field::new("i", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("s", ::fbthrift::TType::Struct, 3),
                ::fbthrift::Field::new("u", ::fbthrift::TType::Struct, 4),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::I32, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::i(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Double, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::d(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 3, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::s(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 4, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(union2::u(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "union2",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }
}

/// Error return types.
pub mod errors {
}
