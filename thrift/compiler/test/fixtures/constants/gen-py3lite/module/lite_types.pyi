#
# Autogenerated by Thrift
#
# DO NOT EDIT
#  @generated
#

import typing as _typing

import enum

import thrift.py3lite.types as _fbthrift_py3lite_types
import thrift.py3lite.exceptions as _fbthrift_py3lite_exceptions


class EmptyEnum(enum.Enum):
    pass


class City(enum.Enum):
    NYC: City = ...
    MPK: City = ...
    SEA: City = ...
    LON: City = ...


class Company(enum.Enum):
    FACEBOOK: Company = ...
    WHATSAPP: Company = ...
    OCULUS: Company = ...
    INSTAGRAM: Company = ...


class Internship(_fbthrift_py3lite_types.Struct):
    weeks: _typing.Final[_typing.Optional[int]] = ...
    title: _typing.Final[str] = ...
    employer: _typing.Final[_typing.Optional[Company]] = ...
    compensation: _typing.Final[_typing.Optional[float]] = ...
    school: _typing.Final[_typing.Optional[str]] = ...
    def __init__(
        self, *,
        weeks: _typing.Optional[int]=...,
        title: _typing.Optional[str]=...,
        employer: _typing.Optional[Company]=...,
        compensation: _typing.Optional[float]=...,
        school: _typing.Optional[str]=...
    ) -> None: ...

    def __call__(
        self, *,
        weeks: _typing.Optional[int]=...,
        title: _typing.Optional[str]=...,
        employer: _typing.Optional[Company]=...,
        compensation: _typing.Optional[float]=...,
        school: _typing.Optional[str]=...
    ) -> Internship: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int, str, Company, float, str]]]: ...


class Range(_fbthrift_py3lite_types.Struct):
    min: _typing.Final[_typing.Optional[int]] = ...
    max: _typing.Final[_typing.Optional[int]] = ...
    def __init__(
        self, *,
        min: _typing.Optional[int]=...,
        max: _typing.Optional[int]=...
    ) -> None: ...

    def __call__(
        self, *,
        min: _typing.Optional[int]=...,
        max: _typing.Optional[int]=...
    ) -> Range: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int, int]]]: ...


class struct1(_fbthrift_py3lite_types.Struct):
    a: _typing.Final[int] = ...
    b: _typing.Final[str] = ...
    def __init__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[str]=...
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[str]=...
    ) -> struct1: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int, str]]]: ...


class struct2(_fbthrift_py3lite_types.Struct):
    a: _typing.Final[int] = ...
    b: _typing.Final[str] = ...
    c: _typing.Final[struct1] = ...
    d: _typing.Final[_typing.Sequence[int]] = ...
    def __init__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[str]=...,
        c: _typing.Optional[struct1]=...,
        d: _typing.Optional[_typing.Sequence[int]]=...
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[str]=...,
        c: _typing.Optional[struct1]=...,
        d: _typing.Optional[_typing.Sequence[int]]=...
    ) -> struct2: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int, str, struct1, _typing.Sequence[int]]]]: ...


class struct3(_fbthrift_py3lite_types.Struct):
    a: _typing.Final[str] = ...
    b: _typing.Final[int] = ...
    c: _typing.Final[struct2] = ...
    def __init__(
        self, *,
        a: _typing.Optional[str]=...,
        b: _typing.Optional[int]=...,
        c: _typing.Optional[struct2]=...
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Optional[str]=...,
        b: _typing.Optional[int]=...,
        c: _typing.Optional[struct2]=...
    ) -> struct3: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, str, int, struct2]]]: ...


class struct4(_fbthrift_py3lite_types.Struct):
    a: _typing.Final[int] = ...
    b: _typing.Final[_typing.Optional[float]] = ...
    c: _typing.Final[_typing.Optional[int]] = ...
    def __init__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[float]=...,
        c: _typing.Optional[int]=...
    ) -> None: ...

    def __call__(
        self, *,
        a: _typing.Optional[int]=...,
        b: _typing.Optional[float]=...,
        c: _typing.Optional[int]=...
    ) -> struct4: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Union[None, int, float, int]]]: ...


class union1(_fbthrift_py3lite_types.Union):
    i: _typing.Final[int] = ...
    d: _typing.Final[float] = ...
    def __init__(
        self, *,
        i: _typing.Optional[int]=...,
        d: _typing.Optional[float]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: union1.Type = ...
        i: union1.Type = ...
        d: union1.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, int, float]) -> union1: ...
    value: _typing.Final[_typing.Union[None, int, float]]
    type: Type
    def get_type(self) -> Type:...


class union2(_fbthrift_py3lite_types.Union):
    i: _typing.Final[int] = ...
    d: _typing.Final[float] = ...
    s: _typing.Final[struct1] = ...
    u: _typing.Final[union1] = ...
    def __init__(
        self, *,
        i: _typing.Optional[int]=...,
        d: _typing.Optional[float]=...,
        s: _typing.Optional[struct1]=...,
        u: _typing.Optional[union1]=...
    ) -> None: ...


    class Type(enum.Enum):
        EMPTY: union2.Type = ...
        i: union2.Type = ...
        d: union2.Type = ...
        s: union2.Type = ...
        u: union2.Type = ...

    @classmethod
    def fromValue(cls, value: _typing.Union[None, int, float, struct1, union1]) -> union2: ...
    value: _typing.Final[_typing.Union[None, int, float, struct1, union1]]
    type: Type
    def get_type(self) -> Type:...


myInt: int = ...

name: str = ...

multi_line_string: str = ...

states: _typing.List[_typing.Mapping[str, int]] = ...

x: float = ...

y: float = ...

z: float = ...

zeroDoubleValue: float = ...

longDoubleValue: float = ...

my_company: Company = ...

foo: str = ...

bar: int = ...

mymap: _typing.Dict[str, str] = ...

instagram: Internship = ...

partial_const: Internship = ...

kRanges: _typing.List[Range] = ...

internList: _typing.List[Internship] = ...

pod_0: struct1 = ...

pod_s_0: struct1 = ...

pod_1: struct1 = ...

pod_s_1: struct1 = ...

pod_2: struct2 = ...

pod_trailing_commas: struct2 = ...

pod_s_2: struct2 = ...

pod_3: struct3 = ...

pod_s_3: struct3 = ...

pod_4: struct4 = ...

u_1_1: union1 = ...

u_1_2: union1 = ...

u_1_3: union1 = ...

u_2_1: union2 = ...

u_2_2: union2 = ...

u_2_3: union2 = ...

u_2_4: union2 = ...

u_2_5: union2 = ...

u_2_6: union2 = ...

apostrophe: str = ...

tripleApostrophe: str = ...

quotationMark: str = ...

backslash: str = ...

escaped_a: str = ...

char2ascii: _typing.Dict[str, int] = ...

escaped_strings: _typing.List[str] = ...

false_c: bool = ...

true_c: bool = ...

zero_byte: int = ...

zero16: int = ...

zero32: int = ...

zero64: int = ...

zero_dot_zero: float = ...

empty_string: str = ...

empty_int_list: _typing.List[int] = ...

empty_string_list: _typing.List[str] = ...

empty_int_set: _typing.Set[int] = ...

empty_string_set: _typing.Set[str] = ...

empty_int_int_map: _typing.Dict[int, int] = ...

empty_int_string_map: _typing.Dict[int, str] = ...

empty_string_int_map: _typing.Dict[str, int] = ...

empty_string_string_map: _typing.Dict[str, str] = ...

MyCompany = Company
MyStringIdentifier = str
MyIntIdentifier = int
MyMapIdentifier = dict
