#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
cimport thrift.py3.std_libcpp as std_libcpp

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class EmptyEnum(Enum):

cdef cEmptyEnum EmptyEnum_to_cpp(value):
class City(Enum):
    NYC = <int> (City__NYC)
    MPK = <int> (City__MPK)
    SEA = <int> (City__SEA)
    LON = <int> (City__LON)

cdef cCity City_to_cpp(value):
    if value == City.NYC:
        return City__NYC
    elif value == City.MPK:
        return City__MPK
    elif value == City.SEA:
        return City__SEA
    elif value == City.LON:
        return City__LON
class Company(Enum):
    FACEBOOK = <int> (Company__FACEBOOK)
    WHATSAPP = <int> (Company__WHATSAPP)
    OCULUS = <int> (Company__OCULUS)
    INSTAGRAM = <int> (Company__INSTAGRAM)

cdef cCompany Company_to_cpp(value):
    if value == Company.FACEBOOK:
        return Company__FACEBOOK
    elif value == Company.WHATSAPP:
        return Company__WHATSAPP
    elif value == Company.OCULUS:
        return Company__OCULUS
    elif value == Company.INSTAGRAM:
        return Company__INSTAGRAM


cdef class Internship(thrift.py3.types.Struct):

    def __init__(
        Internship self,
        weeks=None,
        title=None,
        employer=None
    ):
        self.c_Internship = make_shared[cInternship]()

        inst = self
        if weeks is not None:
            deref(inst.c_Internship).weeks = weeks
        if title is not None:
            deref(inst.c_Internship).title = title.encode('UTF-8')
            deref(inst.c_Internship).__isset.title = True

        if employer is not None:
            deref(inst.c_Internship).employer = Company_to_cpp(employer)
        
            deref(inst.c_Internship).__isset.employer = True


    def __call__(
        Internship self,
        weeks=NOTSET,
        title=NOTSET,
        employer=NOTSET
    ):
        changes = any((
            weeks is not NOTSET,

            title is not NOTSET,

            employer is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Internship>Internship.__new__(Internship)
        inst.c_Internship = make_shared[cInternship](deref(self.c_Internship))
        cdef Internship defaults = Internship_defaults

        # Convert None's to default value.
        if weeks is None:
            deref(inst.c_Internship).weeks = deref(defaults.c_Internship).weeks
        if weeks is NOTSET:
            weeks = None
        if title is None:
            deref(inst.c_Internship).title = deref(defaults.c_Internship).title
            deref(inst.c_Internship).__isset.title = False
        if title is NOTSET:
            title = None
        if employer is None:
            deref(inst.c_Internship).employer = deref(defaults.c_Internship).employer
            deref(inst.c_Internship).__isset.employer = False
        if employer is NOTSET:
            employer = None

        if weeks is not None:
            deref(inst.c_Internship).weeks = weeks
        if title is not None:
            deref(inst.c_Internship).title = title.encode('UTF-8')
            deref(inst.c_Internship).__isset.title = True

        if employer is not None:
            deref(inst.c_Internship).employer = Company_to_cpp(employer)
        
            deref(inst.c_Internship).__isset.employer = True

        return inst

    def __iter__(self):
        yield 'weeks', self.weeks
        yield 'title', self.title
        yield 'employer', self.employer

    def __bool__(self):
        return True or deref(self.c_Internship).__isset.title or deref(self.c_Internship).__isset.employer

    @staticmethod
    cdef create(shared_ptr[cInternship] c_Internship):
        inst = <Internship>Internship.__new__(Internship)
        inst.c_Internship = c_Internship
        return inst

    @property
    def weeks(self):

        return self.c_Internship.get().weeks

    @property
    def title(self):
        if not deref(self.c_Internship).__isset.title:
            return None

        return self.c_Internship.get().title.decode('UTF-8')

    @property
    def employer(self):
        if not deref(self.c_Internship).__isset.employer:
            return None

        cdef int value = <int> deref(self.c_Internship).employer
        try:
            return Company(value)
        except ValueError:
            return thrift.py3.types.BadEnum(Company, value)
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Internship) and
                isinstance(other, Internship)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cInternship cself = deref((<Internship>self).c_Internship)
        cdef cInternship cother = deref((<Internship>other).c_Internship)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Internship self):
        if not self.__hash:
            self.__hash = hash((
            self.weeks,
            self.title,
            self.employer,
            ))
        return self.__hash

    def __repr__(Internship self):
        return f'Internship(weeks={repr(self.weeks)}, title={repr(self.title)}, employer={repr(self.employer)})'


Internship_defaults = Internship()


cdef class UnEnumStruct(thrift.py3.types.Struct):

    def __init__(
        UnEnumStruct self,
        city=None
    ):
        self.c_UnEnumStruct = make_shared[cUnEnumStruct]()

        inst = self
        if city is not None:
            deref(inst.c_UnEnumStruct).city = City_to_cpp(city)
        
            deref(inst.c_UnEnumStruct).__isset.city = True


    def __call__(
        UnEnumStruct self,
        city=NOTSET
    ):
        changes = any((
            city is not NOTSET,
        ))

        if not changes:
            return self

        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst.c_UnEnumStruct = make_shared[cUnEnumStruct](deref(self.c_UnEnumStruct))
        cdef UnEnumStruct defaults = UnEnumStruct_defaults

        # Convert None's to default value.
        if city is None:
            deref(inst.c_UnEnumStruct).city = deref(defaults.c_UnEnumStruct).city
            deref(inst.c_UnEnumStruct).__isset.city = False
        if city is NOTSET:
            city = None

        if city is not None:
            deref(inst.c_UnEnumStruct).city = City_to_cpp(city)
        
            deref(inst.c_UnEnumStruct).__isset.city = True

        return inst

    def __iter__(self):
        yield 'city', self.city

    def __bool__(self):
        return deref(self.c_UnEnumStruct).__isset.city

    @staticmethod
    cdef create(shared_ptr[cUnEnumStruct] c_UnEnumStruct):
        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst.c_UnEnumStruct = c_UnEnumStruct
        return inst

    @property
    def city(self):

        cdef int value = <int> deref(self.c_UnEnumStruct).city
        try:
            return City(value)
        except ValueError:
            return thrift.py3.types.BadEnum(City, value)
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, UnEnumStruct) and
                isinstance(other, UnEnumStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cUnEnumStruct cself = deref((<UnEnumStruct>self).c_UnEnumStruct)
        cdef cUnEnumStruct cother = deref((<UnEnumStruct>other).c_UnEnumStruct)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(UnEnumStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.city,
            ))
        return self.__hash

    def __repr__(UnEnumStruct self):
        return f'UnEnumStruct(city={repr(self.city)})'


UnEnumStruct_defaults = UnEnumStruct()


cdef class Range(thrift.py3.types.Struct):

    def __init__(
        Range self,
        min=None,
        max=None
    ):
        self.c_Range = make_shared[cRange]()

        inst = self
        if min is not None:
            deref(inst.c_Range).min = min
        if max is not None:
            deref(inst.c_Range).max = max

    def __call__(
        Range self,
        min=NOTSET,
        max=NOTSET
    ):
        changes = any((
            min is not NOTSET,

            max is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Range>Range.__new__(Range)
        inst.c_Range = make_shared[cRange](deref(self.c_Range))
        cdef Range defaults = Range_defaults

        # Convert None's to default value.
        if min is None:
            deref(inst.c_Range).min = deref(defaults.c_Range).min
        if min is NOTSET:
            min = None
        if max is None:
            deref(inst.c_Range).max = deref(defaults.c_Range).max
        if max is NOTSET:
            max = None

        if min is not None:
            deref(inst.c_Range).min = min
        if max is not None:
            deref(inst.c_Range).max = max
        return inst

    def __iter__(self):
        yield 'min', self.min
        yield 'max', self.max

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cRange] c_Range):
        inst = <Range>Range.__new__(Range)
        inst.c_Range = c_Range
        return inst

    @property
    def min(self):

        return self.c_Range.get().min

    @property
    def max(self):

        return self.c_Range.get().max


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Range) and
                isinstance(other, Range)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cRange cself = deref((<Range>self).c_Range)
        cdef cRange cother = deref((<Range>other).c_Range)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Range self):
        if not self.__hash:
            self.__hash = hash((
            self.min,
            self.max,
            ))
        return self.__hash

    def __repr__(Range self):
        return f'Range(min={repr(self.min)}, max={repr(self.max)})'


Range_defaults = Range()


cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._map = (<Map__string_i32> items)._map
        else:
          self._map = make_shared[cmap[string,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,int32_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class List__Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_i32):
            self._vector = (<List__Map__string_i32> items)._vector
        else:
          self._vector = make_shared[vector[cmap[string,int32_t]]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(cmap[string,int32_t](deref(Map__string_i32(item)._map.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[string,int32_t]]] c_items):
        inst = <List__Map__string_i32>List__Map__string_i32.__new__(List__Map__string_i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cmap[string,int32_t] citem = (
            deref(self._vector.get())[index])
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._map.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for citem in deref(self._vector):
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._vector.get())
        cdef vector[cmap[string,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._map.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._vector.get())
        cdef vector[cmap[string,int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._map.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_i32)

cdef class List__Range:
    def __init__(self, items=None):
        if isinstance(items, List__Range):
            self._vector = (<List__Range> items)._vector
        else:
          self._vector = make_shared[vector[cRange]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref((<Range> item).c_Range))

    @staticmethod
    cdef create(
            shared_ptr[vector[cRange]] c_items):
        inst = <List__Range>List__Range.__new__(List__Range)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cRange citem = (
            deref(self._vector.get())[index])
        return Range.create(make_shared[cRange](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cRange citem = deref((<Range> item).c_Range)
        cdef vector[cRange] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        for citem in deref(self._vector):
            yield Range.create(make_shared[cRange](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        cdef vector[cRange] vec = deref(
            self._vector.get())
        cdef vector[cRange].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Range.create(make_shared[cRange](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cRange citem = deref((<Range> item).c_Range)
        cdef vector[cRange] vec = deref(self._vector.get())
        cdef vector[cRange].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cRange citem = deref((<Range> item).c_Range)
        cdef vector[cRange] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Range)

cdef class List__Internship:
    def __init__(self, items=None):
        if isinstance(items, List__Internship):
            self._vector = (<List__Internship> items)._vector
        else:
          self._vector = make_shared[vector[cInternship]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(deref((<Internship> item).c_Internship))

    @staticmethod
    cdef create(
            shared_ptr[vector[cInternship]] c_items):
        inst = <List__Internship>List__Internship.__new__(List__Internship)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cInternship citem = (
            deref(self._vector.get())[index])
        return Internship.create(make_shared[cInternship](citem))

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cInternship citem = deref((<Internship> item).c_Internship)
        cdef vector[cInternship] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        for citem in deref(self._vector):
            yield Internship.create(make_shared[cInternship](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        cdef vector[cInternship] vec = deref(
            self._vector.get())
        cdef vector[cInternship].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Internship.create(make_shared[cInternship](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cInternship citem = deref((<Internship> item).c_Internship)
        cdef vector[cInternship] vec = deref(self._vector.get())
        cdef vector[cInternship].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cInternship citem = deref((<Internship> item).c_Internship)
        cdef vector[cInternship] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Internship)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._vector = (<List__string> items)._vector
        else:
          self._vector = make_shared[vector[string]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item.encode('UTF-8'))

    @staticmethod
    cdef create(
            shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef string citem = (
            deref(self._vector.get())[index])
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._vector):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._vector.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._vector = (<List__i32> items)._vector
        else:
          self._vector = make_shared[vector[int32_t]]()
          if items:
              for item in items:
                  deref(self._vector).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef int32_t citem = (
            deref(self._vector.get())[index])
        return citem

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._vector):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._vector.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._set = (<Set__i32> items)._set
        else:
          self._set = make_shared[cset[int32_t]]()
          if items:
              for item in items:
                  deref(self._set).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._set)
            cother = deref((<Set__i32> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._set):
            if deref((<Set__i32> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._set):
            if deref((<Set__i32> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._set = (<Set__string> items)._set
        else:
          self._set = make_shared[cset[string]]()
          if items:
              for item in items:
                  deref(self._set).insert(item.encode('UTF-8'))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._set = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._set).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._set):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._set)
            cother = deref((<Set__string> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._set):
            if deref((<Set__string> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._set):
            if deref((<Set__string> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._map = (<Map__i32_i32> items)._map
        else:
          self._map = make_shared[cmap[int32_t,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[int32_t,int32_t](
                          key,
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_string):
            self._map = (<Map__i32_string> items)._map
        else:
          self._map = make_shared[cmap[int32_t,string]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[int32_t,string](
                          key,
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,string]] c_items):
        inst = <Map__i32_string>Map__i32_string.__new__(Map__i32_string)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._map):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(Map__i32_string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._map = (<Map__string_string> items)._map
        else:
          self._map = make_shared[cmap[string,string]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[string,string](
                          key.encode('UTF-8'),
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._map):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)


myInt = 1337
name = cname().decode('UTF-8')
states = List__Map__string_i32.create(make_shared[vector[cmap[string,int32_t]]](cstates()))
x = 1.0
y = 1000000.0
z = 1000000000.0
instagram = Internship.create(
    make_shared[cInternship](cinstagram()))
kRanges = List__Range.create(make_shared[vector[cRange]](ckRanges()))
internList = List__Internship.create(make_shared[vector[cInternship]](cinternList()))
apostrophe = capostrophe().decode('UTF-8')
tripleApostrophe = ctripleApostrophe().decode('UTF-8')
quotationMark = cquotationMark().decode('UTF-8')
backslash = cbackslash().decode('UTF-8')
escaped_a = cescaped_a().decode('UTF-8')
char2ascii = Map__string_i32.create(make_shared[cmap[string,int32_t]](cchar2ascii()))
escaped_strings = List__string.create(make_shared[vector[string]](cescaped_strings()))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0.0
empty_string = cempty_string().decode('UTF-8')
empty_int_list = List__i32.create(make_shared[vector[int32_t]](cempty_int_list()))
empty_string_list = List__string.create(make_shared[vector[string]](cempty_string_list()))
empty_int_set = Set__i32.create(make_shared[cset[int32_t]](cempty_int_set()))
empty_string_set = Set__string.create(make_shared[cset[string]](cempty_string_set()))
empty_int_int_map = Map__i32_i32.create(make_shared[cmap[int32_t,int32_t]](cempty_int_int_map()))
empty_int_string_map = Map__i32_string.create(make_shared[cmap[int32_t,string]](cempty_int_string_map()))
empty_string_int_map = Map__string_i32.create(make_shared[cmap[string,int32_t]](cempty_string_int_map()))
empty_string_string_map = Map__string_string.create(make_shared[cmap[string,string]](cempty_string_string_map()))
