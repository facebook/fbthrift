#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins


class EmptyEnum(__enum.Enum):

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cEmptyEnum EmptyEnum_to_cpp(value):
    cdef int cvalue = value.value
    pass
class City(__enum.Enum):
    NYC = 0
    MPK = 1
    SEA = 2
    LON = 3

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cCity City_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return City__NYC
    elif cvalue == 1:
        return City__MPK
    elif cvalue == 2:
        return City__SEA
    elif cvalue == 3:
        return City__LON
class Company(__enum.Enum):
    FACEBOOK = 0
    WHATSAPP = 1
    OCULUS = 2
    INSTAGRAM = 3

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cCompany Company_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return Company__FACEBOOK
    elif cvalue == 1:
        return Company__WHATSAPP
    elif cvalue == 2:
        return Company__OCULUS
    elif cvalue == 3:
        return Company__INSTAGRAM


cdef cInternship _Internship_defaults = cInternship()

cdef class Internship(thrift.py3.types.Struct):

    def __init__(
        Internship self, *,
        weeks,
        str title=None,
        employer=None
    ):
        if weeks is not None:
            if not isinstance(weeks, int):
                raise TypeError(f'weeks is not a { int !r}.')
            <int32_t> weeks

        if employer is not None:
            if not isinstance(employer, Company):
                raise TypeError(f'field employer value: { employer !r} is not of the enum type { Company }.')

        self._cpp_obj = move(Internship._make_instance(
          NULL,
          weeks,
          title,
          employer,
        ))

    def __call__(
        Internship self,
        weeks=__NOTSET,
        title=__NOTSET,
        employer=__NOTSET
    ):
        changes = any((
            weeks is not __NOTSET,

            title is not __NOTSET,

            employer is not __NOTSET,
        ))

        if not changes:
            return self

        if weeks is None:
            raise TypeError('field weeks is required and has no default, it can not be unset')
        if None is not weeks is not __NOTSET:
            if not isinstance(weeks, int):
                raise TypeError(f'weeks is not a { int !r}.')
            <int32_t> weeks

        if None is not title is not __NOTSET:
            if not isinstance(title, str):
                raise TypeError(f'title is not a { str !r}.')

        if None is not employer is not __NOTSET:
            if not isinstance(employer, Company):
                raise TypeError(f'field employer value: { employer !r} is not of the enum type { Company }.')

        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = move(Internship._make_instance(
          self._cpp_obj.get(),
          weeks,
          title,
          employer,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cInternship] _make_instance(
        cInternship* base_instance,
        object weeks,
        object title,
        object employer
    ) except *:
        cdef unique_ptr[cInternship] c_inst
        if base_instance:
            c_inst = make_unique[cInternship](deref(base_instance))
        else:
            c_inst = make_unique[cInternship]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if weeks is None:
                pass
            elif weeks is __NOTSET:
                weeks = None

            if title is None:
                deref(c_inst).title = _Internship_defaults.title
                deref(c_inst).__isset.title = False
                pass
            elif title is __NOTSET:
                title = None

            if employer is None:
                deref(c_inst).__isset.employer = False
                pass
            elif employer is __NOTSET:
                employer = None

        if weeks is not None:
            deref(c_inst).weeks = weeks
        if title is not None:
            deref(c_inst).title = title.encode('UTF-8')
            deref(c_inst).__isset.title = True
        if employer is not None:
            deref(c_inst).employer = Company_to_cpp(employer)
            deref(c_inst).__isset.employer = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'weeks', self.weeks
        yield 'title', self.title
        yield 'employer', self.employer

    def __bool__(self):
        return True or True or deref(self._cpp_obj).__isset.employer

    @staticmethod
    cdef create(shared_ptr[cInternship] cpp_obj):
        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def weeks(self):

        return self._cpp_obj.get().weeks

    @property
    def title(self):

        return (<bytes>self._cpp_obj.get().title).decode('UTF-8')

    @property
    def employer(self):
        if not deref(self._cpp_obj).__isset.employer:
            return None

        return translate_cpp_enum_to_python(Company, <int>(deref(self._cpp_obj).employer))


    def __hash__(Internship self):
        if not self.__hash:
            self.__hash = hash((
            self.weeks,
            self.title,
            self.employer,
            ))
        return self.__hash

    def __repr__(Internship self):
        return f'Internship(weeks={repr(self.weeks)}, title={repr(self.title)}, employer={repr(self.employer)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Internship) and
                isinstance(other, Internship)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cInternship cself = deref((<Internship>self)._cpp_obj)
        cdef cInternship cother = deref((<Internship>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(Internship self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Internship self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cInternship]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Internship, serialize(self)))


cdef cUnEnumStruct _UnEnumStruct_defaults = cUnEnumStruct()

cdef class UnEnumStruct(thrift.py3.types.Struct):

    def __init__(
        UnEnumStruct self, *,
        city=None
    ):
        if city is not None:
            if not isinstance(city, City):
                raise TypeError(f'field city value: { city !r} is not of the enum type { City }.')

        self._cpp_obj = move(UnEnumStruct._make_instance(
          NULL,
          city,
        ))

    def __call__(
        UnEnumStruct self,
        city=__NOTSET
    ):
        changes = any((
            city is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not city is not __NOTSET:
            if not isinstance(city, City):
                raise TypeError(f'field city value: { city !r} is not of the enum type { City }.')

        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = move(UnEnumStruct._make_instance(
          self._cpp_obj.get(),
          city,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cUnEnumStruct] _make_instance(
        cUnEnumStruct* base_instance,
        object city
    ) except *:
        cdef unique_ptr[cUnEnumStruct] c_inst
        if base_instance:
            c_inst = make_unique[cUnEnumStruct](deref(base_instance))
        else:
            c_inst = make_unique[cUnEnumStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if city is None:
                deref(c_inst).city = _UnEnumStruct_defaults.city
                deref(c_inst).__isset.city = False
                pass
            elif city is __NOTSET:
                city = None

        if city is not None:
            deref(c_inst).city = City_to_cpp(city)
            deref(c_inst).__isset.city = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'city', self.city

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cUnEnumStruct] cpp_obj):
        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def city(self):

        return translate_cpp_enum_to_python(City, <int>(deref(self._cpp_obj).city))


    def __hash__(UnEnumStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.city,
            ))
        return self.__hash

    def __repr__(UnEnumStruct self):
        return f'UnEnumStruct(city={repr(self.city)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, UnEnumStruct) and
                isinstance(other, UnEnumStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cUnEnumStruct cself = deref((<UnEnumStruct>self)._cpp_obj)
        cdef cUnEnumStruct cother = deref((<UnEnumStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(UnEnumStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(UnEnumStruct self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cUnEnumStruct]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (UnEnumStruct, serialize(self)))


cdef cRange _Range_defaults = cRange()

cdef class Range(thrift.py3.types.Struct):

    def __init__(
        Range self, *,
        min,
        max
    ):
        if min is not None:
            if not isinstance(min, int):
                raise TypeError(f'min is not a { int !r}.')
            <int32_t> min

        if max is not None:
            if not isinstance(max, int):
                raise TypeError(f'max is not a { int !r}.')
            <int32_t> max

        self._cpp_obj = move(Range._make_instance(
          NULL,
          min,
          max,
        ))

    def __call__(
        Range self,
        min=__NOTSET,
        max=__NOTSET
    ):
        changes = any((
            min is not __NOTSET,

            max is not __NOTSET,
        ))

        if not changes:
            return self

        if min is None:
            raise TypeError('field min is required and has no default, it can not be unset')
        if None is not min is not __NOTSET:
            if not isinstance(min, int):
                raise TypeError(f'min is not a { int !r}.')
            <int32_t> min

        if max is None:
            raise TypeError('field max is required and has no default, it can not be unset')
        if None is not max is not __NOTSET:
            if not isinstance(max, int):
                raise TypeError(f'max is not a { int !r}.')
            <int32_t> max

        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = move(Range._make_instance(
          self._cpp_obj.get(),
          min,
          max,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cRange] _make_instance(
        cRange* base_instance,
        object min,
        object max
    ) except *:
        cdef unique_ptr[cRange] c_inst
        if base_instance:
            c_inst = make_unique[cRange](deref(base_instance))
        else:
            c_inst = make_unique[cRange]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if min is None:
                pass
            elif min is __NOTSET:
                min = None

            if max is None:
                pass
            elif max is __NOTSET:
                max = None

        if min is not None:
            deref(c_inst).min = min
        if max is not None:
            deref(c_inst).max = max
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'min', self.min
        yield 'max', self.max

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cRange] cpp_obj):
        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def min(self):

        return self._cpp_obj.get().min

    @property
    def max(self):

        return self._cpp_obj.get().max


    def __hash__(Range self):
        if not self.__hash:
            self.__hash = hash((
            self.min,
            self.max,
            ))
        return self.__hash

    def __repr__(Range self):
        return f'Range(min={repr(self.min)}, max={repr(self.max)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Range) and
                isinstance(other, Range)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cRange cself = deref((<Range>self)._cpp_obj)
        cdef cRange cother = deref((<Range>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(Range self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Range self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cRange]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Range, serialize(self)))


cdef cstruct1 _struct1_defaults = cstruct1()

cdef class struct1(thrift.py3.types.Struct):

    def __init__(
        struct1 self, *,
        a=None,
        str b=None
    ):
        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            <int32_t> a

        self._cpp_obj = move(struct1._make_instance(
          NULL,
          a,
          b,
        ))

    def __call__(
        struct1 self,
        a=__NOTSET,
        b=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            <int32_t> a

        if None is not b is not __NOTSET:
            if not isinstance(b, str):
                raise TypeError(f'b is not a { str !r}.')

        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = move(struct1._make_instance(
          self._cpp_obj.get(),
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct1] _make_instance(
        cstruct1* base_instance,
        object a,
        object b
    ) except *:
        cdef unique_ptr[cstruct1] c_inst
        if base_instance:
            c_inst = make_unique[cstruct1](deref(base_instance))
        else:
            c_inst = make_unique[cstruct1]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct1_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct1_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cstruct1] cpp_obj):
        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return self._cpp_obj.get().a

    @property
    def b(self):

        return (<bytes>self._cpp_obj.get().b).decode('UTF-8')


    def __hash__(struct1 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(struct1 self):
        return f'struct1(a={repr(self.a)}, b={repr(self.b)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct1) and
                isinstance(other, struct1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct1 cself = deref((<struct1>self)._cpp_obj)
        cdef cstruct1 cother = deref((<struct1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct1 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct1 self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct1]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct1, serialize(self)))


cdef cstruct2 _struct2_defaults = cstruct2()

cdef class struct2(thrift.py3.types.Struct):

    def __init__(
        struct2 self, *,
        a=None,
        str b=None,
        struct1 c=None,
        d=None
    ):
        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            <int32_t> a

        self._cpp_obj = move(struct2._make_instance(
          NULL,
          a,
          b,
          c,
          d,
        ))

    def __call__(
        struct2 self,
        a=__NOTSET,
        b=__NOTSET,
        c=__NOTSET,
        d=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,

            c is not __NOTSET,

            d is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            <int32_t> a

        if None is not b is not __NOTSET:
            if not isinstance(b, str):
                raise TypeError(f'b is not a { str !r}.')

        if None is not c is not __NOTSET:
            if not isinstance(c, struct1):
                raise TypeError(f'c is not a { struct1 !r}.')

        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = move(struct2._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
          d,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct2] _make_instance(
        cstruct2* base_instance,
        object a,
        object b,
        object c,
        object d
    ) except *:
        cdef unique_ptr[cstruct2] c_inst
        if base_instance:
            c_inst = make_unique[cstruct2](deref(base_instance))
        else:
            c_inst = make_unique[cstruct2]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct2_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct2_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct2_defaults.c
                deref(c_inst).__isset.c = False
                pass
            elif c is __NOTSET:
                c = None

            if d is None:
                deref(c_inst).d = _struct2_defaults.d
                deref(c_inst).__isset.d = False
                pass
            elif d is __NOTSET:
                d = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True
        if c is not None:
            deref(c_inst).c = deref((<struct1?> c)._cpp_obj)
            deref(c_inst).__isset.c = True
        if d is not None:
            deref(c_inst).d = deref(List__i32(d)._cpp_obj)
            deref(c_inst).__isset.d = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c
        yield 'd', self.d

    def __bool__(self):
        return True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cstruct2] cpp_obj):
        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return self._cpp_obj.get().a

    @property
    def b(self):

        return (<bytes>self._cpp_obj.get().b).decode('UTF-8')

    @property
    def c(self):

        if self.__c is None:
            self.__c = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).c))
        return self.__c

    @property
    def d(self):

        if self.__d is None:
            self.__d = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).d))
        return self.__d


    def __hash__(struct2 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            self.d,
            ))
        return self.__hash

    def __repr__(struct2 self):
        return f'struct2(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)}, d={repr(self.d)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct2) and
                isinstance(other, struct2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct2 cself = deref((<struct2>self)._cpp_obj)
        cdef cstruct2 cother = deref((<struct2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct2 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct2 self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct2]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct2, serialize(self)))


cdef cstruct3 _struct3_defaults = cstruct3()

cdef class struct3(thrift.py3.types.Struct):

    def __init__(
        struct3 self, *,
        str a=None,
        b=None,
        struct2 c=None
    ):
        if b is not None:
            if not isinstance(b, int):
                raise TypeError(f'b is not a { int !r}.')
            <int32_t> b

        self._cpp_obj = move(struct3._make_instance(
          NULL,
          a,
          b,
          c,
        ))

    def __call__(
        struct3 self,
        a=__NOTSET,
        b=__NOTSET,
        c=__NOTSET
    ):
        changes = any((
            a is not __NOTSET,

            b is not __NOTSET,

            c is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not a is not __NOTSET:
            if not isinstance(a, str):
                raise TypeError(f'a is not a { str !r}.')

        if None is not b is not __NOTSET:
            if not isinstance(b, int):
                raise TypeError(f'b is not a { int !r}.')
            <int32_t> b

        if None is not c is not __NOTSET:
            if not isinstance(c, struct2):
                raise TypeError(f'c is not a { struct2 !r}.')

        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = move(struct3._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct3] _make_instance(
        cstruct3* base_instance,
        object a,
        object b,
        object c
    ) except *:
        cdef unique_ptr[cstruct3] c_inst
        if base_instance:
            c_inst = make_unique[cstruct3](deref(base_instance))
        else:
            c_inst = make_unique[cstruct3]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if a is None:
                deref(c_inst).a = _struct3_defaults.a
                deref(c_inst).__isset.a = False
                pass
            elif a is __NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct3_defaults.b
                deref(c_inst).__isset.b = False
                pass
            elif b is __NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct3_defaults.c
                deref(c_inst).__isset.c = False
                pass
            elif c is __NOTSET:
                c = None

        if a is not None:
            deref(c_inst).a = a.encode('UTF-8')
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b
            deref(c_inst).__isset.b = True
        if c is not None:
            deref(c_inst).c = deref((<struct2?> c)._cpp_obj)
            deref(c_inst).__isset.c = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c

    def __bool__(self):
        return True or True or True

    @staticmethod
    cdef create(shared_ptr[cstruct3] cpp_obj):
        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):

        return (<bytes>self._cpp_obj.get().a).decode('UTF-8')

    @property
    def b(self):

        return self._cpp_obj.get().b

    @property
    def c(self):

        if self.__c is None:
            self.__c = struct2.create(make_shared[cstruct2](deref(self._cpp_obj).c))
        return self.__c


    def __hash__(struct3 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            ))
        return self.__hash

    def __repr__(struct3 self):
        return f'struct3(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct3) and
                isinstance(other, struct3)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct3 cself = deref((<struct3>self)._cpp_obj)
        cdef cstruct3 cother = deref((<struct3>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct3 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct3 self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cstruct3]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct3, serialize(self)))


class __union1Type(__enum.Enum):
    EMPTY = <int>cunion1__type___EMPTY__
    i = <int>cunion1__type_i
    d = <int>cunion1__type_d


cdef class union1(thrift.py3.types.Union):
    Type = __union1Type

    def __init__(
        self, *,
        i=None,
        d=None
    ):
        if i is not None:
            if not isinstance(i, int):
                raise TypeError(f'i is not a { int !r}.')
            <int32_t> i

        if d is not None:
            if not isinstance(d, (float, int)):
                raise TypeError(f'd is not a { float !r}.')

        self._cpp_obj = move(union1._make_instance(
          NULL,
          i,
          d,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return union1()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <int32_t> value
                    return union1(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, pbool):
                try:
                    return union1(d=value)
                except OverflowError:
                    pass
        if isinstance(value, (float, int)):
            try:
                <double> value
                return union1(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cunion1] _make_instance(
        cunion1* base_instance,
        i,
        d
    ) except *:
        cdef unique_ptr[cunion1] c_inst = make_unique[cunion1]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type != union1.Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion1] cpp_obj):
        inst = <union1>union1.__new__(union1)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.type != union1.Type.i:
            raise TypeError(f'Union contains a value of type {self.type.name}, not i')
        return self.value

    @property
    def d(self):
        if self.type != union1.Type.d:
            raise TypeError(f'Union contains a value of type {self.type.name}, not d')
        return self.value


    def __hash__(union1 self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(union1 self):
        return f'union1(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(union1 self):
        self.type = union1.Type(<int>(deref(self._cpp_obj).getType()))
        if self.type == union1.Type.EMPTY:
            self.value = None
        elif self.type == union1.Type.i:
            self.value = deref(self._cpp_obj).get_i()
        elif self.type == union1.Type.d:
            self.value = deref(self._cpp_obj).get_d()

    def get_type(union1 self):
        return self.type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union1) and
                isinstance(other, union1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion1 cself = deref((<union1>self)._cpp_obj)
        cdef cunion1 cother = deref((<union1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(union1 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(union1 self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cunion1]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union1, serialize(self)))


class __union2Type(__enum.Enum):
    EMPTY = <int>cunion2__type___EMPTY__
    i = <int>cunion2__type_i
    d = <int>cunion2__type_d
    s = <int>cunion2__type_s
    u = <int>cunion2__type_u


cdef class union2(thrift.py3.types.Union):
    Type = __union2Type

    def __init__(
        self, *,
        i=None,
        d=None,
        struct1 s=None,
        union1 u=None
    ):
        if i is not None:
            if not isinstance(i, int):
                raise TypeError(f'i is not a { int !r}.')
            <int32_t> i

        if d is not None:
            if not isinstance(d, (float, int)):
                raise TypeError(f'd is not a { float !r}.')

        self._cpp_obj = move(union2._make_instance(
          NULL,
          i,
          d,
          s,
          u,
        ))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return union2()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <int32_t> value
                    return union2(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, pbool):
                try:
                    return union2(d=value)
                except OverflowError:
                    pass
        if isinstance(value, struct1):
            return union2(s=value)
        if isinstance(value, union1):
            return union2(u=value)
        if isinstance(value, (float, int)):
            try:
                <double> value
                return union2(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cunion2] _make_instance(
        cunion2* base_instance,
        i,
        d,
        s,
        u
    ) except *:
        cdef unique_ptr[cunion2] c_inst = make_unique[cunion2]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        if s is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_s(deref((<struct1?> s)._cpp_obj))
            any_set = True
        if u is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_u(deref((<union1?> u)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.type != union2.Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion2] cpp_obj):
        inst = <union2>union2.__new__(union2)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.type != union2.Type.i:
            raise TypeError(f'Union contains a value of type {self.type.name}, not i')
        return self.value

    @property
    def d(self):
        if self.type != union2.Type.d:
            raise TypeError(f'Union contains a value of type {self.type.name}, not d')
        return self.value

    @property
    def s(self):
        if self.type != union2.Type.s:
            raise TypeError(f'Union contains a value of type {self.type.name}, not s')
        return self.value

    @property
    def u(self):
        if self.type != union2.Type.u:
            raise TypeError(f'Union contains a value of type {self.type.name}, not u')
        return self.value


    def __hash__(union2 self):
        if not self.__hash:
            self.__hash = hash((
                self.type,
                self.value,
            ))
        return self.__hash

    def __repr__(union2 self):
        return f'union2(type={self.type.name}, value={self.value!r})'

    cdef _load_cache(union2 self):
        self.type = union2.Type(<int>(deref(self._cpp_obj).getType()))
        if self.type == union2.Type.EMPTY:
            self.value = None
        elif self.type == union2.Type.i:
            self.value = deref(self._cpp_obj).get_i()
        elif self.type == union2.Type.d:
            self.value = deref(self._cpp_obj).get_d()
        elif self.type == union2.Type.s:
            self.value = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).get_s()))
        elif self.type == union2.Type.u:
            self.value = union1.create(make_shared[cunion1](deref(self._cpp_obj).get_u()))

    def get_type(union2 self):
        return self.type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union2) and
                isinstance(other, union2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion2 cself = deref((<union2>self)._cpp_obj)
        cdef cunion2 cother = deref((<union2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(union2 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(union2 self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cunion2]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union2, serialize(self)))


cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int32_t]] c_inst = make_unique[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item

                deref(c_inst).insert(cpair[string,int32_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class List__Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_i32):
            self._cpp_obj = (<List__Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,int32_t]]] c_items):
        inst = <List__Map__string_i32>List__Map__string_i32.__new__(List__Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[string,int32_t]]] c_inst = make_unique[vector[cmap[string,int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)
                deref(c_inst).push_back(cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,int32_t]]] c_inst
        cdef cmap[string,int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Map__string_i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            return False
        if not isinstance(item, Map__string_i32):
            return False
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__string_i32):
            raise err
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cmap[string,int32_t]].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__string_i32):
                item = Map__string_i32(item)
        except Exception:
            return 0
        if not isinstance(item, Map__string_i32):
            return 0
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_i32)

cdef class List__Range:
    def __init__(self, items=None):
        if isinstance(items, List__Range):
            self._cpp_obj = (<List__Range> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Range._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cRange]] c_items):
        inst = <List__Range>List__Range.__new__(List__Range)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cRange]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cRange]] c_inst = make_unique[vector[cRange]]()
        if items is not None:
            for item in items:
                if not isinstance(item, Range):
                    raise TypeError(f"{item!r} is not of type 'Range'")
                deref(c_inst).push_back(deref((<Range>item)._cpp_obj))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cRange]] c_inst
        cdef cRange citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cRange]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Range.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Range.create(make_shared[cRange](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, Range):
            return False
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        for citem in deref(self._cpp_obj):
            yield Range.create(make_shared[cRange](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        cdef vector[cRange].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Range.create(make_shared[cRange](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, Range):
            raise err
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        cdef vector[cRange].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cRange].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, Range):
            return 0
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Range)

cdef class List__Internship:
    def __init__(self, items=None):
        if isinstance(items, List__Internship):
            self._cpp_obj = (<List__Internship> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Internship._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cInternship]] c_items):
        inst = <List__Internship>List__Internship.__new__(List__Internship)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cInternship]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cInternship]] c_inst = make_unique[vector[cInternship]]()
        if items is not None:
            for item in items:
                if not isinstance(item, Internship):
                    raise TypeError(f"{item!r} is not of type 'Internship'")
                deref(c_inst).push_back(deref((<Internship>item)._cpp_obj))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cInternship]] c_inst
        cdef cInternship citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cInternship]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__Internship.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Internship.create(make_shared[cInternship](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, Internship):
            return False
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        for citem in deref(self._cpp_obj):
            yield Internship.create(make_shared[cInternship](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        cdef vector[cInternship].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Internship.create(make_shared[cInternship](citem))
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, Internship):
            raise err
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        cdef vector[cInternship].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[cInternship].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, Internship):
            return 0
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Internship)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[string]] _make_instance(object items) except *:
        cdef unique_ptr[vector[string]] c_inst = make_unique[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, str):
            raise err
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[string].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, str):
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,int32_t]] c_inst = make_unique[cmap[int32_t,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item

                deref(c_inst).insert(cpair[int32_t,int32_t](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_string):
            self._cpp_obj = (<Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,string]] c_items):
        inst = <Map__i32_string>Map__i32_string.__new__(Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,string]] c_inst = make_unique[cmap[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(Map__i32_string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,string]] c_inst = make_unique[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[string,string](key.encode('UTF-8'),item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, str):
                key = str(key)
        except Exception:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

myInt = 1337
name = cname().decode('UTF-8')
states = List__Map__string_i32.create(make_shared[vector[cmap[string,int32_t]]](cstates()))
x = 1.0
y = 1000000.0
z = 1000000000.0
zeroDoubleValue = 0.0
longDoubleValue = 0.000026
instagram = Internship.create(make_shared[cInternship](cinstagram()))
kRanges = List__Range.create(make_shared[vector[cRange]](ckRanges()))
internList = List__Internship.create(make_shared[vector[cInternship]](cinternList()))
pod_0 = struct1.create(make_shared[cstruct1](cpod_0()))
pod_1 = struct1.create(make_shared[cstruct1](cpod_1()))
pod_2 = struct2.create(make_shared[cstruct2](cpod_2()))
pod_3 = struct3.create(make_shared[cstruct3](cpod_3()))
u_1_1 = union1.create(make_shared[cunion1](cu_1_1()))
u_1_2 = union1.create(make_shared[cunion1](cu_1_2()))
u_1_3 = union1.create(make_shared[cunion1](cu_1_3()))
u_2_1 = union2.create(make_shared[cunion2](cu_2_1()))
u_2_2 = union2.create(make_shared[cunion2](cu_2_2()))
u_2_3 = union2.create(make_shared[cunion2](cu_2_3()))
u_2_4 = union2.create(make_shared[cunion2](cu_2_4()))
u_2_5 = union2.create(make_shared[cunion2](cu_2_5()))
u_2_6 = union2.create(make_shared[cunion2](cu_2_6()))
apostrophe = capostrophe().decode('UTF-8')
tripleApostrophe = ctripleApostrophe().decode('UTF-8')
quotationMark = cquotationMark().decode('UTF-8')
backslash = cbackslash().decode('UTF-8')
escaped_a = cescaped_a().decode('UTF-8')
char2ascii = Map__string_i32.create(make_shared[cmap[string,int32_t]](cchar2ascii()))
escaped_strings = List__string.create(make_shared[vector[string]](cescaped_strings()))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0.0
empty_string = cempty_string().decode('UTF-8')
empty_int_list = List__i32.create(make_shared[vector[int32_t]](cempty_int_list()))
empty_string_list = List__string.create(make_shared[vector[string]](cempty_string_list()))
empty_int_set = Set__i32.create(make_shared[cset[int32_t]](cempty_int_set()))
empty_string_set = Set__string.create(make_shared[cset[string]](cempty_string_set()))
empty_int_int_map = Map__i32_i32.create(make_shared[cmap[int32_t,int32_t]](cempty_int_int_map()))
empty_int_string_map = Map__i32_string.create(make_shared[cmap[int32_t,string]](cempty_int_string_map()))
empty_string_int_map = Map__string_i32.create(make_shared[cmap[string,int32_t]](cempty_string_int_map()))
empty_string_string_map = Map__string_string.create(make_shared[cmap[string,string]](cempty_string_string_map()))
