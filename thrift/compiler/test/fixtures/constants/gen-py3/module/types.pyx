#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum
import warnings


class EmptyEnum(Enum):

    __hash__ = Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value


cdef cEmptyEnum EmptyEnum_to_cpp(value):
    pass
class City(Enum):
    NYC = <int> (City__NYC)
    MPK = <int> (City__MPK)
    SEA = <int> (City__SEA)
    LON = <int> (City__LON)

    __hash__ = Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value


cdef cCity City_to_cpp(value):
    if value == City.NYC:
        return City__NYC
    elif value == City.MPK:
        return City__MPK
    elif value == City.SEA:
        return City__SEA
    elif value == City.LON:
        return City__LON
class Company(Enum):
    FACEBOOK = <int> (Company__FACEBOOK)
    WHATSAPP = <int> (Company__WHATSAPP)
    OCULUS = <int> (Company__OCULUS)
    INSTAGRAM = <int> (Company__INSTAGRAM)

    __hash__ = Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value


cdef cCompany Company_to_cpp(value):
    if value == Company.FACEBOOK:
        return Company__FACEBOOK
    elif value == Company.WHATSAPP:
        return Company__WHATSAPP
    elif value == Company.OCULUS:
        return Company__OCULUS
    elif value == Company.INSTAGRAM:
        return Company__INSTAGRAM


cdef cInternship _Internship_defaults = cInternship()

cdef class Internship(thrift.py3.types.Struct):

    def __init__(
        Internship self,
        weeks=None,
        title=None,
        employer=None
    ):
        self._cpp_obj = move(Internship._make_instance(
          NULL,
          weeks,
          title,
          employer,
        ))

    def __call__(
        Internship self,
        weeks=NOTSET,
        title=NOTSET,
        employer=NOTSET
    ):
        changes = any((
            weeks is not NOTSET,

            title is not NOTSET,

            employer is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = move(Internship._make_instance(
          self._cpp_obj.get(),
          weeks,
          title,
          employer,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cInternship] _make_instance(
        cInternship* base_instance,
        object weeks,
        object title,
        object employer
    ) except *:
        cdef unique_ptr[cInternship] c_inst
        if base_instance:
            c_inst = make_unique[cInternship](deref(base_instance))
        else:
            c_inst = make_unique[cInternship]()

        if base_instance:
            # Convert None's to default value.
            if weeks is None:
                deref(c_inst).weeks = _Internship_defaults.weeks
            elif weeks is NOTSET:
                weeks = None

            if title is None:
                deref(c_inst).title = _Internship_defaults.title
                deref(c_inst).__isset.title = False
            elif title is NOTSET:
                title = None

            if employer is None:
                deref(c_inst).employer = _Internship_defaults.employer
                deref(c_inst).__isset.employer = False
            elif employer is NOTSET:
                employer = None

        if weeks is not None:
            deref(c_inst).weeks = weeks
        if title is not None:
            deref(c_inst).title = title.encode('UTF-8')
            deref(c_inst).__isset.title = True

        if employer is not None:
            deref(c_inst).employer = Company_to_cpp(employer)
            deref(c_inst).__isset.employer = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'weeks', self.weeks
        yield 'title', self.title
        yield 'employer', self.employer

    def __bool__(self):
        return True or deref(self._cpp_obj).__isset.title or deref(self._cpp_obj).__isset.employer

    @staticmethod
    cdef create(shared_ptr[cInternship] cpp_obj):
        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def weeks(self):
        return self._cpp_obj.get().weeks

    @property
    def title(self):
        if not deref(self._cpp_obj).__isset.title:
            return None

        return self._cpp_obj.get().title.decode('UTF-8')

    @property
    def employer(self):
        if not deref(self._cpp_obj).__isset.employer:
            return None

        return translate_cpp_enum_to_python(Company, <int>deref(self._cpp_obj).employer)


    def __hash__(Internship self):
        if not self.__hash:
            self.__hash = hash((
            self.weeks,
            self.title,
            self.employer,
            ))
        return self.__hash

    def __repr__(Internship self):
        return f'Internship(weeks={repr(self.weeks)}, title={repr(self.title)}, employer={repr(self.employer)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Internship) and
                isinstance(other, Internship)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cInternship cself = deref((<Internship>self)._cpp_obj)
        cdef cInternship cother = deref((<Internship>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(Internship self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Internship self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Internship, serialize(self)))


cdef cUnEnumStruct _UnEnumStruct_defaults = cUnEnumStruct()

cdef class UnEnumStruct(thrift.py3.types.Struct):

    def __init__(
        UnEnumStruct self,
        city=None
    ):
        self._cpp_obj = move(UnEnumStruct._make_instance(
          NULL,
          city,
        ))

    def __call__(
        UnEnumStruct self,
        city=NOTSET
    ):
        changes = any((
            city is not NOTSET,
        ))

        if not changes:
            return self

        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = move(UnEnumStruct._make_instance(
          self._cpp_obj.get(),
          city,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cUnEnumStruct] _make_instance(
        cUnEnumStruct* base_instance,
        object city
    ) except *:
        cdef unique_ptr[cUnEnumStruct] c_inst
        if base_instance:
            c_inst = make_unique[cUnEnumStruct](deref(base_instance))
        else:
            c_inst = make_unique[cUnEnumStruct]()

        if base_instance:
            # Convert None's to default value.
            if city is None:
                deref(c_inst).city = _UnEnumStruct_defaults.city
                deref(c_inst).__isset.city = False
            elif city is NOTSET:
                city = None

        if city is not None:
            deref(c_inst).city = City_to_cpp(city)
            deref(c_inst).__isset.city = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'city', self.city

    def __bool__(self):
        return deref(self._cpp_obj).__isset.city

    @staticmethod
    cdef create(shared_ptr[cUnEnumStruct] cpp_obj):
        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def city(self):
        return translate_cpp_enum_to_python(City, <int>deref(self._cpp_obj).city)


    def __hash__(UnEnumStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.city,
            ))
        return self.__hash

    def __repr__(UnEnumStruct self):
        return f'UnEnumStruct(city={repr(self.city)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, UnEnumStruct) and
                isinstance(other, UnEnumStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cUnEnumStruct cself = deref((<UnEnumStruct>self)._cpp_obj)
        cdef cUnEnumStruct cother = deref((<UnEnumStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(UnEnumStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(UnEnumStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (UnEnumStruct, serialize(self)))


cdef cRange _Range_defaults = cRange()

cdef class Range(thrift.py3.types.Struct):

    def __init__(
        Range self,
        min=None,
        max=None
    ):
        self._cpp_obj = move(Range._make_instance(
          NULL,
          min,
          max,
        ))

    def __call__(
        Range self,
        min=NOTSET,
        max=NOTSET
    ):
        changes = any((
            min is not NOTSET,

            max is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = move(Range._make_instance(
          self._cpp_obj.get(),
          min,
          max,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cRange] _make_instance(
        cRange* base_instance,
        object min,
        object max
    ) except *:
        cdef unique_ptr[cRange] c_inst
        if base_instance:
            c_inst = make_unique[cRange](deref(base_instance))
        else:
            c_inst = make_unique[cRange]()

        if base_instance:
            # Convert None's to default value.
            if min is None:
                deref(c_inst).min = _Range_defaults.min
            elif min is NOTSET:
                min = None

            if max is None:
                deref(c_inst).max = _Range_defaults.max
            elif max is NOTSET:
                max = None

        if min is not None:
            deref(c_inst).min = min
        if max is not None:
            deref(c_inst).max = max
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'min', self.min
        yield 'max', self.max

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cRange] cpp_obj):
        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def min(self):
        return self._cpp_obj.get().min

    @property
    def max(self):
        return self._cpp_obj.get().max


    def __hash__(Range self):
        if not self.__hash:
            self.__hash = hash((
            self.min,
            self.max,
            ))
        return self.__hash

    def __repr__(Range self):
        return f'Range(min={repr(self.min)}, max={repr(self.max)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Range) and
                isinstance(other, Range)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cRange cself = deref((<Range>self)._cpp_obj)
        cdef cRange cother = deref((<Range>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(Range self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Range self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Range, serialize(self)))


cdef cstruct1 _struct1_defaults = cstruct1()

cdef class struct1(thrift.py3.types.Struct):

    def __init__(
        struct1 self,
        a=None,
        b=None
    ):
        self._cpp_obj = move(struct1._make_instance(
          NULL,
          a,
          b,
        ))

    def __call__(
        struct1 self,
        a=NOTSET,
        b=NOTSET
    ):
        changes = any((
            a is not NOTSET,

            b is not NOTSET,
        ))

        if not changes:
            return self

        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = move(struct1._make_instance(
          self._cpp_obj.get(),
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct1] _make_instance(
        cstruct1* base_instance,
        object a,
        object b
    ) except *:
        cdef unique_ptr[cstruct1] c_inst
        if base_instance:
            c_inst = make_unique[cstruct1](deref(base_instance))
        else:
            c_inst = make_unique[cstruct1]()

        if base_instance:
            # Convert None's to default value.
            if a is None:
                deref(c_inst).a = _struct1_defaults.a
                deref(c_inst).__isset.a = False
            elif a is NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct1_defaults.b
                deref(c_inst).__isset.b = False
            elif b is NOTSET:
                b = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True

        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return deref(self._cpp_obj).__isset.a or deref(self._cpp_obj).__isset.b

    @staticmethod
    cdef create(shared_ptr[cstruct1] cpp_obj):
        inst = <struct1>struct1.__new__(struct1)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):
        return self._cpp_obj.get().a

    @property
    def b(self):
        return self._cpp_obj.get().b.decode('UTF-8')


    def __hash__(struct1 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(struct1 self):
        return f'struct1(a={repr(self.a)}, b={repr(self.b)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct1) and
                isinstance(other, struct1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct1 cself = deref((<struct1>self)._cpp_obj)
        cdef cstruct1 cother = deref((<struct1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct1 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct1](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct1 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct1](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct1, serialize(self)))


cdef cstruct2 _struct2_defaults = cstruct2()

cdef class struct2(thrift.py3.types.Struct):

    def __init__(
        struct2 self,
        a=None,
        b=None,
        c=None,
        d=None
    ):
        self._cpp_obj = move(struct2._make_instance(
          NULL,
          a,
          b,
          c,
          d,
        ))

    def __call__(
        struct2 self,
        a=NOTSET,
        b=NOTSET,
        c=NOTSET,
        d=NOTSET
    ):
        changes = any((
            a is not NOTSET,

            b is not NOTSET,

            c is not NOTSET,

            d is not NOTSET,
        ))

        if not changes:
            return self

        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = move(struct2._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
          d,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct2] _make_instance(
        cstruct2* base_instance,
        object a,
        object b,
        object c,
        object d
    ) except *:
        cdef unique_ptr[cstruct2] c_inst
        if base_instance:
            c_inst = make_unique[cstruct2](deref(base_instance))
        else:
            c_inst = make_unique[cstruct2]()

        if base_instance:
            # Convert None's to default value.
            if a is None:
                deref(c_inst).a = _struct2_defaults.a
                deref(c_inst).__isset.a = False
            elif a is NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct2_defaults.b
                deref(c_inst).__isset.b = False
            elif b is NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct2_defaults.c
                deref(c_inst).__isset.c = False
            elif c is NOTSET:
                c = None

            if d is None:
                deref(c_inst).d = _struct2_defaults.d
                deref(c_inst).__isset.d = False
            elif d is NOTSET:
                d = None

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True

        if b is not None:
            deref(c_inst).b = b.encode('UTF-8')
            deref(c_inst).__isset.b = True

        if c is not None:
            deref(c_inst).c = deref((<struct1?> c)._cpp_obj)
            deref(c_inst).__isset.c = True

        if d is not None:
            deref(c_inst).d = <vector[int32_t]>deref(List__i32(d)._cpp_obj)
            deref(c_inst).__isset.d = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c
        yield 'd', self.d

    def __bool__(self):
        return deref(self._cpp_obj).__isset.a or deref(self._cpp_obj).__isset.b or deref(self._cpp_obj).__isset.c or deref(self._cpp_obj).__isset.d

    @staticmethod
    cdef create(shared_ptr[cstruct2] cpp_obj):
        inst = <struct2>struct2.__new__(struct2)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):
        if not deref(self._cpp_obj).__isset.a:
            return None

        return self._cpp_obj.get().a

    @property
    def b(self):
        if not deref(self._cpp_obj).__isset.b:
            return None

        return self._cpp_obj.get().b.decode('UTF-8')

    @property
    def c(self):
        if not deref(self._cpp_obj).__isset.c:
            return None

        if self.__c is None:
            self.__c = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).c))
        return self.__c

    @property
    def d(self):
        if not deref(self._cpp_obj).__isset.d:
            return None

        if self.__d is None:
            self.__d = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).d))
        return self.__d


    def __hash__(struct2 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            self.d,
            ))
        return self.__hash

    def __repr__(struct2 self):
        return f'struct2(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)}, d={repr(self.d)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct2) and
                isinstance(other, struct2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct2 cself = deref((<struct2>self)._cpp_obj)
        cdef cstruct2 cother = deref((<struct2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct2 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct2](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct2 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct2](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct2, serialize(self)))


cdef cstruct3 _struct3_defaults = cstruct3()

cdef class struct3(thrift.py3.types.Struct):

    def __init__(
        struct3 self,
        a=None,
        b=None,
        c=None
    ):
        self._cpp_obj = move(struct3._make_instance(
          NULL,
          a,
          b,
          c,
        ))

    def __call__(
        struct3 self,
        a=NOTSET,
        b=NOTSET,
        c=NOTSET
    ):
        changes = any((
            a is not NOTSET,

            b is not NOTSET,

            c is not NOTSET,
        ))

        if not changes:
            return self

        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = move(struct3._make_instance(
          self._cpp_obj.get(),
          a,
          b,
          c,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cstruct3] _make_instance(
        cstruct3* base_instance,
        object a,
        object b,
        object c
    ) except *:
        cdef unique_ptr[cstruct3] c_inst
        if base_instance:
            c_inst = make_unique[cstruct3](deref(base_instance))
        else:
            c_inst = make_unique[cstruct3]()

        if base_instance:
            # Convert None's to default value.
            if a is None:
                deref(c_inst).a = _struct3_defaults.a
                deref(c_inst).__isset.a = False
            elif a is NOTSET:
                a = None

            if b is None:
                deref(c_inst).b = _struct3_defaults.b
                deref(c_inst).__isset.b = False
            elif b is NOTSET:
                b = None

            if c is None:
                deref(c_inst).c = _struct3_defaults.c
                deref(c_inst).__isset.c = False
            elif c is NOTSET:
                c = None

        if a is not None:
            deref(c_inst).a = a.encode('UTF-8')
            deref(c_inst).__isset.a = True

        if b is not None:
            deref(c_inst).b = b
            deref(c_inst).__isset.b = True

        if c is not None:
            deref(c_inst).c = deref((<struct2?> c)._cpp_obj)
            deref(c_inst).__isset.c = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b
        yield 'c', self.c

    def __bool__(self):
        return deref(self._cpp_obj).__isset.a or deref(self._cpp_obj).__isset.b or deref(self._cpp_obj).__isset.c

    @staticmethod
    cdef create(shared_ptr[cstruct3] cpp_obj):
        inst = <struct3>struct3.__new__(struct3)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def a(self):
        if not deref(self._cpp_obj).__isset.a:
            return None

        return self._cpp_obj.get().a.decode('UTF-8')

    @property
    def b(self):
        if not deref(self._cpp_obj).__isset.b:
            return None

        return self._cpp_obj.get().b

    @property
    def c(self):
        if not deref(self._cpp_obj).__isset.c:
            return None

        if self.__c is None:
            self.__c = struct2.create(make_shared[cstruct2](deref(self._cpp_obj).c))
        return self.__c


    def __hash__(struct3 self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            self.c,
            ))
        return self.__hash

    def __repr__(struct3 self):
        return f'struct3(a={repr(self.a)}, b={repr(self.b)}, c={repr(self.c)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, struct3) and
                isinstance(other, struct3)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cstruct3 cself = deref((<struct3>self)._cpp_obj)
        cdef cstruct3 cother = deref((<struct3>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(struct3 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cstruct3](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(struct3 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cstruct3](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (struct3, serialize(self)))


class union1Type(Enum):
    EMPTY = <int>cunion1__type___EMPTY__
    i = <int>cunion1__type_i
    d = <int>cunion1__type_d

cdef class union1(thrift.py3.types.Struct):
    def __init__(
        union1 self,
        i=None,
        d=None
    ):
        self._cpp_obj = move(union1._make_instance(
          NULL,
          i,
          d,
        ))
        self._load_cache()

    @staticmethod
    cdef unique_ptr[cunion1] _make_instance(
        cunion1* base_instance,
        i,
        d
    ) except *:
        cdef unique_ptr[cunion1] c_inst = make_unique[cunion1]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.__type != union1Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion1] cpp_obj):
        inst = <union1>union1.__new__(union1)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.__type != union1Type.i:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not i')
        return self.__cached

    @property
    def d(self):
        if self.__type != union1Type.d:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not d')
        return self.__cached


    def __hash__(union1 self):
        if not self.__hash:
            self.__hash = hash((
                self.__type,
                self.__cached,
            ))
        return self.__hash

    def __repr__(union1 self):
        return f'union1(type={self.__type.name}, value={repr(self.__cached)})'

    cdef _load_cache(union1 self):
        if self.__type is not None:
            return

        self.__type = union1Type(<int>(deref(self._cpp_obj).getType()))
        if self.__type == union1Type.EMPTY:
            self.__cached = None
        elif self.__type == union1Type.i:
            self.__cached = deref(self._cpp_obj).get_i()
        elif self.__type == union1Type.d:
            self.__cached = deref(self._cpp_obj).get_d()

    def get_type(union1 self):
        return self.__type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union1) and
                isinstance(other, union1)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion1 cself = deref((<union1>self)._cpp_obj)
        cdef cunion1 cother = deref((<union1>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(union1 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cunion1](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(union1 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cunion1](buf, deref(self._cpp_obj.get()))
        # force a cache reload since the underlying data's changed
        self.__type = None
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union1, serialize(self)))


class union2Type(Enum):
    EMPTY = <int>cunion2__type___EMPTY__
    i = <int>cunion2__type_i
    d = <int>cunion2__type_d
    s = <int>cunion2__type_s
    u = <int>cunion2__type_u

cdef class union2(thrift.py3.types.Struct):
    def __init__(
        union2 self,
        i=None,
        d=None,
        s=None,
        u=None
    ):
        self._cpp_obj = move(union2._make_instance(
          NULL,
          i,
          d,
          s,
          u,
        ))
        self._load_cache()

    @staticmethod
    cdef unique_ptr[cunion2] _make_instance(
        cunion2* base_instance,
        i,
        d,
        s,
        u
    ) except *:
        cdef unique_ptr[cunion2] c_inst = make_unique[cunion2]()
        cdef bint any_set = False
        if i is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_i(i)
            any_set = True
        if d is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_d(d)
            any_set = True
        if s is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_s(deref((<struct1?> s)._cpp_obj))
            any_set = True
        if u is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            deref(c_inst).set_u(deref((<union1?> u)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.__type != union2Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[cunion2] cpp_obj):
        inst = <union2>union2.__new__(union2)
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    @property
    def i(self):
        if self.__type != union2Type.i:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not i')
        return self.__cached

    @property
    def d(self):
        if self.__type != union2Type.d:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not d')
        return self.__cached

    @property
    def s(self):
        if self.__type != union2Type.s:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not s')
        return self.__cached

    @property
    def u(self):
        if self.__type != union2Type.u:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not u')
        return self.__cached


    def __hash__(union2 self):
        if not self.__hash:
            self.__hash = hash((
                self.__type,
                self.__cached,
            ))
        return self.__hash

    def __repr__(union2 self):
        return f'union2(type={self.__type.name}, value={repr(self.__cached)})'

    cdef _load_cache(union2 self):
        if self.__type is not None:
            return

        self.__type = union2Type(<int>(deref(self._cpp_obj).getType()))
        if self.__type == union2Type.EMPTY:
            self.__cached = None
        elif self.__type == union2Type.i:
            self.__cached = deref(self._cpp_obj).get_i()
        elif self.__type == union2Type.d:
            self.__cached = deref(self._cpp_obj).get_d()
        elif self.__type == union2Type.s:
            self.__cached = struct1.create(make_shared[cstruct1](deref(self._cpp_obj).get_s()))
        elif self.__type == union2Type.u:
            self.__cached = union1.create(make_shared[cunion1](deref(self._cpp_obj).get_u()))

    def get_type(union2 self):
        return self.__type

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, union2) and
                isinstance(other, union2)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cunion2 cself = deref((<union2>self)._cpp_obj)
        cdef cunion2 cother = deref((<union2>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(union2 self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cunion2](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(union2 self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cunion2](buf, deref(self._cpp_obj.get()))
        # force a cache reload since the underlying data's changed
        self.__type = None
        self._load_cache()
        return needed

    def __reduce__(self):
        return (deserialize, (union2, serialize(self)))


cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,int32_t]] c_inst = make_unique[cmap[string,int32_t]]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[string,int32_t](key.encode('UTF-8'),item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class List__Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_i32):
            self._cpp_obj = (<List__Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Map__string_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cmap[string,int32_t]]] c_items):
        inst = <List__Map__string_i32>List__Map__string_i32.__new__(List__Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cmap[string,int32_t]]] c_inst = make_unique[vector[cmap[string,int32_t]]]()
        if items:
            for item in items:
                deref(c_inst).push_back(cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get())))
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[string,int32_t]]] c_inst
        cdef cmap[string,int32_t] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[string,int32_t]]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Map__string_i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_i32)

cdef class List__Range:
    def __init__(self, items=None):
        if isinstance(items, List__Range):
            self._cpp_obj = (<List__Range> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Range._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cRange]] c_items):
        inst = <List__Range>List__Range.__new__(List__Range)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cRange]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cRange]] c_inst = make_unique[vector[cRange]]()
        if items:
            for item in items:
                deref(c_inst).push_back(deref((<Range>item)._cpp_obj))
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cRange]] c_inst
        cdef cRange citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cRange]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Range.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Range.create(make_shared[cRange](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        for citem in deref(self._cpp_obj):
            yield Range.create(make_shared[cRange](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        cdef vector[cRange].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Range.create(make_shared[cRange](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        cdef vector[cRange].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cRange citem = deref((<Range>item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Range)

cdef class List__Internship:
    def __init__(self, items=None):
        if isinstance(items, List__Internship):
            self._cpp_obj = (<List__Internship> items)._cpp_obj
        else:
            self._cpp_obj = move(List__Internship._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[cInternship]] c_items):
        inst = <List__Internship>List__Internship.__new__(List__Internship)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[cInternship]] _make_instance(object items) except *:
        cdef unique_ptr[vector[cInternship]] c_inst = make_unique[vector[cInternship]]()
        if items:
            for item in items:
                deref(c_inst).push_back(deref((<Internship>item)._cpp_obj))
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cInternship]] c_inst
        cdef cInternship citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cInternship]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__Internship.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return Internship.create(make_shared[cInternship](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        for citem in deref(self._cpp_obj):
            yield Internship.create(make_shared[cInternship](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        cdef vector[cInternship].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Internship.create(make_shared[cInternship](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        cdef vector[cInternship].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cInternship citem = deref((<Internship>item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Internship)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = move(List__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[string]] _make_instance(object items) except *:
        cdef unique_ptr[vector[string]] c_inst = make_unique[vector[string]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[string]] c_inst
        cdef string citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[string]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__string.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cset[int32_t]] c_inst = make_unique[cset[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = move(Set__string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cset[string]] _make_instance(object items) except *:
        cdef unique_ptr[cset[string]] c_inst = make_unique[cset[string]]()
        if items:
            for item in items:
                deref(c_inst).insert(item.encode('UTF-8'))
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,int32_t]] c_inst = make_unique[cmap[int32_t,int32_t]]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[int32_t,int32_t](key,item))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_string):
            self._cpp_obj = (<Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,string]] c_items):
        inst = <Map__i32_string>Map__i32_string.__new__(Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[int32_t,string]] c_inst = make_unique[cmap[int32_t,string]]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(Map__i32_string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = move(Map__string_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef unique_ptr[cmap[string,string]] c_inst = make_unique[cmap[string,string]]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[string,string](key.encode('UTF-8'),item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

myInt = 1337
name = cname().decode('UTF-8')
states = List__Map__string_i32.create(make_shared[vector[cmap[string,int32_t]]](cstates()))
x = 1.0
y = 1000000.0
z = 1000000000.0
zeroDoubleValue = 0.0
longDoubleValue = 0.000026
instagram = Internship.create(make_shared[cInternship](cinstagram()))
kRanges = List__Range.create(make_shared[vector[cRange]](ckRanges()))
internList = List__Internship.create(make_shared[vector[cInternship]](cinternList()))
pod_0 = struct1.create(make_shared[cstruct1](cpod_0()))
pod_1 = struct1.create(make_shared[cstruct1](cpod_1()))
pod_2 = struct2.create(make_shared[cstruct2](cpod_2()))
pod_3 = struct3.create(make_shared[cstruct3](cpod_3()))
u_1_1 = union1.create(make_shared[cunion1](cu_1_1()))
u_1_2 = union1.create(make_shared[cunion1](cu_1_2()))
u_1_3 = union1.create(make_shared[cunion1](cu_1_3()))
u_2_1 = union2.create(make_shared[cunion2](cu_2_1()))
u_2_2 = union2.create(make_shared[cunion2](cu_2_2()))
u_2_3 = union2.create(make_shared[cunion2](cu_2_3()))
u_2_4 = union2.create(make_shared[cunion2](cu_2_4()))
u_2_5 = union2.create(make_shared[cunion2](cu_2_5()))
u_2_6 = union2.create(make_shared[cunion2](cu_2_6()))
apostrophe = capostrophe().decode('UTF-8')
tripleApostrophe = ctripleApostrophe().decode('UTF-8')
quotationMark = cquotationMark().decode('UTF-8')
backslash = cbackslash().decode('UTF-8')
escaped_a = cescaped_a().decode('UTF-8')
char2ascii = Map__string_i32.create(make_shared[cmap[string,int32_t]](cchar2ascii()))
escaped_strings = List__string.create(make_shared[vector[string]](cescaped_strings()))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0.0
empty_string = cempty_string().decode('UTF-8')
empty_int_list = List__i32.create(make_shared[vector[int32_t]](cempty_int_list()))
empty_string_list = List__string.create(make_shared[vector[string]](cempty_string_list()))
empty_int_set = Set__i32.create(make_shared[cset[int32_t]](cempty_int_set()))
empty_string_set = Set__string.create(make_shared[cset[string]](cempty_string_set()))
empty_int_int_map = Map__i32_i32.create(make_shared[cmap[int32_t,int32_t]](cempty_int_int_map()))
empty_int_string_map = Map__i32_string.create(make_shared[cmap[int32_t,string]](cempty_int_string_map()))
empty_string_int_map = Map__string_i32.create(make_shared[cmap[string,int32_t]](cempty_string_int_map()))
empty_string_string_map = Map__string_string.create(make_shared[cmap[string,string]](cempty_string_string_map()))
