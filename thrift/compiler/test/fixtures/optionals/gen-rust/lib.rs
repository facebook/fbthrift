// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type PersonID = ::std::primitive::i64;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Color {
        pub red: ::std::primitive::f64,
        pub green: ::std::primitive::f64,
        pub blue: ::std::primitive::f64,
        pub alpha: ::std::primitive::f64,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Vehicle {
        pub color: crate::types::Color,
        pub licensePlate: ::std::option::Option<::std::string::String>,
        pub description: ::std::option::Option<::std::string::String>,
        pub name: ::std::option::Option<::std::string::String>,
        pub hasAC: ::std::option::Option<::std::primitive::bool>,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct Person {
        pub id: crate::types::PersonID,
        pub name: ::std::string::String,
        pub age: ::std::option::Option<::std::primitive::i16>,
        pub address: ::std::option::Option<::std::string::String>,
        pub favoriteColor: ::std::option::Option<crate::types::Color>,
        pub friends: ::std::option::Option<::std::collections::BTreeSet<crate::types::PersonID>>,
        pub bestFriend: ::std::option::Option<crate::types::PersonID>,
        pub petNames: ::std::option::Option<::std::collections::BTreeMap<crate::types::Animal, ::std::string::String>>,
        pub afraidOfAnimal: ::std::option::Option<crate::types::Animal>,
        pub vehicles: ::std::option::Option<::std::vec::Vec<crate::types::Vehicle>>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct Animal(pub ::std::primitive::i32);

    impl Animal {
        pub const DOG: Self = Animal(1i32);
        pub const CAT: Self = Animal(2i32);
        pub const TARANTULA: Self = Animal(3i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "DOG",
                "CAT",
                "TARANTULA",
            ]
        }
    }

    impl ::std::default::Default for Animal {
        fn default() -> Self {
            Animal(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Animal> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Animal) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Animal> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Animal) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Animal {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Animal {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                Animal::DOG => "DOG",
                Animal::CAT => "CAT",
                Animal::TARANTULA => "TARANTULA",
                Animal(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for Animal {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Animal::{}", self)
        }
    }

    impl ::std::str::FromStr for Animal {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "DOG" => ::std::result::Result::Ok(Animal::DOG),
                "CAT" => ::std::result::Result::Ok(Animal::CAT),
                "TARANTULA" => ::std::result::Result::Ok(Animal::TARANTULA),
                _ => ::anyhow::bail!("Unable to parse {} as Animal", string),
            }
        }
    }

    impl ::fbthrift::GetTType for Animal {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Animal
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Animal
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Animal::from(p.read_i32()?))
        }
    }


    impl ::std::default::Default for self::Color {
        fn default() -> Self {
            Self {
                red: ::std::default::Default::default(),
                green: ::std::default::Default::default(),
                blue: ::std::default::Default::default(),
                alpha: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Color {}
    unsafe impl ::std::marker::Sync for self::Color {}

    impl ::fbthrift::GetTType for self::Color {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Color
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Color");
            p.write_field_begin("red", ::fbthrift::TType::Double, 1);
            ::fbthrift::Serialize::write(&self.red, p);
            p.write_field_end();
            p.write_field_begin("green", ::fbthrift::TType::Double, 2);
            ::fbthrift::Serialize::write(&self.green, p);
            p.write_field_end();
            p.write_field_begin("blue", ::fbthrift::TType::Double, 3);
            ::fbthrift::Serialize::write(&self.blue, p);
            p.write_field_end();
            p.write_field_begin("alpha", ::fbthrift::TType::Double, 4);
            ::fbthrift::Serialize::write(&self.alpha, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Color
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_red = ::std::option::Option::None;
            let mut field_green = ::std::option::Option::None;
            let mut field_blue = ::std::option::Option::None;
            let mut field_alpha = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Double, 1) => field_red = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 2) => field_green = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 3) => field_blue = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Double, 4) => field_alpha = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                red: field_red.unwrap_or_default(),
                green: field_green.unwrap_or_default(),
                blue: field_blue.unwrap_or_default(),
                alpha: field_alpha.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Vehicle {
        fn default() -> Self {
            Self {
                color: ::std::default::Default::default(),
                licensePlate: ::std::option::Option::None,
                description: ::std::option::Option::None,
                name: ::std::option::Option::None,
                hasAC: ::std::option::Option::Some(false),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Vehicle {}
    unsafe impl ::std::marker::Sync for self::Vehicle {}

    impl ::fbthrift::GetTType for self::Vehicle {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Vehicle
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Vehicle");
            p.write_field_begin("color", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.color, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.licensePlate {
                p.write_field_begin("licensePlate", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.description {
                p.write_field_begin("description", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.name {
                p.write_field_begin("name", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.hasAC {
                p.write_field_begin("hasAC", ::fbthrift::TType::Bool, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Vehicle
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_color = ::std::option::Option::None;
            let mut field_licensePlate = ::std::option::Option::None;
            let mut field_description = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_hasAC = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_color = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_licensePlate = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_description = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_hasAC = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                color: field_color.unwrap_or_default(),
                licensePlate: field_licensePlate,
                description: field_description,
                name: field_name,
                hasAC: field_hasAC,
            })
        }
    }


    impl ::std::default::Default for self::Person {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                age: ::std::option::Option::None,
                address: ::std::option::Option::None,
                favoriteColor: ::std::option::Option::None,
                friends: ::std::option::Option::None,
                bestFriend: ::std::option::Option::None,
                petNames: ::std::option::Option::None,
                afraidOfAnimal: ::std::option::Option::None,
                vehicles: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Person {}
    unsafe impl ::std::marker::Sync for self::Person {}

    impl ::fbthrift::GetTType for self::Person {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Person
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Person");
            p.write_field_begin("id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.age {
                p.write_field_begin("age", ::fbthrift::TType::I16, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.address {
                p.write_field_begin("address", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.favoriteColor {
                p.write_field_begin("favoriteColor", ::fbthrift::TType::Struct, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.friends {
                p.write_field_begin("friends", ::fbthrift::TType::Set, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.bestFriend {
                p.write_field_begin("bestFriend", ::fbthrift::TType::I64, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.petNames {
                p.write_field_begin("petNames", ::fbthrift::TType::Map, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.afraidOfAnimal {
                p.write_field_begin("afraidOfAnimal", ::fbthrift::TType::I32, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vehicles {
                p.write_field_begin("vehicles", ::fbthrift::TType::List, 10);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Person
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_id = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_age = ::std::option::Option::None;
            let mut field_address = ::std::option::Option::None;
            let mut field_favoriteColor = ::std::option::Option::None;
            let mut field_friends = ::std::option::Option::None;
            let mut field_bestFriend = ::std::option::Option::None;
            let mut field_petNames = ::std::option::Option::None;
            let mut field_afraidOfAnimal = ::std::option::Option::None;
            let mut field_vehicles = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I16, 3) => field_age = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_address = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 5) => field_favoriteColor = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Set, 6) => field_friends = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_bestFriend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 8) => field_petNames = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 9) => field_afraidOfAnimal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 10) => field_vehicles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                id: field_id.unwrap_or_default(),
                name: field_name.unwrap_or_default(),
                age: field_age,
                address: field_address,
                favoriteColor: field_favoriteColor,
                friends: field_friends,
                bestFriend: field_bestFriend,
                petNames: field_petNames,
                afraidOfAnimal: field_afraidOfAnimal,
                vehicles: field_vehicles,
            })
        }
    }

}

pub mod errors {
}
