/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/complex-struct/gen-cpp2/module_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(const MyStruct&) = default;
MyStruct& MyStruct::operator=(const MyStruct&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct() :
      MyIntField(0),
      myEnum( ::cpp2::MyEnum::MyValue1),
      MyBoolField(0),
      MyByteField(0),
      MyShortField(0),
      MyLongField(0),
      MyDoubleField(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

MyStruct::~MyStruct() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(MyStruct&& other) noexcept  :
    MyIntField(std::move(other.MyIntField)),
    MyStringField(std::move(other.MyStringField)),
    MyDataField(std::move(other.MyDataField)),
    myEnum(std::move(other.myEnum)),
    MyBoolField(std::move(other.MyBoolField)),
    MyByteField(std::move(other.MyByteField)),
    MyShortField(std::move(other.MyShortField)),
    MyLongField(std::move(other.MyLongField)),
    MyDoubleField(std::move(other.MyDoubleField)),
    lDouble(std::move(other.lDouble)),
    lShort(std::move(other.lShort)),
    lInteger(std::move(other.lInteger)),
    lLong(std::move(other.lLong)),
    lString(std::move(other.lString)),
    lBool(std::move(other.lBool)),
    lByte(std::move(other.lByte)),
    mShortString(std::move(other.mShortString)),
    mIntegerString(std::move(other.mIntegerString)),
    mStringMyStruct(std::move(other.mStringMyStruct)),
    mStringBool(std::move(other.mStringBool)),
    mIntegerInteger(std::move(other.mIntegerInteger)),
    mIntegerBool(std::move(other.mIntegerBool)),
    sShort(std::move(other.sShort)),
    sMyStruct(std::move(other.sMyStruct)),
    sLong(std::move(other.sLong)),
    sString(std::move(other.sString)),
    sByte(std::move(other.sByte)),
    mListList(std::move(other.mListList)),
    __isset(other.__isset) {}
MyStruct& MyStruct::operator=(FOLLY_MAYBE_UNUSED MyStruct&& other) noexcept {
    this->MyIntField = std::move(other.MyIntField);
    this->MyStringField = std::move(other.MyStringField);
    this->MyDataField = std::move(other.MyDataField);
    this->myEnum = std::move(other.myEnum);
    this->MyBoolField = std::move(other.MyBoolField);
    this->MyByteField = std::move(other.MyByteField);
    this->MyShortField = std::move(other.MyShortField);
    this->MyLongField = std::move(other.MyLongField);
    this->MyDoubleField = std::move(other.MyDoubleField);
    this->lDouble = std::move(other.lDouble);
    this->lShort = std::move(other.lShort);
    this->lInteger = std::move(other.lInteger);
    this->lLong = std::move(other.lLong);
    this->lString = std::move(other.lString);
    this->lBool = std::move(other.lBool);
    this->lByte = std::move(other.lByte);
    this->mShortString = std::move(other.mShortString);
    this->mIntegerString = std::move(other.mIntegerString);
    this->mStringMyStruct = std::move(other.mStringMyStruct);
    this->mStringBool = std::move(other.mStringBool);
    this->mIntegerInteger = std::move(other.mIntegerInteger);
    this->mIntegerBool = std::move(other.mIntegerBool);
    this->sShort = std::move(other.sShort);
    this->sMyStruct = std::move(other.sMyStruct);
    this->sLong = std::move(other.sLong);
    this->sString = std::move(other.sString);
    this->sByte = std::move(other.sByte);
    this->mListList = std::move(other.mListList);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStruct::MyStruct(apache::thrift::FragileConstructor, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::cpp2::MyDataItem MyDataField__arg, ::cpp2::MyEnum myEnum__arg, bool MyBoolField__arg, ::std::int8_t MyByteField__arg, ::std::int16_t MyShortField__arg, ::std::int64_t MyLongField__arg, double MyDoubleField__arg, ::std::vector<double> lDouble__arg, ::std::vector<::std::int16_t> lShort__arg, ::std::vector<::std::int32_t> lInteger__arg, ::std::vector<::std::int64_t> lLong__arg, ::std::vector<::std::string> lString__arg, ::std::vector<bool> lBool__arg, ::std::vector<::std::int8_t> lByte__arg, ::std::map<::std::int16_t, ::std::string> mShortString__arg, ::std::map<::std::int32_t, ::std::string> mIntegerString__arg, ::std::map<::std::string, ::cpp2::MyStruct> mStringMyStruct__arg, ::std::map<::std::string, bool> mStringBool__arg, ::std::map<::std::int32_t, ::std::int32_t> mIntegerInteger__arg, ::std::map<::std::int32_t, bool> mIntegerBool__arg, ::std::set<::std::int16_t> sShort__arg, ::std::set<::cpp2::MyStruct> sMyStruct__arg, ::std::set<::std::int64_t> sLong__arg, ::std::set<::std::string> sString__arg, ::std::set<::std::int8_t> sByte__arg, ::std::map<::std::vector<::std::int32_t>, ::std::vector<::std::int32_t>> mListList__arg) :
    MyIntField(std::move(MyIntField__arg)),
    MyStringField(std::move(MyStringField__arg)),
    MyDataField(std::move(MyDataField__arg)),
    myEnum(std::move(myEnum__arg)),
    MyBoolField(std::move(MyBoolField__arg)),
    MyByteField(std::move(MyByteField__arg)),
    MyShortField(std::move(MyShortField__arg)),
    MyLongField(std::move(MyLongField__arg)),
    MyDoubleField(std::move(MyDoubleField__arg)),
    lDouble(std::move(lDouble__arg)),
    lShort(std::move(lShort__arg)),
    lInteger(std::move(lInteger__arg)),
    lLong(std::move(lLong__arg)),
    lString(std::move(lString__arg)),
    lBool(std::move(lBool__arg)),
    lByte(std::move(lByte__arg)),
    mShortString(std::move(mShortString__arg)),
    mIntegerString(std::move(mIntegerString__arg)),
    mStringMyStruct(std::move(mStringMyStruct__arg)),
    mStringBool(std::move(mStringBool__arg)),
    mIntegerInteger(std::move(mIntegerInteger__arg)),
    mIntegerBool(std::move(mIntegerBool__arg)),
    sShort(std::move(sShort__arg)),
    sMyStruct(std::move(sMyStruct__arg)),
    sLong(std::move(sLong__arg)),
    sString(std::move(sString__arg)),
    sByte(std::move(sByte__arg)),
    mListList(std::move(mListList__arg)) {
  __isset.MyIntField = true;
  __isset.MyStringField = true;
  __isset.MyDataField = true;
  __isset.myEnum = true;
  __isset.MyBoolField = true;
  __isset.MyByteField = true;
  __isset.MyShortField = true;
  __isset.MyLongField = true;
  __isset.MyDoubleField = true;
  __isset.lDouble = true;
  __isset.lShort = true;
  __isset.lInteger = true;
  __isset.lLong = true;
  __isset.lString = true;
  __isset.lBool = true;
  __isset.lByte = true;
  __isset.mShortString = true;
  __isset.mIntegerString = true;
  __isset.mStringMyStruct = true;
  __isset.mStringBool = true;
  __isset.mIntegerInteger = true;
  __isset.mIntegerBool = true;
  __isset.sShort = true;
  __isset.sMyStruct = true;
  __isset.sLong = true;
  __isset.sString = true;
  __isset.sByte = true;
  __isset.mListList = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void MyStruct::__clear() {
  // clear all fields
  this->MyIntField = 0;
  this->MyStringField = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->myEnum =  ::cpp2::MyEnum::MyValue1;
  this->MyBoolField = 0;
  this->MyByteField = 0;
  this->MyShortField = 0;
  this->MyLongField = 0;
  this->MyDoubleField = 0;
  this->lDouble.clear();
  this->lShort.clear();
  this->lInteger.clear();
  this->lLong.clear();
  this->lString.clear();
  this->lBool.clear();
  this->lByte.clear();
  this->mShortString.clear();
  this->mIntegerString.clear();
  this->mStringMyStruct.clear();
  this->mStringBool.clear();
  this->mIntegerInteger.clear();
  this->mIntegerBool.clear();
  this->sShort.clear();
  this->sMyStruct.clear();
  this->sLong.clear();
  this->sString.clear();
  this->sByte.clear();
  this->mListList.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStruct::operator==(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return false;
  }
  if (!(lhs.MyStringField_ref() == rhs.MyStringField_ref())) {
    return false;
  }
  if (!(lhs.MyDataField_ref() == rhs.MyDataField_ref())) {
    return false;
  }
  if (!(lhs.myEnum_ref() == rhs.myEnum_ref())) {
    return false;
  }
  if (!(lhs.MyBoolField_ref() == rhs.MyBoolField_ref())) {
    return false;
  }
  if (!(lhs.MyByteField_ref() == rhs.MyByteField_ref())) {
    return false;
  }
  if (!(lhs.MyShortField_ref() == rhs.MyShortField_ref())) {
    return false;
  }
  if (!(lhs.MyLongField_ref() == rhs.MyLongField_ref())) {
    return false;
  }
  if (!(lhs.MyDoubleField_ref() == rhs.MyDoubleField_ref())) {
    return false;
  }
  if (!(lhs.lDouble_ref() == rhs.lDouble_ref())) {
    return false;
  }
  if (!(lhs.lShort_ref() == rhs.lShort_ref())) {
    return false;
  }
  if (!(lhs.lInteger_ref() == rhs.lInteger_ref())) {
    return false;
  }
  if (!(lhs.lLong_ref() == rhs.lLong_ref())) {
    return false;
  }
  if (!(lhs.lString_ref() == rhs.lString_ref())) {
    return false;
  }
  if (!(lhs.lBool_ref() == rhs.lBool_ref())) {
    return false;
  }
  if (!(lhs.lByte_ref() == rhs.lByte_ref())) {
    return false;
  }
  if (!(lhs.mShortString_ref() == rhs.mShortString_ref())) {
    return false;
  }
  if (!(lhs.mIntegerString_ref() == rhs.mIntegerString_ref())) {
    return false;
  }
  if (!(lhs.mStringMyStruct_ref() == rhs.mStringMyStruct_ref())) {
    return false;
  }
  if (!(lhs.mStringBool_ref() == rhs.mStringBool_ref())) {
    return false;
  }
  if (!(lhs.mIntegerInteger_ref() == rhs.mIntegerInteger_ref())) {
    return false;
  }
  if (!(lhs.mIntegerBool_ref() == rhs.mIntegerBool_ref())) {
    return false;
  }
  if (!(lhs.sShort_ref() == rhs.sShort_ref())) {
    return false;
  }
  if (!(lhs.sMyStruct_ref() == rhs.sMyStruct_ref())) {
    return false;
  }
  if (!(lhs.sLong_ref() == rhs.sLong_ref())) {
    return false;
  }
  if (!(lhs.sString_ref() == rhs.sString_ref())) {
    return false;
  }
  if (!(lhs.sByte_ref() == rhs.sByte_ref())) {
    return false;
  }
  if (!(lhs.mListList_ref() == rhs.mListList_ref())) {
    return false;
  }
  return true;
}

bool MyStruct::operator<(const MyStruct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return lhs.MyIntField_ref() < rhs.MyIntField_ref();
  }
  if (!(lhs.MyStringField_ref() == rhs.MyStringField_ref())) {
    return lhs.MyStringField_ref() < rhs.MyStringField_ref();
  }
  if (!(lhs.MyDataField_ref() == rhs.MyDataField_ref())) {
    return lhs.MyDataField_ref() < rhs.MyDataField_ref();
  }
  if (!(lhs.myEnum_ref() == rhs.myEnum_ref())) {
    return lhs.myEnum_ref() < rhs.myEnum_ref();
  }
  if (!(lhs.MyBoolField_ref() == rhs.MyBoolField_ref())) {
    return lhs.MyBoolField_ref() < rhs.MyBoolField_ref();
  }
  if (!(lhs.MyByteField_ref() == rhs.MyByteField_ref())) {
    return lhs.MyByteField_ref() < rhs.MyByteField_ref();
  }
  if (!(lhs.MyShortField_ref() == rhs.MyShortField_ref())) {
    return lhs.MyShortField_ref() < rhs.MyShortField_ref();
  }
  if (!(lhs.MyLongField_ref() == rhs.MyLongField_ref())) {
    return lhs.MyLongField_ref() < rhs.MyLongField_ref();
  }
  if (!(lhs.MyDoubleField_ref() == rhs.MyDoubleField_ref())) {
    return lhs.MyDoubleField_ref() < rhs.MyDoubleField_ref();
  }
  if (!(lhs.lDouble_ref() == rhs.lDouble_ref())) {
    return lhs.lDouble_ref() < rhs.lDouble_ref();
  }
  if (!(lhs.lShort_ref() == rhs.lShort_ref())) {
    return lhs.lShort_ref() < rhs.lShort_ref();
  }
  if (!(lhs.lInteger_ref() == rhs.lInteger_ref())) {
    return lhs.lInteger_ref() < rhs.lInteger_ref();
  }
  if (!(lhs.lLong_ref() == rhs.lLong_ref())) {
    return lhs.lLong_ref() < rhs.lLong_ref();
  }
  if (!(lhs.lString_ref() == rhs.lString_ref())) {
    return lhs.lString_ref() < rhs.lString_ref();
  }
  if (!(lhs.lBool_ref() == rhs.lBool_ref())) {
    return lhs.lBool_ref() < rhs.lBool_ref();
  }
  if (!(lhs.lByte_ref() == rhs.lByte_ref())) {
    return lhs.lByte_ref() < rhs.lByte_ref();
  }
  if (!(lhs.mShortString_ref() == rhs.mShortString_ref())) {
    return lhs.mShortString_ref() < rhs.mShortString_ref();
  }
  if (!(lhs.mIntegerString_ref() == rhs.mIntegerString_ref())) {
    return lhs.mIntegerString_ref() < rhs.mIntegerString_ref();
  }
  if (!(lhs.mStringMyStruct_ref() == rhs.mStringMyStruct_ref())) {
    return lhs.mStringMyStruct_ref() < rhs.mStringMyStruct_ref();
  }
  if (!(lhs.mStringBool_ref() == rhs.mStringBool_ref())) {
    return lhs.mStringBool_ref() < rhs.mStringBool_ref();
  }
  if (!(lhs.mIntegerInteger_ref() == rhs.mIntegerInteger_ref())) {
    return lhs.mIntegerInteger_ref() < rhs.mIntegerInteger_ref();
  }
  if (!(lhs.mIntegerBool_ref() == rhs.mIntegerBool_ref())) {
    return lhs.mIntegerBool_ref() < rhs.mIntegerBool_ref();
  }
  if (!(lhs.sShort_ref() == rhs.sShort_ref())) {
    return lhs.sShort_ref() < rhs.sShort_ref();
  }
  if (!(lhs.sMyStruct_ref() == rhs.sMyStruct_ref())) {
    return lhs.sMyStruct_ref() < rhs.sMyStruct_ref();
  }
  if (!(lhs.sLong_ref() == rhs.sLong_ref())) {
    return lhs.sLong_ref() < rhs.sLong_ref();
  }
  if (!(lhs.sString_ref() == rhs.sString_ref())) {
    return lhs.sString_ref() < rhs.sString_ref();
  }
  if (!(lhs.sByte_ref() == rhs.sByte_ref())) {
    return lhs.sByte_ref() < rhs.sByte_ref();
  }
  if (!(lhs.mListList_ref() == rhs.mListList_ref())) {
    return lhs.mListList_ref() < rhs.mListList_ref();
  }
  return false;
}

const ::cpp2::MyDataItem& MyStruct::get_MyDataField() const& {
  return MyDataField;
}

::cpp2::MyDataItem MyStruct::get_MyDataField() && {
  return std::move(MyDataField);
}

const ::std::vector<double>& MyStruct::get_lDouble() const& {
  return lDouble;
}

::std::vector<double> MyStruct::get_lDouble() && {
  return std::move(lDouble);
}

const ::std::vector<::std::int16_t>& MyStruct::get_lShort() const& {
  return lShort;
}

::std::vector<::std::int16_t> MyStruct::get_lShort() && {
  return std::move(lShort);
}

const ::std::vector<::std::int32_t>& MyStruct::get_lInteger() const& {
  return lInteger;
}

::std::vector<::std::int32_t> MyStruct::get_lInteger() && {
  return std::move(lInteger);
}

const ::std::vector<::std::int64_t>& MyStruct::get_lLong() const& {
  return lLong;
}

::std::vector<::std::int64_t> MyStruct::get_lLong() && {
  return std::move(lLong);
}

const ::std::vector<::std::string>& MyStruct::get_lString() const& {
  return lString;
}

::std::vector<::std::string> MyStruct::get_lString() && {
  return std::move(lString);
}

const ::std::vector<bool>& MyStruct::get_lBool() const& {
  return lBool;
}

::std::vector<bool> MyStruct::get_lBool() && {
  return std::move(lBool);
}

const ::std::vector<::std::int8_t>& MyStruct::get_lByte() const& {
  return lByte;
}

::std::vector<::std::int8_t> MyStruct::get_lByte() && {
  return std::move(lByte);
}

const ::std::map<::std::int16_t, ::std::string>& MyStruct::get_mShortString() const& {
  return mShortString;
}

::std::map<::std::int16_t, ::std::string> MyStruct::get_mShortString() && {
  return std::move(mShortString);
}

const ::std::map<::std::int32_t, ::std::string>& MyStruct::get_mIntegerString() const& {
  return mIntegerString;
}

::std::map<::std::int32_t, ::std::string> MyStruct::get_mIntegerString() && {
  return std::move(mIntegerString);
}

const ::std::map<::std::string, ::cpp2::MyStruct>& MyStruct::get_mStringMyStruct() const& {
  return mStringMyStruct;
}

::std::map<::std::string, ::cpp2::MyStruct> MyStruct::get_mStringMyStruct() && {
  return std::move(mStringMyStruct);
}

const ::std::map<::std::string, bool>& MyStruct::get_mStringBool() const& {
  return mStringBool;
}

::std::map<::std::string, bool> MyStruct::get_mStringBool() && {
  return std::move(mStringBool);
}

const ::std::map<::std::int32_t, ::std::int32_t>& MyStruct::get_mIntegerInteger() const& {
  return mIntegerInteger;
}

::std::map<::std::int32_t, ::std::int32_t> MyStruct::get_mIntegerInteger() && {
  return std::move(mIntegerInteger);
}

const ::std::map<::std::int32_t, bool>& MyStruct::get_mIntegerBool() const& {
  return mIntegerBool;
}

::std::map<::std::int32_t, bool> MyStruct::get_mIntegerBool() && {
  return std::move(mIntegerBool);
}

const ::std::set<::std::int16_t>& MyStruct::get_sShort() const& {
  return sShort;
}

::std::set<::std::int16_t> MyStruct::get_sShort() && {
  return std::move(sShort);
}

const ::std::set<::cpp2::MyStruct>& MyStruct::get_sMyStruct() const& {
  return sMyStruct;
}

::std::set<::cpp2::MyStruct> MyStruct::get_sMyStruct() && {
  return std::move(sMyStruct);
}

const ::std::set<::std::int64_t>& MyStruct::get_sLong() const& {
  return sLong;
}

::std::set<::std::int64_t> MyStruct::get_sLong() && {
  return std::move(sLong);
}

const ::std::set<::std::string>& MyStruct::get_sString() const& {
  return sString;
}

::std::set<::std::string> MyStruct::get_sString() && {
  return std::move(sString);
}

const ::std::set<::std::int8_t>& MyStruct::get_sByte() const& {
  return sByte;
}

::std::set<::std::int8_t> MyStruct::get_sByte() && {
  return std::move(sByte);
}

const ::std::map<::std::vector<::std::int32_t>, ::std::vector<::std::int32_t>>& MyStruct::get_mListList() const& {
  return mListList;
}

::std::map<::std::vector<::std::int32_t>, ::std::vector<::std::int32_t>> MyStruct::get_mListList() && {
  return std::move(mListList);
}


void swap(MyStruct& a, MyStruct& b) {
  using ::std::swap;
  swap(a.MyIntField_ref().value(), b.MyIntField_ref().value());
  swap(a.MyStringField_ref().value(), b.MyStringField_ref().value());
  swap(a.MyDataField_ref().value(), b.MyDataField_ref().value());
  swap(a.myEnum_ref().value(), b.myEnum_ref().value());
  swap(a.MyBoolField_ref().value(), b.MyBoolField_ref().value());
  swap(a.MyByteField_ref().value(), b.MyByteField_ref().value());
  swap(a.MyShortField_ref().value(), b.MyShortField_ref().value());
  swap(a.MyLongField_ref().value(), b.MyLongField_ref().value());
  swap(a.MyDoubleField_ref().value(), b.MyDoubleField_ref().value());
  swap(a.lDouble_ref().value(), b.lDouble_ref().value());
  swap(a.lShort_ref().value(), b.lShort_ref().value());
  swap(a.lInteger_ref().value(), b.lInteger_ref().value());
  swap(a.lLong_ref().value(), b.lLong_ref().value());
  swap(a.lString_ref().value(), b.lString_ref().value());
  swap(a.lBool_ref().value(), b.lBool_ref().value());
  swap(a.lByte_ref().value(), b.lByte_ref().value());
  swap(a.mShortString_ref().value(), b.mShortString_ref().value());
  swap(a.mIntegerString_ref().value(), b.mIntegerString_ref().value());
  swap(a.mStringMyStruct_ref().value(), b.mStringMyStruct_ref().value());
  swap(a.mStringBool_ref().value(), b.mStringBool_ref().value());
  swap(a.mIntegerInteger_ref().value(), b.mIntegerInteger_ref().value());
  swap(a.mIntegerBool_ref().value(), b.mIntegerBool_ref().value());
  swap(a.sShort_ref().value(), b.sShort_ref().value());
  swap(a.sMyStruct_ref().value(), b.sMyStruct_ref().value());
  swap(a.sLong_ref().value(), b.sLong_ref().value());
  swap(a.sString_ref().value(), b.sString_ref().value());
  swap(a.sByte_ref().value(), b.sByte_ref().value());
  swap(a.mListList_ref().value(), b.mListList_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyDataItem>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyDataItem>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyStructTypeDef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyStructTypeDef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef(const MyStructTypeDef&) = default;
MyStructTypeDef& MyStructTypeDef::operator=(const MyStructTypeDef&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef() :
      myLongField(0),
      myLongTypeDef(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

MyStructTypeDef::~MyStructTypeDef() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef(MyStructTypeDef&& other) noexcept  :
    myLongField(std::move(other.myLongField)),
    myLongTypeDef(std::move(other.myLongTypeDef)),
    myStringField(std::move(other.myStringField)),
    myStringTypedef(std::move(other.myStringTypedef)),
    myMapField(std::move(other.myMapField)),
    myMapTypedef(std::move(other.myMapTypedef)),
    myListField(std::move(other.myListField)),
    myListTypedef(std::move(other.myListTypedef)),
    myMapListOfTypeDef(std::move(other.myMapListOfTypeDef)),
    __isset(other.__isset) {}
MyStructTypeDef& MyStructTypeDef::operator=(FOLLY_MAYBE_UNUSED MyStructTypeDef&& other) noexcept {
    this->myLongField = std::move(other.myLongField);
    this->myLongTypeDef = std::move(other.myLongTypeDef);
    this->myStringField = std::move(other.myStringField);
    this->myStringTypedef = std::move(other.myStringTypedef);
    this->myMapField = std::move(other.myMapField);
    this->myMapTypedef = std::move(other.myMapTypedef);
    this->myListField = std::move(other.myListField);
    this->myListTypedef = std::move(other.myListTypedef);
    this->myMapListOfTypeDef = std::move(other.myMapListOfTypeDef);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MyStructTypeDef::MyStructTypeDef(apache::thrift::FragileConstructor, ::std::int64_t myLongField__arg, ::cpp2::longTypeDef myLongTypeDef__arg, ::std::string myStringField__arg, ::cpp2::stringTypedef myStringTypedef__arg, ::std::map<::std::int16_t, ::std::string> myMapField__arg, ::cpp2::mapTypedef myMapTypedef__arg, ::std::vector<double> myListField__arg, ::cpp2::listTypedef myListTypedef__arg, ::std::map<::std::int16_t, ::std::vector<::cpp2::listTypedef>> myMapListOfTypeDef__arg) :
    myLongField(std::move(myLongField__arg)),
    myLongTypeDef(std::move(myLongTypeDef__arg)),
    myStringField(std::move(myStringField__arg)),
    myStringTypedef(std::move(myStringTypedef__arg)),
    myMapField(std::move(myMapField__arg)),
    myMapTypedef(std::move(myMapTypedef__arg)),
    myListField(std::move(myListField__arg)),
    myListTypedef(std::move(myListTypedef__arg)),
    myMapListOfTypeDef(std::move(myMapListOfTypeDef__arg)) {
  __isset.myLongField = true;
  __isset.myLongTypeDef = true;
  __isset.myStringField = true;
  __isset.myStringTypedef = true;
  __isset.myMapField = true;
  __isset.myMapTypedef = true;
  __isset.myListField = true;
  __isset.myListTypedef = true;
  __isset.myMapListOfTypeDef = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void MyStructTypeDef::__clear() {
  // clear all fields
  this->myLongField = 0;
  this->myLongTypeDef = 0;
  this->myStringField = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->myStringTypedef = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->myMapField.clear();
  this->myMapTypedef.clear();
  this->myListField.clear();
  this->myListTypedef.clear();
  this->myMapListOfTypeDef.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MyStructTypeDef::operator==(const MyStructTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.myLongField_ref() == rhs.myLongField_ref())) {
    return false;
  }
  if (!(lhs.myLongTypeDef_ref() == rhs.myLongTypeDef_ref())) {
    return false;
  }
  if (!(lhs.myStringField_ref() == rhs.myStringField_ref())) {
    return false;
  }
  if (!(lhs.myStringTypedef_ref() == rhs.myStringTypedef_ref())) {
    return false;
  }
  if (!(lhs.myMapField_ref() == rhs.myMapField_ref())) {
    return false;
  }
  if (!(lhs.myMapTypedef_ref() == rhs.myMapTypedef_ref())) {
    return false;
  }
  if (!(lhs.myListField_ref() == rhs.myListField_ref())) {
    return false;
  }
  if (!(lhs.myListTypedef_ref() == rhs.myListTypedef_ref())) {
    return false;
  }
  if (!(lhs.myMapListOfTypeDef_ref() == rhs.myMapListOfTypeDef_ref())) {
    return false;
  }
  return true;
}

bool MyStructTypeDef::operator<(const MyStructTypeDef& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.myLongField_ref() == rhs.myLongField_ref())) {
    return lhs.myLongField_ref() < rhs.myLongField_ref();
  }
  if (!(lhs.myLongTypeDef_ref() == rhs.myLongTypeDef_ref())) {
    return lhs.myLongTypeDef_ref() < rhs.myLongTypeDef_ref();
  }
  if (!(lhs.myStringField_ref() == rhs.myStringField_ref())) {
    return lhs.myStringField_ref() < rhs.myStringField_ref();
  }
  if (!(lhs.myStringTypedef_ref() == rhs.myStringTypedef_ref())) {
    return lhs.myStringTypedef_ref() < rhs.myStringTypedef_ref();
  }
  if (!(lhs.myMapField_ref() == rhs.myMapField_ref())) {
    return lhs.myMapField_ref() < rhs.myMapField_ref();
  }
  if (!(lhs.myMapTypedef_ref() == rhs.myMapTypedef_ref())) {
    return lhs.myMapTypedef_ref() < rhs.myMapTypedef_ref();
  }
  if (!(lhs.myListField_ref() == rhs.myListField_ref())) {
    return lhs.myListField_ref() < rhs.myListField_ref();
  }
  if (!(lhs.myListTypedef_ref() == rhs.myListTypedef_ref())) {
    return lhs.myListTypedef_ref() < rhs.myListTypedef_ref();
  }
  if (!(lhs.myMapListOfTypeDef_ref() == rhs.myMapListOfTypeDef_ref())) {
    return lhs.myMapListOfTypeDef_ref() < rhs.myMapListOfTypeDef_ref();
  }
  return false;
}

const ::std::map<::std::int16_t, ::std::string>& MyStructTypeDef::get_myMapField() const& {
  return myMapField;
}

::std::map<::std::int16_t, ::std::string> MyStructTypeDef::get_myMapField() && {
  return std::move(myMapField);
}

const ::cpp2::mapTypedef& MyStructTypeDef::get_myMapTypedef() const& {
  return myMapTypedef;
}

::cpp2::mapTypedef MyStructTypeDef::get_myMapTypedef() && {
  return std::move(myMapTypedef);
}

const ::std::vector<double>& MyStructTypeDef::get_myListField() const& {
  return myListField;
}

::std::vector<double> MyStructTypeDef::get_myListField() && {
  return std::move(myListField);
}

const ::cpp2::listTypedef& MyStructTypeDef::get_myListTypedef() const& {
  return myListTypedef;
}

::cpp2::listTypedef MyStructTypeDef::get_myListTypedef() && {
  return std::move(myListTypedef);
}

const ::std::map<::std::int16_t, ::std::vector<::cpp2::listTypedef>>& MyStructTypeDef::get_myMapListOfTypeDef() const& {
  return myMapListOfTypeDef;
}

::std::map<::std::int16_t, ::std::vector<::cpp2::listTypedef>> MyStructTypeDef::get_myMapListOfTypeDef() && {
  return std::move(myMapListOfTypeDef);
}


void swap(MyStructTypeDef& a, MyStructTypeDef& b) {
  using ::std::swap;
  swap(a.myLongField_ref().value(), b.myLongField_ref().value());
  swap(a.myLongTypeDef_ref().value(), b.myLongTypeDef_ref().value());
  swap(a.myStringField_ref().value(), b.myStringField_ref().value());
  swap(a.myStringTypedef_ref().value(), b.myStringTypedef_ref().value());
  swap(a.myMapField_ref().value(), b.myMapField_ref().value());
  swap(a.myMapTypedef_ref().value(), b.myMapTypedef_ref().value());
  swap(a.myListField_ref().value(), b.myListField_ref().value());
  swap(a.myListTypedef_ref().value(), b.myListTypedef_ref().value());
  swap(a.myMapListOfTypeDef_ref().value(), b.myMapListOfTypeDef_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MyStructTypeDef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructTypeDef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructTypeDef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructTypeDef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructTypeDef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructTypeDef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructTypeDef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructTypeDef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::MyUnionFloatFieldThrowExp>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::MyUnionFloatFieldThrowExp>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::size;
folly::Range<::cpp2::MyUnionFloatFieldThrowExp::Type const*> const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::values = folly::range(TEnumDataStorage<::cpp2::MyUnionFloatFieldThrowExp::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::names = folly::range(TEnumDataStorage<::cpp2::MyUnionFloatFieldThrowExp::Type>::names);

char const* TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnionFloatFieldThrowExp::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::MyUnionFloatFieldThrowExp::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::MyUnionFloatFieldThrowExp::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void MyUnionFloatFieldThrowExp::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::myEnum:
      destruct(value_.myEnum);
      break;
    case Type::setFloat:
      destruct(value_.setFloat);
      break;
    case Type::myDataItem:
      destruct(value_.myDataItem);
      break;
    case Type::complexNestedStruct:
      destruct(value_.complexNestedStruct);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool MyUnionFloatFieldThrowExp::operator==(const MyUnionFloatFieldThrowExp& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::myEnum:
      return value_.myEnum == rhs.value_.myEnum;
    case Type::setFloat:
      return value_.setFloat == rhs.value_.setFloat;
    case Type::myDataItem:
      return value_.myDataItem == rhs.value_.myDataItem;
    case Type::complexNestedStruct:
      return value_.complexNestedStruct == rhs.value_.complexNestedStruct;
    default:
      return true;
  }
}

bool MyUnionFloatFieldThrowExp::operator<(const MyUnionFloatFieldThrowExp& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::myEnum:
      return lhs.value_.myEnum < rhs.value_.myEnum;
    case Type::setFloat:
      return lhs.value_.setFloat < rhs.value_.setFloat;
    case Type::myDataItem:
      return lhs.value_.myDataItem < rhs.value_.myDataItem;
    case Type::complexNestedStruct:
      return lhs.value_.complexNestedStruct < rhs.value_.complexNestedStruct;
    default:
      return false;
  }
}

void swap(MyUnionFloatFieldThrowExp& a, MyUnionFloatFieldThrowExp& b) {
  MyUnionFloatFieldThrowExp temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void MyUnionFloatFieldThrowExp::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyUnionFloatFieldThrowExp::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyUnionFloatFieldThrowExp::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyUnionFloatFieldThrowExp::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyUnionFloatFieldThrowExp::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyDataItem>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
        ::cpp2::ComplexNestedStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyDataItem>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MyUnionFloatFieldThrowExp,
        ::apache::thrift::type_class::structure,
        ::cpp2::ComplexNestedStruct>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::emptyXcep>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::emptyXcep>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
emptyXcep::emptyXcep(const emptyXcep&) = default;
emptyXcep& emptyXcep::operator=(const emptyXcep&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
emptyXcep::emptyXcep() {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

emptyXcep::~emptyXcep() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
emptyXcep::emptyXcep(emptyXcep&& other) noexcept { (void)other; }
emptyXcep& emptyXcep::operator=(FOLLY_MAYBE_UNUSED emptyXcep&& other) noexcept {
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
emptyXcep::emptyXcep(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void emptyXcep::__clear() {
  // clear all fields
}

bool emptyXcep::operator==(const emptyXcep& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool emptyXcep::operator<(const emptyXcep& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(emptyXcep& a, emptyXcep& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void emptyXcep::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t emptyXcep::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t emptyXcep::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t emptyXcep::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void emptyXcep::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t emptyXcep::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t emptyXcep::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t emptyXcep::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::complexException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::complexException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException(const complexException&) = default;
complexException& complexException::operator=(const complexException&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException() :
      errorEnum( ::cpp2::MyEnum::MyValue1) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

complexException::~complexException() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException(complexException&& other) noexcept  :
    message(std::move(other.message)),
    listStrings(std::move(other.listStrings)),
    errorEnum(std::move(other.errorEnum)),
    unionError(std::move(other.unionError)),
    structError(std::move(other.structError)),
    lsMap(std::move(other.lsMap)),
    __isset(other.__isset) {}
complexException& complexException::operator=(FOLLY_MAYBE_UNUSED complexException&& other) noexcept {
    this->message = std::move(other.message);
    this->listStrings = std::move(other.listStrings);
    this->errorEnum = std::move(other.errorEnum);
    this->unionError = std::move(other.unionError);
    this->structError = std::move(other.structError);
    this->lsMap = std::move(other.lsMap);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
complexException::complexException(apache::thrift::FragileConstructor, ::std::string message__arg, ::std::vector<::std::string> listStrings__arg, ::cpp2::MyEnum errorEnum__arg, ::cpp2::MyUnion unionError__arg, ::cpp2::MyStruct structError__arg, ::std::map<::std::int64_t, ::std::string> lsMap__arg) :
    message(std::move(message__arg)),
    listStrings(std::move(listStrings__arg)),
    errorEnum(std::move(errorEnum__arg)),
    unionError(std::move(unionError__arg)),
    structError(std::move(structError__arg)),
    lsMap(std::move(lsMap__arg)) {
  __isset.message = true;
  __isset.listStrings = true;
  __isset.errorEnum = true;
  __isset.unionError = true;
  __isset.structError = true;
  __isset.lsMap = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void complexException::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->listStrings.clear();
  this->errorEnum =  ::cpp2::MyEnum::MyValue1;
  this->unionError.__clear();
  this->structError.__clear();
  this->lsMap.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool complexException::operator==(const complexException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return false;
  }
  if (!(lhs.listStrings_ref() == rhs.listStrings_ref())) {
    return false;
  }
  if (!(lhs.errorEnum_ref() == rhs.errorEnum_ref())) {
    return false;
  }
  if (!(lhs.unionError_ref() == rhs.unionError_ref())) {
    return false;
  }
  if (!(lhs.structError_ref() == rhs.structError_ref())) {
    return false;
  }
  if (!(lhs.lsMap_ref() == rhs.lsMap_ref())) {
    return false;
  }
  return true;
}

bool complexException::operator<(const complexException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return lhs.message_ref() < rhs.message_ref();
  }
  if (!(lhs.listStrings_ref() == rhs.listStrings_ref())) {
    return lhs.listStrings_ref() < rhs.listStrings_ref();
  }
  if (!(lhs.errorEnum_ref() == rhs.errorEnum_ref())) {
    return lhs.errorEnum_ref() < rhs.errorEnum_ref();
  }
  if (!(lhs.unionError_ref() == rhs.unionError_ref())) {
    return lhs.unionError_ref() < rhs.unionError_ref();
  }
  if (!(lhs.structError_ref() == rhs.structError_ref())) {
    return lhs.structError_ref() < rhs.structError_ref();
  }
  if (!(lhs.lsMap_ref() == rhs.lsMap_ref())) {
    return lhs.lsMap_ref() < rhs.lsMap_ref();
  }
  return false;
}

const ::std::vector<::std::string>& complexException::get_listStrings() const& {
  return listStrings;
}

::std::vector<::std::string> complexException::get_listStrings() && {
  return std::move(listStrings);
}

const ::cpp2::MyUnion* complexException::get_unionError() const& {
  return unionError_ref().has_value() ? std::addressof(unionError) : nullptr;
}

::cpp2::MyUnion* complexException::get_unionError() & {
  return unionError_ref().has_value() ? std::addressof(unionError) : nullptr;
}

const ::cpp2::MyStruct& complexException::get_structError() const& {
  return structError;
}

::cpp2::MyStruct complexException::get_structError() && {
  return std::move(structError);
}

const ::std::map<::std::int64_t, ::std::string>& complexException::get_lsMap() const& {
  return lsMap;
}

::std::map<::std::int64_t, ::std::string> complexException::get_lsMap() && {
  return std::move(lsMap);
}


void swap(complexException& a, complexException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.listStrings_ref().value(), b.listStrings_ref().value());
  swap(a.errorEnum_ref().value(), b.errorEnum_ref().value());
  swap(a.unionError_ref().value_unchecked(), b.unionError_ref().value_unchecked());
  swap(a.structError_ref().value(), b.structError_ref().value());
  swap(a.lsMap_ref().value(), b.lsMap_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void complexException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t complexException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t complexException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t complexException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void complexException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t complexException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t complexException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t complexException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        complexException,
        ::apache::thrift::type_class::variant,
        ::cpp2::MyUnion>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        complexException,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyStruct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        complexException,
        ::apache::thrift::type_class::variant,
        ::cpp2::MyUnion>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        complexException,
        ::apache::thrift::type_class::structure,
        ::cpp2::MyStruct>,
    "inconsistent use of nimble option");

} // cpp2
