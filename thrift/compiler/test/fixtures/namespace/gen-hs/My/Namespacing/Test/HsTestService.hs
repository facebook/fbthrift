{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module My.Namespacing.Test.HsTestService where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import Control.Applicative (ZipList(..), (<*>))
import Control.Exception
import Control.Monad ( liftM, ap, when )
import Data.ByteString.Lazy (ByteString)
import Data.Functor ( (<$>) )
import Data.Hashable
import Data.Int
import Data.Maybe (catMaybes)
import Data.Text.Lazy.Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import Test.QuickCheck.Arbitrary ( Arbitrary(..) )
import Test.QuickCheck ( elements )

import Thrift hiding (ProtocolExnType(..))
import qualified Thrift (ProtocolExnType(..))
import Thrift.Types
import Thrift.Arbitraries


import My.Namespacing.Test.Hsmodule_Types
import qualified My.Namespacing.Test.HsTestService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Init_args = Init_args
  { init_args_int1 :: Int64
  } deriving (Show,Eq,Typeable)
instance Hashable Init_args where
  hashWithSalt salt record = salt   `hashWithSalt` init_args_int1 record  
instance Arbitrary Init_args where 
  arbitrary = liftM Init_args (arbitrary)
  shrink obj | obj == default_Init_args = []
             | otherwise = catMaybes
    [ if obj == default_Init_args{init_args_int1 = init_args_int1 obj} then Nothing else Just $ default_Init_args{init_args_int1 = init_args_int1 obj}
    ]
from_Init_args :: Init_args -> ThriftVal
from_Init_args record = TStruct $ Map.fromList $ catMaybes
  [ (\_v8 -> Just (1, ("int1",TI64 _v8))) $ init_args_int1 record
  ]
write_Init_args :: (Protocol p, Transport t) => p t -> Init_args -> IO ()
write_Init_args oprot record = writeVal oprot $ from_Init_args record
encode_Init_args :: (Protocol p, Transport t) => p t -> Init_args -> ByteString
encode_Init_args oprot record = serializeVal oprot $ from_Init_args record
to_Init_args :: ThriftVal -> Init_args
to_Init_args (TStruct fields) = Init_args{
  init_args_int1 = maybe (init_args_int1 default_Init_args) (\(_,_val10) -> (case _val10 of {TI64 _val11 -> _val11; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_Init_args _ = error "not a struct"
read_Init_args :: (Transport t, Protocol p) => p t -> IO Init_args
read_Init_args iprot = to_Init_args <$> readVal iprot (T_STRUCT typemap_Init_args)
decode_Init_args :: (Protocol p, Transport t) => p t -> ByteString -> Init_args
decode_Init_args iprot bs = to_Init_args $ deserializeVal iprot (T_STRUCT typemap_Init_args) bs
typemap_Init_args :: TypeMap
typemap_Init_args = Map.fromList [("int1",(1,T_I64))]
default_Init_args :: Init_args
default_Init_args = Init_args{
  init_args_int1 = 0}
data Init_result = Init_result
  { init_result_success :: Int64
  } deriving (Show,Eq,Typeable)
instance Hashable Init_result where
  hashWithSalt salt record = salt   `hashWithSalt` init_result_success record  
instance Arbitrary Init_result where 
  arbitrary = liftM Init_result (arbitrary)
  shrink obj | obj == default_Init_result = []
             | otherwise = catMaybes
    [ if obj == default_Init_result{init_result_success = init_result_success obj} then Nothing else Just $ default_Init_result{init_result_success = init_result_success obj}
    ]
from_Init_result :: Init_result -> ThriftVal
from_Init_result record = TStruct $ Map.fromList $ catMaybes
  [ (\_v14 -> Just (0, ("success",TI64 _v14))) $ init_result_success record
  ]
write_Init_result :: (Protocol p, Transport t) => p t -> Init_result -> IO ()
write_Init_result oprot record = writeVal oprot $ from_Init_result record
encode_Init_result :: (Protocol p, Transport t) => p t -> Init_result -> ByteString
encode_Init_result oprot record = serializeVal oprot $ from_Init_result record
to_Init_result :: ThriftVal -> Init_result
to_Init_result (TStruct fields) = Init_result{
  init_result_success = maybe (init_result_success default_Init_result) (\(_,_val16) -> (case _val16 of {TI64 _val17 -> _val17; _ -> error "wrong type"})) (Map.lookup (0) fields)
  }
to_Init_result _ = error "not a struct"
read_Init_result :: (Transport t, Protocol p) => p t -> IO Init_result
read_Init_result iprot = to_Init_result <$> readVal iprot (T_STRUCT typemap_Init_result)
decode_Init_result :: (Protocol p, Transport t) => p t -> ByteString -> Init_result
decode_Init_result iprot bs = to_Init_result $ deserializeVal iprot (T_STRUCT typemap_Init_result) bs
typemap_Init_result :: TypeMap
typemap_Init_result = Map.fromList [("success",(0,T_I64))]
default_Init_result :: Init_result
default_Init_result = Init_result{
  init_result_success = 0}
process_init (seqid, iprot, oprot, handler) = do
  args <- read_Init_args iprot
  (Control.Exception.catch
    (do
      val <- Iface.init handler (init_args_int1 args)
      let res = default_Init_result{init_result_success = val}
      writeMessage oprot ("init", M_REPLY, seqid) $
        write_Init_result oprot res
      tFlush (getTransport oprot))
    ((\_ -> do
      writeMessage oprot ("init", M_EXCEPTION, seqid) $
        writeAppExn oprot (AppExn AE_UNKNOWN "")
      tFlush (getTransport oprot)) :: SomeException -> IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "init" -> process_init (seqid,iprot,oprot,handler)
  _ -> do
    _ <- readVal iprot (T_STRUCT Map.empty)
    writeMessage oprot (name,M_EXCEPTION,seqid) $
      writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
    tFlush (getTransport oprot)
process handler (iprot, oprot) =
  readMessage iprot (proc_ handler (iprot,oprot)) >> return True
