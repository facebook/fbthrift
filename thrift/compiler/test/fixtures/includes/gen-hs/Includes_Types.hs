{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Includes_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq, succ,
                 pred, enumFrom, enumFromThen, enumFromThenTo,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import Data.List
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries


type IncludedInt64 = Int.Int64

data Included = Included
  { included_MyIntField :: Int.Int64
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable Included where
  encode = encode_Included
  decode = decode_Included
instance Hashable.Hashable Included where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` included_MyIntField record  
instance DeepSeq.NFData Included where
  rnf _record0 =
    DeepSeq.rnf (included_MyIntField _record0) `seq`
    ()
instance Arbitrary.Arbitrary Included where 
  arbitrary = Monad.liftM Included (Arbitrary.arbitrary)
  shrink obj | obj == default_Included = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_Included{included_MyIntField = included_MyIntField obj} then Nothing else Just $ default_Included{included_MyIntField = included_MyIntField obj}
    ]
from_Included :: Included -> Types.ThriftVal
from_Included record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("MyIntField",Types.TI64 _v3))) $ included_MyIntField record
  ]
write_Included :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Included -> IO ()
write_Included oprot record = Thrift.writeVal oprot $ from_Included record
encode_Included :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Included -> BS.ByteString
encode_Included oprot record = Thrift.serializeVal oprot $ from_Included record
to_Included :: Types.ThriftVal -> Included
to_Included (Types.TStruct fields) = Included{
  included_MyIntField = maybe (included_MyIntField default_Included) (\(_,_val5) -> (case _val5 of {Types.TI64 _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields)
  }
to_Included _ = error "not a struct"
read_Included :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO Included
read_Included iprot = to_Included <$> Thrift.readVal iprot (Types.T_STRUCT typemap_Included)
decode_Included :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> Included
decode_Included iprot bs = to_Included $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_Included) bs
typemap_Included :: Types.TypeMap
typemap_Included = Map.fromList [("MyIntField",(1,Types.T_I64))]
default_Included :: Included
default_Included = Included{
  included_MyIntField = 0}
