<?hh // strict
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/**
 * Original thrift enum:-
 * TestEnum
 */
enum TestEnum: int {
  UNKNOWN = 0;
  NEW_VALUE = 1;
}

enum TestUnionEnum: int {
  _EMPTY_ = 0;
  int_value = 1;
  str_value = 2;
  double_value = 3;
  list_of_strings = 4;
  map_of_string_to_ints = 5;
  struct_foo = 6;
}

/**
 * Original thrift struct:-
 * TestUnion
 */
class TestUnion implements \IThriftStruct, \IThriftUnion<TestUnionEnum> {
  use \ThriftUnionSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'int_value',
      'union' => true,
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'str_value',
      'union' => true,
      'type' => \TType::STRING,
    ),
    3 => shape(
      'var' => 'double_value',
      'union' => true,
      'type' => \TType::DOUBLE,
    ),
    4 => shape(
      'var' => 'list_of_strings',
      'union' => true,
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'map_of_string_to_ints',
      'union' => true,
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'struct_foo',
      'union' => true,
      'type' => \TType::STRUCT,
      'class' => Foo::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'int_value' => 1,
    'str_value' => 2,
    'double_value' => 3,
    'list_of_strings' => 4,
    'map_of_string_to_ints' => 5,
    'struct_foo' => 6,
  ];

  const type TConstructorShape = shape(
    ?'int_value' => ?int,
    ?'str_value' => ?string,
    ?'double_value' => ?float,
    ?'list_of_strings' => ?Vector<string>,
    ?'map_of_string_to_ints' => ?Map<string, int>,
    ?'struct_foo' => ?Foo,
  );

  const int STRUCTURAL_ID = 872350750526219001;
  /**
   * Original thrift field:-
   * 1: i32 int_value
   */
  public ?int $int_value;
  /**
   * Original thrift field:-
   * 2: string str_value
   */
  public ?string $str_value;
  /**
   * Original thrift field:-
   * 3: double double_value
   */
  public ?float $double_value;
  /**
   * Original thrift field:-
   * 4: list<string> list_of_strings
   */
  public ?Vector<string> $list_of_strings;
  /**
   * Original thrift field:-
   * 5: map<string, i32> map_of_string_to_ints
   */
  public ?Map<string, int> $map_of_string_to_ints;
  /**
   * Original thrift field:-
   * 6: struct module.Foo struct_foo
   */
  public ?Foo $struct_foo;
  protected TestUnionEnum $_type = TestUnionEnum::_EMPTY_;

  <<__Rx>>
  public function __construct(?int $int_value = null, ?string $str_value = null, ?float $double_value = null, ?Vector<string> $list_of_strings = null, ?Map<string, int> $map_of_string_to_ints = null, ?Foo $struct_foo = null  ) {
    $this->_type = TestUnionEnum::_EMPTY_;
    if ($int_value !== null) {
      $this->int_value = $int_value;
      $this->_type = TestUnionEnum::int_value;
    }
    if ($str_value !== null) {
      $this->str_value = $str_value;
      $this->_type = TestUnionEnum::str_value;
    }
    if ($double_value !== null) {
      $this->double_value = $double_value;
      $this->_type = TestUnionEnum::double_value;
    }
    if ($list_of_strings !== null) {
      $this->list_of_strings = $list_of_strings;
      $this->_type = TestUnionEnum::list_of_strings;
    }
    if ($map_of_string_to_ints !== null) {
      $this->map_of_string_to_ints = $map_of_string_to_ints;
      $this->_type = TestUnionEnum::map_of_string_to_ints;
    }
    if ($struct_foo !== null) {
      $this->struct_foo = $struct_foo;
      $this->_type = TestUnionEnum::struct_foo;
    }
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'int_value'),
      Shapes::idx($shape, 'str_value'),
      Shapes::idx($shape, 'double_value'),
      Shapes::idx($shape, 'list_of_strings'),
      Shapes::idx($shape, 'map_of_string_to_ints'),
      Shapes::idx($shape, 'struct_foo'),
    );
  }

  public function getName(): string {
    return 'TestUnion';
  }

  public function getType(): TestUnionEnum {
    return $this->_type;
  }

  public function reset(): void {
    switch ($this->_type) {
      case TestUnionEnum::int_value:
        $this->int_value = null;
        break;
      case TestUnionEnum::str_value:
        $this->str_value = null;
        break;
      case TestUnionEnum::double_value:
        $this->double_value = null;
        break;
      case TestUnionEnum::list_of_strings:
        $this->list_of_strings = null;
        break;
      case TestUnionEnum::map_of_string_to_ints:
        $this->map_of_string_to_ints = null;
        break;
      case TestUnionEnum::struct_foo:
        $this->struct_foo = null;
        break;
      case TestUnionEnum::_EMPTY_:
        break;
    }
    $this->_type = TestUnionEnum::_EMPTY_;
}

  public function set_int_value(int $int_value): this {
    $this->reset();
    $this->_type = TestUnionEnum::int_value;
    $this->int_value = $int_value;
    return $this;
  }

  public function get_int_value(): int {
    invariant(
      $this->_type === TestUnionEnum::int_value,
      'get_int_value called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->int_value as nonnull;
  }

  public function set_str_value(string $str_value): this {
    $this->reset();
    $this->_type = TestUnionEnum::str_value;
    $this->str_value = $str_value;
    return $this;
  }

  public function get_str_value(): string {
    invariant(
      $this->_type === TestUnionEnum::str_value,
      'get_str_value called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->str_value as nonnull;
  }

  public function set_double_value(float $double_value): this {
    $this->reset();
    $this->_type = TestUnionEnum::double_value;
    $this->double_value = $double_value;
    return $this;
  }

  public function get_double_value(): float {
    invariant(
      $this->_type === TestUnionEnum::double_value,
      'get_double_value called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->double_value as nonnull;
  }

  public function set_list_of_strings(Vector<string> $list_of_strings): this {
    $this->reset();
    $this->_type = TestUnionEnum::list_of_strings;
    $this->list_of_strings = $list_of_strings;
    return $this;
  }

  public function get_list_of_strings(): Vector<string> {
    invariant(
      $this->_type === TestUnionEnum::list_of_strings,
      'get_list_of_strings called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->list_of_strings as nonnull;
  }

  public function set_map_of_string_to_ints(Map<string, int> $map_of_string_to_ints): this {
    $this->reset();
    $this->_type = TestUnionEnum::map_of_string_to_ints;
    $this->map_of_string_to_ints = $map_of_string_to_ints;
    return $this;
  }

  public function get_map_of_string_to_ints(): Map<string, int> {
    invariant(
      $this->_type === TestUnionEnum::map_of_string_to_ints,
      'get_map_of_string_to_ints called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->map_of_string_to_ints as nonnull;
  }

  public function set_struct_foo(Foo $struct_foo): this {
    $this->reset();
    $this->_type = TestUnionEnum::struct_foo;
    $this->struct_foo = $struct_foo;
    return $this;
  }

  public function get_struct_foo(): Foo {
    invariant(
      $this->_type === TestUnionEnum::struct_foo,
      'get_struct_foo called on an instance of TestUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->struct_foo as nonnull;
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'int_value' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'str_value' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'double_value' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'list_of_strings' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'map_of_string_to_ints' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'struct_foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

}

/**
 * Original thrift struct:-
 * Foo
 */
class Foo implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::LST,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::LST,
        'etype' => \TType::SET,
        'elem' => shape(
          'type' => \TType::SET,
          'etype' => \TType::I32,
          'elem' => shape(
            'type' => \TType::I32,
          ),
          'format' => 'collection',
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'c',
      'type' => \TType::I64,
    ),
    4 => shape(
      'var' => 'd',
      'type' => \TType::BOOL,
    ),
    5 => shape(
      'var' => 'str_value',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
    'c' => 3,
    'd' => 4,
    'str_value' => 5,
  ];

  const type TConstructorShape = shape(
    ?'a' => Vector<string>,
    ?'b' => ?Map<string, Vector<Set<int>>>,
    ?'c' => int,
    ?'d' => bool,
    ?'str_value' => string,
  );

  const int STRUCTURAL_ID = 5952652426480946901;
  /**
   * Original thrift field:-
   * 1: list<string> a
   */
  public Vector<string> $a;
  /**
   * Original thrift field:-
   * 2: map<string, list<set<i32>>> b
   */
  public ?Map<string, Vector<Set<int>>> $b;
  /**
   * Original thrift field:-
   * 3: i64 c
   */
  public int $c;
  /**
   * Original thrift field:-
   * 4: bool d
   */
  public bool $d;
  /**
   * Original thrift field:-
   * 5: string str_value
   */
  public string $str_value;

  <<__Rx>>
  public function __construct(?Vector<string> $a = null, ?Map<string, Vector<Set<int>>> $b = null, ?int $c = null, ?bool $d = null, ?string $str_value = null  ) {
    $this->a = $a ?? Vector {};
    $this->b = $b;
    $this->c = $c ?? 7;
    $this->d = $d ?? false;
    $this->str_value = $str_value ?? "hello";
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
      Shapes::idx($shape, 'c'),
      Shapes::idx($shape, 'd'),
      Shapes::idx($shape, 'str_value'),
    );
  }

  public function getName(): string {
    return 'Foo';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'a' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'b' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'c' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'd' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'str_value' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

}

/**
 * Original thrift struct:-
 * TestStruct
 */
class TestStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo_struct',
      'type' => \TType::STRUCT,
      'class' => Foo::class,
    ),
    2 => shape(
      'var' => 'union_value',
      'type' => \TType::STRUCT,
      'class' => TestUnion::class,
    ),
    3 => shape(
      'var' => 'struct_of_self',
      'type' => \TType::STRUCT,
      'class' => TestStruct::class,
    ),
    4 => shape(
      'var' => 'list_of_struct_foo',
      'type' => \TType::LST,
      'etype' => \TType::STRUCT,
      'elem' => shape(
        'type' => \TType::STRUCT,
        'class' => Foo::class,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'map_of_string_to_struct_foo',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::STRUCT,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::STRUCT,
        'class' => Foo::class,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'list_of_struct_self',
      'type' => \TType::LST,
      'etype' => \TType::STRUCT,
      'elem' => shape(
        'type' => \TType::STRUCT,
        'class' => TestStruct::class,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo_struct' => 1,
    'union_value' => 2,
    'struct_of_self' => 3,
    'list_of_struct_foo' => 4,
    'map_of_string_to_struct_foo' => 5,
    'list_of_struct_self' => 6,
  ];

  const type TConstructorShape = shape(
    ?'foo_struct' => ?Foo,
    ?'union_value' => ?TestUnion,
    ?'struct_of_self' => ?TestStruct,
    ?'list_of_struct_foo' => Vector<Foo>,
    ?'map_of_string_to_struct_foo' => Map<string, Foo>,
    ?'list_of_struct_self' => Vector<TestStruct>,
  );

  const int STRUCTURAL_ID = 6681594433718475023;
  /**
   * Original thrift field:-
   * 1: struct module.Foo foo_struct
   */
  public ?Foo $foo_struct;
  /**
   * Original thrift field:-
   * 2: struct module.TestUnion union_value
   */
  public ?TestUnion $union_value;
  /**
   * Original thrift field:-
   * 3: struct module.TestStruct struct_of_self
   */
  public ?TestStruct $struct_of_self;
  /**
   * Original thrift field:-
   * 4: list<struct module.Foo> list_of_struct_foo
   */
  public Vector<Foo> $list_of_struct_foo;
  /**
   * Original thrift field:-
   * 5: map<string, struct module.Foo> map_of_string_to_struct_foo
   */
  public Map<string, Foo> $map_of_string_to_struct_foo;
  /**
   * Original thrift field:-
   * 6: list<struct module.TestStruct> list_of_struct_self
   */
  public Vector<TestStruct> $list_of_struct_self;

  <<__Rx>>
  public function __construct(?Foo $foo_struct = null, ?TestUnion $union_value = null, ?TestStruct $struct_of_self = null, ?Vector<Foo> $list_of_struct_foo = null, ?Map<string, Foo> $map_of_string_to_struct_foo = null, ?Vector<TestStruct> $list_of_struct_self = null  ) {
    $this->foo_struct = $foo_struct;
    $this->union_value = $union_value;
    $this->struct_of_self = $struct_of_self;
    $this->list_of_struct_foo = $list_of_struct_foo ?? Vector {};
    $this->map_of_string_to_struct_foo = $map_of_string_to_struct_foo ?? Map {};
    $this->list_of_struct_self = $list_of_struct_self ?? Vector {};
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'foo_struct'),
      Shapes::idx($shape, 'union_value'),
      Shapes::idx($shape, 'struct_of_self'),
      Shapes::idx($shape, 'list_of_struct_foo'),
      Shapes::idx($shape, 'map_of_string_to_struct_foo'),
      Shapes::idx($shape, 'list_of_struct_self'),
    );
  }

  public function getName(): string {
    return 'TestStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'foo_struct' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'union_value' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'struct_of_self' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'list_of_struct_foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'map_of_string_to_struct_foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'list_of_struct_self' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

}

/**
 * Original thrift exception:-
 * Baz
 */
class Baz extends \TException implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'message',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'some_field',
      'type' => \TType::STRUCT,
      'class' => Foo::class,
    ),
    3 => shape(
      'var' => 'some_container',
      'type' => \TType::SET,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'code',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'message' => 1,
    'some_field' => 2,
    'some_container' => 3,
    'code' => 4,
  ];

  const type TConstructorShape = shape(
    ?'message' => string,
    ?'some_field' => ?Foo,
    ?'some_container' => Set<string>,
    ?'code' => int,
  );

  const int STRUCTURAL_ID = 1663976252517274137;
  /**
   * Original thrift field:-
   * 1: string message
   */
  public string $message;
  /**
   * Original thrift field:-
   * 2: struct module.Foo some_field
   */
  public ?Foo $some_field;
  /**
   * Original thrift field:-
   * 3: set<string> some_container
   */
  public Set<string> $some_container;
  /**
   * Original thrift field:-
   * 4: i32 code
   */
  public int $code;

  <<__Rx>>
  public function __construct(?string $message = null, ?Foo $some_field = null, ?Set<string> $some_container = null, ?int $code = null  ) {
    parent::__construct();
    $this->message = $message ?? '';
    $this->some_field = $some_field;
    $this->some_container = $some_container ?? Set {};
    $this->code = $code ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'message'),
      Shapes::idx($shape, 'some_field'),
      Shapes::idx($shape, 'some_container'),
      Shapes::idx($shape, 'code'),
    );
  }

  public function getName(): string {
    return 'Baz';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'message' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'some_field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'some_container' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'code' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

}

/**
 * Original thrift exception:-
 * OptBaz
 */
class OptBaz extends \TException implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'message',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'message' => 1,
  ];

  const type TConstructorShape = shape(
    ?'message' => ?string,
  );

  const int STRUCTURAL_ID = 546500496397478593;
  /**
   * Original thrift field:-
   * 1: string message
   */
  public string $message;

  <<__Rx>>
  public function __construct(?string $message = null  ) {
    parent::__construct();
    $this->message = $message ?? '';
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'message'),
    );
  }

  public function getName(): string {
    return 'OptBaz';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'message' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

}

