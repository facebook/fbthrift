#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'Foo', 'Bar', 'SetWithAdapter', 'ListWithElemAdapter']

class Foo:
  """
  Attributes:
   - intField
   - optionalIntField
   - intFieldWithDefault
   - setField
   - optionalSetField
   - mapField
   - optionalMapField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.optionalIntField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intFieldWithDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.setField = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.optionalSetField = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in six.moves.range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.mapField = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in six.moves.range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = []
              (_etype24, _size21) = iprot.readListBegin()
              if _size21 >= 0:
                for _i25 in six.moves.range(_size21):
                  _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem26)
              else: 
                while iprot.peekList():
                  _elem27 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem27)
              iprot.readListEnd()
              self.mapField[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = []
              (_etype33, _size30) = iprot.readListBegin()
              if _size30 >= 0:
                for _i34 in six.moves.range(_size30):
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem35)
              else: 
                while iprot.peekList():
                  _elem36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem36)
              iprot.readListEnd()
              self.mapField[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.optionalMapField = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in six.moves.range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in six.moves.range(_size44):
                  _elem49 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.optionalMapField[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in six.moves.range(_size53):
                  _elem58 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.optionalMapField[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Foo')
    if self.intField != None:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      oprot.writeI32(self.intField)
      oprot.writeFieldEnd()
    if self.optionalIntField != None:
      oprot.writeFieldBegin('optionalIntField', TType.I32, 2)
      oprot.writeI32(self.optionalIntField)
      oprot.writeFieldEnd()
    if self.intFieldWithDefault != None:
      oprot.writeFieldBegin('intFieldWithDefault', TType.I32, 3)
      oprot.writeI32(self.intFieldWithDefault)
      oprot.writeFieldEnd()
    if self.setField != None:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.setField))
      for iter60 in self.setField:
        oprot.writeString(iter60.encode('utf-8')) if UTF8STRINGS and not isinstance(iter60, bytes) else oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optionalSetField != None:
      oprot.writeFieldBegin('optionalSetField', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.optionalSetField))
      for iter61 in self.optionalSetField:
        oprot.writeString(iter61.encode('utf-8')) if UTF8STRINGS and not isinstance(iter61, bytes) else oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mapField != None:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapField))
      for kiter62,viter63 in self.mapField.items():
        oprot.writeString(kiter62.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter62, bytes) else oprot.writeString(kiter62)
        oprot.writeListBegin(TType.STRING, len(viter63))
        for iter64 in viter63:
          oprot.writeString(iter64.encode('utf-8')) if UTF8STRINGS and not isinstance(iter64, bytes) else oprot.writeString(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optionalMapField != None:
      oprot.writeFieldBegin('optionalMapField', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.optionalMapField))
      for kiter65,viter66 in self.optionalMapField.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        oprot.writeListBegin(TType.STRING, len(viter66))
        for iter67 in viter66:
          oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'intField' in json_obj and json_obj['intField'] is not None:
      self.intField = json_obj['intField']
      if self.intField > 0x7fffffff or self.intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optionalIntField' in json_obj and json_obj['optionalIntField'] is not None:
      self.optionalIntField = json_obj['optionalIntField']
      if self.optionalIntField > 0x7fffffff or self.optionalIntField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'intFieldWithDefault' in json_obj and json_obj['intFieldWithDefault'] is not None:
      self.intFieldWithDefault = json_obj['intFieldWithDefault']
      if self.intFieldWithDefault > 0x7fffffff or self.intFieldWithDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'setField' in json_obj and json_obj['setField'] is not None:
      self.setField = set_cls()
      for _tmp_e68 in json_obj['setField']:
        self.setField.add(_tmp_e68)
    if 'optionalSetField' in json_obj and json_obj['optionalSetField'] is not None:
      self.optionalSetField = set_cls()
      for _tmp_e69 in json_obj['optionalSetField']:
        self.optionalSetField.add(_tmp_e69)
    if 'mapField' in json_obj and json_obj['mapField'] is not None:
      self.mapField = dict_cls()
      for _tmp_k70, _tmp_v71 in json_obj['mapField'].items():
        _tmp_kp72 = _tmp_k70
        _list73 = []
        for _tmp_e74 in _tmp_v71:
          _list73.append(_tmp_e74)
        self.mapField[_tmp_kp72] = _list73
    if 'optionalMapField' in json_obj and json_obj['optionalMapField'] is not None:
      self.optionalMapField = dict_cls()
      for _tmp_k75, _tmp_v76 in json_obj['optionalMapField'].items():
        _tmp_kp77 = _tmp_k75
        _list78 = []
        for _tmp_e79 in _tmp_v76:
          _list78.append(_tmp_e79)
        self.optionalMapField[_tmp_kp77] = _list78

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.intField is not None:
      value = pprint.pformat(self.intField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intField=%s' % (value))
    if self.optionalIntField is not None:
      value = pprint.pformat(self.optionalIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalIntField=%s' % (value))
    if self.intFieldWithDefault is not None:
      value = pprint.pformat(self.intFieldWithDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intFieldWithDefault=%s' % (value))
    if self.setField is not None:
      value = pprint.pformat(self.setField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    setField=%s' % (value))
    if self.optionalSetField is not None:
      value = pprint.pformat(self.optionalSetField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalSetField=%s' % (value))
    if self.mapField is not None:
      value = pprint.pformat(self.mapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapField=%s' % (value))
    if self.optionalMapField is not None:
      value = pprint.pformat(self.optionalMapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalMapField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Bar:
  """
  Attributes:
   - structField
   - optionalStructField
   - structListField
   - optionalStructListField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.structField = Foo()
          self.structField.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optionalStructField = Foo()
          self.optionalStructField.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.structListField = []
          (_etype83, _size80) = iprot.readListBegin()
          if _size80 >= 0:
            for _i84 in six.moves.range(_size80):
              _elem85 = Foo()
              _elem85.read(iprot)
              self.structListField.append(_elem85)
          else: 
            while iprot.peekList():
              _elem86 = Foo()
              _elem86.read(iprot)
              self.structListField.append(_elem86)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.optionalStructListField = []
          (_etype90, _size87) = iprot.readListBegin()
          if _size87 >= 0:
            for _i91 in six.moves.range(_size87):
              _elem92 = Foo()
              _elem92.read(iprot)
              self.optionalStructListField.append(_elem92)
          else: 
            while iprot.peekList():
              _elem93 = Foo()
              _elem93.read(iprot)
              self.optionalStructListField.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.structField != None:
      oprot.writeFieldBegin('structField', TType.STRUCT, 1)
      self.structField.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalStructField != None:
      oprot.writeFieldBegin('optionalStructField', TType.STRUCT, 2)
      self.optionalStructField.write(oprot)
      oprot.writeFieldEnd()
    if self.structListField != None:
      oprot.writeFieldBegin('structListField', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.structListField))
      for iter94 in self.structListField:
        iter94.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optionalStructListField != None:
      oprot.writeFieldBegin('optionalStructListField', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.optionalStructListField))
      for iter95 in self.optionalStructListField:
        iter95.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structField' in json_obj and json_obj['structField'] is not None:
      self.structField = Foo()
      self.structField.readFromJson(json_obj['structField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalStructField' in json_obj and json_obj['optionalStructField'] is not None:
      self.optionalStructField = Foo()
      self.optionalStructField.readFromJson(json_obj['optionalStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structListField' in json_obj and json_obj['structListField'] is not None:
      self.structListField = []
      for _tmp_e96 in json_obj['structListField']:
        _struct97 = Foo()
        _struct97.readFromJson(_tmp_e96, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.structListField.append(_struct97)
    if 'optionalStructListField' in json_obj and json_obj['optionalStructListField'] is not None:
      self.optionalStructListField = []
      for _tmp_e98 in json_obj['optionalStructListField']:
        _struct99 = Foo()
        _struct99.readFromJson(_tmp_e98, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.optionalStructListField.append(_struct99)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structField is not None:
      value = pprint.pformat(self.structField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structField=%s' % (value))
    if self.optionalStructField is not None:
      value = pprint.pformat(self.optionalStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructField=%s' % (value))
    if self.structListField is not None:
      value = pprint.pformat(self.structListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structListField=%s' % (value))
    if self.optionalStructListField is not None:
      value = pprint.pformat(self.optionalStructListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructListField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

SetWithAdapter = UnimplementedTypedef()
ListWithElemAdapter = UnimplementedTypedef()
all_structs.append(Foo)
Foo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (2, TType.I32, 'optionalIntField', None, None, 1, ), # 2
  (3, TType.I32, 'intFieldWithDefault', None, 13, 2, ), # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (5, TType.SET, 'optionalSetField', (TType.STRING,True), None, 1, ), # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (7, TType.MAP, 'optionalMapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 1, ), # 7
)

Foo.thrift_struct_annotations = {
}
Foo.thrift_field_annotations = {
}

def Foo__init__(self, intField=None, optionalIntField=None, intFieldWithDefault=Foo.thrift_spec[3][4], setField=None, optionalSetField=None, mapField=None, optionalMapField=None,):
  self.intField = intField
  self.optionalIntField = optionalIntField
  self.intFieldWithDefault = intFieldWithDefault
  self.setField = setField
  self.optionalSetField = optionalSetField
  self.mapField = mapField
  self.optionalMapField = optionalMapField

Foo.__init__ = Foo__init__

def Foo__setstate__(self, state):
  state.setdefault('intField', None)
  state.setdefault('optionalIntField', None)
  state.setdefault('intFieldWithDefault', 13)
  state.setdefault('setField', None)
  state.setdefault('optionalSetField', None)
  state.setdefault('mapField', None)
  state.setdefault('optionalMapField', None)
  self.__dict__ = state

Foo.__getstate__ = lambda self: self.__dict__.copy()
Foo.__setstate__ = Foo__setstate__

all_structs.append(Bar)
Bar.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'structField', [Foo, Foo.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'optionalStructField', [Foo, Foo.thrift_spec, False], None, 1, ), # 2
  (3, TType.LIST, 'structListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False]), None, 2, ), # 3
  (4, TType.LIST, 'optionalStructListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False]), None, 1, ), # 4
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, structField=None, optionalStructField=None, structListField=None, optionalStructListField=None,):
  self.structField = structField
  self.optionalStructField = optionalStructField
  self.structListField = structListField
  self.optionalStructListField = optionalStructListField

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('structField', None)
  state.setdefault('optionalStructField', None)
  state.setdefault('structListField', None)
  state.setdefault('optionalStructListField', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

fix_spec(all_structs)
del all_structs
