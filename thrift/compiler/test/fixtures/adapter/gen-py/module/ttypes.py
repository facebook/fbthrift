#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.cpp.ttypes

import my


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'Foo', 'Baz', 'Bar', 'StructWithFieldAdapter', 'SetWithAdapter', 'ListWithElemAdapter', 'StructWithAdapter', 'UnionWithAdapter']

class Foo:
  """
  Attributes:
   - intField
   - optionalIntField
   - intFieldWithDefault
   - setField
   - optionalSetField
   - mapField
   - optionalMapField
   - binaryField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.optionalIntField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intFieldWithDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.setField = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.optionalSetField = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.mapField = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = []
              (_etype24, _size21) = iprot.readListBegin()
              if _size21 >= 0:
                for _i25 in range(_size21):
                  _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem26)
              else: 
                while iprot.peekList():
                  _elem27 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem27)
              iprot.readListEnd()
              self.mapField[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = []
              (_etype33, _size30) = iprot.readListBegin()
              if _size30 >= 0:
                for _i34 in range(_size30):
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem35)
              else: 
                while iprot.peekList():
                  _elem36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem36)
              iprot.readListEnd()
              self.mapField[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.optionalMapField = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in range(_size44):
                  _elem49 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.optionalMapField[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in range(_size53):
                  _elem58 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.optionalMapField[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryField = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Foo')
    if self.intField != None:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      oprot.writeI32(self.intField)
      oprot.writeFieldEnd()
    if self.optionalIntField != None:
      oprot.writeFieldBegin('optionalIntField', TType.I32, 2)
      oprot.writeI32(self.optionalIntField)
      oprot.writeFieldEnd()
    if self.intFieldWithDefault != None:
      oprot.writeFieldBegin('intFieldWithDefault', TType.I32, 3)
      oprot.writeI32(self.intFieldWithDefault)
      oprot.writeFieldEnd()
    if self.setField != None:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.setField))
      for iter60 in self.setField:
        oprot.writeString(iter60.encode('utf-8')) if UTF8STRINGS and not isinstance(iter60, bytes) else oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optionalSetField != None:
      oprot.writeFieldBegin('optionalSetField', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.optionalSetField))
      for iter61 in self.optionalSetField:
        oprot.writeString(iter61.encode('utf-8')) if UTF8STRINGS and not isinstance(iter61, bytes) else oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mapField != None:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapField))
      for kiter62,viter63 in self.mapField.items():
        oprot.writeString(kiter62.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter62, bytes) else oprot.writeString(kiter62)
        oprot.writeListBegin(TType.STRING, len(viter63))
        for iter64 in viter63:
          oprot.writeString(iter64.encode('utf-8')) if UTF8STRINGS and not isinstance(iter64, bytes) else oprot.writeString(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optionalMapField != None:
      oprot.writeFieldBegin('optionalMapField', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.optionalMapField))
      for kiter65,viter66 in self.optionalMapField.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        oprot.writeListBegin(TType.STRING, len(viter66))
        for iter67 in viter66:
          oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.binaryField != None:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      oprot.writeString(self.binaryField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'intField' in json_obj and json_obj['intField'] is not None:
      self.intField = json_obj['intField']
      if self.intField > 0x7fffffff or self.intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optionalIntField' in json_obj and json_obj['optionalIntField'] is not None:
      self.optionalIntField = json_obj['optionalIntField']
      if self.optionalIntField > 0x7fffffff or self.optionalIntField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'intFieldWithDefault' in json_obj and json_obj['intFieldWithDefault'] is not None:
      self.intFieldWithDefault = json_obj['intFieldWithDefault']
      if self.intFieldWithDefault > 0x7fffffff or self.intFieldWithDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'setField' in json_obj and json_obj['setField'] is not None:
      self.setField = set_cls()
      for _tmp_e68 in json_obj['setField']:
        self.setField.add(_tmp_e68)
    if 'optionalSetField' in json_obj and json_obj['optionalSetField'] is not None:
      self.optionalSetField = set_cls()
      for _tmp_e69 in json_obj['optionalSetField']:
        self.optionalSetField.add(_tmp_e69)
    if 'mapField' in json_obj and json_obj['mapField'] is not None:
      self.mapField = dict_cls()
      for _tmp_k70, _tmp_v71 in json_obj['mapField'].items():
        _tmp_kp72 = _tmp_k70
        _list73 = []
        for _tmp_e74 in _tmp_v71:
          _list73.append(_tmp_e74)
        self.mapField[_tmp_kp72] = _list73
    if 'optionalMapField' in json_obj and json_obj['optionalMapField'] is not None:
      self.optionalMapField = dict_cls()
      for _tmp_k75, _tmp_v76 in json_obj['optionalMapField'].items():
        _tmp_kp77 = _tmp_k75
        _list78 = []
        for _tmp_e79 in _tmp_v76:
          _list78.append(_tmp_e79)
        self.optionalMapField[_tmp_kp77] = _list78
    if 'binaryField' in json_obj and json_obj['binaryField'] is not None:
      self.binaryField = json_obj['binaryField']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.intField is not None:
      value = pprint.pformat(self.intField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intField=%s' % (value))
    if self.optionalIntField is not None:
      value = pprint.pformat(self.optionalIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalIntField=%s' % (value))
    if self.intFieldWithDefault is not None:
      value = pprint.pformat(self.intFieldWithDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intFieldWithDefault=%s' % (value))
    if self.setField is not None:
      value = pprint.pformat(self.setField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    setField=%s' % (value))
    if self.optionalSetField is not None:
      value = pprint.pformat(self.optionalSetField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalSetField=%s' % (value))
    if self.mapField is not None:
      value = pprint.pformat(self.mapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapField=%s' % (value))
    if self.optionalMapField is not None:
      value = pprint.pformat(self.optionalMapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalMapField=%s' % (value))
    if self.binaryField is not None:
      value = pprint.pformat(self.binaryField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Baz(object):
  """
  Attributes:
   - intField
   - setField
   - mapField
   - binaryField
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INTFIELD = 1
  SETFIELD = 4
  MAPFIELD = 6
  BINARYFIELD = 8
  
  @staticmethod
  def isUnion():
    return True

  def get_intField(self):
    assert self.field == 1
    return self.value

  def get_setField(self):
    assert self.field == 4
    return self.value

  def get_mapField(self):
    assert self.field == 6
    return self.value

  def get_binaryField(self):
    assert self.field == 8
    return self.value

  def set_intField(self, value):
    self.field = 1
    self.value = value

  def set_setField(self, value):
    self.field = 4
    self.value = value

  def set_mapField(self, value):
    self.field = 6
    self.value = value

  def set_binaryField(self, value):
    self.field = 8
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('intField', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('setField', value)
    if self.field == 6:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mapField', value)
    if self.field == 8:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binaryField', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          intField = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_intField(intField)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          setField = set()
          (_etype83, _size80) = iprot.readSetBegin()
          if _size80 >= 0:
            for _i84 in range(_size80):
              _elem85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              setField.add(_elem85)
          else: 
            while iprot.peekSet():
              _elem86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              setField.add(_elem86)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_setField(setField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          mapField = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          if _size87 >= 0:
            for _i91 in range(_size87):
              _key92 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val93 = []
              (_etype97, _size94) = iprot.readListBegin()
              if _size94 >= 0:
                for _i98 in range(_size94):
                  _elem99 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem99)
              else: 
                while iprot.peekList():
                  _elem100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem100)
              iprot.readListEnd()
              mapField[_key92] = _val93
          else: 
            while iprot.peekMap():
              _key101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val102 = []
              (_etype106, _size103) = iprot.readListBegin()
              if _size103 >= 0:
                for _i107 in range(_size103):
                  _elem108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem108)
              else: 
                while iprot.peekList():
                  _elem109 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem109)
              iprot.readListEnd()
              mapField[_key101] = _val102
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_mapField(mapField)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          binaryField = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binaryField(binaryField)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Baz')
    if self.field == 1:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      intField = self.value
      oprot.writeI32(intField)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      setField = self.value
      oprot.writeSetBegin(TType.STRING, len(setField))
      for iter110 in setField:
        oprot.writeString(iter110.encode('utf-8')) if UTF8STRINGS and not isinstance(iter110, bytes) else oprot.writeString(iter110)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      mapField = self.value
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(mapField))
      for kiter111,viter112 in mapField.items():
        oprot.writeString(kiter111.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter111, bytes) else oprot.writeString(kiter111)
        oprot.writeListBegin(TType.STRING, len(viter112))
        for iter113 in viter112:
          oprot.writeString(iter113.encode('utf-8')) if UTF8STRINGS and not isinstance(iter113, bytes) else oprot.writeString(iter113)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      binaryField = self.value
      oprot.writeString(binaryField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'intField' in obj:
      intField = obj['intField']
      if intField > 0x7fffffff or intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_intField(intField)
    if 'setField' in obj:
      setField = set_cls()
      for _tmp_e114 in obj['setField']:
        setField.add(_tmp_e114)
      self.set_setField(setField)
    if 'mapField' in obj:
      mapField = dict_cls()
      for _tmp_k115, _tmp_v116 in obj['mapField'].items():
        _tmp_kp117 = _tmp_k115
        _list118 = []
        for _tmp_e119 in _tmp_v116:
          _list118.append(_tmp_e119)
        mapField[_tmp_kp117] = _list118
      self.set_mapField(mapField)
    if 'binaryField' in obj:
      binaryField = obj['binaryField']
      self.set_binaryField(binaryField)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Bar:
  """
  Attributes:
   - structField
   - optionalStructField
   - structListField
   - optionalStructListField
   - unionField
   - optionalUnionField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.structField = Foo()
          self.structField.read(iprot)
          self.structField = my.Adapter1.from_thrift(self.structField)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optionalStructField = Foo()
          self.optionalStructField.read(iprot)
          self.optionalStructField = my.Adapter1.from_thrift(self.optionalStructField)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.structListField = []
          (_etype123, _size120) = iprot.readListBegin()
          if _size120 >= 0:
            for _i124 in range(_size120):
              _elem125 = Foo()
              _elem125.read(iprot)
              _elem125 = my.Adapter1.from_thrift(_elem125)
              self.structListField.append(_elem125)
          else: 
            while iprot.peekList():
              _elem126 = Foo()
              _elem126.read(iprot)
              _elem126 = my.Adapter1.from_thrift(_elem126)
              self.structListField.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.optionalStructListField = []
          (_etype130, _size127) = iprot.readListBegin()
          if _size127 >= 0:
            for _i131 in range(_size127):
              _elem132 = Foo()
              _elem132.read(iprot)
              _elem132 = my.Adapter1.from_thrift(_elem132)
              self.optionalStructListField.append(_elem132)
          else: 
            while iprot.peekList():
              _elem133 = Foo()
              _elem133.read(iprot)
              _elem133 = my.Adapter1.from_thrift(_elem133)
              self.optionalStructListField.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.unionField = Baz()
          self.unionField.read(iprot)
          self.unionField = my.Adapter1.from_thrift(self.unionField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.optionalUnionField = Baz()
          self.optionalUnionField.read(iprot)
          self.optionalUnionField = my.Adapter1.from_thrift(self.optionalUnionField)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.structField != None:
      oprot.writeFieldBegin('structField', TType.STRUCT, 1)
      adpt134 = my.Adapter1.to_thrift(self.structField)
      adpt134.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalStructField != None:
      oprot.writeFieldBegin('optionalStructField', TType.STRUCT, 2)
      adpt135 = my.Adapter1.to_thrift(self.optionalStructField)
      adpt135.write(oprot)
      oprot.writeFieldEnd()
    if self.structListField != None:
      oprot.writeFieldBegin('structListField', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.structListField))
      for iter136 in self.structListField:
        adpt137 = my.Adapter1.to_thrift(iter136)
        adpt137.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optionalStructListField != None:
      oprot.writeFieldBegin('optionalStructListField', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.optionalStructListField))
      for iter138 in self.optionalStructListField:
        adpt139 = my.Adapter1.to_thrift(iter138)
        adpt139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unionField != None:
      oprot.writeFieldBegin('unionField', TType.STRUCT, 5)
      adpt140 = my.Adapter1.to_thrift(self.unionField)
      adpt140.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalUnionField != None:
      oprot.writeFieldBegin('optionalUnionField', TType.STRUCT, 6)
      adpt141 = my.Adapter1.to_thrift(self.optionalUnionField)
      adpt141.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structField' in json_obj and json_obj['structField'] is not None:
      self.structField = Foo()
      self.structField.readFromJson(json_obj['structField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalStructField' in json_obj and json_obj['optionalStructField'] is not None:
      self.optionalStructField = Foo()
      self.optionalStructField.readFromJson(json_obj['optionalStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structListField' in json_obj and json_obj['structListField'] is not None:
      self.structListField = []
      for _tmp_e142 in json_obj['structListField']:
        _struct143 = Foo()
        _struct143.readFromJson(_tmp_e142, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.structListField.append(_struct143)
    if 'optionalStructListField' in json_obj and json_obj['optionalStructListField'] is not None:
      self.optionalStructListField = []
      for _tmp_e144 in json_obj['optionalStructListField']:
        _struct145 = Foo()
        _struct145.readFromJson(_tmp_e144, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.optionalStructListField.append(_struct145)
    if 'unionField' in json_obj and json_obj['unionField'] is not None:
      self.unionField = Baz()
      self.unionField.readFromJson(json_obj['unionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalUnionField' in json_obj and json_obj['optionalUnionField'] is not None:
      self.optionalUnionField = Baz()
      self.optionalUnionField.readFromJson(json_obj['optionalUnionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structField is not None:
      value = pprint.pformat(self.structField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structField=%s' % (value))
    if self.optionalStructField is not None:
      value = pprint.pformat(self.optionalStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructField=%s' % (value))
    if self.structListField is not None:
      value = pprint.pformat(self.structListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structListField=%s' % (value))
    if self.optionalStructListField is not None:
      value = pprint.pformat(self.optionalStructListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructListField=%s' % (value))
    if self.unionField is not None:
      value = pprint.pformat(self.unionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionField=%s' % (value))
    if self.optionalUnionField is not None:
      value = pprint.pformat(self.optionalUnionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalUnionField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StructWithFieldAdapter:
  """
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithFieldAdapter')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

SetWithAdapter = UnimplementedTypedef()
ListWithElemAdapter = UnimplementedTypedef()
StructWithAdapter = my.Adapter2.Type
UnionWithAdapter = my.Adapter2.Type
all_structs.append(Foo)
Foo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (2, TType.I32, 'optionalIntField', None, None, 1, ), # 2
  (3, TType.I32, 'intFieldWithDefault', None, 13, 2, ), # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (5, TType.SET, 'optionalSetField', (TType.STRING,True), None, 1, ), # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (7, TType.MAP, 'optionalMapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 1, ), # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
)

Foo.thrift_struct_annotations = {
}
Foo.thrift_field_annotations = {
}

def Foo__init__(self, intField=None, optionalIntField=None, intFieldWithDefault=Foo.thrift_spec[3][4], setField=None, optionalSetField=None, mapField=None, optionalMapField=None, binaryField=None,):
  self.intField = intField
  self.optionalIntField = optionalIntField
  self.intFieldWithDefault = intFieldWithDefault
  self.setField = setField
  self.optionalSetField = optionalSetField
  self.mapField = mapField
  self.optionalMapField = optionalMapField
  self.binaryField = binaryField

Foo.__init__ = Foo__init__

def Foo__setstate__(self, state):
  state.setdefault('intField', None)
  state.setdefault('optionalIntField', None)
  state.setdefault('intFieldWithDefault', 13)
  state.setdefault('setField', None)
  state.setdefault('optionalSetField', None)
  state.setdefault('mapField', None)
  state.setdefault('optionalMapField', None)
  state.setdefault('binaryField', None)
  self.__dict__ = state

Foo.__getstate__ = lambda self: self.__dict__.copy()
Foo.__setstate__ = Foo__setstate__

all_structs.append(Baz)
Baz.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  None, # 2
  None, # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  None, # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  None, # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
)

Baz.thrift_struct_annotations = {
}
Baz.thrift_field_annotations = {
}

def Baz__init__(self, intField=None, setField=None, mapField=None, binaryField=None,):
  self.field = 0
  self.value = None
  if intField is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = intField
  if setField is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = setField
  if mapField is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = mapField
  if binaryField is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = binaryField

Baz.__init__ = Baz__init__

all_structs.append(Bar)
Bar.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'structField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 2, ), # 1
  (2, TType.STRUCT, 'optionalStructField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 1, ), # 2
  (3, TType.LIST, 'structListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 2, ), # 3
  (4, TType.LIST, 'optionalStructListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 1, ), # 4
  (5, TType.STRUCT, 'unionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 2, ), # 5
  (6, TType.STRUCT, 'optionalUnionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 1, ), # 6
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, structField=None, optionalStructField=None, structListField=None, optionalStructListField=None, unionField=None, optionalUnionField=None,):
  self.structField = structField
  self.optionalStructField = optionalStructField
  self.structListField = structListField
  self.optionalStructListField = optionalStructListField
  self.unionField = unionField
  self.optionalUnionField = optionalUnionField

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('structField', None)
  state.setdefault('optionalStructField', None)
  state.setdefault('structListField', None)
  state.setdefault('optionalStructListField', None)
  state.setdefault('unionField', None)
  state.setdefault('optionalUnionField', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(StructWithFieldAdapter)
StructWithFieldAdapter.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
)

StructWithFieldAdapter.thrift_struct_annotations = {
}
StructWithFieldAdapter.thrift_field_annotations = {
}

def StructWithFieldAdapter__init__(self, field=None,):
  self.field = field

StructWithFieldAdapter.__init__ = StructWithFieldAdapter__init__

def StructWithFieldAdapter__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

StructWithFieldAdapter.__getstate__ = lambda self: self.__dict__.copy()
StructWithFieldAdapter.__setstate__ = StructWithFieldAdapter__setstate__

fix_spec(all_structs)
del all_structs
