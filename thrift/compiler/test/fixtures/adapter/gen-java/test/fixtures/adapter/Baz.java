/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package test.fixtures.adapter;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import com.facebook.thrift.*;
import com.facebook.thrift.annotations.*;
import com.facebook.thrift.async.*;
import com.facebook.thrift.meta_data.*;
import com.facebook.thrift.server.*;
import com.facebook.thrift.transport.*;
import com.facebook.thrift.protocol.*;

@SuppressWarnings({ "unused", "serial", "unchecked" })
public class Baz extends TUnion<Baz> implements Comparable<Baz> {
  private static final TStruct STRUCT_DESC = new TStruct("Baz");
  private static final TField INT_FIELD_FIELD_DESC = new TField("intField", TType.I32, (short)1);
  private static final TField SET_FIELD_FIELD_DESC = new TField("setField", TType.SET, (short)4);
  private static final TField MAP_FIELD_FIELD_DESC = new TField("mapField", TType.MAP, (short)6);
  private static final TField BINARY_FIELD_FIELD_DESC = new TField("binaryField", TType.STRING, (short)8);

  public static final int INTFIELD = 1;
  public static final int SETFIELD = 4;
  public static final int MAPFIELD = 6;
  public static final int BINARYFIELD = 8;

  public static final Map<Integer, FieldMetaData> metaDataMap;

  static {
    Map<Integer, FieldMetaData> tmpMetaDataMap = new HashMap<Integer, FieldMetaData>();
    tmpMetaDataMap.put(INTFIELD, new FieldMetaData("intField", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32)));
    tmpMetaDataMap.put(SETFIELD, new FieldMetaData("setField", TFieldRequirementType.DEFAULT, 
        new SetMetaData(TType.SET, 
            new FieldValueMetaData(TType.STRING))));
    tmpMetaDataMap.put(MAPFIELD, new FieldMetaData("mapField", TFieldRequirementType.DEFAULT, 
        new MapMetaData(TType.MAP, 
            new FieldValueMetaData(TType.STRING), 
            new ListMetaData(TType.LIST, 
                new FieldValueMetaData(TType.STRING)))));
    tmpMetaDataMap.put(BINARYFIELD, new FieldMetaData("binaryField", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING)));
    metaDataMap = Collections.unmodifiableMap(tmpMetaDataMap);
  }

  public Baz() {
    super();
  }

  public Baz(int setField, Object __value) {
    super(setField, __value);
  }

  public Baz(Baz other) {
    super(other);
  }

  public Baz deepCopy() {
    return new Baz(this);
  }

  public static Baz intField(int __value) {
    Baz x = new Baz();
    x.setIntField(__value);
    return x;
  }

  public static Baz setField(Set<String> __value) {
    Baz x = new Baz();
    x.setSetField(__value);
    return x;
  }

  public static Baz mapField(Map<String,List<String>> __value) {
    Baz x = new Baz();
    x.setMapField(__value);
    return x;
  }

  public static Baz binaryField(byte[] __value) {
    Baz x = new Baz();
    x.setBinaryField(__value);
    return x;
  }


  @Override
  protected void checkType(short setField, Object __value) throws ClassCastException {
    switch (setField) {
      case INTFIELD:
        if (__value instanceof Integer) {
          break;
        }
        throw new ClassCastException("Was expecting value of type Integer for field 'intField', but got " + __value.getClass().getSimpleName());
      case SETFIELD:
        if (__value instanceof Set) {
          break;
        }
        throw new ClassCastException("Was expecting value of type Set<String> for field 'setField', but got " + __value.getClass().getSimpleName());
      case MAPFIELD:
        if (__value instanceof Map) {
          break;
        }
        throw new ClassCastException("Was expecting value of type Map<String,List<String>> for field 'mapField', but got " + __value.getClass().getSimpleName());
      case BINARYFIELD:
        if (__value instanceof byte[]) {
          break;
        }
        throw new ClassCastException("Was expecting value of type byte[] for field 'binaryField', but got " + __value.getClass().getSimpleName());
      default:
        throw new IllegalArgumentException("Unknown field id " + setField);
    }
  }

  @Override
  public void read(TProtocol iprot) throws TException {
    setField_ = 0;
    value_ = null;
    iprot.readStructBegin(metaDataMap);
    TField __field = iprot.readFieldBegin();
    if (__field.type != TType.STOP)
    {
      value_ = readValue(iprot, __field);
      if (value_ != null)
      {
        switch (__field.id) {
          case INTFIELD:
            if (__field.type == INT_FIELD_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
          case SETFIELD:
            if (__field.type == SET_FIELD_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
          case MAPFIELD:
            if (__field.type == MAP_FIELD_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
          case BINARYFIELD:
            if (__field.type == BINARY_FIELD_FIELD_DESC.type) {
              setField_ = __field.id;
            }
            break;
        }
      }
      iprot.readFieldEnd();
      TField __stopField = iprot.readFieldBegin();
      if (__stopField.type != TType.STOP) {
        throw new TProtocolException(TProtocolException.INVALID_DATA, "Union 'Baz' is missing a STOP byte");
      }
    }
    iprot.readStructEnd();
  }

  @Override
  protected Object readValue(TProtocol iprot, TField __field) throws TException {
    switch (__field.id) {
      case INTFIELD:
        if (__field.type == INT_FIELD_FIELD_DESC.type) {
          Integer intField;
          intField = iprot.readI32();
          return intField;
        }
        break;
      case SETFIELD:
        if (__field.type == SET_FIELD_FIELD_DESC.type) {
          Set<String> setField;
          {
            TSet _set26 = iprot.readSetBegin();
            setField = new HashSet<String>(Math.max(0, 2*_set26.size));
            for (int _i27 = 0; 
                 (_set26.size < 0) ? iprot.peekSet() : (_i27 < _set26.size); 
                 ++_i27)
            {
              String _elem28;
              _elem28 = iprot.readString();
              setField.add(_elem28);
            }
            iprot.readSetEnd();
          }
          return setField;
        }
        break;
      case MAPFIELD:
        if (__field.type == MAP_FIELD_FIELD_DESC.type) {
          Map<String,List<String>> mapField;
          {
            TMap _map29 = iprot.readMapBegin();
            mapField = new HashMap<String,List<String>>(Math.max(0, 2*_map29.size));
            for (int _i30 = 0; 
                 (_map29.size < 0) ? iprot.peekMap() : (_i30 < _map29.size); 
                 ++_i30)
            {
              String _key31;
              List<String> _val32;
              _key31 = iprot.readString();
              {
                TList _list33 = iprot.readListBegin();
                _val32 = new ArrayList<String>(Math.max(0, _list33.size));
                for (int _i34 = 0; 
                     (_list33.size < 0) ? iprot.peekList() : (_i34 < _list33.size); 
                     ++_i34)
                {
                  String _elem35;
                  _elem35 = iprot.readString();
                  _val32.add(_elem35);
                }
                iprot.readListEnd();
              }
              mapField.put(_key31, _val32);
            }
            iprot.readMapEnd();
          }
          return mapField;
        }
        break;
      case BINARYFIELD:
        if (__field.type == BINARY_FIELD_FIELD_DESC.type) {
          byte[] binaryField;
          binaryField = iprot.readBinary();
          return binaryField;
        }
        break;
    }
    TProtocolUtil.skip(iprot, __field.type);
    return null;
  }

  @Override
  protected void writeValue(TProtocol oprot, short setField, Object __value) throws TException {
    switch (setField) {
      case INTFIELD:
        Integer intField = (Integer)getFieldValue();
        oprot.writeI32(intField);
        return;
      case SETFIELD:
        Set<String> setField = (Set<String>)getFieldValue();
        {
          oprot.writeSetBegin(new TSet(TType.STRING, setField.size()));
          for (String _iter36 : setField)          {
            oprot.writeString(_iter36);
          }
          oprot.writeSetEnd();
        }
        return;
      case MAPFIELD:
        Map<String,List<String>> mapField = (Map<String,List<String>>)getFieldValue();
        {
          oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, mapField.size()));
          for (Map.Entry<String, List<String>> _iter37 : mapField.entrySet())          {
            oprot.writeString(_iter37.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRING, _iter37.getValue().size()));
              for (String _iter38 : _iter37.getValue())              {
                oprot.writeString(_iter38);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        return;
      case BINARYFIELD:
        byte[] binaryField = (byte[])getFieldValue();
        oprot.writeBinary(binaryField);
        return;
      default:
        throw new IllegalStateException("Cannot write union with unknown field " + setField);
    }
  }

  @Override
  protected TField getFieldDesc(int setField) {
    switch (setField) {
      case INTFIELD:
        return INT_FIELD_FIELD_DESC;
      case SETFIELD:
        return SET_FIELD_FIELD_DESC;
      case MAPFIELD:
        return MAP_FIELD_FIELD_DESC;
      case BINARYFIELD:
        return BINARY_FIELD_FIELD_DESC;
      default:
        throw new IllegalArgumentException("Unknown field id " + setField);
    }
  }

  @Override
  protected TStruct getStructDesc() {
    return STRUCT_DESC;
  }

  @Override
  protected Map<Integer, FieldMetaData> getMetaDataMap() { return metaDataMap; }

  private Object __getValue(int expectedFieldId) {
    if (getSetField() == expectedFieldId) {
      return getFieldValue();
    } else {
      throw new RuntimeException("Cannot get field '" + getFieldDesc(expectedFieldId).name + "' because union is currently set to " + getFieldDesc(getSetField()).name);
    }
  }

  private void __setValue(int fieldId, Object __value) {
    if (__value == null) throw new NullPointerException();
    setField_ = fieldId;
    value_ = __value;
  }

  public int getIntField() {
    return (Integer) __getValue(INTFIELD);
  }

  public void setIntField(int __value) {
    setField_ = INTFIELD;
    value_ = __value;
  }

  public Set<String> getSetField() {
    return (Set<String>) __getValue(SETFIELD);
  }

  public void setSetField(Set<String> __value) {
    __setValue(SETFIELD, __value);
  }

  public Map<String,List<String>> getMapField() {
    return (Map<String,List<String>>) __getValue(MAPFIELD);
  }

  public void setMapField(Map<String,List<String>> __value) {
    __setValue(MAPFIELD, __value);
  }

  public byte[] getBinaryField() {
    return (byte[]) __getValue(BINARYFIELD);
  }

  public void setBinaryField(byte[] __value) {
    __setValue(BINARYFIELD, __value);
  }

  public boolean equals(Object other) {
    if (other instanceof Baz) {
      return equals((Baz)other);
    } else {
      return false;
    }
  }

  public boolean equals(Baz other) {
    return equalsSlowImpl(other);
  }

  @Override
  public int compareTo(Baz other) {
    return compareToImpl(other);
  }


  @Override
  public int hashCode() {
    return Arrays.deepHashCode(new Object[] {getSetField(), getFieldValue()});
  }

}
