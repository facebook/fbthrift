/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}
#include "thrift/compiler/test/fixtures/qualified/gen-cpp/module0_types.h"
#include "thrift/compiler/test/fixtures/qualified/gen-cpp/module1_types.h"


namespace MODULE2 {

class Struct;

class BigStruct;

void swap(Struct &a, Struct &b);

class Struct : public apache::thrift::TStructType<Struct> {
 public:

  static const uint64_t _reflection_id = 6048788120110564236U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Struct() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit Struct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    Struct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    first = arg.move();
    __isset.first = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit Struct(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    Struct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    second = arg.move();
    __isset.second = true;
  }

  Struct(const Struct&) = default;
  Struct& operator=(const Struct& src)= default;
  Struct(Struct&&) = default;
  Struct& operator=(Struct&&) = default;

  void __clear();

  virtual ~Struct() noexcept {}

   ::MODULE0::Struct first;
   ::MODULE1::Struct second;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      first = false;
      second = false;
    }
    bool first;
    bool second;
  } __isset;

  bool operator == (const Struct &) const;
  bool operator != (const Struct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Struct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Struct;
void merge(const Struct& from, Struct& to);
void merge(Struct&& from, Struct& to);
void swap(BigStruct &a, BigStruct &b);

class BigStruct : public apache::thrift::TStructType<BigStruct> {
 public:

  static const uint64_t _reflection_id = 18288836959267843340U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  BigStruct() : id(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit BigStruct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    BigStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    s = arg.move();
    __isset.s = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit BigStruct(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    BigStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    id = arg.move();
    __isset.id = true;
  }

  BigStruct(const BigStruct&) = default;
  BigStruct& operator=(const BigStruct& src)= default;
  BigStruct(BigStruct&&) = default;
  BigStruct& operator=(BigStruct&&) = default;

  void __clear();

  virtual ~BigStruct() noexcept {}

  Struct s;
  int32_t id;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      s = false;
      id = false;
    }
    bool s;
    bool id;
  } __isset;

  bool operator == (const BigStruct &) const;
  bool operator != (const BigStruct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BigStruct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class BigStruct;
void merge(const BigStruct& from, BigStruct& to);
void merge(BigStruct&& from, BigStruct& to);
} // namespace

