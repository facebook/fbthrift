{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Module2_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import qualified Control.Applicative as Applicative (ZipList(..))
import Control.Applicative ( (<*>) )
import qualified Control.DeepSeq as DeepSeq
import qualified Control.Exception as Exception
import qualified Control.Monad as Monad ( liftM, ap, when )
import qualified Data.ByteString.Lazy as BS
import Data.Functor ( (<$>) )
import qualified Data.Hashable as Hashable
import qualified Data.Int as Int
import qualified Data.Maybe as Maybe (catMaybes)
import qualified Data.Text.Lazy.Encoding as Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified Data.Typeable as Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as Arbitrary ( Arbitrary(..) )
import qualified Test.QuickCheck as QuickCheck ( elements )

import qualified Thrift
import qualified Thrift.Types as Types
import qualified Thrift.Serializable as Serializable
import qualified Thrift.Arbitraries as Arbitraries

import qualified Module0_Types as Module0_Types
import qualified Module1_Types as Module1_Types


data Struct = Struct
  { struct_first :: Module0_Types.Struct
  , struct_second :: Module1_Types.Struct
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable Struct where
  encode = encode_Struct
  decode = decode_Struct
instance Hashable.Hashable Struct where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` struct_first record   `Hashable.hashWithSalt` struct_second record  
instance DeepSeq.NFData Struct where
  rnf _record0 =
    DeepSeq.rnf (struct_first _record0) `seq`
    DeepSeq.rnf (struct_second _record0) `seq`
    ()
instance Arbitrary.Arbitrary Struct where 
  arbitrary = Monad.liftM Struct (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_Struct = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_Struct{struct_first = struct_first obj} then Nothing else Just $ default_Struct{struct_first = struct_first obj}
    , if obj == default_Struct{struct_second = struct_second obj} then Nothing else Just $ default_Struct{struct_second = struct_second obj}
    ]
from_Struct :: Struct -> Types.ThriftVal
from_Struct record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v3 -> Just (1, ("first",Module0_Types.from_Struct _v3))) $ struct_first record
  , (\_v3 -> Just (2, ("second",Module1_Types.from_Struct _v3))) $ struct_second record
  ]
write_Struct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Struct -> IO ()
write_Struct oprot record = Thrift.writeVal oprot $ from_Struct record
encode_Struct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> Struct -> BS.ByteString
encode_Struct oprot record = Thrift.serializeVal oprot $ from_Struct record
to_Struct :: Types.ThriftVal -> Struct
to_Struct (Types.TStruct fields) = Struct{
  struct_first = maybe (struct_first default_Struct) (\(_,_val5) -> (case _val5 of {Types.TStruct _val6 -> (Module0_Types.to_Struct (Types.TStruct _val6)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  struct_second = maybe (struct_second default_Struct) (\(_,_val5) -> (case _val5 of {Types.TStruct _val7 -> (Module1_Types.to_Struct (Types.TStruct _val7)); _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_Struct _ = error "not a struct"
read_Struct :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO Struct
read_Struct iprot = to_Struct <$> Thrift.readVal iprot (Types.T_STRUCT typemap_Struct)
decode_Struct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> Struct
decode_Struct iprot bs = to_Struct $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_Struct) bs
typemap_Struct :: Types.TypeMap
typemap_Struct = Map.fromList [("first",(1,(Types.T_STRUCT Module0_Types.typemap_Struct))),("second",(2,(Types.T_STRUCT Module1_Types.typemap_Struct)))]
default_Struct :: Struct
default_Struct = Struct{
  struct_first = Module0_Types.default_Struct,
  struct_second = Module1_Types.default_Struct}
data BigStruct = BigStruct
  { bigStruct_s :: Module2_Types.Struct
  , bigStruct_id :: Int.Int32
  } deriving (Show,Eq,Typeable.Typeable)
instance Serializable.ThriftSerializable BigStruct where
  encode = encode_BigStruct
  decode = decode_BigStruct
instance Hashable.Hashable BigStruct where
  hashWithSalt salt record = salt   `Hashable.hashWithSalt` bigStruct_s record   `Hashable.hashWithSalt` bigStruct_id record  
instance DeepSeq.NFData BigStruct where
  rnf _record8 =
    DeepSeq.rnf (bigStruct_s _record8) `seq`
    DeepSeq.rnf (bigStruct_id _record8) `seq`
    ()
instance Arbitrary.Arbitrary BigStruct where 
  arbitrary = Monad.liftM BigStruct (Arbitrary.arbitrary)
          `Monad.ap`(Arbitrary.arbitrary)
  shrink obj | obj == default_BigStruct = []
             | otherwise = Maybe.catMaybes
    [ if obj == default_BigStruct{bigStruct_s = bigStruct_s obj} then Nothing else Just $ default_BigStruct{bigStruct_s = bigStruct_s obj}
    , if obj == default_BigStruct{bigStruct_id = bigStruct_id obj} then Nothing else Just $ default_BigStruct{bigStruct_id = bigStruct_id obj}
    ]
from_BigStruct :: BigStruct -> Types.ThriftVal
from_BigStruct record = Types.TStruct $ Map.fromList $ Maybe.catMaybes
  [ (\_v11 -> Just (1, ("s",Module2_Types.from_Struct _v11))) $ bigStruct_s record
  , (\_v11 -> Just (2, ("id",Types.TI32 _v11))) $ bigStruct_id record
  ]
write_BigStruct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BigStruct -> IO ()
write_BigStruct oprot record = Thrift.writeVal oprot $ from_BigStruct record
encode_BigStruct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BigStruct -> BS.ByteString
encode_BigStruct oprot record = Thrift.serializeVal oprot $ from_BigStruct record
to_BigStruct :: Types.ThriftVal -> BigStruct
to_BigStruct (Types.TStruct fields) = BigStruct{
  bigStruct_s = maybe (bigStruct_s default_BigStruct) (\(_,_val13) -> (case _val13 of {Types.TStruct _val14 -> (Module2_Types.to_Struct (Types.TStruct _val14)); _ -> error "wrong type"})) (Map.lookup (1) fields),
  bigStruct_id = maybe (bigStruct_id default_BigStruct) (\(_,_val13) -> (case _val13 of {Types.TI32 _val15 -> _val15; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_BigStruct _ = error "not a struct"
read_BigStruct :: (Thrift.Transport t, Thrift.Protocol p) => p t -> IO BigStruct
read_BigStruct iprot = to_BigStruct <$> Thrift.readVal iprot (Types.T_STRUCT typemap_BigStruct)
decode_BigStruct :: (Thrift.Protocol p, Thrift.Transport t) => p t -> BS.ByteString -> BigStruct
decode_BigStruct iprot bs = to_BigStruct $ Thrift.deserializeVal iprot (Types.T_STRUCT typemap_BigStruct) bs
typemap_BigStruct :: Types.TypeMap
typemap_BigStruct = Map.fromList [("s",(1,(Types.T_STRUCT Module2_Types.typemap_Struct))),("id",(2,Types.T_I32))]
default_BigStruct :: BigStruct
default_BigStruct = BigStruct{
  bigStruct_s = Module2_Types.default_Struct,
  bigStruct_id = 0}
