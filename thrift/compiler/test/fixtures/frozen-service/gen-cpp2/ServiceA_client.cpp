/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "src/gen-cpp2/ServiceA.h"
#include "src/gen-cpp2/ServiceA.tcc"

#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
#include <thrift/lib/cpp2/protocol/Frozen2Protocol.h>

namespace some { namespace ns {
const char* ServiceAAsyncClient::getServiceName() {
  return "ServiceA";
}

void ServiceAAsyncClient::moduleAMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleAMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleAMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleAMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleAMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  moduleAMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleAMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleAMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAMethod, channel_);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleAMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAMethod, channel_);
  moduleAMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

void ServiceAAsyncClient::moduleAMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_moduleAMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_moduleAMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_moduleAMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleAMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleAMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleAMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleAMethod(state);
}

void ServiceAAsyncClient::moduleBMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleBMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleBMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  moduleBMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleBMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleB& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleBMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleBMethod(const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleBMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  moduleBMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleBMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleBMethod(const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleBMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleBMethod, channel_);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleBMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleBMethod, channel_);
  moduleBMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

void ServiceAAsyncClient::moduleBMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleB& modArg) {
  moduleBMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_moduleBMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_moduleBMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_moduleBMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleBMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleBMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleBMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleBMethod(state);
}

void ServiceAAsyncClient::i32StrDoubleMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  i32StrDoubleMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  i32StrDoubleMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::i32StrDoubleMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      i32StrDoubleMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_i32StrDoubleMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_i32StrDoubleMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::sync_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  i32StrDoubleMethodImpl(true, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_i32StrDoubleMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32StrDoubleMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_i32StrDoubleMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32StrDoubleMethod, channel_);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_i32StrDoubleMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32StrDoubleMethod, channel_);
  i32StrDoubleMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

void ServiceAAsyncClient::i32StrDoubleMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  i32StrDoubleMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg, strArg, doubleArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_i32StrDoubleMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_i32StrDoubleMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_i32StrDoubleMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_i32StrDoubleMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  recv_i32StrDoubleMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_i32StrDoubleMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_i32StrDoubleMethod(state);
}

void ServiceAAsyncClient::versioningMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  versioningMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::versioningMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  versioningMethodImpl(false, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::versioningMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      versioningMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_versioningMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_versioningMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

void ServiceAAsyncClient::sync_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  versioningMethodImpl(true, rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_versioningMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_versioningMethod(int32_t i32Arg, const std::string& strArg, double doubleArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_versioningMethod(rpcOptions, i32Arg, strArg, doubleArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_versioningMethod, channel_);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_versioningMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_versioningMethod, channel_);
  versioningMethod(rpcOptions, std::move(callback), i32Arg, strArg, doubleArg);
  return _future;
}

void ServiceAAsyncClient::versioningMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg, const std::string& strArg, double doubleArg) {
  versioningMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg, strArg, doubleArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_versioningMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_versioningMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_versioningMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_versioningMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  recv_versioningMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_versioningMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_versioningMethod(state);
}

void ServiceAAsyncClient::retI32Method(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  retI32MethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retI32Method(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  retI32MethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retI32MethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      retI32MethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

int32_t ServiceAAsyncClient::sync_retI32Method() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_retI32Method(rpcOptions);
}

int32_t ServiceAAsyncClient::sync_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  retI32MethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return recv_retI32Method(_returnState);
}

folly::Future<int32_t> ServiceAAsyncClient::future_retI32Method() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_retI32Method(rpcOptions);
}

folly::Future<int32_t> ServiceAAsyncClient::future_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(_promise), recv_wrapped_retI32Method, channel_);
  retI32Method(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_retI32Method(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(_promise), recv_wrapped_retI32Method, channel_);
  retI32Method(rpcOptions, std::move(callback));
  return _future;
}

void ServiceAAsyncClient::retI32Method(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  retI32Method(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_retI32Method(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_retI32MethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_retI32MethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_retI32MethodT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t ServiceAAsyncClient::recv_retI32Method(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_retI32Method(_return, state);
  if (ew) {
    ew.throw_exception();
  }
  return _return;
}

int32_t ServiceAAsyncClient::recv_instance_retI32Method(::apache::thrift::ClientReceiveState& state) {
  return recv_retI32Method(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_retI32Method(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_retI32Method(_return, state);
}

void ServiceAAsyncClient::retModAMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  retModAMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retModAMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  retModAMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::retModAMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      retModAMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_retModAMethod( ::some::ns::ModuleA& _return) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_retModAMethod(rpcOptions, _return);
}

void ServiceAAsyncClient::sync_retModAMethod(apache::thrift::RpcOptions& rpcOptions,  ::some::ns::ModuleA& _return) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  retModAMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_retModAMethod(_return, _returnState);
}

folly::Future< ::some::ns::ModuleA> ServiceAAsyncClient::future_retModAMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_retModAMethod(rpcOptions);
}

folly::Future< ::some::ns::ModuleA> ServiceAAsyncClient::future_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise< ::some::ns::ModuleA> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback< ::some::ns::ModuleA>>(std::move(_promise), recv_wrapped_retModAMethod, channel_);
  retModAMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair< ::some::ns::ModuleA, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_retModAMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair< ::some::ns::ModuleA, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback< ::some::ns::ModuleA>>(std::move(_promise), recv_wrapped_retModAMethod, channel_);
  retModAMethod(rpcOptions, std::move(callback));
  return _future;
}

void ServiceAAsyncClient::retModAMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  retModAMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_retModAMethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_retModAMethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_retModAMethodT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_retModAMethod(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_retModAMethod(_return, state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_retModAMethod( ::some::ns::ModuleA& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_retModAMethod(_return, state);
}

void ServiceAAsyncClient::throwMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  throwMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::throwMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  throwMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::throwMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      throwMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_throwMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_throwMethod(rpcOptions);
}

void ServiceAAsyncClient::sync_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  throwMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_throwMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_throwMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_throwMethod(rpcOptions);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_throwMethod, channel_);
  throwMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_throwMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_throwMethod, channel_);
  throwMethod(rpcOptions, std::move(callback));
  return _future;
}

void ServiceAAsyncClient::throwMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  throwMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_throwMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_throwMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_throwMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_throwMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_throwMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_throwMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_throwMethod(::apache::thrift::ClientReceiveState& state) {
  recv_throwMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_throwMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_throwMethod(state);
}

void ServiceAAsyncClient::multiThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiThrowMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::multiThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  multiThrowMethodImpl(false, rpcOptions, std::move(callback));
}

void ServiceAAsyncClient::multiThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      multiThrowMethodT(&writer, useSync, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_multiThrowMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiThrowMethod(rpcOptions);
}

void ServiceAAsyncClient::sync_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  multiThrowMethodImpl(true, rpcOptions, std::move(callback));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_multiThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_multiThrowMethod() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiThrowMethod(rpcOptions);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_multiThrowMethod, channel_);
  multiThrowMethod(rpcOptions, std::move(callback));
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_multiThrowMethod(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_multiThrowMethod, channel_);
  multiThrowMethod(rpcOptions, std::move(callback));
  return _future;
}

void ServiceAAsyncClient::multiThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  multiThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_multiThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_multiThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_multiThrowMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_multiThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_multiThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiThrowMethod(state);
}

void ServiceAAsyncClient::i32ThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  i32ThrowMethodImpl(false, rpcOptions, std::move(callback), i32Arg);
}

void ServiceAAsyncClient::i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  i32ThrowMethodImpl(false, rpcOptions, std::move(callback), i32Arg);
}

void ServiceAAsyncClient::i32ThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t i32Arg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      i32ThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), i32Arg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_i32ThrowMethod(int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_i32ThrowMethod(rpcOptions, i32Arg);
}

void ServiceAAsyncClient::sync_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  i32ThrowMethodImpl(true, rpcOptions, std::move(callback), i32Arg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_i32ThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32ThrowMethod(int32_t i32Arg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_i32ThrowMethod(rpcOptions, i32Arg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32ThrowMethod, channel_);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_i32ThrowMethod(apache::thrift::RpcOptions& rpcOptions, int32_t i32Arg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_i32ThrowMethod, channel_);
  i32ThrowMethod(rpcOptions, std::move(callback), i32Arg);
  return _future;
}

void ServiceAAsyncClient::i32ThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t i32Arg) {
  i32ThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), i32Arg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_i32ThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_i32ThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_i32ThrowMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_i32ThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_i32ThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_i32ThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_i32ThrowMethod(state);
}

void ServiceAAsyncClient::moduleAThrowMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  moduleAThrowMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAThrowMethodImpl(false, rpcOptions, std::move(callback), modArg);
}

void ServiceAAsyncClient::moduleAThrowMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::some::ns::ModuleA& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      moduleAThrowMethodT(&writer, useSync, rpcOptions, std::move(callback), modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_moduleAThrowMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_moduleAThrowMethod(rpcOptions, modArg);
}

void ServiceAAsyncClient::sync_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  moduleAThrowMethodImpl(true, rpcOptions, std::move(callback), modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_moduleAThrowMethod(_returnState);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAThrowMethod(const  ::some::ns::ModuleA& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_moduleAThrowMethod(rpcOptions, modArg);
}

folly::Future<folly::Unit> ServiceAAsyncClient::future_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAThrowMethod, channel_);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

folly::Future<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_moduleAThrowMethod(apache::thrift::RpcOptions& rpcOptions, const  ::some::ns::ModuleA& modArg) {
  folly::Promise<std::pair<folly::Unit, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<folly::Unit>>(std::move(_promise), recv_wrapped_moduleAThrowMethod, channel_);
  moduleAThrowMethod(rpcOptions, std::move(callback), modArg);
  return _future;
}

void ServiceAAsyncClient::moduleAThrowMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const  ::some::ns::ModuleA& modArg) {
  moduleAThrowMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_moduleAThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_moduleAThrowMethodT(&reader, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_moduleAThrowMethodT(&reader, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_moduleAThrowMethod(state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  recv_moduleAThrowMethod(state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_moduleAThrowMethod(::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_moduleAThrowMethod(state);
}

void ServiceAAsyncClient::mixedMethod(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  mixedMethodImpl(false, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::mixedMethod(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  mixedMethodImpl(false, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::mixedMethodImpl(bool useSync, apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolWriter writer;
      mixedMethodT(&writer, useSync, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
      break;
    }
    default:
    {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void ServiceAAsyncClient::sync_mixedMethod(std::string& _return, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_mixedMethod(rpcOptions, _return, strArg, i32Arg, modArg);
}

void ServiceAAsyncClient::sync_mixedMethod(apache::thrift::RpcOptions& rpcOptions, std::string& _return, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback = std::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, false);
  mixedMethodImpl(true, rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    _returnState.exception().throw_exception();
  }
  recv_mixedMethod(_return, _returnState);
}

folly::Future<std::string> ServiceAAsyncClient::future_mixedMethod(const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_mixedMethod(rpcOptions, strArg, i32Arg, modArg);
}

folly::Future<std::string> ServiceAAsyncClient::future_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::string> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::FutureCallback<std::string>>(std::move(_promise), recv_wrapped_mixedMethod, channel_);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return _future;
}

folly::Future<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> ServiceAAsyncClient::header_future_mixedMethod(apache::thrift::RpcOptions& rpcOptions, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  folly::Promise<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<apache::thrift::HeaderFutureCallback<std::string>>(std::move(_promise), recv_wrapped_mixedMethod, channel_);
  mixedMethod(rpcOptions, std::move(callback), strArg, i32Arg, modArg);
  return _future;
}

void ServiceAAsyncClient::mixedMethod(folly::Function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::string& strArg, int32_t i32Arg, const  ::some::ns::ModuleB& modArg) {
  mixedMethod(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), strArg, i32Arg, modArg);
}

folly::exception_wrapper ServiceAAsyncClient::recv_wrapped_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_mixedMethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_mixedMethodT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_FROZEN2_PROTOCOL:
    {
      apache::thrift::Frozen2ProtocolReader reader;
      return recv_wrapped_mixedMethodT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ServiceAAsyncClient::recv_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_mixedMethod(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void ServiceAAsyncClient::recv_instance_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_mixedMethod(_return, state);
}

folly::exception_wrapper ServiceAAsyncClient::recv_instance_wrapped_mixedMethod(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_mixedMethod(_return, state);
}

}} // some::ns
namespace apache { namespace thrift {

}} // apache::thrift
