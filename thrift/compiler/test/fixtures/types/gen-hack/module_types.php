<?hh // strict
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/**
 * Original thrift enum:-
 * has_bitwise_ops
 */
enum has_bitwise_ops: int {
  none = 0;
  zero = 1;
  one = 2;
  two = 4;
  three = 8;
}

/**
 * Original thrift enum:-
 * is_unscoped
 */
enum is_unscoped: int {
  hello = 0;
  world = 1;
}

/**
 * Original thrift enum:-
 * MyForwardRefEnum
 */
enum MyForwardRefEnum: int {
  ZERO = 0;
  NONZERO = 12;
}

/**
 * Original thrift enum:-
 * MyEnumA
 */
enum MyEnumA: int {
  fieldA = 1;
  fieldB = 2;
  fieldC = 4;
}

/**
 * Original thrift struct:-
 * decorated_struct
 */
class decorated_struct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'field',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'field' => 1,
  ];

  const type TConstructorShape = shape(
    ?'field' => string,
  );

  const int STRUCTURAL_ID = 6158382972310209096;
  /**
   * Original thrift field:-
   * 1: string field
   */
  public string $field;

  <<__Rx>>
  public function __construct(?string $field = null  ) {
    $this->field = $field ?? '';
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'field'),
    );
  }

  public function getName(): string {
    return 'decorated_struct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.declare_equal_to' => "1",
      'cpp.declare_hash' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'field') !== null) {
      $this->field = /* HH_FIXME[4110] */ $parsed['field'];
    }    
  }

}

/**
 * Original thrift struct:-
 * ContainerStruct
 */
class ContainerStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    12 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'fieldB',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'fieldC',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'fieldD',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'fieldE',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'fieldF',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    7 => shape(
      'var' => 'fieldG',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    8 => shape(
      'var' => 'fieldH',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 12,
    'fieldB' => 2,
    'fieldC' => 3,
    'fieldD' => 4,
    'fieldE' => 5,
    'fieldF' => 6,
    'fieldG' => 7,
    'fieldH' => 8,
  ];

  const type TConstructorShape = shape(
    ?'fieldA' => Vector<int>,
    ?'fieldB' => Vector<int>,
    ?'fieldC' => Vector<int>,
    ?'fieldD' => Vector<int>,
    ?'fieldE' => Vector<int>,
    ?'fieldF' => Set<int>,
    ?'fieldG' => Map<int, string>,
    ?'fieldH' => Map<int, string>,
  );

  const int STRUCTURAL_ID = 2901459969892394021;
  /**
   * Original thrift field:-
   * 12: list<i32> fieldA
   */
  public Vector<int> $fieldA;
  /**
   * Original thrift field:-
   * 2: list<i32> fieldB
   */
  public Vector<int> $fieldB;
  /**
   * Original thrift field:-
   * 3: list<i32> fieldC
   */
  public Vector<int> $fieldC;
  /**
   * Original thrift field:-
   * 4: list<i32> fieldD
   */
  public Vector<int> $fieldD;
  /**
   * Original thrift field:-
   * 5: list<i32> fieldE
   */
  public Vector<int> $fieldE;
  /**
   * Original thrift field:-
   * 6: set<i32> fieldF
   */
  public Set<int> $fieldF;
  /**
   * Original thrift field:-
   * 7: map<i32, string> fieldG
   */
  public Map<int, string> $fieldG;
  /**
   * Original thrift field:-
   * 8: map<i32, string> fieldH
   */
  public Map<int, string> $fieldH;

  <<__Rx>>
  public function __construct(?Vector<int> $fieldA = null, ?Vector<int> $fieldB = null, ?Vector<int> $fieldC = null, ?Vector<int> $fieldD = null, ?Vector<int> $fieldE = null, ?Set<int> $fieldF = null, ?Map<int, string> $fieldG = null, ?Map<int, string> $fieldH = null  ) {
    $this->fieldA = $fieldA ?? Vector {};
    $this->fieldB = $fieldB ?? Vector {};
    $this->fieldC = $fieldC ?? Vector {};
    $this->fieldD = $fieldD ?? Vector {};
    $this->fieldE = $fieldE ?? Vector {};
    $this->fieldF = $fieldF ?? Set {};
    $this->fieldG = $fieldG ?? Map {};
    $this->fieldH = $fieldH ?? Map {};
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'fieldA'),
      Shapes::idx($shape, 'fieldB'),
      Shapes::idx($shape, 'fieldC'),
      Shapes::idx($shape, 'fieldD'),
      Shapes::idx($shape, 'fieldE'),
      Shapes::idx($shape, 'fieldF'),
      Shapes::idx($shape, 'fieldG'),
      Shapes::idx($shape, 'fieldH'),
    );
  }

  public function getName(): string {
    return 'ContainerStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'fieldA' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldB' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldC' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldD' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldE' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldF' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldG' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'fieldH' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['fieldA'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }    
    if (idx($parsed, 'fieldB') !== null) {
      $_json10 = /* HH_FIXME[4110] */ $parsed['fieldB'];
      $_container11 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11 []= $_elem12;
      }
      $this->fieldB = $_container11;
    }    
    if (idx($parsed, 'fieldC') !== null) {
      $_json17 = /* HH_FIXME[4110] */ $parsed['fieldC'];
      $_container18 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json17 as $_key15 => $_value16) {
        $_elem19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem19 = (int)$_tmp20;
        }
        $_container18 []= $_elem19;
      }
      $this->fieldC = $_container18;
    }    
    if (idx($parsed, 'fieldD') !== null) {
      $_json24 = /* HH_FIXME[4110] */ $parsed['fieldD'];
      $_container25 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json24 as $_key22 => $_value23) {
        $_elem26 = 0;
        $_tmp27 = (int)$_value23;
        if ($_tmp27 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem26 = (int)$_tmp27;
        }
        $_container25 []= $_elem26;
      }
      $this->fieldD = $_container25;
    }    
    if (idx($parsed, 'fieldE') !== null) {
      $_json31 = /* HH_FIXME[4110] */ $parsed['fieldE'];
      $_container32 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json31 as $_key29 => $_value30) {
        $_elem33 = 0;
        $_tmp34 = (int)$_value30;
        if ($_tmp34 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem33 = (int)$_tmp34;
        }
        $_container32 []= $_elem33;
      }
      $this->fieldE = $_container32;
    }    
    if (idx($parsed, 'fieldF') !== null) {
      $_json38 = /* HH_FIXME[4110] */ $parsed['fieldF'];
      $_container39 = Set {};
      foreach(/* HH_FIXME[4110] */ $_json38 as $_key36 => $_value37) {
        $_elem40 = 0;
        $_tmp41 = (int)$_value37;
        if ($_tmp41 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem40 = (int)$_tmp41;
        }
        $_container39->add($_elem40);
      }
      $this->fieldF = $_container39;
    }    
    if (idx($parsed, 'fieldG') !== null) {
      $_json45 = /* HH_FIXME[4110] */ $parsed['fieldG'];
      $_container46 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json45 as $_key43 => $_value44) {
        $_value47 = '';
        $_value47 = $_value44;
        $_container46[$_key43] = $_value47;
      }
      $this->fieldG = $_container46;
    }    
    if (idx($parsed, 'fieldH') !== null) {
      $_json51 = /* HH_FIXME[4110] */ $parsed['fieldH'];
      $_container52 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json51 as $_key49 => $_value50) {
        $_value53 = '';
        $_value53 = $_value50;
        $_container52[$_key49] = $_value53;
      }
      $this->fieldH = $_container52;
    }    
  }

}

/**
 * Original thrift struct:-
 * CppTypeStruct
 */
class CppTypeStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 1,
  ];

  const type TConstructorShape = shape(
    ?'fieldA' => Vector<int>,
  );

  const int STRUCTURAL_ID = 9369458949141941;
  /**
   * Original thrift field:-
   * 1: list<i32> fieldA
   */
  public Vector<int> $fieldA;

  <<__Rx>>
  public function __construct(?Vector<int> $fieldA = null  ) {
    $this->fieldA = $fieldA ?? Vector {};
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'fieldA'),
    );
  }

  public function getName(): string {
    return 'CppTypeStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'fieldA' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['fieldA'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * VirtualStruct
 */
class VirtualStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
  ];

  const type TConstructorShape = shape(
    ?'MyIntField' => int,
  );

  const int STRUCTURAL_ID = 7014352813131039231;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;

  <<__Rx>>
  public function __construct(?int $MyIntField = null  ) {
    $this->MyIntField = $MyIntField ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'MyIntField'),
    );
  }

  public function getName(): string {
    return 'VirtualStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'MyIntField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.virtual' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
  }

}

/**
 * Original thrift struct:-
 * MyStructWithForwardRefEnum
 */
class MyStructWithForwardRefEnum implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => ?MyForwardRefEnum,
    ?'b' => ?MyForwardRefEnum,
  );

  const int STRUCTURAL_ID = 6098225215594902198;
  /**
   * Original thrift field:-
   * 1: enum module.MyForwardRefEnum a
   */
  public ?MyForwardRefEnum $a;
  /**
   * Original thrift field:-
   * 2: enum module.MyForwardRefEnum b
   */
  public ?MyForwardRefEnum $b;

  <<__Rx>>
  public function __construct(?MyForwardRefEnum $a = null, ?MyForwardRefEnum $b = null  ) {
    $this->a = $a ?? MyForwardRefEnum::NONZERO;
    $this->b = $b ?? MyForwardRefEnum::NONZERO;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName(): string {
    return 'MyStructWithForwardRefEnum';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'a' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'b' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = MyForwardRefEnum::coerce(/* HH_FIXME[4110] */ $parsed['a']);    }    
    if (idx($parsed, 'b') !== null) {
      $this->b = MyForwardRefEnum::coerce(/* HH_FIXME[4110] */ $parsed['b']);    }    
  }

}

/**
 * Original thrift struct:-
 * TrivialNumeric
 */
class TrivialNumeric implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => int,
    ?'b' => bool,
  );

  const int STRUCTURAL_ID = 3920068475021763685;
  /**
   * Original thrift field:-
   * 1: i32 a
   */
  public int $a;
  /**
   * Original thrift field:-
   * 2: bool b
   */
  public bool $b;

  <<__Rx>>
  public function __construct(?int $a = null, ?bool $b = null  ) {
    $this->a = $a ?? 0;
    $this->b = $b ?? false;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName(): string {
    return 'TrivialNumeric';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'a' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'b' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['a'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->a = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'b') !== null) {
      $this->b = /* HH_FIXME[4110] */ $parsed['b'];
    }    
  }

}

/**
 * Original thrift struct:-
 * TrivialNestedWithDefault
 */
class TrivialNestedWithDefault implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => TrivialNumeric::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];

  const type TConstructorShape = shape(
    ?'z' => int,
    ?'n' => ?TrivialNumeric,
  );

  const int STRUCTURAL_ID = 5012136746274172257;
  /**
   * Original thrift field:-
   * 1: i32 z
   */
  public int $z;
  /**
   * Original thrift field:-
   * 2: struct module.TrivialNumeric n
   */
  public ?TrivialNumeric $n;

  <<__Rx>>
  public function __construct(?int $z = null, ?TrivialNumeric $n = null  ) {
    $this->z = $z ?? 4;
    $this->n = $n;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'z'),
      Shapes::idx($shape, 'n'),
    );
  }

  public function getName(): string {
    return 'TrivialNestedWithDefault';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'z' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'n' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['z'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->z = (int)$_tmp0;
      }
    }    
    if (idx($parsed, 'n') !== null) {
      $_tmp1 = json_encode(/* HH_FIXME[4110] */ $parsed['n']);
      $_tmp2 = new TrivialNumeric();
      $_tmp2->readFromJson($_tmp1);
      $this->n = $_tmp2;
    }    
  }

}

/**
 * Original thrift struct:-
 * ComplexString
 */
class ComplexString implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => string,
    ?'b' => Map<string, int>,
  );

  const int STRUCTURAL_ID = 5460740530481786095;
  /**
   * Original thrift field:-
   * 1: string a
   */
  public string $a;
  /**
   * Original thrift field:-
   * 2: map<string, i32> b
   */
  public Map<string, int> $b;

  <<__Rx>>
  public function __construct(?string $a = null, ?Map<string, int> $b = null  ) {
    $this->a = $a ?? '';
    $this->b = $b ?? Map {};
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName(): string {
    return 'ComplexString';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'a' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'b' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = /* HH_FIXME[4110] */ $parsed['a'];
    }    
    if (idx($parsed, 'b') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['b'];
      $_container4 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_value5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_value5 = (int)$_tmp6;
        }
        $_container4[$_key1] = $_value5;
      }
      $this->b = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * ComplexNestedWithDefault
 */
class ComplexNestedWithDefault implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => ComplexString::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];

  const type TConstructorShape = shape(
    ?'z' => string,
    ?'n' => ?ComplexString,
  );

  const int STRUCTURAL_ID = 2913723608362321564;
  /**
   * Original thrift field:-
   * 1: string z
   */
  public string $z;
  /**
   * Original thrift field:-
   * 2: struct module.ComplexString n
   */
  public ?ComplexString $n;

  <<__Rx>>
  public function __construct(?string $z = null, ?ComplexString $n = null  ) {
    $this->z = $z ?? "4";
    $this->n = $n;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'z'),
      Shapes::idx($shape, 'n'),
    );
  }

  public function getName(): string {
    return 'ComplexNestedWithDefault';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'z' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'n' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $this->z = /* HH_FIXME[4110] */ $parsed['z'];
    }    
    if (idx($parsed, 'n') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['n']);
      $_tmp1 = new ComplexString();
      $_tmp1->readFromJson($_tmp0);
      $this->n = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * MinPadding
 */
class MinPadding implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'small',
      'type' => \TType::BYTE,
    ),
    2 => shape(
      'var' => 'big',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'medium',
      'type' => \TType::I16,
    ),
    4 => shape(
      'var' => 'biggish',
      'type' => \TType::I32,
    ),
    5 => shape(
      'var' => 'tiny',
      'type' => \TType::BYTE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'small' => 1,
    'big' => 2,
    'medium' => 3,
    'biggish' => 4,
    'tiny' => 5,
  ];

  const type TConstructorShape = shape(
    ?'small' => int,
    ?'big' => int,
    ?'medium' => int,
    ?'biggish' => int,
    ?'tiny' => int,
  );

  const int STRUCTURAL_ID = 723753448680843528;
  /**
   * Original thrift field:-
   * 1: byte small
   */
  public int $small;
  /**
   * Original thrift field:-
   * 2: i64 big
   */
  public int $big;
  /**
   * Original thrift field:-
   * 3: i16 medium
   */
  public int $medium;
  /**
   * Original thrift field:-
   * 4: i32 biggish
   */
  public int $biggish;
  /**
   * Original thrift field:-
   * 5: byte tiny
   */
  public int $tiny;

  <<__Rx>>
  public function __construct(?int $small = null, ?int $big = null, ?int $medium = null, ?int $biggish = null, ?int $tiny = null  ) {
    $this->small = $small ?? 0;
    $this->big = $big ?? 0;
    $this->medium = $medium ?? 0;
    $this->biggish = $biggish ?? 0;
    $this->tiny = $tiny ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'small'),
      Shapes::idx($shape, 'big'),
      Shapes::idx($shape, 'medium'),
      Shapes::idx($shape, 'biggish'),
      Shapes::idx($shape, 'tiny'),
    );
  }

  public function getName(): string {
    return 'MinPadding';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'small' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'big' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'medium' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'biggish' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'tiny' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.minimize_padding' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'small') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['small'];
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->small = (int)$_tmp0;
      }
    } else {
      throw new \TProtocolException("Required field small cannot be found.");
    }    
    if (idx($parsed, 'big') !== null) {
      $this->big = /* HH_FIXME[4110] */ $parsed['big'];
    } else {
      throw new \TProtocolException("Required field big cannot be found.");
    }    
    if (idx($parsed, 'medium') !== null) {
      $_tmp1 = (int)/* HH_FIXME[4110] */ $parsed['medium'];
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->medium = (int)$_tmp1;
      }
    } else {
      throw new \TProtocolException("Required field medium cannot be found.");
    }    
    if (idx($parsed, 'biggish') !== null) {
      $_tmp2 = (int)/* HH_FIXME[4110] */ $parsed['biggish'];
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->biggish = (int)$_tmp2;
      }
    } else {
      throw new \TProtocolException("Required field biggish cannot be found.");
    }    
    if (idx($parsed, 'tiny') !== null) {
      $_tmp3 = (int)/* HH_FIXME[4110] */ $parsed['tiny'];
      if ($_tmp3 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->tiny = (int)$_tmp3;
      }
    } else {
      throw new \TProtocolException("Required field tiny cannot be found.");
    }    
  }

}

/**
 * Original thrift struct:-
 * MyStruct
 */
class MyStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    2 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    3 => shape(
      'var' => 'majorVer',
      'type' => \TType::I64,
    ),
    4 => shape(
      'var' => 'data',
      'type' => \TType::STRUCT,
      'class' => MyDataItem::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
    'MyStringField' => 2,
    'majorVer' => 3,
    'data' => 4,
  ];

  const type TConstructorShape = shape(
    ?'MyIntField' => int,
    ?'MyStringField' => string,
    ?'majorVer' => int,
    ?'data' => ?MyDataItem,
  );

  const int STRUCTURAL_ID = 2472338421128341558;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 2: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 3: i64 majorVer
   */
  public int $majorVer;
  /**
   * Original thrift field:-
   * 4: struct module.MyDataItem data
   */
  public ?MyDataItem $data;

  <<__Rx>>
  public function __construct(?int $MyIntField = null, ?string $MyStringField = null, ?int $majorVer = null, ?MyDataItem $data = null  ) {
    $this->MyIntField = $MyIntField ?? 0;
    $this->MyStringField = $MyStringField ?? '';
    $this->majorVer = $majorVer ?? 0;
    $this->data = $data;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'MyIntField'),
      Shapes::idx($shape, 'MyStringField'),
      Shapes::idx($shape, 'majorVer'),
      Shapes::idx($shape, 'data'),
    );
  }

  public function getName(): string {
    return 'MyStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'MyIntField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyStringField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'majorVer' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'data' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp2.noncomparable' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = /* HH_FIXME[4110] */ $parsed['MyStringField'];
    }    
    if (idx($parsed, 'majorVer') !== null) {
      $this->majorVer = /* HH_FIXME[4110] */ $parsed['majorVer'];
    }    
    if (idx($parsed, 'data') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['data']);
      $_tmp1 = new MyDataItem();
      $_tmp1->readFromJson($_tmp0);
      $this->data = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * MyDataItem
 */
class MyDataItem implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const int STRUCTURAL_ID = 957977401221134810;

  <<__Rx>>
  public function __construct(  ) {
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
    );
  }

  public function getName(): string {
    return 'MyDataItem';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp2.noncomparable' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * Renaming
 */
class Renaming implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => int,
  );

  const int STRUCTURAL_ID = 2811793053530639830;
  /**
   * Original thrift field:-
   * 1: i64 foo
   */
  public int $foo;

  <<__Rx>>
  public function __construct(?int $foo = null  ) {
    $this->foo = $foo ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName(): string {
    return 'Renaming';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $this->foo = /* HH_FIXME[4110] */ $parsed['foo'];
    }    
  }

}

/**
 * Original thrift struct:-
 * AnnotatedTypes
 */
class AnnotatedTypes implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'binary_field',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'list_field',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::I32,
        'vtype' => \TType::STRING,
        'key' => shape(
          'type' => \TType::I32,
        ),
        'val' => shape(
          'type' => \TType::STRING,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'binary_field' => 1,
    'list_field' => 2,
  ];

  const type TConstructorShape = shape(
    ?'binary_field' => string,
    ?'list_field' => Vector<Map<int, string>>,
  );

  const int STRUCTURAL_ID = 7799859984459418183;
  /**
   * Original thrift field:-
   * 1: binary binary_field
   */
  public string $binary_field;
  /**
   * Original thrift field:-
   * 2: list<map<i32, string>> list_field
   */
  public Vector<Map<int, string>> $list_field;

  <<__Rx>>
  public function __construct(?string $binary_field = null, ?Vector<Map<int, string>> $list_field = null  ) {
    $this->binary_field = $binary_field ?? '';
    $this->list_field = $list_field ?? Vector {};
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'binary_field'),
      Shapes::idx($shape, 'list_field'),
    );
  }

  public function getName(): string {
    return 'AnnotatedTypes';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'binary_field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'list_field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'binary_field') !== null) {
      $this->binary_field = /* HH_FIXME[4110] */ $parsed['binary_field'];
    }    
    if (idx($parsed, 'list_field') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['list_field'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = Map {};
        $_json9 = $_value2;
        $_container10 = Map {};
        foreach(/* HH_FIXME[4110] */ $_json9 as $_key7 => $_value8) {
          $_value11 = '';
          $_value11 = $_value8;
          $_container10[$_key7] = $_value11;
        }
        $_elem5 = $_container10;
        $_container4 []= $_elem5;
      }
      $this->list_field = $_container4;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageRoot
 */
class ForwardUsageRoot implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'ForwardUsageStruct',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageStruct::class,
    ),
    2 => shape(
      'var' => 'ForwardUsageByRef',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageByRef::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'ForwardUsageStruct' => 1,
    'ForwardUsageByRef' => 2,
  ];

  const type TConstructorShape = shape(
    ?'ForwardUsageStruct' => ?ForwardUsageStruct,
    ?'ForwardUsageByRef' => ?ForwardUsageByRef,
  );

  const int STRUCTURAL_ID = 839155360071855827;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageStruct ForwardUsageStruct
   */
  public ?ForwardUsageStruct $ForwardUsageStruct;
  /**
   * Original thrift field:-
   * 2: struct module.ForwardUsageByRef ForwardUsageByRef
   */
  public ?ForwardUsageByRef $ForwardUsageByRef;

  <<__Rx>>
  public function __construct(?ForwardUsageStruct $ForwardUsageStruct = null, ?ForwardUsageByRef $ForwardUsageByRef = null  ) {
    $this->ForwardUsageStruct = $ForwardUsageStruct;
    $this->ForwardUsageByRef = $ForwardUsageByRef;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'ForwardUsageStruct'),
      Shapes::idx($shape, 'ForwardUsageByRef'),
    );
  }

  public function getName(): string {
    return 'ForwardUsageRoot';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'ForwardUsageStruct' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'ForwardUsageByRef' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'ForwardUsageStruct') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['ForwardUsageStruct']);
      $_tmp1 = new ForwardUsageStruct();
      $_tmp1->readFromJson($_tmp0);
      $this->ForwardUsageStruct = $_tmp1;
    }    
    if (idx($parsed, 'ForwardUsageByRef') !== null) {
      $_tmp2 = json_encode(/* HH_FIXME[4110] */ $parsed['ForwardUsageByRef']);
      $_tmp3 = new ForwardUsageByRef();
      $_tmp3->readFromJson($_tmp2);
      $this->ForwardUsageByRef = $_tmp3;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageStruct
 */
class ForwardUsageStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => ?ForwardUsageRoot,
  );

  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  <<__Rx>>
  public function __construct(?ForwardUsageRoot $foo = null  ) {
    $this->foo = $foo;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName(): string {
    return 'ForwardUsageStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['foo']);
      $_tmp1 = new ForwardUsageRoot();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageByRef
 */
class ForwardUsageByRef implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => ?ForwardUsageRoot,
  );

  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  <<__Rx>>
  public function __construct(?ForwardUsageRoot $foo = null  ) {
    $this->foo = $foo;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName(): string {
    return 'ForwardUsageByRef';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'foo' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = json_encode(/* HH_FIXME[4110] */ $parsed['foo']);
      $_tmp1 = new ForwardUsageRoot();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }    
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveEmpty
 */
class NoexceptMoveEmpty implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const int STRUCTURAL_ID = 957977401221134810;

  <<__Rx>>
  public function __construct(  ) {
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
    );
  }

  public function getName(): string {
    return 'NoexceptMoveEmpty';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveSimpleStruct
 */
class NoexceptMoveSimpleStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'boolField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'boolField' => 1,
  ];

  const type TConstructorShape = shape(
    ?'boolField' => int,
  );

  const int STRUCTURAL_ID = 7058232826271171943;
  /**
   * Original thrift field:-
   * 1: i64 boolField
   */
  public int $boolField;

  <<__Rx>>
  public function __construct(?int $boolField = null  ) {
    $this->boolField = $boolField ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'boolField'),
    );
  }

  public function getName(): string {
    return 'NoexceptMoveSimpleStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'boolField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'boolField') !== null) {
      $this->boolField = /* HH_FIXME[4110] */ $parsed['boolField'];
    }    
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveComplexStruct
 */
class NoexceptMoveComplexStruct implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyBoolField',
      'type' => \TType::BOOL,
    ),
    2 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    4 => shape(
      'var' => 'MyStringField2',
      'type' => \TType::STRING,
    ),
    5 => shape(
      'var' => 'MyBinaryField',
      'type' => \TType::STRING,
    ),
    6 => shape(
      'var' => 'MyBinaryField2',
      'type' => \TType::STRING,
    ),
    7 => shape(
      'var' => 'MyBinaryField3',
      'type' => \TType::STRING,
    ),
    8 => shape(
      'var' => 'MyBinaryListField4',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    9 => shape(
      'var' => 'MyMapEnumAndInt',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
        'enum' => MyEnumA::class,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyBoolField' => 1,
    'MyIntField' => 2,
    'MyStringField' => 3,
    'MyStringField2' => 4,
    'MyBinaryField' => 5,
    'MyBinaryField2' => 6,
    'MyBinaryField3' => 7,
    'MyBinaryListField4' => 8,
    'MyMapEnumAndInt' => 9,
  ];

  const type TConstructorShape = shape(
    ?'MyBoolField' => bool,
    ?'MyIntField' => int,
    ?'MyStringField' => string,
    ?'MyStringField2' => string,
    ?'MyBinaryField' => string,
    ?'MyBinaryField2' => ?string,
    ?'MyBinaryField3' => string,
    ?'MyBinaryListField4' => Vector<string>,
    ?'MyMapEnumAndInt' => Map<MyEnumA, string>,
  );

  const int STRUCTURAL_ID = 8958221528844030164;
  /**
   * Original thrift field:-
   * 1: bool MyBoolField
   */
  public bool $MyBoolField;
  /**
   * Original thrift field:-
   * 2: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 3: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 4: string MyStringField2
   */
  public string $MyStringField2;
  /**
   * Original thrift field:-
   * 5: binary MyBinaryField
   */
  public string $MyBinaryField;
  /**
   * Original thrift field:-
   * 6: binary MyBinaryField2
   */
  public ?string $MyBinaryField2;
  /**
   * Original thrift field:-
   * 7: binary MyBinaryField3
   */
  public string $MyBinaryField3;
  /**
   * Original thrift field:-
   * 8: list<binary> MyBinaryListField4
   */
  public Vector<string> $MyBinaryListField4;
  /**
   * Original thrift field:-
   * 9: map<enum module.MyEnumA, string> MyMapEnumAndInt
   */
  public Map<MyEnumA, string> $MyMapEnumAndInt;

  <<__Rx>>
  public function __construct(?bool $MyBoolField = null, ?int $MyIntField = null, ?string $MyStringField = null, ?string $MyStringField2 = null, ?string $MyBinaryField = null, ?string $MyBinaryField2 = null, ?string $MyBinaryField3 = null, ?Vector<string> $MyBinaryListField4 = null, ?Map<MyEnumA, string> $MyMapEnumAndInt = null  ) {
    $this->MyBoolField = $MyBoolField ?? false;
    $this->MyIntField = $MyIntField ?? 12;
    $this->MyStringField = $MyStringField ?? "test";
    $this->MyStringField2 = $MyStringField2 ?? '';
    $this->MyBinaryField = $MyBinaryField ?? '';
    $this->MyBinaryField2 = $MyBinaryField2;
    $this->MyBinaryField3 = $MyBinaryField3 ?? '';
    $this->MyBinaryListField4 = $MyBinaryListField4 ?? Vector {};
    $this->MyMapEnumAndInt = $MyMapEnumAndInt ?? Map {
      MyEnumA::fieldA => "fieldA",
      MyEnumA::fieldC => "fieldC",
    };
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'MyBoolField'),
      Shapes::idx($shape, 'MyIntField'),
      Shapes::idx($shape, 'MyStringField'),
      Shapes::idx($shape, 'MyStringField2'),
      Shapes::idx($shape, 'MyBinaryField'),
      Shapes::idx($shape, 'MyBinaryField2'),
      Shapes::idx($shape, 'MyBinaryField3'),
      Shapes::idx($shape, 'MyBinaryListField4'),
      Shapes::idx($shape, 'MyMapEnumAndInt'),
    );
  }

  public function getName(): string {
    return 'NoexceptMoveComplexStruct';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'MyBoolField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyIntField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyStringField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyStringField2' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyBinaryField' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyBinaryField2' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyBinaryField3' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyBinaryListField4' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'MyMapEnumAndInt' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyBoolField') !== null) {
      $this->MyBoolField = /* HH_FIXME[4110] */ $parsed['MyBoolField'];
    }    
    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = /* HH_FIXME[4110] */ $parsed['MyIntField'];
    }    
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = /* HH_FIXME[4110] */ $parsed['MyStringField'];
    }    
    if (idx($parsed, 'MyStringField2') !== null) {
      $this->MyStringField2 = /* HH_FIXME[4110] */ $parsed['MyStringField2'];
    }    
    if (idx($parsed, 'MyBinaryField') !== null) {
      $this->MyBinaryField = /* HH_FIXME[4110] */ $parsed['MyBinaryField'];
    }    
    if (idx($parsed, 'MyBinaryField2') !== null) {
      $this->MyBinaryField2 = /* HH_FIXME[4110] */ $parsed['MyBinaryField2'];
    }    
    if (idx($parsed, 'MyBinaryField3') !== null) {
      $this->MyBinaryField3 = /* HH_FIXME[4110] */ $parsed['MyBinaryField3'];
    } else {
      throw new \TProtocolException("Required field MyBinaryField3 cannot be found.");
    }    
    if (idx($parsed, 'MyBinaryListField4') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['MyBinaryListField4'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = '';
        $_elem5 = $_value2;
        $_container4 []= $_elem5;
      }
      $this->MyBinaryListField4 = $_container4;
    }    
    if (idx($parsed, 'MyMapEnumAndInt') !== null) {
      $_json9 = /* HH_FIXME[4110] */ $parsed['MyMapEnumAndInt'];
      $_container10 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json9 as $_key7 => $_value8) {
        $_value11 = '';
        $_value11 = $_value8;
        $_container10[$_key7] = $_value11;
      }
      $this->MyMapEnumAndInt = $_container10;
    }    
  }

}

enum NoExceptMoveUnionEnum: int {
  _EMPTY_ = 0;
  string_field = 1;
  i32_field = 2;
}

/**
 * Original thrift struct:-
 * NoExceptMoveUnion
 */
class NoExceptMoveUnion implements \IThriftStruct, \IThriftUnion<NoExceptMoveUnionEnum> {
  use \ThriftUnionSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'string_field',
      'union' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'i32_field',
      'union' => true,
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'string_field' => 1,
    'i32_field' => 2,
  ];

  const type TConstructorShape = shape(
    ?'string_field' => ?string,
    ?'i32_field' => ?int,
  );

  const int STRUCTURAL_ID = 5659539827624892912;
  /**
   * Original thrift field:-
   * 1: string string_field
   */
  public ?string $string_field;
  /**
   * Original thrift field:-
   * 2: i32 i32_field
   */
  public ?int $i32_field;
  protected NoExceptMoveUnionEnum $_type = NoExceptMoveUnionEnum::_EMPTY_;

  <<__Rx>>
  public function __construct(?string $string_field = null, ?int $i32_field = null  ) {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    if ($string_field !== null) {
      $this->string_field = $string_field;
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }
    if ($i32_field !== null) {
      $this->i32_field = $i32_field;
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'string_field'),
      Shapes::idx($shape, 'i32_field'),
    );
  }

  public function getName(): string {
    return 'NoExceptMoveUnion';
  }

  public function getType(): NoExceptMoveUnionEnum {
    return $this->_type;
  }

  public function reset(): void {
    switch ($this->_type) {
      case NoExceptMoveUnionEnum::string_field:
        $this->string_field = null;
        break;
      case NoExceptMoveUnionEnum::i32_field:
        $this->i32_field = null;
        break;
      case NoExceptMoveUnionEnum::_EMPTY_:
        break;
    }
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
}

  public function set_string_field(string $string_field): this {
    $this->reset();
    $this->_type = NoExceptMoveUnionEnum::string_field;
    $this->string_field = $string_field;
    return $this;
  }

  public function get_string_field(): string {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::string_field,
      'get_string_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->string_field as nonnull;
  }

  public function set_i32_field(int $i32_field): this {
    $this->reset();
    $this->_type = NoExceptMoveUnionEnum::i32_field;
    $this->i32_field = $i32_field;
    return $this;
  }

  public function get_i32_field(): int {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::i32_field,
      'get_i32_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->i32_field as nonnull;
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'string_field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'i32_field' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.noexcept_move' => "1",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'string_field') !== null) {
      $this->string_field = /* HH_FIXME[4110] */ $parsed['string_field'];
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }    
    if (idx($parsed, 'i32_field') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['i32_field'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32_field = (int)$_tmp0;
      }
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }    
  }

}

/**
 * Original thrift struct:-
 * AllocatorAware
 */
class AllocatorAware implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'aa_list',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'aa_set',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'aa_map',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'aa_string',
      'type' => \TType::STRING,
    ),
    5 => shape(
      'var' => 'not_a_container',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'aa_list' => 1,
    'aa_set' => 2,
    'aa_map' => 3,
    'aa_string' => 4,
    'not_a_container' => 5,
  ];

  const type TConstructorShape = shape(
    ?'aa_list' => Vector<int>,
    ?'aa_set' => Set<int>,
    ?'aa_map' => Map<int, int>,
    ?'aa_string' => string,
    ?'not_a_container' => int,
  );

  const int STRUCTURAL_ID = 5875128050373741032;
  /**
   * Original thrift field:-
   * 1: list<i32> aa_list
   */
  public Vector<int> $aa_list;
  /**
   * Original thrift field:-
   * 2: set<i32> aa_set
   */
  public Set<int> $aa_set;
  /**
   * Original thrift field:-
   * 3: map<i32, i32> aa_map
   */
  public Map<int, int> $aa_map;
  /**
   * Original thrift field:-
   * 4: string aa_string
   */
  public string $aa_string;
  /**
   * Original thrift field:-
   * 5: i32 not_a_container
   */
  public int $not_a_container;

  <<__Rx>>
  public function __construct(?Vector<int> $aa_list = null, ?Set<int> $aa_set = null, ?Map<int, int> $aa_map = null, ?string $aa_string = null, ?int $not_a_container = null  ) {
    $this->aa_list = $aa_list ?? Vector {};
    $this->aa_set = $aa_set ?? Set {};
    $this->aa_map = $aa_map ?? Map {};
    $this->aa_string = $aa_string ?? '';
    $this->not_a_container = $not_a_container ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'aa_list'),
      Shapes::idx($shape, 'aa_set'),
      Shapes::idx($shape, 'aa_map'),
      Shapes::idx($shape, 'aa_string'),
      Shapes::idx($shape, 'not_a_container'),
    );
  }

  public function getName(): string {
    return 'AllocatorAware';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'aa_list' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'aa_set' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'aa_map' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'aa_string' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
        'not_a_container' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.allocator' => "some_allocator",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'aa_list') !== null) {
      $_json3 = /* HH_FIXME[4110] */ $parsed['aa_list'];
      $_container4 = Vector {};
      foreach(/* HH_FIXME[4110] */ $_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->aa_list = $_container4;
    }    
    if (idx($parsed, 'aa_set') !== null) {
      $_json10 = /* HH_FIXME[4110] */ $parsed['aa_set'];
      $_container11 = Set {};
      foreach(/* HH_FIXME[4110] */ $_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11->add($_elem12);
      }
      $this->aa_set = $_container11;
    }    
    if (idx($parsed, 'aa_map') !== null) {
      $_json17 = /* HH_FIXME[4110] */ $parsed['aa_map'];
      $_container18 = Map {};
      foreach(/* HH_FIXME[4110] */ $_json17 as $_key15 => $_value16) {
        $_value19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_value19 = (int)$_tmp20;
        }
        $_container18[$_key15] = $_value19;
      }
      $this->aa_map = $_container18;
    }    
    if (idx($parsed, 'aa_string') !== null) {
      $this->aa_string = /* HH_FIXME[4110] */ $parsed['aa_string'];
    }    
    if (idx($parsed, 'not_a_container') !== null) {
      $_tmp21 = (int)/* HH_FIXME[4110] */ $parsed['not_a_container'];
      if ($_tmp21 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->not_a_container = (int)$_tmp21;
      }
    }    
  }

}

/**
 * Original thrift struct:-
 * AllocatorAware2
 */
class AllocatorAware2 implements \IThriftStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'not_a_container',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'not_a_container' => 1,
  ];

  const type TConstructorShape = shape(
    ?'not_a_container' => int,
  );

  const int STRUCTURAL_ID = 3476753821834683211;
  /**
   * Original thrift field:-
   * 1: i32 not_a_container
   */
  public int $not_a_container;

  <<__Rx>>
  public function __construct(?int $not_a_container = null  ) {
    $this->not_a_container = $not_a_container ?? 0;
  }

  <<__Rx>>
  public static function fromShape(self::TConstructorShape $shape): this {
    return new static(
      Shapes::idx($shape, 'not_a_container'),
    );
  }

  public function getName(): string {
    return 'AllocatorAware2';
  }

  public static function getAllStructuredAnnotations(): \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
        'not_a_container' => shape(
          'field' => dict[],
          'type' => dict[],
        ),
      ],
    );
  }

  public static function getAnnotations(): darray<string, mixed> {
    return darray[
      'cpp.allocator' => "some_allocator",
    ];
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'not_a_container') !== null) {
      $_tmp0 = (int)/* HH_FIXME[4110] */ $parsed['not_a_container'];
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->not_a_container = (int)$_tmp0;
      }
    }    
  }

}

