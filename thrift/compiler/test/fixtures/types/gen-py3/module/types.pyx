#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import enum as __enum
import warnings
import builtins as _builtins
cimport include.types as _include_types
import include.types as _include_types


class has_bitwise_ops(__enum.Enum):
    none = 0
    zero = 1
    one = 2
    two = 4
    three = 8

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline chas_bitwise_ops has_bitwise_ops_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return has_bitwise_ops__none
    elif cvalue == 1:
        return has_bitwise_ops__zero
    elif cvalue == 2:
        return has_bitwise_ops__one
    elif cvalue == 4:
        return has_bitwise_ops__two
    elif cvalue == 8:
        return has_bitwise_ops__three
class is_unscoped(__enum.Enum):
    hello = 0
    world = 1

    __hash__ = __enum.Enum.__hash__

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            warnings.warn(f"comparison not supported between instances of {type(self)} and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self.value == other.value

    def __int__(self):
        return self.value

cdef inline cis_unscoped is_unscoped_to_cpp(value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return is_unscoped__hello
    elif cvalue == 1:
        return is_unscoped__world


cdef cdecorated_struct _decorated_struct_defaults = cdecorated_struct()

cdef class decorated_struct(thrift.py3.types.Struct):

    def __init__(
        decorated_struct self, *,
        str field=None
    ):
        self._cpp_obj = move(decorated_struct._make_instance(
          NULL,
          field,
        ))

    def __call__(
        decorated_struct self,
        field=__NOTSET
    ):
        changes = any((
            field is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not field is not __NOTSET:
            if not isinstance(field, str):
                raise TypeError(f'field is not a { str !r}.')

        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = move(decorated_struct._make_instance(
          self._cpp_obj.get(),
          field,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cdecorated_struct] _make_instance(
        cdecorated_struct* base_instance,
        object field
    ) except *:
        cdef unique_ptr[cdecorated_struct] c_inst
        if base_instance:
            c_inst = make_unique[cdecorated_struct](deref(base_instance))
        else:
            c_inst = make_unique[cdecorated_struct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if field is None:
                deref(c_inst).field = _decorated_struct_defaults.field
                deref(c_inst).__isset.field = False
                pass
            elif field is __NOTSET:
                field = None

        if field is not None:
            deref(c_inst).field = field.encode('UTF-8')
            deref(c_inst).__isset.field = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'field', self.field

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cdecorated_struct] cpp_obj):
        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def field(self):

        return (<bytes>self._cpp_obj.get().field).decode('UTF-8')


    def __hash__(decorated_struct self):
        if not self.__hash:
            self.__hash = hash((
            self.field,
            ))
        return self.__hash

    def __repr__(decorated_struct self):
        return f'decorated_struct(field={repr(self.field)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, decorated_struct) and
                isinstance(other, decorated_struct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cdecorated_struct cself = deref((<decorated_struct>self)._cpp_obj)
        cdef cdecorated_struct cother = deref((<decorated_struct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(decorated_struct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(decorated_struct self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cdecorated_struct]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (decorated_struct, serialize(self)))


cdef cContainerStruct _ContainerStruct_defaults = cContainerStruct()

cdef class ContainerStruct(thrift.py3.types.Struct):

    def __init__(
        ContainerStruct self, *,
        fieldA=None,
        fieldB=None,
        fieldC=None,
        fieldD=None,
        fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None
    ):
        self._cpp_obj = move(ContainerStruct._make_instance(
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))

    def __call__(
        ContainerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET
    ):
        changes = any((
            fieldA is not __NOTSET,

            fieldB is not __NOTSET,

            fieldC is not __NOTSET,

            fieldD is not __NOTSET,

            fieldE is not __NOTSET,

            fieldF is not __NOTSET,

            fieldG is not __NOTSET,

            fieldH is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = move(ContainerStruct._make_instance(
          self._cpp_obj.get(),
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cContainerStruct] _make_instance(
        cContainerStruct* base_instance,
        object fieldA,
        object fieldB,
        object fieldC,
        object fieldD,
        object fieldE,
        object fieldF,
        object fieldG,
        object fieldH
    ) except *:
        cdef unique_ptr[cContainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[cContainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[cContainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if fieldA is None:
                deref(c_inst).fieldA = _ContainerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass
            elif fieldA is __NOTSET:
                fieldA = None

            if fieldB is None:
                deref(c_inst).fieldB = _ContainerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
                pass
            elif fieldB is __NOTSET:
                fieldB = None

            if fieldC is None:
                deref(c_inst).fieldC = _ContainerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
                pass
            elif fieldC is __NOTSET:
                fieldC = None

            if fieldD is None:
                deref(c_inst).fieldD = _ContainerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
                pass
            elif fieldD is __NOTSET:
                fieldD = None

            if fieldE is None:
                deref(c_inst).fieldE = _ContainerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
                pass
            elif fieldE is __NOTSET:
                fieldE = None

            if fieldF is None:
                deref(c_inst).fieldF = _ContainerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
                pass
            elif fieldF is __NOTSET:
                fieldF = None

            if fieldG is None:
                deref(c_inst).fieldG = _ContainerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
                pass
            elif fieldG is __NOTSET:
                fieldG = None

            if fieldH is None:
                deref(c_inst).fieldH = _ContainerStruct_defaults.fieldH
                deref(c_inst).__isset.fieldH = False
                pass
            elif fieldH is __NOTSET:
                fieldH = None

        if fieldA is not None:
            deref(c_inst).fieldA = <vector[int32_t]>deref(List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB = <std_list[int32_t]>deref(std_list__List__i32(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC = <std_deque[int32_t]>deref(std_deque__List__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD = <folly_fbvector[int32_t]>deref(folly_fbvector__List__i32(fieldD)._cpp_obj)
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE = <folly_small_vector[int32_t]>deref(folly_small_vector__List__i32(fieldE)._cpp_obj)
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF = <folly_sorted_vector_set[int32_t]>deref(folly_sorted_vector_set__Set__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG = <folly_sorted_vector_map[int32_t,string]>deref(folly_sorted_vector_map__Map__i32_string(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH = <std_unordered_map[int32_t,string]>deref(std_unordered_map__Map__i32_string(fieldH)._cpp_obj)
            deref(c_inst).__isset.fieldH = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH

    def __bool__(self):
        return True or True or True or True or True or True or True or True

    @staticmethod
    cdef create(shared_ptr[cContainerStruct] cpp_obj):
        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def fieldA(self):

        if self.__fieldA is None:
            self.__fieldA = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).fieldA))
        return self.__fieldA

    @property
    def fieldB(self):

        if self.__fieldB is None:
            self.__fieldB = std_list__List__i32.create(make_shared[std_list[int32_t]](deref(self._cpp_obj).fieldB))
        return self.__fieldB

    @property
    def fieldC(self):

        if self.__fieldC is None:
            self.__fieldC = std_deque__List__i32.create(make_shared[std_deque[int32_t]](deref(self._cpp_obj).fieldC))
        return self.__fieldC

    @property
    def fieldD(self):

        if self.__fieldD is None:
            self.__fieldD = folly_fbvector__List__i32.create(make_shared[folly_fbvector[int32_t]](deref(self._cpp_obj).fieldD))
        return self.__fieldD

    @property
    def fieldE(self):

        if self.__fieldE is None:
            self.__fieldE = folly_small_vector__List__i32.create(make_shared[folly_small_vector[int32_t]](deref(self._cpp_obj).fieldE))
        return self.__fieldE

    @property
    def fieldF(self):

        if self.__fieldF is None:
            self.__fieldF = folly_sorted_vector_set__Set__i32.create(make_shared[folly_sorted_vector_set[int32_t]](deref(self._cpp_obj).fieldF))
        return self.__fieldF

    @property
    def fieldG(self):

        if self.__fieldG is None:
            self.__fieldG = folly_sorted_vector_map__Map__i32_string.create(make_shared[folly_sorted_vector_map[int32_t,string]](deref(self._cpp_obj).fieldG))
        return self.__fieldG

    @property
    def fieldH(self):

        if self.__fieldH is None:
            self.__fieldH = std_unordered_map__Map__i32_string.create(make_shared[std_unordered_map[int32_t,string]](deref(self._cpp_obj).fieldH))
        return self.__fieldH


    def __hash__(ContainerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            ))
        return self.__hash

    def __repr__(ContainerStruct self):
        return f'ContainerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ContainerStruct) and
                isinstance(other, ContainerStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cContainerStruct cself = deref((<ContainerStruct>self)._cpp_obj)
        cdef cContainerStruct cother = deref((<ContainerStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(ContainerStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(ContainerStruct self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cContainerStruct]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (ContainerStruct, serialize(self)))


cdef cVirtualStruct _VirtualStruct_defaults = cVirtualStruct()

cdef class VirtualStruct(thrift.py3.types.Struct):

    def __init__(
        VirtualStruct self, *,
        MyIntField=None
    ):
        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            <int64_t> MyIntField

        self._cpp_obj = move(VirtualStruct._make_instance(
          NULL,
          MyIntField,
        ))

    def __call__(
        VirtualStruct self,
        MyIntField=__NOTSET
    ):
        changes = any((
            MyIntField is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not MyIntField is not __NOTSET:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            <int64_t> MyIntField

        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = move(VirtualStruct._make_instance(
          self._cpp_obj.get(),
          MyIntField,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cVirtualStruct] _make_instance(
        cVirtualStruct* base_instance,
        object MyIntField
    ) except *:
        cdef unique_ptr[cVirtualStruct] c_inst
        if base_instance:
            c_inst = make_unique[cVirtualStruct](deref(base_instance))
        else:
            c_inst = make_unique[cVirtualStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if MyIntField is None:
                deref(c_inst).MyIntField = _VirtualStruct_defaults.MyIntField
                deref(c_inst).__isset.MyIntField = False
                pass
            elif MyIntField is __NOTSET:
                MyIntField = None

        if MyIntField is not None:
            deref(c_inst).MyIntField = MyIntField
            deref(c_inst).__isset.MyIntField = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'MyIntField', self.MyIntField

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cVirtualStruct] cpp_obj):
        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def MyIntField(self):

        return self._cpp_obj.get().MyIntField


    def __hash__(VirtualStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.MyIntField,
            ))
        return self.__hash

    def __repr__(VirtualStruct self):
        return f'VirtualStruct(MyIntField={repr(self.MyIntField)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, VirtualStruct) and
                isinstance(other, VirtualStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cVirtualStruct cself = deref((<VirtualStruct>self)._cpp_obj)
        cdef cVirtualStruct cother = deref((<VirtualStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(VirtualStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cVirtualStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cVirtualStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cVirtualStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(VirtualStruct self, const IOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cVirtualStruct]()
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cVirtualStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cVirtualStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cVirtualStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (VirtualStruct, serialize(self)))


cdef class std_unordered_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, std_unordered_map__Map__i32_string):
            self._cpp_obj = (<std_unordered_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(std_unordered_map__Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_unordered_map[int32_t,string]] c_items):
        inst = <std_unordered_map__Map__i32_string>std_unordered_map__Map__i32_string.__new__(std_unordered_map__Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_unordered_map[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[std_unordered_map[int32_t,string]] c_inst = make_unique[std_unordered_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef std_unordered_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(std_unordered_map__Map__i32_string)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class std_list__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list__List__i32):
            self._cpp_obj = (<std_list__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_list__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_list[int32_t]] c_items):
        inst = <std_list__List__i32>std_list__List__i32.__new__(std_list__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_list[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_list[int32_t]] c_inst = make_unique[std_list[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_list[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return std_list__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_list[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_list[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef std_list[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_list__List__i32)

cdef class std_deque__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_deque__List__i32):
            self._cpp_obj = (<std_deque__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_deque__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_deque[int32_t]] c_items):
        inst = <std_deque__List__i32>std_deque__List__i32.__new__(std_deque__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_deque[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_deque[int32_t]] c_inst = make_unique[std_deque[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_deque[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_deque[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return std_deque__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_deque[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_deque[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef std_deque[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_deque__List__i32)

cdef class folly_fbvector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_fbvector__List__i32):
            self._cpp_obj = (<folly_fbvector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_fbvector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_fbvector[int32_t]] c_items):
        inst = <folly_fbvector__List__i32>folly_fbvector__List__i32.__new__(folly_fbvector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_fbvector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_fbvector[int32_t]] c_inst = make_unique[folly_fbvector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_fbvector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_fbvector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return folly_fbvector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_fbvector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_fbvector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef folly_fbvector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_fbvector__List__i32)

cdef class folly_small_vector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_small_vector__List__i32):
            self._cpp_obj = (<folly_small_vector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_small_vector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_small_vector[int32_t]] c_items):
        inst = <folly_small_vector__List__i32>folly_small_vector__List__i32.__new__(folly_small_vector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_small_vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_small_vector[int32_t]] c_inst = make_unique[folly_small_vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_small_vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_small_vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
            return folly_small_vector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_small_vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_small_vector[int32_t].iterator end = std_libcpp.prev(vec.end(), <int64_t>offset_end)
        cdef folly_small_vector[int32_t].iterator loc = std_libcpp.find(
            std_libcpp.next(vec.begin(), <int64_t>offset_begin),
            end,
            citem
        )
        if loc != end:
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_small_vector__List__i32)

cdef class folly_sorted_vector_set__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_set__Set__i32):
            self._cpp_obj = (<folly_sorted_vector_set__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_set__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_set[int32_t]] c_items):
        inst = <folly_sorted_vector_set__Set__i32>folly_sorted_vector_set__Set__i32.__new__(folly_sorted_vector_set__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_set[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_set[int32_t]] c_inst = make_unique[folly_sorted_vector_set[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                <int32_t> item
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef folly_sorted_vector_set[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, folly_sorted_vector_set__Set__i32) and
                isinstance(other, folly_sorted_vector_set__Set__i32)):
            cself = deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj)
            cother = deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(folly_sorted_vector_set__Set__i32)

cdef class folly_sorted_vector_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_map__Map__i32_string):
            self._cpp_obj = (<folly_sorted_vector_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_map__Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_map[int32_t,string]] c_items):
        inst = <folly_sorted_vector_map__Map__i32_string>folly_sorted_vector_map__Map__i32_string.__new__(folly_sorted_vector_map__Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] c_inst = make_unique[folly_sorted_vector_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err
        cdef int32_t ckey = key
        cdef folly_sorted_vector_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, int):
                key = int(key)
        except Exception:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(folly_sorted_vector_map__Map__i32_string)

