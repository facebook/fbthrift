#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.serializer import Protocol
import typing as _typing

import sys
import itertools
from enum import Enum


class has_bitwise_ops(Enum):
    none: ...
    zero: ...
    one: ...
    two: ...
    three: ...
    value: int


class is_unscoped(Enum):
    hello: ...
    world: ...
    value: int


# Forward Definitions for Structs
class decorated_struct(thrift.py3.types.Struct): ...
class ContainerStruct(thrift.py3.types.Struct): ...
class VirtualStruct(thrift.py3.types.Struct): ...
# Forward Definitions for Containers
class std_unordered_map__Map__i32_string(_typing.Mapping[int, str]): ...
class List__i32(_typing.Sequence[int]): ...
class std_list__List__i32(_typing.Sequence[int]): ...
class std_deque__List__i32(_typing.Sequence[int]): ...
class folly_fbvector__List__i32(_typing.Sequence[int]): ...
class folly_small_vector__List__i32(_typing.Sequence[int]): ...
class folly_sorted_vector_set__Set__i32(_typing.AbstractSet[int]): ...
class folly_sorted_vector_map__Map__i32_string(_typing.Mapping[int, str]): ...


class decorated_struct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        field: str=None
    ) -> None: ...

    def __call__(
        self, *,
        field: _typing.Union[str, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[decorated_struct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: decorated_struct) -> bool: ...
    def __lt__(self, other: decorated_struct) -> bool: ...

    @property
    def field(self) -> str: ...


class ContainerStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        fieldA: _typing.Sequence[int]=None,
        fieldB: _typing.Sequence[int]=None,
        fieldC: _typing.Sequence[int]=None,
        fieldD: _typing.Sequence[int]=None,
        fieldE: _typing.Sequence[int]=None,
        fieldF: _typing.AbstractSet[int]=None,
        fieldG: _typing.Mapping[int, str]=None,
        fieldH: _typing.Mapping[int, str]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldB: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldC: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldD: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldE: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldF: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        fieldG: _typing.Union[_typing.Mapping[int, str], NOTSET, None]=NOTSET,
        fieldH: _typing.Union[_typing.Mapping[int, str], NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[ContainerStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: ContainerStruct) -> bool: ...
    def __lt__(self, other: ContainerStruct) -> bool: ...

    @property
    def fieldA(self) -> List__i32: ...
    @property
    def fieldB(self) -> std_list__List__i32: ...
    @property
    def fieldC(self) -> std_deque__List__i32: ...
    @property
    def fieldD(self) -> folly_fbvector__List__i32: ...
    @property
    def fieldE(self) -> folly_small_vector__List__i32: ...
    @property
    def fieldF(self) -> folly_sorted_vector_set__Set__i32: ...
    @property
    def fieldG(self) -> folly_sorted_vector_map__Map__i32_string: ...
    @property
    def fieldH(self) -> std_unordered_map__Map__i32_string: ...


class VirtualStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        MyIntField: int=None
    ) -> None: ...

    def __call__(
        self, *,
        MyIntField: _typing.Union[int, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[VirtualStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: VirtualStruct) -> bool: ...
    def __lt__(self, other: VirtualStruct) -> bool: ...

    @property
    def MyIntField(self) -> int: ...


class std_unordered_map__Map__i32_string(_typing.Mapping[int, str]):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, str]) -> bool: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, str]]: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> List__i32: ...
    def __radd__(self, other: _List__i32T) -> _List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_std_list__List__i32T = _typing.TypeVar('_std_list__List__i32T', bound=_typing.Sequence[int])


class std_list__List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> std_list__List__i32: ...
    def __radd__(self, other: _std_list__List__i32T) -> _std_list__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> std_list__List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_std_deque__List__i32T = _typing.TypeVar('_std_deque__List__i32T', bound=_typing.Sequence[int])


class std_deque__List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> std_deque__List__i32: ...
    def __radd__(self, other: _std_deque__List__i32T) -> _std_deque__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> std_deque__List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_folly_fbvector__List__i32T = _typing.TypeVar('_folly_fbvector__List__i32T', bound=_typing.Sequence[int])


class folly_fbvector__List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> folly_fbvector__List__i32: ...
    def __radd__(self, other: _folly_fbvector__List__i32T) -> _folly_fbvector__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> folly_fbvector__List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_folly_small_vector__List__i32T = _typing.TypeVar('_folly_small_vector__List__i32T', bound=_typing.Sequence[int])


class folly_small_vector__List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> folly_small_vector__List__i32: ...
    def __radd__(self, other: _folly_small_vector__List__i32T) -> _folly_small_vector__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> folly_small_vector__List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


class folly_sorted_vector_set__Set__i32(_typing.AbstractSet[int]):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __contains__(self, item: int) -> bool: ...
    def __iter__(self) -> int): ...
    def __add__(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def __or__(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def __xor__(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def intersection(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def difference(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> folly_sorted_vector_set__Set__i32: ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...


class folly_sorted_vector_map__Map__i32_string(_typing.Mapping[int, str]):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, str]) -> bool: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, str]]: ...


