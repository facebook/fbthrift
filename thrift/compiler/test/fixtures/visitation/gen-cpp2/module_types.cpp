/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::size;
folly::Range<::test_cpp2::cpp_reflection::enum1 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum1_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES = _enum1_EnumMapFactory::makeValuesToNamesMap();
const _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES = _enum1_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::size;
folly::Range<::test_cpp2::cpp_reflection::enum2 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum2_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES = _enum2_EnumMapFactory::makeValuesToNamesMap();
const _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES = _enum2_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::size;
folly::Range<::test_cpp2::cpp_reflection::enum3 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum3_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES = _enum3_EnumMapFactory::makeValuesToNamesMap();
const _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES = _enum3_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::size;
folly::Range<::test_cpp2::cpp_reflection::enum_with_special_names const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findName(type value) {
  using factory = ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(char const* name, type* out) {
  using factory = ::test_cpp2::cpp_reflection::_enum_with_special_names_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES = _enum_with_special_names_EnumMapFactory::makeValuesToNamesMap();
const _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES = _enum_with_special_names_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union1::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union1::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union1::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union1::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
      destruct(value_.ui);
      break;
    case Type::ud:
      destruct(value_.ud);
      break;
    case Type::us:
      destruct(value_.us);
      break;
    case Type::ue:
      destruct(value_.ue);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
      return value_.ui == rhs.value_.ui;
    case Type::ud:
      return value_.ud == rhs.value_.ud;
    case Type::us:
      return value_.us == rhs.value_.us;
    case Type::ue:
      return value_.ue == rhs.value_.ue;
    default:
      return true;
  }
}

bool union1::operator<(const union1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui:
      return lhs.value_.ui < rhs.value_.ui;
    case Type::ud:
      return lhs.value_.ud < rhs.value_.ud;
    case Type::us:
      return lhs.value_.us < rhs.value_.us;
    case Type::ue:
      return lhs.value_.ue < rhs.value_.ue;
    default:
      return false;
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union2::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union2::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union2::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union2::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
      destruct(value_.ui_2);
      break;
    case Type::ud_2:
      destruct(value_.ud_2);
      break;
    case Type::us_2:
      destruct(value_.us_2);
      break;
    case Type::ue_2:
      destruct(value_.ue_2);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
      return value_.ui_2 == rhs.value_.ui_2;
    case Type::ud_2:
      return value_.ud_2 == rhs.value_.ud_2;
    case Type::us_2:
      return value_.us_2 == rhs.value_.us_2;
    case Type::ue_2:
      return value_.ue_2 == rhs.value_.ue_2;
    default:
      return true;
  }
}

bool union2::operator<(const union2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui_2:
      return lhs.value_.ui_2 < rhs.value_.ui_2;
    case Type::ud_2:
      return lhs.value_.ud_2 < rhs.value_.ud_2;
    case Type::us_2:
      return lhs.value_.us_2 < rhs.value_.us_2;
    case Type::ue_2:
      return lhs.value_.ue_2 < rhs.value_.ue_2;
    default:
      return false;
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union3::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union3::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union3::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union3::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
      destruct(value_.ui_3);
      break;
    case Type::ud_3:
      destruct(value_.ud_3);
      break;
    case Type::us_3:
      destruct(value_.us_3);
      break;
    case Type::ue_3:
      destruct(value_.ue_3);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
      return value_.ui_3 == rhs.value_.ui_3;
    case Type::ud_3:
      return value_.ud_3 == rhs.value_.ud_3;
    case Type::us_3:
      return value_.us_3 == rhs.value_.us_3;
    case Type::ue_3:
      return value_.ue_3 == rhs.value_.ue_3;
    default:
      return true;
  }
}

bool union3::operator<(const union3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::ui_3:
      return lhs.value_.ui_3 < rhs.value_.ui_3;
    case Type::ud_3:
      return lhs.value_.ud_3 < rhs.value_.ud_3;
    case Type::us_3:
      return lhs.value_.us_3 < rhs.value_.us_3;
    case Type::ue_3:
      return lhs.value_.ue_3 < rhs.value_.ue_3;
    default:
      return false;
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structA::structA(const structA&) = default;
structA& structA::operator=(const structA&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structA::structA(structA&& other) noexcept  :
    a(std::move(other.a)),
    b(std::move(other.b)),
    __isset(other.__isset) {}
structA& structA::operator=(FOLLY_MAYBE_UNUSED structA&& other) noexcept {
    this->a = std::move(other.a);
    this->b = std::move(other.b);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structA::structA(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)) {
  __isset.a = true;
  __isset.b = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void structA::__clear() {
  // clear all fields
  this->a = 0;
  this->b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structA::operator==(const structA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  return true;
}

bool structA::operator<(const structA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  return false;
}


void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::unionA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::unionA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::unionA::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::unionA::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::unionA::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void unionA::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::i:
      destruct(value_.i);
      break;
    case Type::d:
      destruct(value_.d);
      break;
    case Type::s:
      destruct(value_.s);
      break;
    case Type::e:
      destruct(value_.e);
      break;
    case Type::a:
      destruct(value_.a);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::i:
      return value_.i == rhs.value_.i;
    case Type::d:
      return value_.d == rhs.value_.d;
    case Type::s:
      return value_.s == rhs.value_.s;
    case Type::e:
      return value_.e == rhs.value_.e;
    case Type::a:
      return value_.a == rhs.value_.a;
    default:
      return true;
  }
}

bool unionA::operator<(const unionA& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::i:
      return lhs.value_.i < rhs.value_.i;
    case Type::d:
      return lhs.value_.d < rhs.value_.d;
    case Type::s:
      return lhs.value_.s < rhs.value_.s;
    case Type::e:
      return lhs.value_.e < rhs.value_.e;
    case Type::a:
      return lhs.value_.a < rhs.value_.a;
    default:
      return false;
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void unionA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void unionA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        unionA,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        unionA,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structB>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structB>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structB::structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
    c(std::move(c__arg)),
    d(std::move(d__arg)) {
  __isset.c = true;
  __isset.d = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void structB::__clear() {
  // clear all fields
  this->c = 0;
  this->d = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structB::operator==(const structB& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return false;
  }
  return true;
}

bool structB::operator<(const structB& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return lhs.d_ref() < rhs.d_ref();
  }
  return false;
}


void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.d_ref().value(), b.d_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structB::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structB::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structC>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structC>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC(const structC&) = default;
structC& structC::operator=(const structC&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC() :
      a(0),
      c(0),
      d(0),
      e( ::test_cpp2::cpp_reflection::enum1::field0),
      f( ::test_cpp2::cpp_reflection::enum2::field0_2) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

structC::~structC() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC(structC&& other) noexcept  :
    a(std::move(other.a)),
    b(std::move(other.b)),
    c(std::move(other.c)),
    d(std::move(other.d)),
    e(std::move(other.e)),
    f(std::move(other.f)),
    g(std::move(other.g)),
    h(std::move(other.h)),
    i(std::move(other.i)),
    j(std::move(other.j)),
    j1(std::move(other.j1)),
    j2(std::move(other.j2)),
    j3(std::move(other.j3)),
    k(std::move(other.k)),
    k1(std::move(other.k1)),
    k2(std::move(other.k2)),
    k3(std::move(other.k3)),
    l(std::move(other.l)),
    l1(std::move(other.l1)),
    l2(std::move(other.l2)),
    l3(std::move(other.l3)),
    m1(std::move(other.m1)),
    m2(std::move(other.m2)),
    m3(std::move(other.m3)),
    n1(std::move(other.n1)),
    n2(std::move(other.n2)),
    n3(std::move(other.n3)),
    o1(std::move(other.o1)),
    o2(std::move(other.o2)),
    o3(std::move(other.o3)),
    __isset(other.__isset) {}
structC& structC::operator=(FOLLY_MAYBE_UNUSED structC&& other) noexcept {
    this->a = std::move(other.a);
    this->b = std::move(other.b);
    this->c = std::move(other.c);
    this->d = std::move(other.d);
    this->e = std::move(other.e);
    this->f = std::move(other.f);
    this->g = std::move(other.g);
    this->h = std::move(other.h);
    this->i = std::move(other.i);
    this->j = std::move(other.j);
    this->j1 = std::move(other.j1);
    this->j2 = std::move(other.j2);
    this->j3 = std::move(other.j3);
    this->k = std::move(other.k);
    this->k1 = std::move(other.k1);
    this->k2 = std::move(other.k2);
    this->k3 = std::move(other.k3);
    this->l = std::move(other.l);
    this->l1 = std::move(other.l1);
    this->l2 = std::move(other.l2);
    this->l3 = std::move(other.l3);
    this->m1 = std::move(other.m1);
    this->m2 = std::move(other.m2);
    this->m3 = std::move(other.m3);
    this->n1 = std::move(other.n1);
    this->n2 = std::move(other.n2);
    this->n3 = std::move(other.n3);
    this->o1 = std::move(other.o1);
    this->o2 = std::move(other.o2);
    this->o3 = std::move(other.o3);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
structC::structC(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg, ::test_cpp2::cpp_reflection::enum1 e__arg, ::test_cpp2::cpp_reflection::enum2 f__arg, ::test_cpp2::cpp_reflection::union1 g__arg, ::test_cpp2::cpp_reflection::unionA h__arg, ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<::std::int32_t> j__arg, ::std::vector<::std::int32_t> j1__arg, ::std::vector<::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<::std::int32_t> k__arg, ::std::set<::std::int32_t> k1__arg, ::std::set<::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set<::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<::std::int32_t, ::std::int32_t> l__arg, ::std::map<::std::int32_t, ::std::int32_t> l1__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> m1__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, ::std::int32_t> n1__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> o1__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> o3__arg) :
    a(std::move(a__arg)),
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    d(std::move(d__arg)),
    e(std::move(e__arg)),
    f(std::move(f__arg)),
    g(std::move(g__arg)),
    h(std::move(h__arg)),
    i(std::move(i__arg)),
    j(std::move(j__arg)),
    j1(std::move(j1__arg)),
    j2(std::move(j2__arg)),
    j3(std::move(j3__arg)),
    k(std::move(k__arg)),
    k1(std::move(k1__arg)),
    k2(std::move(k2__arg)),
    k3(std::move(k3__arg)),
    l(std::move(l__arg)),
    l1(std::move(l1__arg)),
    l2(std::move(l2__arg)),
    l3(std::move(l3__arg)),
    m1(std::move(m1__arg)),
    m2(std::move(m2__arg)),
    m3(std::move(m3__arg)),
    n1(std::move(n1__arg)),
    n2(std::move(n2__arg)),
    n3(std::move(n3__arg)),
    o1(std::move(o1__arg)),
    o2(std::move(o2__arg)),
    o3(std::move(o3__arg)) {
  __isset.a = true;
  __isset.b = true;
  __isset.c = true;
  __isset.d = true;
  __isset.e = true;
  __isset.f = true;
  __isset.g = true;
  __isset.h = true;
  __isset.i = true;
  __isset.j = true;
  __isset.j1 = true;
  __isset.j2 = true;
  __isset.j3 = true;
  __isset.k = true;
  __isset.k1 = true;
  __isset.k2 = true;
  __isset.k3 = true;
  __isset.l = true;
  __isset.l1 = true;
  __isset.l2 = true;
  __isset.l3 = true;
  __isset.m1 = true;
  __isset.m2 = true;
  __isset.m3 = true;
  __isset.n1 = true;
  __isset.n2 = true;
  __isset.n3 = true;
  __isset.o1 = true;
  __isset.o2 = true;
  __isset.o3 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void structC::__clear() {
  // clear all fields
  this->a = 0;
  this->b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->c = 0;
  this->d = 0;
  this->e =  ::test_cpp2::cpp_reflection::enum1::field0;
  this->f =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  this->g.__clear();
  this->h.__clear();
  this->i.__clear();
  this->j.clear();
  this->j1.clear();
  this->j2.clear();
  this->j3.clear();
  this->k.clear();
  this->k1.clear();
  this->k2.clear();
  this->k3.clear();
  this->l.clear();
  this->l1.clear();
  this->l2.clear();
  this->l3.clear();
  this->m1.clear();
  this->m2.clear();
  this->m3.clear();
  this->n1.clear();
  this->n2.clear();
  this->n3.clear();
  this->o1.clear();
  this->o2.clear();
  this->o3.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool structC::operator==(const structC& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return false;
  }
  if (!(lhs.e_ref() == rhs.e_ref())) {
    return false;
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return false;
  }
  if (!(lhs.g_ref() == rhs.g_ref())) {
    return false;
  }
  if (!(lhs.h_ref() == rhs.h_ref())) {
    return false;
  }
  if (!(lhs.i_ref() == rhs.i_ref())) {
    return false;
  }
  if (!(lhs.j_ref() == rhs.j_ref())) {
    return false;
  }
  if (!(lhs.j1_ref() == rhs.j1_ref())) {
    return false;
  }
  if (!(lhs.j2_ref() == rhs.j2_ref())) {
    return false;
  }
  if (!(lhs.j3_ref() == rhs.j3_ref())) {
    return false;
  }
  if (!(lhs.k_ref() == rhs.k_ref())) {
    return false;
  }
  if (!(lhs.k1_ref() == rhs.k1_ref())) {
    return false;
  }
  if (!(lhs.k2_ref() == rhs.k2_ref())) {
    return false;
  }
  if (!(lhs.k3_ref() == rhs.k3_ref())) {
    return false;
  }
  if (!(lhs.l_ref() == rhs.l_ref())) {
    return false;
  }
  if (!(lhs.l1_ref() == rhs.l1_ref())) {
    return false;
  }
  if (!(lhs.l2_ref() == rhs.l2_ref())) {
    return false;
  }
  if (!(lhs.l3_ref() == rhs.l3_ref())) {
    return false;
  }
  if (!(lhs.m1_ref() == rhs.m1_ref())) {
    return false;
  }
  if (!(lhs.m2_ref() == rhs.m2_ref())) {
    return false;
  }
  if (!(lhs.m3_ref() == rhs.m3_ref())) {
    return false;
  }
  if (!(lhs.n1_ref() == rhs.n1_ref())) {
    return false;
  }
  if (!(lhs.n2_ref() == rhs.n2_ref())) {
    return false;
  }
  if (!(lhs.n3_ref() == rhs.n3_ref())) {
    return false;
  }
  if (!(lhs.o1_ref() == rhs.o1_ref())) {
    return false;
  }
  if (!(lhs.o2_ref() == rhs.o2_ref())) {
    return false;
  }
  if (!(lhs.o3_ref() == rhs.o3_ref())) {
    return false;
  }
  return true;
}

bool structC::operator<(const structC& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.d_ref() == rhs.d_ref())) {
    return lhs.d_ref() < rhs.d_ref();
  }
  if (!(lhs.e_ref() == rhs.e_ref())) {
    return lhs.e_ref() < rhs.e_ref();
  }
  if (!(lhs.f_ref() == rhs.f_ref())) {
    return lhs.f_ref() < rhs.f_ref();
  }
  if (!(lhs.g_ref() == rhs.g_ref())) {
    return lhs.g_ref() < rhs.g_ref();
  }
  if (!(lhs.h_ref() == rhs.h_ref())) {
    return lhs.h_ref() < rhs.h_ref();
  }
  if (!(lhs.i_ref() == rhs.i_ref())) {
    return lhs.i_ref() < rhs.i_ref();
  }
  if (!(lhs.j_ref() == rhs.j_ref())) {
    return lhs.j_ref() < rhs.j_ref();
  }
  if (!(lhs.j1_ref() == rhs.j1_ref())) {
    return lhs.j1_ref() < rhs.j1_ref();
  }
  if (!(lhs.j2_ref() == rhs.j2_ref())) {
    return lhs.j2_ref() < rhs.j2_ref();
  }
  if (!(lhs.j3_ref() == rhs.j3_ref())) {
    return lhs.j3_ref() < rhs.j3_ref();
  }
  if (!(lhs.k_ref() == rhs.k_ref())) {
    return lhs.k_ref() < rhs.k_ref();
  }
  if (!(lhs.k1_ref() == rhs.k1_ref())) {
    return lhs.k1_ref() < rhs.k1_ref();
  }
  if (!(lhs.k2_ref() == rhs.k2_ref())) {
    return lhs.k2_ref() < rhs.k2_ref();
  }
  if (!(lhs.k3_ref() == rhs.k3_ref())) {
    return lhs.k3_ref() < rhs.k3_ref();
  }
  if (!(lhs.l_ref() == rhs.l_ref())) {
    return lhs.l_ref() < rhs.l_ref();
  }
  if (!(lhs.l1_ref() == rhs.l1_ref())) {
    return lhs.l1_ref() < rhs.l1_ref();
  }
  if (!(lhs.l2_ref() == rhs.l2_ref())) {
    return lhs.l2_ref() < rhs.l2_ref();
  }
  if (!(lhs.l3_ref() == rhs.l3_ref())) {
    return lhs.l3_ref() < rhs.l3_ref();
  }
  if (!(lhs.m1_ref() == rhs.m1_ref())) {
    return lhs.m1_ref() < rhs.m1_ref();
  }
  if (!(lhs.m2_ref() == rhs.m2_ref())) {
    return lhs.m2_ref() < rhs.m2_ref();
  }
  if (!(lhs.m3_ref() == rhs.m3_ref())) {
    return lhs.m3_ref() < rhs.m3_ref();
  }
  if (!(lhs.n1_ref() == rhs.n1_ref())) {
    return lhs.n1_ref() < rhs.n1_ref();
  }
  if (!(lhs.n2_ref() == rhs.n2_ref())) {
    return lhs.n2_ref() < rhs.n2_ref();
  }
  if (!(lhs.n3_ref() == rhs.n3_ref())) {
    return lhs.n3_ref() < rhs.n3_ref();
  }
  if (!(lhs.o1_ref() == rhs.o1_ref())) {
    return lhs.o1_ref() < rhs.o1_ref();
  }
  if (!(lhs.o2_ref() == rhs.o2_ref())) {
    return lhs.o2_ref() < rhs.o2_ref();
  }
  if (!(lhs.o3_ref() == rhs.o3_ref())) {
    return lhs.o3_ref() < rhs.o3_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return g;
}

::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(g);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return h;
}

::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(h);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return i;
}

::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(i);
}

const ::std::vector<::std::int32_t>& structC::get_j() const& {
  return j;
}

::std::vector<::std::int32_t> structC::get_j() && {
  return std::move(j);
}

const ::std::vector<::std::int32_t>& structC::get_j1() const& {
  return j1;
}

::std::vector<::std::int32_t> structC::get_j1() && {
  return std::move(j1);
}

const ::std::vector<::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return j2;
}

::std::vector<::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(j2);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return j3;
}

::std::vector<::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(j3);
}

const ::std::set<::std::int32_t>& structC::get_k() const& {
  return k;
}

::std::set<::std::int32_t> structC::get_k() && {
  return std::move(k);
}

const ::std::set<::std::int32_t>& structC::get_k1() const& {
  return k1;
}

::std::set<::std::int32_t> structC::get_k1() && {
  return std::move(k1);
}

const ::std::set<::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return k2;
}

::std::set<::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(k2);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return k3;
}

::std::set<::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(k3);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l() const& {
  return l;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l() && {
  return std::move(l);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l1() const& {
  return l1;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l1() && {
  return std::move(l1);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return l2;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(l2);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return l3;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(l3);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>& structC::get_m1() const& {
  return m1;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> structC::get_m1() && {
  return std::move(m1);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return m2;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(m2);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return m3;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(m3);
}

const ::std::map<::std::string, ::std::int32_t>& structC::get_n1() const& {
  return n1;
}

::std::map<::std::string, ::std::int32_t> structC::get_n1() && {
  return std::move(n1);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return n2;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(n2);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return n3;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(n3);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>& structC::get_o1() const& {
  return o1;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> structC::get_o1() && {
  return std::move(o1);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return o2;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(o2);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return o3;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(o3);
}


void swap(structC& a, structC& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.d_ref().value(), b.d_ref().value());
  swap(a.e_ref().value(), b.e_ref().value());
  swap(a.f_ref().value(), b.f_ref().value());
  swap(a.g_ref().value(), b.g_ref().value());
  swap(a.h_ref().value(), b.h_ref().value());
  swap(a.i_ref().value(), b.i_ref().value());
  swap(a.j_ref().value(), b.j_ref().value());
  swap(a.j1_ref().value(), b.j1_ref().value());
  swap(a.j2_ref().value(), b.j2_ref().value());
  swap(a.j3_ref().value(), b.j3_ref().value());
  swap(a.k_ref().value(), b.k_ref().value());
  swap(a.k1_ref().value(), b.k1_ref().value());
  swap(a.k2_ref().value(), b.k2_ref().value());
  swap(a.k3_ref().value(), b.k3_ref().value());
  swap(a.l_ref().value(), b.l_ref().value());
  swap(a.l1_ref().value(), b.l1_ref().value());
  swap(a.l2_ref().value(), b.l2_ref().value());
  swap(a.l3_ref().value(), b.l3_ref().value());
  swap(a.m1_ref().value(), b.m1_ref().value());
  swap(a.m2_ref().value(), b.m2_ref().value());
  swap(a.m3_ref().value(), b.m3_ref().value());
  swap(a.n1_ref().value(), b.n1_ref().value());
  swap(a.n2_ref().value(), b.n2_ref().value());
  swap(a.n3_ref().value(), b.n3_ref().value());
  swap(a.o1_ref().value(), b.o1_ref().value());
  swap(a.o2_ref().value(), b.o2_ref().value());
  swap(a.o3_ref().value(), b.o3_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void structC::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structC::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1(const struct1&) = default;
struct1& struct1::operator=(const struct1&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0),
      field3( ::test_cpp2::cpp_reflection::enum2::field0_2) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

struct1::~struct1() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1(struct1&& other) noexcept  :
    field0(std::move(other.field0)),
    field1(std::move(other.field1)),
    field2(std::move(other.field2)),
    field3(std::move(other.field3)),
    field4(std::move(other.field4)),
    field5(std::move(other.field5)),
    __isset(other.__isset) {}
struct1& struct1::operator=(FOLLY_MAYBE_UNUSED struct1&& other) noexcept {
    this->field0 = std::move(other.field0);
    this->field1 = std::move(other.field1);
    this->field2 = std::move(other.field2);
    this->field3 = std::move(other.field3);
    this->field4 = std::move(other.field4);
    this->field5 = std::move(other.field5);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct1::struct1(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::enum2 field3__arg, ::test_cpp2::cpp_reflection::union1 field4__arg, ::test_cpp2::cpp_reflection::union2 field5__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)),
    field4(std::move(field4__arg)),
    field5(std::move(field5__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
  __isset.field4 = true;
  __isset.field5 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct1::__clear() {
  // clear all fields
  this->field0 = 0;
  this->field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  this->field3 =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  this->field4.__clear();
  this->field5.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct1::operator==(const struct1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return false;
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return false;
  }
  if (!(lhs.field5_ref() == rhs.field5_ref())) {
    return false;
  }
  return true;
}

bool struct1::operator<(const struct1& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return lhs.field3_ref() < rhs.field3_ref();
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return lhs.field4_ref() < rhs.field4_ref();
  }
  if (!(lhs.field5_ref() == rhs.field5_ref())) {
    return lhs.field5_ref() < rhs.field5_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(field4) : nullptr;
}

::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return field4_ref().has_value() ? std::addressof(field4) : nullptr;
}

const ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return field5;
}

::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(field5);
}


void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3_ref().value(), b.field3_ref().value());
  swap(a.field4_ref().value_unchecked(), b.field4_ref().value_unchecked());
  swap(a.field5_ref().value(), b.field5_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2(const struct2&) = default;
struct2& struct2::operator=(const struct2&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
      fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

struct2::~struct2() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2(struct2&& other) noexcept  :
    fieldA(std::move(other.fieldA)),
    fieldB(std::move(other.fieldB)),
    fieldC(std::move(other.fieldC)),
    fieldD(std::move(other.fieldD)),
    fieldE(std::move(other.fieldE)),
    fieldF(std::move(other.fieldF)),
    fieldG(std::move(other.fieldG)),
    __isset(other.__isset) {}
struct2& struct2::operator=(FOLLY_MAYBE_UNUSED struct2&& other) noexcept {
    this->fieldA = std::move(other.fieldA);
    this->fieldB = std::move(other.fieldB);
    this->fieldC = std::move(other.fieldC);
    this->fieldD = std::move(other.fieldD);
    this->fieldE = std::move(other.fieldE);
    this->fieldF = std::move(other.fieldF);
    this->fieldG = std::move(other.fieldG);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct2::struct2(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)) {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct2::__clear() {
  // clear all fields
  this->fieldA = 0;
  this->fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  this->fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  this->fieldE.__clear();
  this->fieldF.__clear();
  this->fieldG.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct2::operator==(const struct2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return false;
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return false;
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return false;
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return false;
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return false;
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return false;
  }
  return true;
}

bool struct2::operator<(const struct2& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return lhs.fieldA_ref() < rhs.fieldA_ref();
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return lhs.fieldB_ref() < rhs.fieldB_ref();
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return lhs.fieldC_ref() < rhs.fieldC_ref();
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return lhs.fieldD_ref() < rhs.fieldD_ref();
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return lhs.fieldE_ref() < rhs.fieldE_ref();
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return lhs.fieldF_ref() < rhs.fieldF_ref();
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return lhs.fieldG_ref() < rhs.fieldG_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return fieldE;
}

::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return fieldF;
}

::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(fieldG);
}


void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
  swap(a.fieldB_ref().value(), b.fieldB_ref().value());
  swap(a.fieldC_ref().value(), b.fieldC_ref().value());
  swap(a.fieldD_ref().value(), b.fieldD_ref().value());
  swap(a.fieldE_ref().value(), b.fieldE_ref().value());
  swap(a.fieldF_ref().value(), b.fieldF_ref().value());
  swap(a.fieldG_ref().value(), b.fieldG_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct2,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3(const struct3&) = default;
struct3& struct3::operator=(const struct3&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3() :
      fieldA(0),
      fieldC( ::test_cpp2::cpp_reflection::enum1::field0),
      fieldD( ::test_cpp2::cpp_reflection::enum2::field0_2) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

struct3::~struct3() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3(struct3&& other) noexcept  :
    fieldA(std::move(other.fieldA)),
    fieldB(std::move(other.fieldB)),
    fieldC(std::move(other.fieldC)),
    fieldD(std::move(other.fieldD)),
    fieldE(std::move(other.fieldE)),
    fieldF(std::move(other.fieldF)),
    fieldG(std::move(other.fieldG)),
    fieldH(std::move(other.fieldH)),
    fieldI(std::move(other.fieldI)),
    fieldJ(std::move(other.fieldJ)),
    fieldK(std::move(other.fieldK)),
    fieldL(std::move(other.fieldL)),
    fieldM(std::move(other.fieldM)),
    fieldN(std::move(other.fieldN)),
    fieldO(std::move(other.fieldO)),
    fieldP(std::move(other.fieldP)),
    fieldQ(std::move(other.fieldQ)),
    fieldR(std::move(other.fieldR)),
    __isset(other.__isset) {}
struct3& struct3::operator=(FOLLY_MAYBE_UNUSED struct3&& other) noexcept {
    this->fieldA = std::move(other.fieldA);
    this->fieldB = std::move(other.fieldB);
    this->fieldC = std::move(other.fieldC);
    this->fieldD = std::move(other.fieldD);
    this->fieldE = std::move(other.fieldE);
    this->fieldF = std::move(other.fieldF);
    this->fieldG = std::move(other.fieldG);
    this->fieldH = std::move(other.fieldH);
    this->fieldI = std::move(other.fieldI);
    this->fieldJ = std::move(other.fieldJ);
    this->fieldK = std::move(other.fieldK);
    this->fieldL = std::move(other.fieldL);
    this->fieldM = std::move(other.fieldM);
    this->fieldN = std::move(other.fieldN);
    this->fieldO = std::move(other.fieldO);
    this->fieldP = std::move(other.fieldP);
    this->fieldQ = std::move(other.fieldQ);
    this->fieldR = std::move(other.fieldR);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct3::struct3(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg, ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<::std::int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<::std::int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set<::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
    fieldA(std::move(fieldA__arg)),
    fieldB(std::move(fieldB__arg)),
    fieldC(std::move(fieldC__arg)),
    fieldD(std::move(fieldD__arg)),
    fieldE(std::move(fieldE__arg)),
    fieldF(std::move(fieldF__arg)),
    fieldG(std::move(fieldG__arg)),
    fieldH(std::move(fieldH__arg)),
    fieldI(std::move(fieldI__arg)),
    fieldJ(std::move(fieldJ__arg)),
    fieldK(std::move(fieldK__arg)),
    fieldL(std::move(fieldL__arg)),
    fieldM(std::move(fieldM__arg)),
    fieldN(std::move(fieldN__arg)),
    fieldO(std::move(fieldO__arg)),
    fieldP(std::move(fieldP__arg)),
    fieldQ(std::move(fieldQ__arg)),
    fieldR(std::move(fieldR__arg)) {
  __isset.fieldA = true;
  __isset.fieldB = true;
  __isset.fieldC = true;
  __isset.fieldD = true;
  __isset.fieldE = true;
  __isset.fieldF = true;
  __isset.fieldG = true;
  __isset.fieldH = true;
  __isset.fieldI = true;
  __isset.fieldJ = true;
  __isset.fieldK = true;
  __isset.fieldL = true;
  __isset.fieldM = true;
  __isset.fieldN = true;
  __isset.fieldO = true;
  __isset.fieldP = true;
  __isset.fieldQ = true;
  __isset.fieldR = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct3::__clear() {
  // clear all fields
  this->fieldA = 0;
  this->fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->fieldC =  ::test_cpp2::cpp_reflection::enum1::field0;
  this->fieldD =  ::test_cpp2::cpp_reflection::enum2::field0_2;
  this->fieldE.__clear();
  this->fieldF.__clear();
  this->fieldG.__clear();
  this->fieldH.__clear();
  this->fieldI.clear();
  this->fieldJ.clear();
  this->fieldK.clear();
  this->fieldL.clear();
  this->fieldM.clear();
  this->fieldN.clear();
  this->fieldO.clear();
  this->fieldP.clear();
  this->fieldQ.clear();
  this->fieldR.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct3::operator==(const struct3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return false;
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return false;
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return false;
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return false;
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return false;
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return false;
  }
  if (!(lhs.fieldH_ref() == rhs.fieldH_ref())) {
    return false;
  }
  if (!(lhs.fieldI_ref() == rhs.fieldI_ref())) {
    return false;
  }
  if (!(lhs.fieldJ_ref() == rhs.fieldJ_ref())) {
    return false;
  }
  if (!(lhs.fieldK_ref() == rhs.fieldK_ref())) {
    return false;
  }
  if (!(lhs.fieldL_ref() == rhs.fieldL_ref())) {
    return false;
  }
  if (!(lhs.fieldM_ref() == rhs.fieldM_ref())) {
    return false;
  }
  if (!(lhs.fieldN_ref() == rhs.fieldN_ref())) {
    return false;
  }
  if (!(lhs.fieldO_ref() == rhs.fieldO_ref())) {
    return false;
  }
  if (!(lhs.fieldP_ref() == rhs.fieldP_ref())) {
    return false;
  }
  if (!(lhs.fieldQ_ref() == rhs.fieldQ_ref())) {
    return false;
  }
  if (!(lhs.fieldR_ref() == rhs.fieldR_ref())) {
    return false;
  }
  return true;
}

bool struct3::operator<(const struct3& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return lhs.fieldA_ref() < rhs.fieldA_ref();
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return lhs.fieldB_ref() < rhs.fieldB_ref();
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return lhs.fieldC_ref() < rhs.fieldC_ref();
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return lhs.fieldD_ref() < rhs.fieldD_ref();
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return lhs.fieldE_ref() < rhs.fieldE_ref();
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return lhs.fieldF_ref() < rhs.fieldF_ref();
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return lhs.fieldG_ref() < rhs.fieldG_ref();
  }
  if (!(lhs.fieldH_ref() == rhs.fieldH_ref())) {
    return lhs.fieldH_ref() < rhs.fieldH_ref();
  }
  if (!(lhs.fieldI_ref() == rhs.fieldI_ref())) {
    return lhs.fieldI_ref() < rhs.fieldI_ref();
  }
  if (!(lhs.fieldJ_ref() == rhs.fieldJ_ref())) {
    return lhs.fieldJ_ref() < rhs.fieldJ_ref();
  }
  if (!(lhs.fieldK_ref() == rhs.fieldK_ref())) {
    return lhs.fieldK_ref() < rhs.fieldK_ref();
  }
  if (!(lhs.fieldL_ref() == rhs.fieldL_ref())) {
    return lhs.fieldL_ref() < rhs.fieldL_ref();
  }
  if (!(lhs.fieldM_ref() == rhs.fieldM_ref())) {
    return lhs.fieldM_ref() < rhs.fieldM_ref();
  }
  if (!(lhs.fieldN_ref() == rhs.fieldN_ref())) {
    return lhs.fieldN_ref() < rhs.fieldN_ref();
  }
  if (!(lhs.fieldO_ref() == rhs.fieldO_ref())) {
    return lhs.fieldO_ref() < rhs.fieldO_ref();
  }
  if (!(lhs.fieldP_ref() == rhs.fieldP_ref())) {
    return lhs.fieldP_ref() < rhs.fieldP_ref();
  }
  if (!(lhs.fieldQ_ref() == rhs.fieldQ_ref())) {
    return lhs.fieldQ_ref() < rhs.fieldQ_ref();
  }
  if (!(lhs.fieldR_ref() == rhs.fieldR_ref())) {
    return lhs.fieldR_ref() < rhs.fieldR_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return fieldE;
}

::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return fieldF;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(fieldG);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return fieldH;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(fieldH);
}

const ::std::vector<::std::int32_t>& struct3::get_fieldI() const& {
  return fieldI;
}

::std::vector<::std::int32_t> struct3::get_fieldI() && {
  return std::move(fieldI);
}

const ::std::vector<::std::string>& struct3::get_fieldJ() const& {
  return fieldJ;
}

::std::vector<::std::string> struct3::get_fieldJ() && {
  return std::move(fieldJ);
}

const ::std::vector<::std::string>& struct3::get_fieldK() const& {
  return fieldK;
}

::std::vector<::std::string> struct3::get_fieldK() && {
  return std::move(fieldK);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return fieldL;
}

::std::vector<::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(fieldL);
}

const ::std::set<::std::int32_t>& struct3::get_fieldM() const& {
  return fieldM;
}

::std::set<::std::int32_t> struct3::get_fieldM() && {
  return std::move(fieldM);
}

const ::std::set<::std::string>& struct3::get_fieldN() const& {
  return fieldN;
}

::std::set<::std::string> struct3::get_fieldN() && {
  return std::move(fieldN);
}

const ::std::set<::std::string>& struct3::get_fieldO() const& {
  return fieldO;
}

::std::set<::std::string> struct3::get_fieldO() && {
  return std::move(fieldO);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return fieldP;
}

::std::set<::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(fieldP);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return fieldQ;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(fieldQ);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return fieldR;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(fieldR);
}


void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA_ref().value(), b.fieldA_ref().value());
  swap(a.fieldB_ref().value(), b.fieldB_ref().value());
  swap(a.fieldC_ref().value(), b.fieldC_ref().value());
  swap(a.fieldD_ref().value(), b.fieldD_ref().value());
  swap(a.fieldE_ref().value(), b.fieldE_ref().value());
  swap(a.fieldF_ref().value(), b.fieldF_ref().value());
  swap(a.fieldG_ref().value(), b.fieldG_ref().value());
  swap(a.fieldH_ref().value(), b.fieldH_ref().value());
  swap(a.fieldI_ref().value(), b.fieldI_ref().value());
  swap(a.fieldJ_ref().value(), b.fieldJ_ref().value());
  swap(a.fieldK_ref().value(), b.fieldK_ref().value());
  swap(a.fieldL_ref().value(), b.fieldL_ref().value());
  swap(a.fieldM_ref().value(), b.fieldM_ref().value());
  swap(a.fieldN_ref().value(), b.fieldN_ref().value());
  swap(a.fieldO_ref().value(), b.fieldO_ref().value());
  swap(a.fieldP_ref().value(), b.fieldP_ref().value());
  swap(a.fieldQ_ref().value(), b.fieldQ_ref().value());
  swap(a.fieldR_ref().value(), b.fieldR_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct4>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct4>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

struct4::struct4(const struct4& srcObj) {
  field0 = srcObj.field0;
  field1 = srcObj.field1;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.field1 = srcObj.__isset.field1;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  field2 = srcObj.field2;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset.field2 = srcObj.__isset.field2;
THRIFT_IGNORE_ISSET_USE_WARNING_END
  field3 = ::apache::thrift::detail::st::copy_field<
        ::apache::thrift::type_class::structure>(srcObj.field3);
}

struct4& struct4::operator=(const struct4& src) {
  struct4 tmp(src);
  swap(*this, tmp);
  return *this;
}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct4::struct4(struct4&& other) noexcept  :
    field0(std::move(other.field0)),
    field1(std::move(other.field1)),
    field2(std::move(other.field2)),
    field3(std::move(other.field3)),
    __isset(other.__isset) {}
struct4& struct4::operator=(FOLLY_MAYBE_UNUSED struct4&& other) noexcept {
    this->field0 = std::move(other.field0);
    this->field1 = std::move(other.field1);
    this->field2 = std::move(other.field2);
    this->field3 = std::move(other.field3);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct4::struct4(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::std::unique_ptr<::test_cpp2::cpp_reflection::structA> field3__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct4::__clear() {
  // clear all fields
  this->field0 = 0;
  this->field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  if (this->field3) this->field3->__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct4::operator==(const struct4& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if ((lhs.field3 == nullptr) != (rhs.field3 == nullptr) || (lhs.field3 != nullptr && lhs.field3 != rhs.field3 && !(*lhs.field3 == *rhs.field3))) {
    return false;
  }
  return true;
}

bool struct4::operator<(const struct4& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if ((lhs.field3 == nullptr) != (rhs.field3 == nullptr) || (lhs.field3 != nullptr && lhs.field3 != rhs.field3 && !(*lhs.field3 == *rhs.field3))) {
    return lhs.field3 == nullptr || (rhs.field3 != nullptr && *lhs.field3 < *rhs.field3);
  }
  return false;
}


void swap(struct4& a, struct4& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3, b.field3);
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct4::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct4::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct4,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct4,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct5>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct5>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5(const struct5&) = default;
struct5& struct5::operator=(const struct5&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

struct5::~struct5() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5(struct5&& other) noexcept  :
    field0(std::move(other.field0)),
    field1(std::move(other.field1)),
    field2(std::move(other.field2)),
    field3(std::move(other.field3)),
    field4(std::move(other.field4)),
    __isset(other.__isset) {}
struct5& struct5::operator=(FOLLY_MAYBE_UNUSED struct5&& other) noexcept {
    this->field0 = std::move(other.field0);
    this->field1 = std::move(other.field1);
    this->field2 = std::move(other.field2);
    this->field3 = std::move(other.field3);
    this->field4 = std::move(other.field4);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct5::struct5(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::structA field3__arg, ::test_cpp2::cpp_reflection::structB field4__arg) :
    field0(std::move(field0__arg)),
    field1(std::move(field1__arg)),
    field2(std::move(field2__arg)),
    field3(std::move(field3__arg)),
    field4(std::move(field4__arg)) {
  __isset.field1 = true;
  __isset.field2 = true;
  __isset.field3 = true;
  __isset.field4 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct5::__clear() {
  // clear all fields
  this->field0 = 0;
  this->field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->field2 =  ::test_cpp2::cpp_reflection::enum1::field0;
  this->field3.__clear();
  this->field4.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct5::operator==(const struct5& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return false;
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return false;
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return false;
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return false;
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return false;
  }
  return true;
}

bool struct5::operator<(const struct5& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.field0_ref() == rhs.field0_ref())) {
    return lhs.field0_ref() < rhs.field0_ref();
  }
  if (!(lhs.field1_ref() == rhs.field1_ref())) {
    return lhs.field1_ref() < rhs.field1_ref();
  }
  if (!(lhs.field2_ref() == rhs.field2_ref())) {
    return lhs.field2_ref() < rhs.field2_ref();
  }
  if (!(lhs.field3_ref() == rhs.field3_ref())) {
    return lhs.field3_ref() < rhs.field3_ref();
  }
  if (!(lhs.field4_ref() == rhs.field4_ref())) {
    return lhs.field4_ref() < rhs.field4_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::structA& struct5::get_field3() const& {
  return field3;
}

::test_cpp2::cpp_reflection::structA struct5::get_field3() && {
  return std::move(field3);
}

const ::test_cpp2::cpp_reflection::structB& struct5::get_field4() const& {
  return field4;
}

::test_cpp2::cpp_reflection::structB struct5::get_field4() && {
  return std::move(field4);
}


void swap(struct5& a, struct5& b) {
  using ::std::swap;
  swap(a.field0_ref().value(), b.field0_ref().value());
  swap(a.field1_ref().value_unchecked(), b.field1_ref().value_unchecked());
  swap(a.field2_ref().value(), b.field2_ref().value());
  swap(a.field3_ref().value(), b.field3_ref().value());
  swap(a.field4_ref().value(), b.field4_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct5::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct5::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_binary>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_binary>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_binary::struct_binary(const struct_binary&) = default;
struct_binary& struct_binary::operator=(const struct_binary&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_binary::struct_binary(struct_binary&& other) noexcept  :
    bi(std::move(other.bi)),
    __isset(other.__isset) {}
struct_binary& struct_binary::operator=(FOLLY_MAYBE_UNUSED struct_binary&& other) noexcept {
    this->bi = std::move(other.bi);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_binary::struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg) :
    bi(std::move(bi__arg)) {
  __isset.bi = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct_binary::__clear() {
  // clear all fields
  this->bi = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_binary::operator==(const struct_binary& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.bi, rhs.bi)) {
    return false;
  }
  return true;
}

bool struct_binary::operator<(const struct_binary& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.bi, rhs.bi)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.bi, rhs.bi);
  }
  return false;
}


void swap(struct_binary& a, struct_binary& b) {
  using ::std::swap;
  swap(a.bi_ref().value(), b.bi_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_binary::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_binary::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_A_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_A_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
dep_A_struct::dep_A_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    i_a(std::move(i_a__arg)) {
  __isset.b = true;
  __isset.c = true;
  __isset.i_a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void dep_A_struct::__clear() {
  // clear all fields
  this->b.__clear();
  this->c.__clear();
  this->i_a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool dep_A_struct::operator==(const dep_A_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return false;
  }
  return true;
}

bool dep_A_struct::operator<(const dep_A_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return lhs.i_a_ref() < rhs.i_a_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_A_struct::get_b() const& {
  return b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_A_struct::get_b() && {
  return std::move(b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_A_struct::get_c() const& {
  return c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_A_struct::get_c() && {
  return std::move(c);
}


void swap(dep_A_struct& a, dep_A_struct& b) {
  using ::std::swap;
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.i_a_ref().value(), b.i_a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void dep_A_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_A_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_B_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_B_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
dep_B_struct::dep_B_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    b(std::move(b__arg)),
    c(std::move(c__arg)),
    i_a(std::move(i_a__arg)) {
  __isset.b = true;
  __isset.c = true;
  __isset.i_a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void dep_B_struct::__clear() {
  // clear all fields
  this->b.__clear();
  this->c.__clear();
  this->i_a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool dep_B_struct::operator==(const dep_B_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return false;
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return false;
  }
  return true;
}

bool dep_B_struct::operator<(const dep_B_struct& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  if (!(lhs.c_ref() == rhs.c_ref())) {
    return lhs.c_ref() < rhs.c_ref();
  }
  if (!(lhs.i_a_ref() == rhs.i_a_ref())) {
    return lhs.i_a_ref() < rhs.i_a_ref();
  }
  return false;
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_B_struct::get_b() const& {
  return b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_B_struct::get_b() && {
  return std::move(b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_B_struct::get_c() const& {
  return c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_B_struct::get_c() && {
  return std::move(c);
}


void swap(dep_B_struct& a, dep_B_struct& b) {
  using ::std::swap;
  swap(a.b_ref().value(), b.b_ref().value());
  swap(a.c_ref().value(), b.c_ref().value());
  swap(a.i_a_ref().value(), b.i_a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void dep_B_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_B_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of nimble option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::annotated>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::annotated>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
annotated::annotated(apache::thrift::FragileConstructor, ::std::int32_t a__arg) :
    a(std::move(a__arg)) {
  __isset.a = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void annotated::__clear() {
  // clear all fields
  this->a = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool annotated::operator==(const annotated& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  return true;
}

bool annotated::operator<(const annotated& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  return false;
}


void swap(annotated& a, annotated& b) {
  using ::std::swap;
  swap(a.a_ref().value(), b.a_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void annotated::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void annotated::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::size;
folly::Range<::test_cpp2::cpp_reflection::union_with_special_names::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names);

char const* TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union_with_special_names::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::test_cpp2::cpp_reflection::union_with_special_names::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

void union_with_special_names::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::get:
      destruct(value_.get);
      break;
    case Type::getter:
      destruct(value_.getter);
      break;
    case Type::lists:
      destruct(value_.lists);
      break;
    case Type::maps:
      destruct(value_.maps);
      break;
    case Type::name:
      destruct(value_.name);
      break;
    case Type::name_to_value:
      destruct(value_.name_to_value);
      break;
    case Type::names:
      destruct(value_.names);
      break;
    case Type::prefix_tree:
      destruct(value_.prefix_tree);
      break;
    case Type::sets:
      destruct(value_.sets);
      break;
    case Type::setter:
      destruct(value_.setter);
      break;
    case Type::str:
      destruct(value_.str);
      break;
    case Type::strings:
      destruct(value_.strings);
      break;
    case Type::type:
      destruct(value_.type);
      break;
    case Type::value:
      destruct(value_.value);
      break;
    case Type::value_to_name:
      destruct(value_.value_to_name);
      break;
    case Type::values:
      destruct(value_.values);
      break;
    case Type::id:
      destruct(value_.id);
      break;
    case Type::ids:
      destruct(value_.ids);
      break;
    case Type::descriptor:
      destruct(value_.descriptor);
      break;
    case Type::descriptors:
      destruct(value_.descriptors);
      break;
    case Type::key:
      destruct(value_.key);
      break;
    case Type::keys:
      destruct(value_.keys);
      break;
    case Type::annotation:
      destruct(value_.annotation);
      break;
    case Type::annotations:
      destruct(value_.annotations);
      break;
    case Type::member:
      destruct(value_.member);
      break;
    case Type::members:
      destruct(value_.members);
      break;
    case Type::field:
      destruct(value_.field);
      break;
    case Type::fields:
      destruct(value_.fields);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::get:
      return value_.get == rhs.value_.get;
    case Type::getter:
      return value_.getter == rhs.value_.getter;
    case Type::lists:
      return value_.lists == rhs.value_.lists;
    case Type::maps:
      return value_.maps == rhs.value_.maps;
    case Type::name:
      return value_.name == rhs.value_.name;
    case Type::name_to_value:
      return value_.name_to_value == rhs.value_.name_to_value;
    case Type::names:
      return value_.names == rhs.value_.names;
    case Type::prefix_tree:
      return value_.prefix_tree == rhs.value_.prefix_tree;
    case Type::sets:
      return value_.sets == rhs.value_.sets;
    case Type::setter:
      return value_.setter == rhs.value_.setter;
    case Type::str:
      return value_.str == rhs.value_.str;
    case Type::strings:
      return value_.strings == rhs.value_.strings;
    case Type::type:
      return value_.type == rhs.value_.type;
    case Type::value:
      return value_.value == rhs.value_.value;
    case Type::value_to_name:
      return value_.value_to_name == rhs.value_.value_to_name;
    case Type::values:
      return value_.values == rhs.value_.values;
    case Type::id:
      return value_.id == rhs.value_.id;
    case Type::ids:
      return value_.ids == rhs.value_.ids;
    case Type::descriptor:
      return value_.descriptor == rhs.value_.descriptor;
    case Type::descriptors:
      return value_.descriptors == rhs.value_.descriptors;
    case Type::key:
      return value_.key == rhs.value_.key;
    case Type::keys:
      return value_.keys == rhs.value_.keys;
    case Type::annotation:
      return value_.annotation == rhs.value_.annotation;
    case Type::annotations:
      return value_.annotations == rhs.value_.annotations;
    case Type::member:
      return value_.member == rhs.value_.member;
    case Type::members:
      return value_.members == rhs.value_.members;
    case Type::field:
      return value_.field == rhs.value_.field;
    case Type::fields:
      return value_.fields == rhs.value_.fields;
    default:
      return true;
  }
}

bool union_with_special_names::operator<(const union_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::get:
      return lhs.value_.get < rhs.value_.get;
    case Type::getter:
      return lhs.value_.getter < rhs.value_.getter;
    case Type::lists:
      return lhs.value_.lists < rhs.value_.lists;
    case Type::maps:
      return lhs.value_.maps < rhs.value_.maps;
    case Type::name:
      return lhs.value_.name < rhs.value_.name;
    case Type::name_to_value:
      return lhs.value_.name_to_value < rhs.value_.name_to_value;
    case Type::names:
      return lhs.value_.names < rhs.value_.names;
    case Type::prefix_tree:
      return lhs.value_.prefix_tree < rhs.value_.prefix_tree;
    case Type::sets:
      return lhs.value_.sets < rhs.value_.sets;
    case Type::setter:
      return lhs.value_.setter < rhs.value_.setter;
    case Type::str:
      return lhs.value_.str < rhs.value_.str;
    case Type::strings:
      return lhs.value_.strings < rhs.value_.strings;
    case Type::type:
      return lhs.value_.type < rhs.value_.type;
    case Type::value:
      return lhs.value_.value < rhs.value_.value;
    case Type::value_to_name:
      return lhs.value_.value_to_name < rhs.value_.value_to_name;
    case Type::values:
      return lhs.value_.values < rhs.value_.values;
    case Type::id:
      return lhs.value_.id < rhs.value_.id;
    case Type::ids:
      return lhs.value_.ids < rhs.value_.ids;
    case Type::descriptor:
      return lhs.value_.descriptor < rhs.value_.descriptor;
    case Type::descriptors:
      return lhs.value_.descriptors < rhs.value_.descriptors;
    case Type::key:
      return lhs.value_.key < rhs.value_.key;
    case Type::keys:
      return lhs.value_.keys < rhs.value_.keys;
    case Type::annotation:
      return lhs.value_.annotation < rhs.value_.annotation;
    case Type::annotations:
      return lhs.value_.annotations < rhs.value_.annotations;
    case Type::member:
      return lhs.value_.member < rhs.value_.member;
    case Type::members:
      return lhs.value_.members < rhs.value_.members;
    case Type::field:
      return lhs.value_.field < rhs.value_.field;
    case Type::fields:
      return lhs.value_.fields < rhs.value_.fields;
    default:
      return false;
  }
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_special_names::struct_with_special_names(apache::thrift::FragileConstructor, ::std::int32_t get__arg, ::std::int32_t getter__arg, ::std::int32_t lists__arg, ::std::int32_t maps__arg, ::std::int32_t name__arg, ::std::int32_t name_to_value__arg, ::std::int32_t names__arg, ::std::int32_t prefix_tree__arg, ::std::int32_t sets__arg, ::std::int32_t setter__arg, ::std::int32_t str__arg, ::std::int32_t strings__arg, ::std::int32_t type__arg, ::std::int32_t value__arg, ::std::int32_t value_to_name__arg, ::std::int32_t values__arg, ::std::int32_t id__arg, ::std::int32_t ids__arg, ::std::int32_t descriptor__arg, ::std::int32_t descriptors__arg, ::std::int32_t key__arg, ::std::int32_t keys__arg, ::std::int32_t annotation__arg, ::std::int32_t annotations__arg, ::std::int32_t member__arg, ::std::int32_t members__arg, ::std::int32_t field__arg, ::std::int32_t fields__arg) :
    get(std::move(get__arg)),
    getter(std::move(getter__arg)),
    lists(std::move(lists__arg)),
    maps(std::move(maps__arg)),
    name(std::move(name__arg)),
    name_to_value(std::move(name_to_value__arg)),
    names(std::move(names__arg)),
    prefix_tree(std::move(prefix_tree__arg)),
    sets(std::move(sets__arg)),
    setter(std::move(setter__arg)),
    str(std::move(str__arg)),
    strings(std::move(strings__arg)),
    type(std::move(type__arg)),
    value(std::move(value__arg)),
    value_to_name(std::move(value_to_name__arg)),
    values(std::move(values__arg)),
    id(std::move(id__arg)),
    ids(std::move(ids__arg)),
    descriptor(std::move(descriptor__arg)),
    descriptors(std::move(descriptors__arg)),
    key(std::move(key__arg)),
    keys(std::move(keys__arg)),
    annotation(std::move(annotation__arg)),
    annotations(std::move(annotations__arg)),
    member(std::move(member__arg)),
    members(std::move(members__arg)),
    field(std::move(field__arg)),
    fields(std::move(fields__arg)) {
  __isset.get = true;
  __isset.getter = true;
  __isset.lists = true;
  __isset.maps = true;
  __isset.name = true;
  __isset.name_to_value = true;
  __isset.names = true;
  __isset.prefix_tree = true;
  __isset.sets = true;
  __isset.setter = true;
  __isset.str = true;
  __isset.strings = true;
  __isset.type = true;
  __isset.value = true;
  __isset.value_to_name = true;
  __isset.values = true;
  __isset.id = true;
  __isset.ids = true;
  __isset.descriptor = true;
  __isset.descriptors = true;
  __isset.key = true;
  __isset.keys = true;
  __isset.annotation = true;
  __isset.annotations = true;
  __isset.member = true;
  __isset.members = true;
  __isset.field = true;
  __isset.fields = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct_with_special_names::__clear() {
  // clear all fields
  this->get = 0;
  this->getter = 0;
  this->lists = 0;
  this->maps = 0;
  this->name = 0;
  this->name_to_value = 0;
  this->names = 0;
  this->prefix_tree = 0;
  this->sets = 0;
  this->setter = 0;
  this->str = 0;
  this->strings = 0;
  this->type = 0;
  this->value = 0;
  this->value_to_name = 0;
  this->values = 0;
  this->id = 0;
  this->ids = 0;
  this->descriptor = 0;
  this->descriptors = 0;
  this->key = 0;
  this->keys = 0;
  this->annotation = 0;
  this->annotations = 0;
  this->member = 0;
  this->members = 0;
  this->field = 0;
  this->fields = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_with_special_names::operator==(const struct_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.get_ref() == rhs.get_ref())) {
    return false;
  }
  if (!(lhs.getter_ref() == rhs.getter_ref())) {
    return false;
  }
  if (!(lhs.lists_ref() == rhs.lists_ref())) {
    return false;
  }
  if (!(lhs.maps_ref() == rhs.maps_ref())) {
    return false;
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return false;
  }
  if (!(lhs.name_to_value_ref() == rhs.name_to_value_ref())) {
    return false;
  }
  if (!(lhs.names_ref() == rhs.names_ref())) {
    return false;
  }
  if (!(lhs.prefix_tree_ref() == rhs.prefix_tree_ref())) {
    return false;
  }
  if (!(lhs.sets_ref() == rhs.sets_ref())) {
    return false;
  }
  if (!(lhs.setter_ref() == rhs.setter_ref())) {
    return false;
  }
  if (!(lhs.str_ref() == rhs.str_ref())) {
    return false;
  }
  if (!(lhs.strings_ref() == rhs.strings_ref())) {
    return false;
  }
  if (!(lhs.type_ref() == rhs.type_ref())) {
    return false;
  }
  if (!(lhs.value_ref() == rhs.value_ref())) {
    return false;
  }
  if (!(lhs.value_to_name_ref() == rhs.value_to_name_ref())) {
    return false;
  }
  if (!(lhs.values_ref() == rhs.values_ref())) {
    return false;
  }
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return false;
  }
  if (!(lhs.ids_ref() == rhs.ids_ref())) {
    return false;
  }
  if (!(lhs.descriptor_ref() == rhs.descriptor_ref())) {
    return false;
  }
  if (!(lhs.descriptors_ref() == rhs.descriptors_ref())) {
    return false;
  }
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return false;
  }
  if (!(lhs.keys_ref() == rhs.keys_ref())) {
    return false;
  }
  if (!(lhs.annotation_ref() == rhs.annotation_ref())) {
    return false;
  }
  if (!(lhs.annotations_ref() == rhs.annotations_ref())) {
    return false;
  }
  if (!(lhs.member_ref() == rhs.member_ref())) {
    return false;
  }
  if (!(lhs.members_ref() == rhs.members_ref())) {
    return false;
  }
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return false;
  }
  if (!(lhs.fields_ref() == rhs.fields_ref())) {
    return false;
  }
  return true;
}

bool struct_with_special_names::operator<(const struct_with_special_names& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.get_ref() == rhs.get_ref())) {
    return lhs.get_ref() < rhs.get_ref();
  }
  if (!(lhs.getter_ref() == rhs.getter_ref())) {
    return lhs.getter_ref() < rhs.getter_ref();
  }
  if (!(lhs.lists_ref() == rhs.lists_ref())) {
    return lhs.lists_ref() < rhs.lists_ref();
  }
  if (!(lhs.maps_ref() == rhs.maps_ref())) {
    return lhs.maps_ref() < rhs.maps_ref();
  }
  if (!(lhs.name_ref() == rhs.name_ref())) {
    return lhs.name_ref() < rhs.name_ref();
  }
  if (!(lhs.name_to_value_ref() == rhs.name_to_value_ref())) {
    return lhs.name_to_value_ref() < rhs.name_to_value_ref();
  }
  if (!(lhs.names_ref() == rhs.names_ref())) {
    return lhs.names_ref() < rhs.names_ref();
  }
  if (!(lhs.prefix_tree_ref() == rhs.prefix_tree_ref())) {
    return lhs.prefix_tree_ref() < rhs.prefix_tree_ref();
  }
  if (!(lhs.sets_ref() == rhs.sets_ref())) {
    return lhs.sets_ref() < rhs.sets_ref();
  }
  if (!(lhs.setter_ref() == rhs.setter_ref())) {
    return lhs.setter_ref() < rhs.setter_ref();
  }
  if (!(lhs.str_ref() == rhs.str_ref())) {
    return lhs.str_ref() < rhs.str_ref();
  }
  if (!(lhs.strings_ref() == rhs.strings_ref())) {
    return lhs.strings_ref() < rhs.strings_ref();
  }
  if (!(lhs.type_ref() == rhs.type_ref())) {
    return lhs.type_ref() < rhs.type_ref();
  }
  if (!(lhs.value_ref() == rhs.value_ref())) {
    return lhs.value_ref() < rhs.value_ref();
  }
  if (!(lhs.value_to_name_ref() == rhs.value_to_name_ref())) {
    return lhs.value_to_name_ref() < rhs.value_to_name_ref();
  }
  if (!(lhs.values_ref() == rhs.values_ref())) {
    return lhs.values_ref() < rhs.values_ref();
  }
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return lhs.id_ref() < rhs.id_ref();
  }
  if (!(lhs.ids_ref() == rhs.ids_ref())) {
    return lhs.ids_ref() < rhs.ids_ref();
  }
  if (!(lhs.descriptor_ref() == rhs.descriptor_ref())) {
    return lhs.descriptor_ref() < rhs.descriptor_ref();
  }
  if (!(lhs.descriptors_ref() == rhs.descriptors_ref())) {
    return lhs.descriptors_ref() < rhs.descriptors_ref();
  }
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return lhs.key_ref() < rhs.key_ref();
  }
  if (!(lhs.keys_ref() == rhs.keys_ref())) {
    return lhs.keys_ref() < rhs.keys_ref();
  }
  if (!(lhs.annotation_ref() == rhs.annotation_ref())) {
    return lhs.annotation_ref() < rhs.annotation_ref();
  }
  if (!(lhs.annotations_ref() == rhs.annotations_ref())) {
    return lhs.annotations_ref() < rhs.annotations_ref();
  }
  if (!(lhs.member_ref() == rhs.member_ref())) {
    return lhs.member_ref() < rhs.member_ref();
  }
  if (!(lhs.members_ref() == rhs.members_ref())) {
    return lhs.members_ref() < rhs.members_ref();
  }
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return lhs.field_ref() < rhs.field_ref();
  }
  if (!(lhs.fields_ref() == rhs.fields_ref())) {
    return lhs.fields_ref() < rhs.fields_ref();
  }
  return false;
}


void swap(struct_with_special_names& a, struct_with_special_names& b) {
  using ::std::swap;
  swap(a.get_ref().value(), b.get_ref().value());
  swap(a.getter_ref().value(), b.getter_ref().value());
  swap(a.lists_ref().value(), b.lists_ref().value());
  swap(a.maps_ref().value(), b.maps_ref().value());
  swap(a.name_ref().value(), b.name_ref().value());
  swap(a.name_to_value_ref().value(), b.name_to_value_ref().value());
  swap(a.names_ref().value(), b.names_ref().value());
  swap(a.prefix_tree_ref().value(), b.prefix_tree_ref().value());
  swap(a.sets_ref().value(), b.sets_ref().value());
  swap(a.setter_ref().value(), b.setter_ref().value());
  swap(a.str_ref().value(), b.str_ref().value());
  swap(a.strings_ref().value(), b.strings_ref().value());
  swap(a.type_ref().value(), b.type_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.value_to_name_ref().value(), b.value_to_name_ref().value());
  swap(a.values_ref().value(), b.values_ref().value());
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.ids_ref().value(), b.ids_ref().value());
  swap(a.descriptor_ref().value(), b.descriptor_ref().value());
  swap(a.descriptors_ref().value(), b.descriptors_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.keys_ref().value(), b.keys_ref().value());
  swap(a.annotation_ref().value(), b.annotation_ref().value());
  swap(a.annotations_ref().value(), b.annotations_ref().value());
  swap(a.member_ref().value(), b.member_ref().value());
  swap(a.members_ref().value(), b.members_ref().value());
  swap(a.field_ref().value(), b.field_ref().value());
  swap(a.fields_ref().value(), b.fields_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_indirections>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_indirections>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections(const struct_with_indirections&) = default;
struct_with_indirections& struct_with_indirections::operator=(const struct_with_indirections&) = default;
THRIFT_IGNORE_ISSET_USE_WARNING_END
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections() :
      real(0),
      fake(0),
      number(0),
      result(0) {
}

THRIFT_IGNORE_ISSET_USE_WARNING_END

struct_with_indirections::~struct_with_indirections() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections(struct_with_indirections&& other) noexcept  :
    real(std::move(other.real)),
    fake(std::move(other.fake)),
    number(std::move(other.number)),
    result(std::move(other.result)),
    phrase(std::move(other.phrase)),
    __isset(other.__isset) {}
struct_with_indirections& struct_with_indirections::operator=(FOLLY_MAYBE_UNUSED struct_with_indirections&& other) noexcept {
    this->real = std::move(other.real);
    this->fake = std::move(other.fake);
    this->number = std::move(other.number);
    this->result = std::move(other.result);
    this->phrase = std::move(other.phrase);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
struct_with_indirections::struct_with_indirections(apache::thrift::FragileConstructor, ::std::int32_t real__arg, ::test_cpp2::cpp_reflection::FakeI32 fake__arg, ::test_cpp2::cpp_reflection::HasANumber number__arg, ::test_cpp2::cpp_reflection::HasAResult result__arg, ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg) :
    real(std::move(real__arg)),
    fake(std::move(fake__arg)),
    number(std::move(number__arg)),
    result(std::move(result__arg)),
    phrase(std::move(phrase__arg)) {
  __isset.real = true;
  __isset.fake = true;
  __isset.number = true;
  __isset.result = true;
  __isset.phrase = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END

void struct_with_indirections::__clear() {
  // clear all fields
  this->real = 0;
  this->fake = 0;
  ::apache::thrift::apply_indirection(this->number) = 0;
  ::apache::thrift::apply_indirection(this->result) = 0;
  ::apache::thrift::apply_indirection(this->phrase) = apache::thrift::StringTraits<::folly::remove_cvref_t<::folly::invoke_result_t<::apache::thrift::detail::apply_indirection_fn, CppHasAPhrase const&>>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool struct_with_indirections::operator==(const struct_with_indirections& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return false;
  }
  if (!(lhs.fake_ref() == rhs.fake_ref())) {
    return false;
  }
  if (!(lhs.number_ref() == rhs.number_ref())) {
    return false;
  }
  if (!(lhs.result_ref() == rhs.result_ref())) {
    return false;
  }
  if (!(lhs.phrase_ref() == rhs.phrase_ref())) {
    return false;
  }
  return true;
}

bool struct_with_indirections::operator<(const struct_with_indirections& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.real_ref() == rhs.real_ref())) {
    return lhs.real_ref() < rhs.real_ref();
  }
  if (!(lhs.fake_ref() == rhs.fake_ref())) {
    return lhs.fake_ref() < rhs.fake_ref();
  }
  if (!(lhs.number_ref() == rhs.number_ref())) {
    return lhs.number_ref() < rhs.number_ref();
  }
  if (!(lhs.result_ref() == rhs.result_ref())) {
    return lhs.result_ref() < rhs.result_ref();
  }
  if (!(lhs.phrase_ref() == rhs.phrase_ref())) {
    return lhs.phrase_ref() < rhs.phrase_ref();
  }
  return false;
}


void swap(struct_with_indirections& a, struct_with_indirections& b) {
  using ::std::swap;
  swap(a.real_ref().value(), b.real_ref().value());
  swap(a.fake_ref().value(), b.fake_ref().value());
  swap(a.number_ref().value(), b.number_ref().value());
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.phrase_ref().value(), b.phrase_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void struct_with_indirections::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_indirections::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // test_cpp2::cpp_reflection
