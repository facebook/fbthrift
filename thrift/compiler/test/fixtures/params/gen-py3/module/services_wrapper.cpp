/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <src/gen-py3/module/services_wrapper.h>
#include <src/gen-py3/module/services_api.h>
#include <thrift/lib/cpp2/async/AsyncProcessor.h>

namespace cpp2 {

NestedContainersWrapper::NestedContainersWrapper(PyObject *obj, folly::Executor* exc)
  : if_object(obj), executor(exc)
  {
    import_module__services();
    Py_XINCREF(this->if_object);
  }

NestedContainersWrapper::~NestedContainersWrapper() {
    Py_XDECREF(this->if_object);
}

folly::Future<folly::Unit> NestedContainersWrapper::future_mapList(
  std::unique_ptr<std::map<int32_t,std::vector<int32_t>>> foo
) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  folly::via(
    this->executor,
    [this,
     promise = std::move(promise),
foo = std::move(foo)    ]() mutable {
        call_cy_NestedContainers_mapList(
            this->if_object,
            std::move(promise),
    std::move(foo)        );
    });

  return future;
}

folly::Future<folly::Unit> NestedContainersWrapper::future_mapSet(
  std::unique_ptr<std::map<int32_t,std::set<int32_t>>> foo
) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  folly::via(
    this->executor,
    [this,
     promise = std::move(promise),
foo = std::move(foo)    ]() mutable {
        call_cy_NestedContainers_mapSet(
            this->if_object,
            std::move(promise),
    std::move(foo)        );
    });

  return future;
}

folly::Future<folly::Unit> NestedContainersWrapper::future_listMap(
  std::unique_ptr<std::vector<std::map<int32_t,int32_t>>> foo
) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  folly::via(
    this->executor,
    [this,
     promise = std::move(promise),
foo = std::move(foo)    ]() mutable {
        call_cy_NestedContainers_listMap(
            this->if_object,
            std::move(promise),
    std::move(foo)        );
    });

  return future;
}

folly::Future<folly::Unit> NestedContainersWrapper::future_listSet(
  std::unique_ptr<std::vector<std::set<int32_t>>> foo
) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  folly::via(
    this->executor,
    [this,
     promise = std::move(promise),
foo = std::move(foo)    ]() mutable {
        call_cy_NestedContainers_listSet(
            this->if_object,
            std::move(promise),
    std::move(foo)        );
    });

  return future;
}

folly::Future<folly::Unit> NestedContainersWrapper::future_turtles(
  std::unique_ptr<std::vector<std::vector<std::map<int32_t,std::map<int32_t,std::set<int32_t>>>>>> foo
) {
  folly::Promise<folly::Unit> promise;
  auto future = promise.getFuture();
  folly::via(
    this->executor,
    [this,
     promise = std::move(promise),
foo = std::move(foo)    ]() mutable {
        call_cy_NestedContainers_turtles(
            this->if_object,
            std::move(promise),
    std::move(foo)        );
    });

  return future;
}

std::shared_ptr<apache::thrift::ServerInterface> NestedContainersInterface(PyObject *if_object, folly::Executor *exc) {
  return std::make_shared<NestedContainersWrapper>(if_object, exc);
}
} // namespace cpp2
