// Autogenerated by Thrift Compiler (facebook)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
// @generated

package module

import (
	"bytes"
	"context"
	"sync"
	"fmt"
	thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = sync.Mutex{}
var _ = bytes.Equal
var _ = context.Background

type NestedContainers interface {
  // Parameters:
  //  - Foo
  MapList(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  MapSet(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  ListMap(foo []map[int32]int32) (err error)
  // Parameters:
  //  - Foo
  ListSet(foo [][]int32) (err error)
  // Parameters:
  //  - Foo
  Turtles(foo [][]map[int32]map[int32][]int32) (err error)
}

type NestedContainersClientInterface interface {
  thrift.ClientInterface
  // Parameters:
  //  - Foo
  MapList(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  MapSet(foo map[int32][]int32) (err error)
  // Parameters:
  //  - Foo
  ListMap(foo []map[int32]int32) (err error)
  // Parameters:
  //  - Foo
  ListSet(foo [][]int32) (err error)
  // Parameters:
  //  - Foo
  Turtles(foo [][]map[int32]map[int32][]int32) (err error)
}

type NestedContainersClient struct {
  NestedContainersClientInterface
  CC thrift.ClientConn
}

func(client *NestedContainersClient) Open() error {
  return client.CC.Open()
}

func(client *NestedContainersClient) Close() error {
  return client.CC.Close()
}

func(client *NestedContainersClient) IsOpen() bool {
  return client.CC.IsOpen()
}

func NewNestedContainersClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersClient {
  return &NestedContainersClient{ CC: thrift.NewClientConn(t, f) }
}

func NewNestedContainersClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersClient {
  return &NestedContainersClient{ CC: thrift.NewClientConnWithProtocols(t, iprot, oprot) }
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapList(foo map[int32][]int32) (err error) {
  args := NestedContainersMapListArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapList", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapList()
}


func (p *NestedContainersClient) recvMapList() (err error) {
  var result NestedContainersMapListResult
  return p.CC.RecvMsg("mapList", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) MapSet(foo map[int32][]int32) (err error) {
  args := NestedContainersMapSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapSet()
}


func (p *NestedContainersClient) recvMapSet() (err error) {
  var result NestedContainersMapSetResult
  return p.CC.RecvMsg("mapSet", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListMap(foo []map[int32]int32) (err error) {
  args := NestedContainersListMapArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listMap", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListMap()
}


func (p *NestedContainersClient) recvListMap() (err error) {
  var result NestedContainersListMapResult
  return p.CC.RecvMsg("listMap", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) ListSet(foo [][]int32) (err error) {
  args := NestedContainersListSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListSet()
}


func (p *NestedContainersClient) recvListSet() (err error) {
  var result NestedContainersListSetResult
  return p.CC.RecvMsg("listSet", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  args := NestedContainersTurtlesArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("turtles", &args, thrift.CALL)
  if err != nil { return }
  return p.recvTurtles()
}


func (p *NestedContainersClient) recvTurtles() (err error) {
  var result NestedContainersTurtlesResult
  return p.CC.RecvMsg("turtles", &result)
}


type NestedContainersThreadsafeClient struct {
  NestedContainersClientInterface
  CC thrift.ClientConn
  Mu sync.Mutex
}

func(client *NestedContainersThreadsafeClient) Open() error {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.Open()
}

func(client *NestedContainersThreadsafeClient) Close() error {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.Close()
}

func(client *NestedContainersThreadsafeClient) IsOpen() bool {
  client.Mu.Lock()
  defer client.Mu.Unlock()
  return client.CC.IsOpen()
}

func NewNestedContainersThreadsafeClientFactory(t thrift.Transport, f thrift.ProtocolFactory) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{ CC: thrift.NewClientConn(t, f) }
}

func NewNestedContainersThreadsafeClient(t thrift.Transport, iprot thrift.Protocol, oprot thrift.Protocol) *NestedContainersThreadsafeClient {
  return &NestedContainersThreadsafeClient{ CC: thrift.NewClientConnWithProtocols(t, iprot, oprot) }
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapList(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersMapListArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapList", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapList()
}


func (p *NestedContainersThreadsafeClient) recvMapList() (err error) {
  var result NestedContainersMapListResult
  return p.CC.RecvMsg("mapList", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) MapSet(foo map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersMapSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("mapSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvMapSet()
}


func (p *NestedContainersThreadsafeClient) recvMapSet() (err error) {
  var result NestedContainersMapSetResult
  return p.CC.RecvMsg("mapSet", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListMap(foo []map[int32]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersListMapArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listMap", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListMap()
}


func (p *NestedContainersThreadsafeClient) recvListMap() (err error) {
  var result NestedContainersListMapResult
  return p.CC.RecvMsg("listMap", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) ListSet(foo [][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersListSetArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("listSet", &args, thrift.CALL)
  if err != nil { return }
  return p.recvListSet()
}


func (p *NestedContainersThreadsafeClient) recvListSet() (err error) {
  var result NestedContainersListSetResult
  return p.CC.RecvMsg("listSet", &result)
}

// Parameters:
//  - Foo
func (p *NestedContainersThreadsafeClient) Turtles(foo [][]map[int32]map[int32][]int32) (err error) {
  p.Mu.Lock()
  defer p.Mu.Unlock()
  args := NestedContainersTurtlesArgs{
    Foo : foo,
  }
  err = p.CC.SendMsg("turtles", &args, thrift.CALL)
  if err != nil { return }
  return p.recvTurtles()
}


func (p *NestedContainersThreadsafeClient) recvTurtles() (err error) {
  var result NestedContainersTurtlesResult
  return p.CC.RecvMsg("turtles", &result)
}


type NestedContainersProcessor struct {
  processorMap map[string]thrift.ProcessorFunction
  handler NestedContainers
}

func (p *NestedContainersProcessor) AddToProcessorMap(key string, processor thrift.ProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *NestedContainersProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction, err error) {
  if processor, ok := p.processorMap[key]; ok {
    return processor, nil
  }
  return nil, nil // generic error message will be sent
}

func (p *NestedContainersProcessor) ProcessorMap() map[string]thrift.ProcessorFunction {
  return p.processorMap
}

func NewNestedContainersProcessor(handler NestedContainers) *NestedContainersProcessor {
  self0 := &NestedContainersProcessor{handler:handler, processorMap:make(map[string]thrift.ProcessorFunction)}
  self0.processorMap["mapList"] = &nestedContainersProcessorMapList{handler:handler}
  self0.processorMap["mapSet"] = &nestedContainersProcessorMapSet{handler:handler}
  self0.processorMap["listMap"] = &nestedContainersProcessorListMap{handler:handler}
  self0.processorMap["listSet"] = &nestedContainersProcessorListSet{handler:handler}
  self0.processorMap["turtles"] = &nestedContainersProcessorTurtles{handler:handler}
  return self0
}

type nestedContainersProcessorMapList struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorMapList) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapListArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapList) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapList", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapList) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapListArgs)
  var result NestedContainersMapListResult
  if err := p.handler.MapList(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapList: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorMapSet struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorMapSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersMapSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorMapSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("mapSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorMapSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersMapSetArgs)
  var result NestedContainersMapSetResult
  if err := p.handler.MapSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mapSet: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorListMap struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorListMap) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListMapArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListMap) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listMap", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListMap) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListMapArgs)
  var result NestedContainersListMapResult
  if err := p.handler.ListMap(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listMap: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorListSet struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorListSet) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersListSetArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorListSet) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("listSet", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorListSet) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersListSetArgs)
  var result NestedContainersListSetResult
  if err := p.handler.ListSet(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listSet: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}

type nestedContainersProcessorTurtles struct {
  handler NestedContainers
}

func (p *nestedContainersProcessorTurtles) Read(iprot thrift.Protocol) (thrift.Struct, thrift.Exception) {
  args := NestedContainersTurtlesArgs{}
  if err := args.Read(iprot); err != nil {
    return nil, err
  }
  iprot.ReadMessageEnd()
  return &args, nil
}

func (p *nestedContainersProcessorTurtles) Write(seqId int32, result thrift.WritableStruct, oprot thrift.Protocol) (err thrift.Exception) {
  var err2 error
  messageType := thrift.REPLY
  switch result.(type) {
  case thrift.ApplicationException:
    messageType = thrift.EXCEPTION
  }
  if err2 = oprot.WriteMessageBegin("turtles", messageType, seqId); err2 != nil {
    err = err2
  }
  if err2 = result.Write(oprot); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
    err = err2
  }
  if err2 = oprot.Flush(); err == nil && err2 != nil {
    err = err2
  }
  return err
}

func (p *nestedContainersProcessorTurtles) Run(argStruct thrift.Struct) (thrift.WritableStruct, thrift.ApplicationException) {
  args := argStruct.(*NestedContainersTurtlesArgs)
  var result NestedContainersTurtlesResult
  if err := p.handler.Turtles(args.Foo); err != nil {
    switch err.(type) {
    default:
      x := thrift.NewApplicationException(thrift.INTERNAL_ERROR, "Internal error processing turtles: " + err.Error())
      return x, x
    }
  }
  return &result, nil
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Foo
type NestedContainersMapListArgs struct {
  thrift.IRequest
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapListArgs() *NestedContainersMapListArgs {
  return &NestedContainersMapListArgs{}
}


func (p *NestedContainersMapListArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersMapListArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
var _key2 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key2 = v
}
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]int32, 0, size)
    _val3 :=  tSlice
    for i := 0; i < size; i ++ {
var _elem4 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem4 = v
}
      _val3 = append(_val3, _elem4)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo[_key2] = _val3
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapListArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapListArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersMapListArgs({Foo:%s})", fooVal)
}

type NestedContainersMapListResult struct {
  thrift.IResponse
}

func NewNestedContainersMapListResult() *NestedContainersMapListResult {
  return &NestedContainersMapListResult{}
}

func (p *NestedContainersMapListResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapListResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapList_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapListResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersMapListResult({})")
}

// Attributes:
//  - Foo
type NestedContainersMapSetArgs struct {
  thrift.IRequest
  Foo map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersMapSetArgs() *NestedContainersMapSetArgs {
  return &NestedContainersMapSetArgs{}
}


func (p *NestedContainersMapSetArgs) GetFoo() map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersMapSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, _, size, err := iprot.ReadMapBegin()
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[int32][]int32, size)
  p.Foo =  tMap
  for i := 0; i < size; i ++ {
var _key5 int32
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key5 = v
}
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _val6 :=  tSet
    for i := 0; i < size; i ++ {
var _elem7 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem7 = v
}
      _val6 = append(_val6, _elem7)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo[_key5] = _val6
  }
  if err := iprot.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *NestedContainersMapSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Foo {
    if err := oprot.WriteI32(int32(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersMapSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersMapSetArgs({Foo:%s})", fooVal)
}

type NestedContainersMapSetResult struct {
  thrift.IResponse
}

func NewNestedContainersMapSetResult() *NestedContainersMapSetResult {
  return &NestedContainersMapSetResult{}
}

func (p *NestedContainersMapSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersMapSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("mapSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersMapSetResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersMapSetResult({})")
}

// Attributes:
//  - Foo
type NestedContainersListMapArgs struct {
  thrift.IRequest
  Foo []map[int32]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListMapArgs() *NestedContainersListMapArgs {
  return &NestedContainersListMapArgs{}
}


func (p *NestedContainersListMapArgs) GetFoo() []map[int32]int32 {
  return p.Foo
}
func (p *NestedContainersListMapArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]map[int32]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, _, size, err := iprot.ReadMapBegin()
    if err != nil {
      return thrift.PrependError("error reading map begin: ", err)
    }
    tMap := make(map[int32]int32, size)
    _elem8 :=  tMap
    for i := 0; i < size; i ++ {
var _key9 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _key9 = v
}
var _val10 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _val10 = v
}
      _elem8[_key9] = _val10
    }
    if err := iprot.ReadMapEnd(); err != nil {
      return thrift.PrependError("error reading map end: ", err)
    }
    p.Foo = append(p.Foo, _elem8)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListMapArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.MAP, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range v {
      if err := oprot.WriteI32(int32(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListMapArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersListMapArgs({Foo:%s})", fooVal)
}

type NestedContainersListMapResult struct {
  thrift.IResponse
}

func NewNestedContainersListMapResult() *NestedContainersListMapResult {
  return &NestedContainersListMapResult{}
}

func (p *NestedContainersListMapResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListMapResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listMap_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListMapResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersListMapResult({})")
}

// Attributes:
//  - Foo
type NestedContainersListSetArgs struct {
  thrift.IRequest
  Foo [][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersListSetArgs() *NestedContainersListSetArgs {
  return &NestedContainersListSetArgs{}
}


func (p *NestedContainersListSetArgs) GetFoo() [][]int32 {
  return p.Foo
}
func (p *NestedContainersListSetArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadSetBegin()
    if err != nil {
      return thrift.PrependError("error reading set begin: ", err)
    }
    tSet := make([]int32, 0, size)
    _elem11 :=  tSet
    for i := 0; i < size; i ++ {
var _elem12 int32
      if v, err := iprot.ReadI32(); err != nil {
      return thrift.PrependError("error reading field 0: ", err)
} else {
      _elem12 = v
}
      _elem11 = append(_elem11, _elem12)
    }
    if err := iprot.ReadSetEnd(); err != nil {
      return thrift.PrependError("error reading set end: ", err)
    }
    p.Foo = append(p.Foo, _elem11)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersListSetArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.SET, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    set := make(map[int32]bool, len(v))
    for _, v := range v {
      if ok := set[v]; ok {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
      }
      set[v] = true
    }
    for _, v := range v {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersListSetArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersListSetArgs({Foo:%s})", fooVal)
}

type NestedContainersListSetResult struct {
  thrift.IResponse
}

func NewNestedContainersListSetResult() *NestedContainersListSetResult {
  return &NestedContainersListSetResult{}
}

func (p *NestedContainersListSetResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersListSetResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("listSet_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersListSetResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersListSetResult({})")
}

// Attributes:
//  - Foo
type NestedContainersTurtlesArgs struct {
  thrift.IRequest
  Foo [][]map[int32]map[int32][]int32 `thrift:"foo,1" db:"foo" json:"foo"`
}

func NewNestedContainersTurtlesArgs() *NestedContainersTurtlesArgs {
  return &NestedContainersTurtlesArgs{}
}


func (p *NestedContainersTurtlesArgs) GetFoo() [][]map[int32]map[int32][]int32 {
  return p.Foo
}
func (p *NestedContainersTurtlesArgs) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if err := p.ReadField1(iprot); err != nil {
        return err
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs)  ReadField1(iprot thrift.Protocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]map[int32]map[int32][]int32, 0, size)
  p.Foo =  tSlice
  for i := 0; i < size; i ++ {
    _, size, err := iprot.ReadListBegin()
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make([]map[int32]map[int32][]int32, 0, size)
    _elem13 :=  tSlice
    for i := 0; i < size; i ++ {
      _, _, size, err := iprot.ReadMapBegin()
      if err != nil {
        return thrift.PrependError("error reading map begin: ", err)
      }
      tMap := make(map[int32]map[int32][]int32, size)
      _elem14 :=  tMap
      for i := 0; i < size; i ++ {
var _key15 int32
        if v, err := iprot.ReadI32(); err != nil {
        return thrift.PrependError("error reading field 0: ", err)
} else {
        _key15 = v
}
        _, _, size, err := iprot.ReadMapBegin()
        if err != nil {
          return thrift.PrependError("error reading map begin: ", err)
        }
        tMap := make(map[int32][]int32, size)
        _val16 :=  tMap
        for i := 0; i < size; i ++ {
var _key17 int32
          if v, err := iprot.ReadI32(); err != nil {
          return thrift.PrependError("error reading field 0: ", err)
} else {
          _key17 = v
}
          _, size, err := iprot.ReadSetBegin()
          if err != nil {
            return thrift.PrependError("error reading set begin: ", err)
          }
          tSet := make([]int32, 0, size)
          _val18 :=  tSet
          for i := 0; i < size; i ++ {
var _elem19 int32
            if v, err := iprot.ReadI32(); err != nil {
            return thrift.PrependError("error reading field 0: ", err)
} else {
            _elem19 = v
}
            _val18 = append(_val18, _elem19)
          }
          if err := iprot.ReadSetEnd(); err != nil {
            return thrift.PrependError("error reading set end: ", err)
          }
          _val16[_key17] = _val18
        }
        if err := iprot.ReadMapEnd(); err != nil {
          return thrift.PrependError("error reading map end: ", err)
        }
        _elem14[_key15] = _val16
      }
      if err := iprot.ReadMapEnd(); err != nil {
        return thrift.PrependError("error reading map end: ", err)
      }
      _elem13 = append(_elem13, _elem14)
    }
    if err := iprot.ReadListEnd(); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Foo = append(p.Foo, _elem13)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *NestedContainersTurtlesArgs) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := p.writeField1(oprot); err != nil { return err }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesArgs) writeField1(oprot thrift.Protocol) (err error) {
  if err := oprot.WriteFieldBegin("foo", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:foo: ", p), err) }
  if err := oprot.WriteListBegin(thrift.LIST, len(p.Foo)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Foo {
    if err := oprot.WriteListBegin(thrift.MAP, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := oprot.WriteMapBegin(thrift.I32, thrift.MAP, len(v)); err != nil {
        return thrift.PrependError("error writing map begin: ", err)
      }
      for k, v := range v {
        if err := oprot.WriteI32(int32(k)); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
        if err := oprot.WriteMapBegin(thrift.I32, thrift.SET, len(v)); err != nil {
          return thrift.PrependError("error writing map begin: ", err)
        }
        for k, v := range v {
          if err := oprot.WriteI32(int32(k)); err != nil {
          return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          if err := oprot.WriteSetBegin(thrift.I32, len(v)); err != nil {
            return thrift.PrependError("error writing set begin: ", err)
          }
          set := make(map[int32]bool, len(v))
          for _, v := range v {
            if ok := set[v]; ok {
              return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", v))
            }
            set[v] = true
          }
          for _, v := range v {
            if err := oprot.WriteI32(int32(v)); err != nil {
            return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
          }
          if err := oprot.WriteSetEnd(); err != nil {
            return thrift.PrependError("error writing set end: ", err)
          }
        }
        if err := oprot.WriteMapEnd(); err != nil {
          return thrift.PrependError("error writing map end: ", err)
        }
      }
      if err := oprot.WriteMapEnd(); err != nil {
        return thrift.PrependError("error writing map end: ", err)
      }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:foo: ", p), err) }
  return err
}

func (p *NestedContainersTurtlesArgs) String() string {
  if p == nil {
    return "<nil>"
  }

  fooVal := fmt.Sprintf("%v", p.Foo)
  return fmt.Sprintf("NestedContainersTurtlesArgs({Foo:%s})", fooVal)
}

type NestedContainersTurtlesResult struct {
  thrift.IResponse
}

func NewNestedContainersTurtlesResult() *NestedContainersTurtlesResult {
  return &NestedContainersTurtlesResult{}
}

func (p *NestedContainersTurtlesResult) Read(iprot thrift.Protocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *NestedContainersTurtlesResult) Write(oprot thrift.Protocol) error {
  if err := oprot.WriteStructBegin("turtles_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *NestedContainersTurtlesResult) String() string {
  if p == nil {
    return "<nil>"
  }

  return fmt.Sprintf("NestedContainersTurtlesResult({})")
}


