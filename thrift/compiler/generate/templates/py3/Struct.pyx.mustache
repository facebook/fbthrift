{{!

  Copyright 2016 Facebook, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}{{!

Python wrappers of the structs defined in the services files. This file is
compiled into it's own module to be included by clients and services and
end-user code. It's one of the more complicated files, as it has to map
Pythonic APIs to C++ objects and back.

One of the nastier things in this file is the definition of containers.
A separate container wrapper has to be defined for each type of contained
attribute because Cython can't template C++ classes. So, for example, we need
a List__int16 or a List__string or a Map__string_mystruct instance for each
container/type combination. Consider that containers can contain other containers
or structs that contain containers and you realize how messy this can get.
Further, we'd prefer to have the end user freed from having to know about these
container types, so we'll need to define factories for them based on what they
want to include.

}}
{{> AutoGeneratedPy}}

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from cython.operator cimport dereference as deref, preincrement as inc
from thrift.py3.exceptions cimport TException
cimport thrift.py3.std_libcpp as std_libcpp

from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum
{{#program:includeNamespaces}}
{{#hasTypes?}}
cimport {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
import {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
{{/hasTypes?}}
{{/program:includeNamespaces}}


{{#program:enums}}
class {{enum:name}}(Enum):
    {{#enum:values}}
    {{enumValue:name}} = <int> ({{enum:name}}__{{enumValue:name}})
    {{/enum:values}}

cdef c{{enum:name}} {{enum:name}}_to_cpp(value):
    {{#enum:values}}
    {{^first?}}el{{/first?}}if value == {{enum:name}}.{{enumValue:name}}:
        return {{enum:name}}__{{enumValue:name}}
    {{/enum:values}}
{{/program:enums}}


{{#program:structs}}
cdef class {{struct:name}}{{#struct:exception?}}(TException){{/struct:exception?}}:
    def __init__(
        {{struct:name}} self{{#struct:fields}},
        {{field:name}}{{/struct:fields}}
    ):
        self.c_{{struct:name}} = make_shared[c{{struct:name}}]()
        {{#struct:fields}}
        {{#field:type}}
        {{> CythonAssignField}}

        {{/field:type}}
        {{/struct:fields}}
        {{^struct:fields}}pass
{{/struct:fields}}

    @staticmethod
    cdef create(shared_ptr[c{{struct:name}}] c_{{struct:name}}):
        inst = <{{struct:name}}>{{struct:name}}.__new__({{struct:name}})
        inst.c_{{struct:name}} = c_{{struct:name}}
        return inst

    {{#struct:fields}}
    @property
    def {{field:name}}(self):
        {{#field:type}}
        {{> CythonStructGetter}}

        {{/field:type}}

    {{/struct:fields}}

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, {{struct:name}}) and
                isinstance(other, {{struct:name}})):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef c{{struct:name}} cself = deref((<{{struct:name}}>self).c_{{struct:name}})
        cdef c{{struct:name}} cother = deref((<{{struct:name}}>other).c_{{struct:name}})
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__({{struct:name}} self):
        return hash((
          {{#struct:fields}}
          self.{{field:name}},
          {{/struct:fields}}
        ))



{{/program:structs}}
{{#program:containerTypes}}
cdef class {{type:flat_name}}:
{{#type:list?}}
    def __init__(self, items=None):
        if isinstance(items, {{type:flat_name}}):
            self._vector = (<{{type:flat_name}}> items)._vector
        else:
          self._vector = make_shared[vector[{{#type:listElemType}}{{!
              }}{{> ContainerCythonFieldTypeConditionally}}{{!
              }}{{/type:listElemType}}]]()
          if items:
              for item in items:
                  deref(self._vector).push_back({{#type:listElemType}}{{!
                      }}{{> CythonPythonToCppItem}}{{/type:listElemType}})

    @staticmethod
    cdef create(
            shared_ptr[vector[{{#type:listElemType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}}{{/type:listElemType}}{{!
            }}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        {{#type:listElemType}}
        cdef {{> ContainerCythonFieldTypeConditionally}} citem = (
            deref(self._vector.get())[index])
        return {{> ContainerCythonCppToPythonItem}}
        {{/type:listElemType}}

    def __len__(self):
        return deref(self._vector).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple(self))

    def __contains__(self, item):
        cdef {{#type:listElemType}}{{!
          }}{{> ContainerCythonFieldTypeConditionally}} citem = {{!
          }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> ContainerCythonFieldTypeConditionally}} vec = deref(
            self._vector.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        cdef {{#type:listElemType}}{{!
            }}{{>ContainerCythonFieldTypeConditionally}}{{!
            }}{{/type:listElemType}} citem
        for citem in deref(self._vector):
            yield {{#type:listElemType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{!
                }}{{/type:listElemType}}

    def __reversed__(self):
        cdef {{#type:listElemType}}{{!
            }}{{>ContainerCythonFieldTypeConditionally}}{{!
            }}{{/type:listElemType}} citem
        cdef {{> ContainerCythonFieldTypeConditionally}} vec = deref(
            self._vector.get())
        cdef {{>ContainerCythonFieldTypeConditionally}}.reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield {{#type:listElemType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{!
                }}{{/type:listElemType}}
            inc(loc)

    def index(self, item):
        cdef {{#type:listElemType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} citem = {{!
            }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> ContainerCythonFieldTypeConditionally}} vec = {{!
            }}deref(self._vector.get())
        cdef {{>ContainerCythonFieldTypeConditionally}}.iterator loc = {{!
            }}std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError("{} is not in list".format(item))

    def count(self, item):
        cdef {{#type:listElemType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} citem = {{!
            }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> ContainerCythonFieldTypeConditionally}} vec = {{!
            }}deref(self._vector.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register({{type:flat_name}})
{{/type:list?}}
{{#type:set?}}
    def __init__(self, items=None):
        if isinstance(items, {{type:flat_name}}):
            self._set = (<{{type:flat_name}}> items)._set
        else:
          self._set = make_shared[cset[{{#type:setElemType}}{{> ContainerCythonFieldType}}{{/type:setElemType}}]]()
          if items:
              for item in items:
                  deref(self._set).insert({{#type:setElemType}}{{> CythonPythonToCppItem}}{{/type:setElemType}})

    @staticmethod
    cdef create(shared_ptr[cset[{{!
            }}{{#type:setElemType}}{{> ContainerCythonFieldTypeConditionally}}{{/type:setElemType}}{{!
            }}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._set = c_items
        return inst

    def __contains__(self, item):
        return pbool(deref(self._set).count({{#type:setElemType}}{{>CythonPythonToCppItem}}{{/type:setElemType}}))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        for citem in deref(self._set):
            yield {{#type:setElemType}}{{> ContainerCythonCppToPythonItem}}{{/type:setElemType}}

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[{{!
            }}{{#type:setElemType}}{{!
            }}{{> ContainerCythonFieldType}}{{!
            }}{{/type:setElemType}}]{{!
            }} cself, cother
        cdef cbool retval
        if (isinstance(self, {{type:flat_name}}) and
                isinstance(other, {{type:flat_name}})):
            cself = deref((<{{type:flat_name}}> self)._set)
            cother = deref((<{{type:flat_name}}> other)._set)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        return hash(tuple(self))

    def __and__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        {{#type:setElemType}}
        cdef shared_ptr[cset[{{> ContainerCythonFieldType}}]] shretval = \
            make_shared[cset[{{> ContainerCythonFieldType}}]]()
        {{/type:setElemType}}
        for citem in deref((<{{type:flat_name}}> self)._set):
            if deref((<{{type:flat_name}}> other)._set).count(citem) > 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        {{#type:setElemType}}
        cdef shared_ptr[cset[{{> ContainerCythonFieldType}}]] shretval = \
            make_shared[cset[{{> ContainerCythonFieldType}}]]()
        {{/type:setElemType}}
        for citem in deref((<{{type:flat_name}}> self)._set):
            if deref((<{{type:flat_name}}> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __or__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        {{#type:setElemType}}
        cdef shared_ptr[cset[{{> ContainerCythonFieldType}}]] shretval = \
            make_shared[cset[{{> ContainerCythonFieldType}}]]()
        {{/type:setElemType}}
        for citem in deref((<{{type:flat_name}}> self)._set):
                deref(shretval).insert(citem)
        for citem in deref((<{{type:flat_name}}> other)._set):
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        {{#type:setElemType}}
        cdef shared_ptr[cset[{{> ContainerCythonFieldType}}]] shretval = \
            make_shared[cset[{{> ContainerCythonFieldType}}]]()
        {{/type:setElemType}}
        for citem in deref((<{{type:flat_name}}> self)._set):
            if deref((<{{type:flat_name}}> other)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<{{type:flat_name}}> other)._set):
            if deref((<{{type:flat_name}}> self)._set).count(citem) == 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other



Set.register({{type:flat_name}})
{{/type:set?}}
{{#type:map?}}
    def __init__(self, items=None):
        if isinstance(items, {{type:flat_name}}):
            self._map = (<{{type:flat_name}}> items)._map
        else:
          self._map = make_shared[cmap[{{> CythonMapKeyValueConditionally}}]]()
          if items:
              for key, item in items.items():
                  deref(self._map).insert(
                      cpair[{{> CythonMapKeyValueConditionally}}](
                          {{#type:keyType}}{{> CythonPythonToCppKey}}{{/type:keyType}},
                          {{#type:valueType}}{{> CythonPythonToCppItem}}{{/type:valueType}}))

    @staticmethod
    cdef create(shared_ptr[cmap[{{> CythonMapKeyValueConditionally}}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._map = c_items
        return inst

    def __getitem__(self, key):
        cdef {{#type:keyType}}{{> ContainerCythonFieldTypeConditionally}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        cdef cmap[{{>CythonMapKeyValueConditionally}}].iterator iter = deref(
            self._map).find(ckey)
        if iter == deref(self._map).end():
            raise KeyError(str(key))
        cdef {{#type:valueType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} {{!
            }}citem = deref(iter).second{{/type:valueType}}
        return {{#type:valueType}}{{!
            }}{{> ContainerCythonCppToPythonItem}}{{/type:valueType}}

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef {{#type:keyType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}}{{/type:keyType}} citem
        for pair in deref(self._map):
            citem = pair.first
            yield {{#type:keyType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{/type:keyType}}

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        return hash(tuple((tuple(self), tuple(self[k] for k in self))))

    def __contains__(self, key):
        cdef {{#type:keyType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        return deref(self._map).count(ckey) > 0

    def get(self, key, default=None):
        cdef {{#type:keyType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        cdef cmap[{{>CythonMapKeyValueConditionally}}].iterator iter = \
            deref(self._map).find(ckey)
        if iter == deref(self._map).end():
            return default
        cdef {{#type:valueType}}{{!
            }}{{> ContainerCythonFieldTypeConditionally}} citem = {{!
            }}deref(iter).second{{/type:valueType}}
        return {{#type:valueType}}{{!
          }}{{> ContainerCythonCppToPythonItem}}{{!
          }}{{/type:valueType}}

    def keys(self):
        return self.__iter__()

    def values(self):
        cdef {{#type:valueType}}{{!
          }}{{> ContainerCythonFieldTypeConditionally}}{{!
          }}{{/type:valueType}}{{!!
          }} citem
        for pair in deref(self._map):
            citem = pair.second
            yield {{#type:valueType}}{{!
              }}{{> ContainerCythonCppToPythonItem}}{{!
              }}{{/type:valueType}}

    def items(self):
        cdef {{#type:keyType}}{{!
          }}{{> ContainerCythonFieldTypeConditionally}}{{!
          }}{{/type:keyType}}{{!
          }} ckey
        cdef {{#type:valueType}}{{!
          }}{{> ContainerCythonFieldTypeConditionally}}{{!
          }}{{/type:valueType}} citem
        for pair in deref(self._map):
            ckey = pair.first
            citem = pair.second

            yield ({{!
              }}{{#type:keyType}}{{!
              }}{{> ContainerCythonCppToPythonKey}}{{!
              }}{{/type:keyType}}, {{!
              }}{{#type:valueType}}{{!
              }}{{> ContainerCythonCppToPythonItem}}{{!
              }}{{/type:valueType}})



Mapping.register({{type:flat_name}})
{{/type:map?}}

{{/program:containerTypes}}

{{#program:constants}}
{{#constant:value}}{{> ConstantValue}}{{/constant:value}}{{/program:constants}}
