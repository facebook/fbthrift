{{!

  Copyright 2016 Facebook, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}{{!

Python wrappers of the structs defined in the services files. This file is
compiled into it's own module to be included by clients and services and
end-user code. It's one of the more complicated files, as it has to map
Pythonic APIs to C++ objects and back.

One of the nastier things in this file is the definition of containers.
A separate container wrapper has to be defined for each type of contained
attribute because Cython can't template C++ classes. So, for example, we need
a List__int16 or a List__string or a Map__string_mystruct instance for each
container/type combination. Consider that containers can contain other containers
or structs that contain containers and you realize how messy this can get.
Further, we'd prefer to have the end user freed from having to know about these
container types, so we'll need to define factories for them based on what they
want to include.

}}
{{> AutoGeneratedPy}}

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from cython.operator cimport dereference as deref
from thrift.lib.py3.thrift_server cimport TException

from collections.abc import Sequence, Set, Mapping
from enum import Enum
cimport {{#program:py3Namespaces}}{{value}}.{{/program:py3Namespaces}}{{program:name}}_types
{{#program:includeNamespaces}}
cimport {{value}}_types
{{/program:includeNamespaces}}

{{#program:enums}}
class {{enum:name}}(Enum):
    {{#enum:values}}
    {{enumValue:name}} = <int> ({{enum:name}}__{{enumValue:name}})
    {{/enum:values}}

cdef c{{enum:name}} {{enum:name}}_to_cpp(value):
    {{#enum:values}}
    {{^first?}}el{{/first?}}if value == {{enum:name}}.{{enumValue:name}}:
        return {{enum:name}}__{{enumValue:name}}
    {{/enum:values}}
{{/program:enums}}


{{#program:structs}}
cdef class {{struct:name}}{{#struct:exception?}}(TException){{/struct:exception?}}:
    def __init__(
        self{{#struct:fields}},
        {{#field:type}}{{> PythonFieldType}}{{/field:type}}{{!
        }} {{field:name}}{{/struct:fields}}
    ):
        self.c_{{struct:name}} = make_shared[c{{struct:name}}]()
        {{#struct:fields}}
        {{#field:type}}
        {{> CythonAssignField}}
        {{/field:type}}
        {{/struct:fields}}
        {{^struct:fields}}pass
{{/struct:fields}}

    @staticmethod
    cdef create(shared_ptr[c{{struct:name}}] c_{{struct:name}}):
        inst = <{{struct:name}}>{{struct:name}}.__new__({{struct:name}})
        inst.c_{{struct:name}} = c_{{struct:name}}
        return inst

    {{#struct:fields}}
    @property
    def {{field:name}}(self):
        {{#field:type}}
        {{> CythonStructGetter}}

        {{/field:type}}

    {{/struct:fields}}

{{/program:structs}}


{{#program:containerTypes}}
cdef class {{type:flat_name}}:
{{#type:list?}}
    def __init__(self, items=None):
        self._vector = make_shared[vector[{{#type:listElemType}}{{> ContainerCythonFieldType}}{{/type:listElemType}}]]()
        if items:
            for item in items:
                deref(self._vector).push_back({{#type:listElemType}}{{> CythonPythonToCppItem}}{{/type:listElemType}})

    @staticmethod
    cdef create(shared_ptr[vector[{{#type:listElemType}}{{> ContainerCythonFieldType}}{{/type:listElemType}}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._vector = c_items
        return inst

    def __getitem__(self, int index):
        cdef {{#type:listElemType}}{{> ContainerCythonFieldType}}{{/type:listElemType}} citem = deref(self._vector).at(index)
        return {{#type:listElemType}}{{> ContainerCythonCppToPythonItem}}{{/type:listElemType}}

    def __len__(self):
        return deref(self._vector).size()

Sequence.register({{type:flat_name}})
{{/type:list?}}
{{#type:set?}}
    def __init__(self, items=None):
        self._set = make_shared[cset[{{#type:setElemType}}{{> ContainerCythonFieldType}}{{/type:setElemType}}]]()
        if items:
            for item in items:
                deref(self._set).insert({{#type:setElemType}}{{> CythonPythonToCppItem}}{{/type:setElemType}})

    @staticmethod
    cdef create(shared_ptr[cset[{{#type:setElemType}}{{> ContainerCythonFieldType}}{{/type:setElemType}}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._set = c_items
        return inst

    def __contains__(self, {{#type:setElemType}}{{> PythonFieldType}}{{/type:setElemType}} item):
        return pbool(deref(self._set).count({{#type:setElemType}}{{>CythonPythonToCppItem}}{{/type:setElemType}}))

    def __len__(self):
        return deref(self._set).size()

    def __iter__(self):
        for citem in deref(self._set):
            yield {{#type:setElemType}}{{> ContainerCythonCppToPythonItem}}{{/type:setElemType}}

Set.register({{type:flat_name}})
{{/type:set?}}
{{#type:map?}}
    def __init__(self, items=None):

        self._map = make_shared[cmap[{{> CythonMapKeyValue}}]]()
        if items:
            for key, item in items.items():
                deref(self._map).insert(cpair[{{> CythonMapKeyValue}}]({{#type:keyType}}{{> CythonPythonToCppKey}}{{/type:keyType}}, {{!
                  }}{{#type:valueType}}{{> CythonPythonToCppItem}}{{/type:valueType}}))

    @staticmethod
    cdef create(shared_ptr[cmap[{{> CythonMapKeyValue}}]] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._map = c_items
        return inst

    def __getitem__(self, {{#type:keyType}}{{> PythonFieldType}}{{/type:keyType}} key):
        cdef {{#type:keyType}}{{> ContainerCythonFieldType}} ckey = {{> CythonPythonToCppKey}}{{/type:keyType}}
        cdef {{#type:valueType}}{{> ContainerCythonFieldType}} citem = deref(self._map)[ckey]{{/type:valueType}}
        return {{#type:valueType}}{{> ContainerCythonCppToPythonItem}}{{/type:valueType}}

    def __len__(self):
        return deref(self._map).size()

    def __iter__(self):
        cdef {{#type:keyType}}{{> ContainerCythonFieldType}}{{/type:keyType}} citem
        for pair in deref(self._map):
            citem = pair.first
            yield {{#type:keyType}}{{> ContainerCythonCppToPythonItem}}{{/type:keyType}}

Mapping.register({{type:flat_name}})
{{/type:map?}}

{{/program:containerTypes}}

{{#program:constants}}
{{#constant:value}}{{> ConstantValue}}{{/constant:value}}{{/program:constants}}
